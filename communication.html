<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Sparta Modeling Framework: Communication, Events, and Scheduling</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">The Sparta Modeling Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('communication.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Communication, Events, and Scheduling</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul>
  <li class="level1">
    <a href="#comm_ports">Ports</a>
    <ul>
      <li class="level2">
        <a href="#sync_ports">sparta::SyncPorts</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#comm_events">Events</a>
  </li>
  <li class="level1">
    <a href="#comm_clocks">Clocks</a>
  </li>
  <li class="level1">
    <a href="#comm_schedulers">Scheduling</a>
    <ul>
      <li class="level2">
        <a href="#sparta_Scheduler">sparta::Scheduler</a>
      </li>
      <li class="level2">
        <a href="#sysc_scheduler">sparta::SysCSpartaSchedulerAdapter</a>
      </li>
    </ul>
  </li>
</ul>
</div>
<div class="textblock"><p>In addition to providing a simulation command line infrastructure (see <a class="el" href="config.html">Simulator Configuration</a>) as well as resource creation (see resources) in a tree form for organization (see trees), Sparta provides a series of classes and ordering specifically dedicated for resource to resource communication as well as internal resource communication. This communication can be timed or untimed as desired.</p>
<p>The first point of Sparta's communication philosophy lies behind the timing aspects of Sparta: There are scheduling phases (<a class="el" href="namespacesparta.html#aeec80d237ace9f07634c3d24c9aed9a0" title="The SchedulingPhases used for events (Tick, Update, PortUpdate, etc)">sparta::SchedulingPhase</a>) that allows a user to count on certain ordering between resources and another. This is different from prior versions of Sparta where every scheduleable type of event was in a single phase and required the user to provide explicit orderings.</p>
<p>Ordering within a phase, however, is still supported, allowing a modeler to specify the order in which events are scheduled/fired within that phase. For example, a modeler may desired eventA which reads from a Port to be scheduled before eventB which might act on the data read.</p>
<p>The classes that support communication and scheduling are:</p><ul>
<li><a class="el" href="classsparta_1_1Port.html">sparta::Port</a></li>
<li><a class="el" href="classsparta_1_1PortSet.html">sparta::PortSet</a></li>
<li><a class="el" href="classsparta_1_1DataInPort.html">sparta::DataInPort</a>, <a class="el" href="classsparta_1_1DataOutPort.html">sparta::DataOutPort</a></li>
<li><a class="el" href="classsparta_1_1SignalInPort.html">sparta::SignalInPort</a>, <a class="el" href="classsparta_1_1SignalOutPort.html">sparta::SignalOutPort</a></li>
<li><a class="el" href="classsparta_1_1SyncInPort.html">sparta::SyncInPort</a>, <a class="el" href="classsparta_1_1SyncOutPort.html">sparta::SyncOutPort</a></li>
<li><a class="el" href="classsparta_1_1Scheduleable.html">sparta::Scheduleable</a></li>
<li><a class="el" href="classsparta_1_1Event.html">sparta::Event</a></li>
<li><a class="el" href="classsparta_1_1UniqueEvent.html">sparta::UniqueEvent</a></li>
<li><a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html">sparta::SingleCycleUniqueEvent</a></li>
<li><a class="el" href="classsparta_1_1PayloadEvent.html">sparta::PayloadEvent</a></li>
<li><a class="el" href="classsparta_1_1EventSet.html">sparta::EventSet</a></li>
<li><a class="el" href="classsparta_1_1Clock.html">sparta::Clock</a></li>
<li><a class="el" href="classsparta_1_1Scheduler.html">sparta::Scheduler</a></li>
<li><a class="el" href="namespacesparta.html#aeec80d237ace9f07634c3d24c9aed9a0">sparta::SchedulingPhase</a></li>
<li><a class="el" href="classsparta_1_1SysCSpartaSchedulerAdapter.html">sparta::SysCSpartaSchedulerAdapter</a></li>
</ul>
<p>The below sections detail each. To build the examples documented in this section, please see the README.md for directions/prerequisite for creating a build directory. Then, build in the example/Documentation/communication directory:</p>
<div class="fragment"><div class="line">cd <a class="code hl_namespace" href="namespacesparta.html">sparta</a></div>
<div class="line">cd <a class="code hl_namespace" href="namespacesparta.html">sparta</a>/build-dir  # Please see the README.md <span class="keywordflow">for</span> creation</div>
<div class="line">cd example/Documentation/communication</div>
<div class="line">make</div>
<div class="ttc" id="anamespacesparta_html"><div class="ttname"><a href="namespacesparta.html">sparta</a></div><div class="ttdoc">Macros for handling exponential backoff.</div><div class="ttdef"><b>Definition</b> <a href="AppTriggers_8hpp_source.html#l00022">AppTriggers.hpp:22</a></div></div>
</div><!-- fragment --><hr  />
 <h1><a class="anchor" id="comm_ports"></a>
Ports</h1>
<p>Ports are the mechanism in which a resource communicates a message to another resource (for example, via the method <a class="el" href="classsparta_1_1DataOutPort.html#aff5410bcc188a40ebd3434a80b7ae94e" title="Send data to bound receivers.">sparta::DataOutPort::send</a>). The two resources do not know about each other and don't need to. Typically, during <a class="el" href="classsparta_1_1app_1_1Simulation.html#a200bdd31a21e24a242770fcb8e7fff5f" title="Finalizes the device tree.">sparta::app::Simulation::finalizeTree</a> (calls <a class="el" href="classsparta_1_1app_1_1Simulation.html#a2481dd90dd3544ce4c5b385617c74cb6" title="Allows implementer to bind ports to gether.">sparta::app::Simulation::bindTree_</a>) phase, any <a class="el" href="classsparta_1_1Port.html" title="The port interface used to bind port types together and defines a port behavior.">sparta::Port</a> derived classes that are constructed with a <a class="el" href="classsparta_1_1PortSet.html" title="A TreeNode that represents a set of ports used by a Resource.">sparta::PortSet</a> are bound together using sparta::bind(sparta::Port,
sparta::Port) methods. An example of how this is done is found in details section of <a class="el" href="classsparta_1_1DataOutPort.html" title="DataOutPort is used for transferring any data to another module.">sparta::DataOutPort</a> as well as the example core simulator's ExampleSimulator::buildTree_ (see <a class="el" href="core_example.html">Core Example Using Sparta</a>) method (source found in example/CoreExample/src).</p>
<p>For the receiver of the data, the receiver would have to register a callback on the <a class="el" href="classsparta_1_1DataInPort.html" title="DataInPort receives data from sender using a DataOutPort.">sparta::DataInPort</a> via the <a class="el" href="classsparta_1_1InPort.html#a0c3a7eb0dc8bad5657bb5f7905fb8d78" title="Register a handler to this Port (must be Direction::IN) to handle data arrival.">sparta::DataInPort::registerConsumerHandler</a>. This callback <b>must</b> be a member of the containing class or another persistent class in simulation.</p>
<p>Example of a device receiving data can be found in <code>example/Documentation/communication/Ports_example.hpp</code>:</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;cinttypes&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="TreeNode_8hpp.html">sparta/simulation/TreeNode.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="ParameterSet_8hpp.html">sparta/simulation/ParameterSet.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="Unit_8hpp.html">sparta/simulation/Unit.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="PortSet_8hpp.html">sparta/ports/PortSet.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="DataPort_8hpp.html">sparta/ports/DataPort.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define ILOG(msg) \</span></div>
<div class="line"><span class="preprocessor">    if(SPARTA_EXPECT_FALSE(info_logger_)) { \</span></div>
<div class="line"><span class="preprocessor">        info_logger_ &lt;&lt; msg; \</span></div>
<div class="line"><span class="preprocessor">    }</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Basic device parameters</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">class </span>MyDeviceParams : <span class="keyword">public</span> <a class="code hl_class" href="classsparta_1_1ParameterSet.html">sparta::ParameterSet</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyDeviceParams(<a class="code hl_class" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a>* n) :</div>
<div class="line">        <a class="code hl_namespace" href="namespacesparta.html">sparta</a>::ParameterSet(n)</div>
<div class="line">    {</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">auto</span> a_dumb_true_validator = [](<span class="keywordtype">bool</span> &amp; val, <span class="keyword">const</span> <a class="code hl_class" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a>*)-&gt;<span class="keywordtype">bool</span> {</div>
<div class="line">            <span class="comment">// Really dumb validator</span></div>
<div class="line">            <span class="keywordflow">if</span>(val == <span class="keyword">true</span>) {</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        };</div>
<div class="line">        my_device_param.addDependentValidationCallback(a_dumb_true_validator,</div>
<div class="line">                                                       <span class="stringliteral">&quot;My device parameter must be true&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    <a class="code hl_define" href="ParameterSet_8hpp.html#ad28d04879dbb0b83eae950324ae0493a">PARAMETER</a>(<span class="keywordtype">bool</span>, my_device_param, <span class="keyword">true</span>, <span class="stringliteral">&quot;An example device parameter&quot;</span>)</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Example of a Device in simulation</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">class </span>MyDevice : <span class="keyword">public</span> <a class="code hl_class" href="classsparta_1_1Unit.html">sparta::Unit</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Typical and expected constructor signature if this device is</span></div>
<div class="line">    <span class="comment">// build using sparta::ResourceFactory concept</span></div>
<div class="line">    MyDevice(<a class="code hl_class" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a> * parent_node, <span class="comment">// The TreeNode this Devive belongs to</span></div>
<div class="line">             <span class="keyword">const</span> MyDeviceParams * my_params);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Name of this resource. Required by sparta::ResourceFactory.  The</span></div>
<div class="line">    <span class="comment">// code will not compile without it</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * name;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// A data in port that receives uint32_t</span></div>
<div class="line">    <a class="code hl_class" href="classsparta_1_1DataInPort.html">sparta::DataInPort&lt;uint32_t&gt;</a> a_delay_in_;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The callback to receive data from a sender</span></div>
<div class="line">    <span class="keywordtype">void</span> myDataReceiver_(<span class="keyword">const</span> uint32_t &amp; dat);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Defined name</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> * MyDevice::name = <span class="stringliteral">&quot;my_device&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Implementation</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Construction</span></div>
<div class="line">MyDevice::MyDevice(<a class="code hl_class" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a> * my_node,</div>
<div class="line">                   <span class="keyword">const</span> MyDeviceParams * my_params) :</div>
<div class="line">    <a class="code hl_namespace" href="namespacesparta.html">sparta</a>::Unit(my_node, name),</div>
<div class="line">    a_delay_in_(&amp;unit_port_set_, <span class="stringliteral">&quot;a_delay_in&quot;</span>, 1) <span class="comment">// Receive data one cycle later</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Tell SPARTA to ignore this parameter</span></div>
<div class="line">    my_params-&gt;my_device_param.ignore();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Register the callback</span></div>
<div class="line">    a_delay_in_.</div>
<div class="line">        registerConsumerHandler(<a class="code hl_define" href="SpartaHandler_8hpp.html#a730d425d4939baaa8b16c245f5091020">CREATE_SPARTA_HANDLER_WITH_DATA</a>(MyDevice, myDataReceiver_, uint32_t));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This function will be called when a sender with a DataOutPort</span></div>
<div class="line"><span class="comment">// sends data on its out port.  An example would look like:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//     a_delay_out.send(1234);</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">void</span> MyDevice::myDataReceiver_(<span class="keyword">const</span> uint32_t &amp; dat)</div>
<div class="line">{</div>
<div class="line">    ILOG(<span class="stringliteral">&quot;I got data: &quot;</span> &lt;&lt; dat);</div>
<div class="line">}</div>
<div class="ttc" id="aDataPort_8hpp_html"><div class="ttname"><a href="DataPort_8hpp.html">DataPort.hpp</a></div><div class="ttdoc">File that defines Data[In,Out]Port&lt;DataT&gt;</div></div>
<div class="ttc" id="aParameterSet_8hpp_html"><div class="ttname"><a href="ParameterSet_8hpp.html">ParameterSet.hpp</a></div><div class="ttdoc">A set of sparta::Parameters per sparta::ResourceTreeNode.</div></div>
<div class="ttc" id="aParameterSet_8hpp_html_ad28d04879dbb0b83eae950324ae0493a"><div class="ttname"><a href="ParameterSet_8hpp.html#ad28d04879dbb0b83eae950324ae0493a">PARAMETER</a></div><div class="ttdeci">#define PARAMETER(type, name, def, doc)</div><div class="ttdoc">Parameter declaration.</div><div class="ttdef"><b>Definition</b> <a href="ParameterSet_8hpp_source.html#l00741">ParameterSet.hpp:741</a></div></div>
<div class="ttc" id="aPortSet_8hpp_html"><div class="ttname"><a href="PortSet_8hpp.html">PortSet.hpp</a></div><div class="ttdoc">File that defines the PortSet class.</div></div>
<div class="ttc" id="aSpartaHandler_8hpp_html_a730d425d4939baaa8b16c245f5091020"><div class="ttname"><a href="SpartaHandler_8hpp.html#a730d425d4939baaa8b16c245f5091020">CREATE_SPARTA_HANDLER_WITH_DATA</a></div><div class="ttdeci">#define CREATE_SPARTA_HANDLER_WITH_DATA(clname, meth, dataT)</div><div class="ttdef"><b>Definition</b> <a href="SpartaHandler_8hpp_source.html#l00441">SpartaHandler.hpp:441</a></div></div>
<div class="ttc" id="aTreeNode_8hpp_html"><div class="ttname"><a href="TreeNode_8hpp.html">TreeNode.hpp</a></div><div class="ttdoc">Basic Node framework in sparta device tree composite pattern.</div></div>
<div class="ttc" id="aUnit_8hpp_html"><div class="ttname"><a href="Unit_8hpp.html">Unit.hpp</a></div><div class="ttdoc">File that defines the Unit class, a common grouping of sets and loggers.</div></div>
<div class="ttc" id="aclasssparta_1_1DataInPort_html"><div class="ttname"><a href="classsparta_1_1DataInPort.html">sparta::DataInPort</a></div><div class="ttdoc">DataInPort receives data from sender using a DataOutPort.</div><div class="ttdef"><b>Definition</b> <a href="DataPort_8hpp_source.html#l00288">DataPort.hpp:289</a></div></div>
<div class="ttc" id="aclasssparta_1_1ParameterSet_html"><div class="ttname"><a href="classsparta_1_1ParameterSet.html">sparta::ParameterSet</a></div><div class="ttdoc">Generic container of Parameters.</div><div class="ttdef"><b>Definition</b> <a href="ParameterSet_8hpp_source.html#l00064">ParameterSet.hpp:65</a></div></div>
<div class="ttc" id="aclasssparta_1_1TreeNode_html"><div class="ttname"><a href="classsparta_1_1TreeNode.html">sparta::TreeNode</a></div><div class="ttdoc">Node in a composite tree representing a sparta Tree item.</div><div class="ttdef"><b>Definition</b> <a href="TreeNode_8hpp_source.html#l00204">TreeNode.hpp:205</a></div></div>
<div class="ttc" id="aclasssparta_1_1Unit_html"><div class="ttname"><a href="classsparta_1_1Unit.html">sparta::Unit</a></div><div class="ttdoc">The is the base class for user defined blocks in simulation.</div><div class="ttdef"><b>Definition</b> <a href="Unit_8hpp_source.html#l00037">Unit.hpp:38</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="sync_ports"></a>
sparta::SyncPorts</h2>
<p>To enable communication between components on different Clock boundaries, use <a class="el" href="classsparta_1_1SyncInPort.html" title="Class that defines an synchronized input port on modules on two different clocks.">sparta::SyncInPort</a> and <a class="el" href="classsparta_1_1SyncOutPort.html" title="Class that defines a synchronized SyncOutPort for data writes on different clocks.">sparta::SyncOutPort</a>. This type of port is identical to DataIn/OutPort with the exception that data sent on the out port is delayed until the "rising edge" of the receiver's clock. See <a class="el" href="classsparta_1_1SyncOutPort.html" title="Class that defines a synchronized SyncOutPort for data writes on different clocks.">sparta::SyncOutPort</a> for more information.</p>
<hr  />
 <h1><a class="anchor" id="comm_events"></a>
Events</h1>
<p>Events are mechanism to allow the scheduling of work based on activity within a resource. For example, the receiving of data from an external resource on a port might trigger the need to act upon that data and send it on. Take the previous example in the Port section and add an event based on the receiving of data (found example/Documentation/communication/Events_example.hpp).</p>
<div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;cinttypes&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="TreeNode_8hpp.html">sparta/simulation/TreeNode.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="ParameterSet_8hpp.html">sparta/simulation/ParameterSet.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="Unit_8hpp.html">sparta/simulation/Unit.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="PortSet_8hpp.html">sparta/ports/PortSet.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="DataPort_8hpp.html">sparta/ports/DataPort.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Include Event.h</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="Event_8hpp.html">sparta/events/Event.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define ILOG(msg) \</span></div>
<div class="line"><span class="preprocessor">    if(SPARTA_EXPECT_FALSE(info_logger_)) { \</span></div>
<div class="line"><span class="preprocessor">        info_logger_ &lt;&lt; msg; \</span></div>
<div class="line"><span class="preprocessor">    }</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyDeviceParams : <span class="keyword">public</span> <a class="code hl_class" href="classsparta_1_1ParameterSet.html">sparta::ParameterSet</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyDeviceParams(<a class="code hl_class" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a>* n) :</div>
<div class="line">        <a class="code hl_namespace" href="namespacesparta.html">sparta</a>::ParameterSet(n)</div>
<div class="line">    {</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">auto</span> a_dumb_true_validator = [](<span class="keywordtype">bool</span> &amp; val, <span class="keyword">const</span> <a class="code hl_class" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a>*)-&gt;<span class="keywordtype">bool</span> {</div>
<div class="line">            <span class="comment">// Really dumb validator</span></div>
<div class="line">            <span class="keywordflow">if</span>(val == <span class="keyword">true</span>) {</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        };</div>
<div class="line">        my_device_param.addDependentValidationCallback(a_dumb_true_validator,</div>
<div class="line">                                                       <span class="stringliteral">&quot;My device parameter must be true&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    <a class="code hl_define" href="ParameterSet_8hpp.html#ad28d04879dbb0b83eae950324ae0493a">PARAMETER</a>(<span class="keywordtype">bool</span>, my_device_param, <span class="keyword">true</span>, <span class="stringliteral">&quot;An example device parameter&quot;</span>)</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyDevice : <span class="keyword">public</span> <a class="code hl_class" href="classsparta_1_1Unit.html">sparta::Unit</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyDevice(<a class="code hl_class" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a> * parent_node,</div>
<div class="line">             <span class="keyword">const</span> MyDeviceParams * my_params);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * name;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// A data in port that receives uint32_t</span></div>
<div class="line">    <a class="code hl_class" href="classsparta_1_1DataInPort.html">sparta::DataInPort&lt;uint32_t&gt;</a> a_delay_in_;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The callback to receive data from a sender</span></div>
<div class="line">    <span class="keywordtype">void</span> myDataReceiver_(<span class="keyword">const</span> uint32_t &amp; dat);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// An event to be scheduled in the sparta::SchedulingPhase::Tick</span></div>
<div class="line">    <span class="comment">// phase if data is received</span></div>
<div class="line">    <a class="code hl_class" href="classsparta_1_1Event.html">sparta::Event&lt;&gt;</a> event_do_some_work_{&amp;<a class="code hl_variable" href="classsparta_1_1Unit.html#a05e1c7baa56947c79d72fe4334be0653">unit_event_set_</a>, <span class="stringliteral">&quot;do_work_event&quot;</span>,</div>
<div class="line">                                        <a class="code hl_define" href="SpartaHandler_8hpp.html#aa0cfa5521686f6c2ca417e1d972ebc45">CREATE_SPARTA_HANDLER</a>(MyDevice, doSomeWork_)};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Method called by the event &#39;event_do_some_work_&#39;</span></div>
<div class="line">    <span class="keywordtype">void</span> doSomeWork_();</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Source</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> * MyDevice::name = <span class="stringliteral">&quot;my_device&quot;</span>;</div>
<div class="line"> </div>
<div class="line">MyDevice::MyDevice(<a class="code hl_class" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a> * my_node,</div>
<div class="line">                   <span class="keyword">const</span> MyDeviceParams * my_params) :</div>
<div class="line">    <a class="code hl_namespace" href="namespacesparta.html">sparta</a>::Unit(my_node, name),</div>
<div class="line">    a_delay_in_(&amp;unit_port_set_, <span class="stringliteral">&quot;a_delay_in&quot;</span>, 1) <span class="comment">// Receive data one cycle later</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Tell SPARTA to ignore this parameter</span></div>
<div class="line">    my_params-&gt;my_device_param.ignore();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Register the callback</span></div>
<div class="line">    a_delay_in_.registerConsumerHandler(<a class="code hl_define" href="SpartaHandler_8hpp.html#a730d425d4939baaa8b16c245f5091020">CREATE_SPARTA_HANDLER_WITH_DATA</a>(MyDevice, myDataReceiver_, uint32_t));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This function will be called when a sender with a DataOutPort</span></div>
<div class="line"><span class="comment">// sends data on its out port.  An example would look like:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//     a_delay_out.send(1234);</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">void</span> MyDevice::myDataReceiver_(<span class="keyword">const</span> uint32_t &amp; dat)</div>
<div class="line">{</div>
<div class="line">    ILOG(<span class="stringliteral">&quot;I got data: &quot;</span> &lt;&lt; dat);</div>
<div class="line">    ILOG(<span class="stringliteral">&quot;Time to do some work this cycle: &quot;</span></div>
<div class="line">         &lt;&lt; getClock()-&gt;currentCycle());</div>
<div class="line">    <span class="comment">// Schedule doSomeWork_() for THIS cycle -- implicit precedence, BTW!</span></div>
<div class="line">    event_do_some_work_.schedule();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Called from the scheduler; scheduled by the event_do_some_work_</span></div>
<div class="line"><span class="comment">// event.</span></div>
<div class="line"><span class="keywordtype">void</span> MyDevice::doSomeWork_() {</div>
<div class="line">    ILOG(<span class="stringliteral">&quot;Well, it&#39;s time to do some work. Cycle:&quot;</span></div>
<div class="line">         &lt;&lt; getClock()-&gt;currentCycle());</div>
<div class="line">}</div>
<div class="ttc" id="aEvent_8hpp_html"><div class="ttname"><a href="Event_8hpp.html">Event.hpp</a></div><div class="ttdoc">File that defines the Event class.</div></div>
<div class="ttc" id="aSpartaHandler_8hpp_html_aa0cfa5521686f6c2ca417e1d972ebc45"><div class="ttname"><a href="SpartaHandler_8hpp.html#aa0cfa5521686f6c2ca417e1d972ebc45">CREATE_SPARTA_HANDLER</a></div><div class="ttdeci">#define CREATE_SPARTA_HANDLER(clname, meth)</div><div class="ttdef"><b>Definition</b> <a href="SpartaHandler_8hpp_source.html#l00317">SpartaHandler.hpp:317</a></div></div>
<div class="ttc" id="aclasssparta_1_1Event_html"><div class="ttname"><a href="classsparta_1_1Event.html">sparta::Event</a></div><div class="ttdoc">Event is a simple class for scheduling random events on the Scheduler.</div><div class="ttdef"><b>Definition</b> <a href="Event_8hpp_source.html#l00041">Event.hpp:42</a></div></div>
<div class="ttc" id="aclasssparta_1_1Unit_html_a05e1c7baa56947c79d72fe4334be0653"><div class="ttname"><a href="classsparta_1_1Unit.html#a05e1c7baa56947c79d72fe4334be0653">sparta::Unit::unit_event_set_</a></div><div class="ttdeci">sparta::EventSet unit_event_set_</div><div class="ttdoc">The Unit's event set.</div><div class="ttdef"><b>Definition</b> <a href="Unit_8hpp_source.html#l00114">Unit.hpp:114</a></div></div>
</div><!-- fragment --><p>This isn't a very interesting class as <code>myDataReceiver_()</code> could easily just call <code>doSomeWork_()</code> directly. But, what if <code>MyDevice</code> had <b>two</b> inports that needed to be called <b>before</b> doing some work? That's no problem either. Let's extend the class, but this time adding a second port and changing event_do_some_work_ from a <a class="el" href="classsparta_1_1Event.html" title="Event is a simple class for scheduling random events on the Scheduler.">sparta::Event</a> to a <a class="el" href="classsparta_1_1UniqueEvent.html" title="A type of Event that uniquely schedules itself on the schedule within a single time quantum....">sparta::UniqueEvent</a> to ensure it gets called only once when scheduled by both handlers. Code found in example/Documentation/communication/Events_dual_example.hpp.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;cinttypes&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="TreeNode_8hpp.html">sparta/simulation/TreeNode.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="ParameterSet_8hpp.html">sparta/simulation/ParameterSet.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="Unit_8hpp.html">sparta/simulation/Unit.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="PortSet_8hpp.html">sparta/ports/PortSet.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="DataPort_8hpp.html">sparta/ports/DataPort.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="SpartaAssert_8hpp.html">sparta/utils/SpartaAssert.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Include Event.h</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="Event_8hpp.html">sparta/events/Event.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define ILOG(msg) \</span></div>
<div class="line"><span class="preprocessor">    if(SPARTA_EXPECT_FALSE(info_logger_)) { \</span></div>
<div class="line"><span class="preprocessor">        info_logger_ &lt;&lt; msg; \</span></div>
<div class="line"><span class="preprocessor">    }</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyDeviceParams : <span class="keyword">public</span> <a class="code hl_class" href="classsparta_1_1ParameterSet.html">sparta::ParameterSet</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyDeviceParams(<a class="code hl_class" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a>* n) :</div>
<div class="line">        <a class="code hl_namespace" href="namespacesparta.html">sparta</a>::ParameterSet(n)</div>
<div class="line">    {</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">auto</span> a_dumb_true_validator = [](<span class="keywordtype">bool</span> &amp; val, <span class="keyword">const</span> <a class="code hl_class" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a>*)-&gt;<span class="keywordtype">bool</span> {</div>
<div class="line">            <span class="comment">// Really dumb validator</span></div>
<div class="line">            <span class="keywordflow">if</span>(val == <span class="keyword">true</span>) {</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        };</div>
<div class="line">        my_device_param.addDependentValidationCallback(a_dumb_true_validator,</div>
<div class="line">                                                       <span class="stringliteral">&quot;My device parameter must be true&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    <a class="code hl_define" href="ParameterSet_8hpp.html#ad28d04879dbb0b83eae950324ae0493a">PARAMETER</a>(<span class="keywordtype">bool</span>, my_device_param, <span class="keyword">true</span>, <span class="stringliteral">&quot;An example device parameter&quot;</span>)</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyDevice : <span class="keyword">public</span> <a class="code hl_class" href="classsparta_1_1Unit.html">sparta::Unit</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyDevice(<a class="code hl_class" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a> * parent_node,</div>
<div class="line">             <span class="keyword">const</span> MyDeviceParams * my_params);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * name;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// A data in port that receives uint32_t from source 1</span></div>
<div class="line">    <a class="code hl_class" href="classsparta_1_1DataInPort.html">sparta::DataInPort&lt;uint32_t&gt;</a> a_delay_in_source1_;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The callback to receive data from the first sender</span></div>
<div class="line">    <span class="keywordtype">void</span> myDataReceiverFromSource1_(<span class="keyword">const</span> uint32_t &amp; dat1);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// A data in port that receives uint32_t from a second source</span></div>
<div class="line">    <a class="code hl_class" href="classsparta_1_1DataInPort.html">sparta::DataInPort&lt;uint32_t&gt;</a> a_delay_in_source2_;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The callback to receive data from a second sender</span></div>
<div class="line">    <span class="keywordtype">void</span> myDataReceiverFromSource2_(<span class="keyword">const</span> uint32_t &amp; dat2);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// An event to be scheduled if data is received, but it&#39;s unique!</span></div>
<div class="line">    <span class="comment">// This means it can scheduled many times for a given cycle, but</span></div>
<div class="line">    <span class="comment">// it&#39;s only called once.  Also, this event in the</span></div>
<div class="line">    <span class="comment">// SchedulingPhase::Tick phase with a delay of 0.</span></div>
<div class="line">    <a class="code hl_class" href="classsparta_1_1UniqueEvent.html">sparta::UniqueEvent&lt;&gt;</a> event_do_some_work_{&amp;<a class="code hl_variable" href="classsparta_1_1Unit.html#a05e1c7baa56947c79d72fe4334be0653">unit_event_set_</a>, <span class="stringliteral">&quot;do_some_work_event&quot;</span>,</div>
<div class="line">            <a class="code hl_define" href="SpartaHandler_8hpp.html#aa0cfa5521686f6c2ca417e1d972ebc45">CREATE_SPARTA_HANDLER</a>(MyDevice, doSomeWork_)};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Method called by the event &#39;event_do_some_work_&#39;</span></div>
<div class="line">    <span class="keywordtype">void</span> doSomeWork_();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The data in question. DO NOT initialize</span></div>
<div class="line">    <a class="code hl_class" href="classsparta_1_1utils_1_1ValidValue.html">sparta::utils::ValidValue&lt;uint32_t&gt;</a> data1_;</div>
<div class="line">    <a class="code hl_class" href="classsparta_1_1utils_1_1ValidValue.html">sparta::utils::ValidValue&lt;uint32_t&gt;</a> data2_;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The result after getting both data</span></div>
<div class="line">    uint32_t total_data_ = 0;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Source</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> * MyDevice::name = <span class="stringliteral">&quot;my_device&quot;</span>;</div>
<div class="line"> </div>
<div class="line">MyDevice::MyDevice(<a class="code hl_class" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a> * my_node,</div>
<div class="line">                   <span class="keyword">const</span> MyDeviceParams * my_params) :</div>
<div class="line">    <a class="code hl_namespace" href="namespacesparta.html">sparta</a>::Unit(my_node, name),</div>
<div class="line">    a_delay_in_source1_(&amp;unit_port_set_, <span class="stringliteral">&quot;a_delay_in_source1&quot;</span>, 1), <span class="comment">// Receive data one cycle later</span></div>
<div class="line">    a_delay_in_source2_(&amp;unit_port_set_, <span class="stringliteral">&quot;a_delay_in_source2&quot;</span>, 1)  <span class="comment">// Receive data one cycle later</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Tell SPARTA to ignore this parameter</span></div>
<div class="line">    my_params-&gt;my_device_param.ignore();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Register the callbacks.  These callbacks are called in the</span></div>
<div class="line">    <span class="comment">// Port&#39;s SchedulingPhase::PortUpdate phase (which is before</span></div>
<div class="line">    <span class="comment">// SchedulingPhase::Tick)</span></div>
<div class="line">    a_delay_in_source1_.registerConsumerHandler(</div>
<div class="line">       <a class="code hl_define" href="SpartaHandler_8hpp.html#a730d425d4939baaa8b16c245f5091020">CREATE_SPARTA_HANDLER_WITH_DATA</a>(MyDevice, myDataReceiverFromSource1_, uint32_t));</div>
<div class="line">    a_delay_in_source2_.registerConsumerHandler(</div>
<div class="line">       <a class="code hl_define" href="SpartaHandler_8hpp.html#a730d425d4939baaa8b16c245f5091020">CREATE_SPARTA_HANDLER_WITH_DATA</a>(MyDevice, myDataReceiverFromSource2_, uint32_t));</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This function will be called when a sender with a DataOutPort</span></div>
<div class="line"><span class="comment">// sends data on its out port.  An example would look like:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//     a_delay_out_source1_.send(1234);</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">void</span> MyDevice::myDataReceiverFromSource1_(<span class="keyword">const</span> uint32_t &amp; dat)</div>
<div class="line">{</div>
<div class="line">    ILOG(<span class="stringliteral">&quot;I got data from Source1: &quot;</span> &lt;&lt; dat);</div>
<div class="line">    ILOG(<span class="stringliteral">&quot;Time to do some work this cycle: &quot;</span> &lt;&lt; getClock()-&gt;currentCycle());</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Schedule doSomeWork_() for THIS cycle.  Doesn&#39;t matter if data</span></div>
<div class="line">    <span class="comment">// from Source2 is here yet.  Since the event_do_some_work_ is in</span></div>
<div class="line">    <span class="comment">// the SchedulingPhase::Tick phase, it will be scheduled for later</span></div>
<div class="line">    <span class="comment">// in this cycle. No argument to schedule == 0 cycle delay.</span></div>
<div class="line">    event_do_some_work_.schedule();</div>
<div class="line">    <a class="code hl_define" href="SpartaAssert_8hpp.html#a64d6ced6d78b1678a0564374f5801c04">sparta_assert</a>(!data1_.isValid());</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Save the data</span></div>
<div class="line">    data1_ = dat;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This function will be called when a sender with a DataOutPort</span></div>
<div class="line"><span class="comment">// sends data on its out port.  An example would look like:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//     a_delay_out_source2_.send(4321);</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">void</span> MyDevice::myDataReceiverFromSource2_(<span class="keyword">const</span> uint32_t &amp; dat)</div>
<div class="line">{</div>
<div class="line">    ILOG(<span class="stringliteral">&quot;I got data from Source2: &quot;</span> &lt;&lt; dat);</div>
<div class="line">    ILOG(<span class="stringliteral">&quot;Time to do some work this cycle: &quot;</span> &lt;&lt; getClock()-&gt;currentCycle());</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Schedule doSomeWork_() for THIS cycle.  Since the</span></div>
<div class="line">    <span class="comment">// event_do_some_work_ is in the SchedulingPhase::Tick phase, it</span></div>
<div class="line">    <span class="comment">// will be scheduled for later in this cycle.</span></div>
<div class="line">    event_do_some_work_.schedule();</div>
<div class="line">    <a class="code hl_define" href="SpartaAssert_8hpp.html#a64d6ced6d78b1678a0564374f5801c04">sparta_assert</a>(!data2_.isValid());</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Save the data</span></div>
<div class="line">    data2_ = dat;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Called from the scheduler; scheduled by the event_do_some_work_</span></div>
<div class="line"><span class="comment">// event.</span></div>
<div class="line"><span class="keywordtype">void</span> MyDevice::doSomeWork_() {</div>
<div class="line">    ILOG(<span class="stringliteral">&quot;Well, it&#39;s time to do some work. Cycle: &quot;</span> &lt;&lt; getClock()-&gt;currentCycle());</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="SpartaAssert_8hpp.html#a64d6ced6d78b1678a0564374f5801c04">sparta_assert</a>(data1_.isValid() &amp;&amp; data2_.isValid(),</div>
<div class="line">                  <span class="stringliteral">&quot;Hey, we didn&#39;t get data1 and data2 before&quot;</span><span class="stringliteral">&quot; this function was called!&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    ILOG(<span class="stringliteral">&quot;Got these values: &quot;</span></div>
<div class="line">         &lt;&lt; data1_.getValue() &lt;&lt; <span class="stringliteral">&quot; and &quot;</span></div>
<div class="line">         &lt;&lt; data2_.getValue());</div>
<div class="line"> </div>
<div class="line">    total_data_ = data1_.getValue() + data2_.getValue();</div>
<div class="line">    data1_.clearValid();</div>
<div class="line">    data2_.clearValid();</div>
<div class="line">}</div>
<div class="ttc" id="aSpartaAssert_8hpp_html"><div class="ttname"><a href="SpartaAssert_8hpp.html">SpartaAssert.hpp</a></div><div class="ttdoc">Set of macros for Sparta assertions. Caught by the framework.</div></div>
<div class="ttc" id="aSpartaAssert_8hpp_html_a64d6ced6d78b1678a0564374f5801c04"><div class="ttname"><a href="SpartaAssert_8hpp.html#a64d6ced6d78b1678a0564374f5801c04">sparta_assert</a></div><div class="ttdeci">#define sparta_assert(...)</div><div class="ttdoc">Simple variadic assertion that will throw a sparta_exception if the condition fails.</div><div class="ttdef"><b>Definition</b> <a href="SpartaAssert_8hpp_source.html#l00114">SpartaAssert.hpp:114</a></div></div>
<div class="ttc" id="aclasssparta_1_1UniqueEvent_html"><div class="ttname"><a href="classsparta_1_1UniqueEvent.html">sparta::UniqueEvent</a></div><div class="ttdoc">A type of Event that uniquely schedules itself on the schedule within a single time quantum....</div><div class="ttdef"><b>Definition</b> <a href="UniqueEvent_8hpp_source.html#l00072">UniqueEvent.hpp:73</a></div></div>
<div class="ttc" id="aclasssparta_1_1utils_1_1ValidValue_html"><div class="ttname"><a href="classsparta_1_1utils_1_1ValidValue.html">sparta::utils::ValidValue</a></div><div class="ttdoc">Provides a wrapper around a value to ensure that the value is assigned.</div><div class="ttdef"><b>Definition</b> <a href="ValidValue_8hpp_source.html#l00025">ValidValue.hpp:26</a></div></div>
</div><!-- fragment --><hr  />
 <h1><a class="anchor" id="comm_clocks"></a>
Clocks</h1>
<p>Sparta's clocking and clock management are contained in <a class="el" href="classsparta_1_1Clock.html" title="A representation of simulated time.">sparta::Clock</a> and <a class="el" href="classsparta_1_1ClockManager.html" title="Manages building a clock tree.">sparta::ClockManager</a> classes. The main difference to note in Sparta, is that <a class="el" href="classsparta_1_1Clock.html" title="A representation of simulated time.">sparta::Clock</a> objects are not event-based objects nor do they constantly "clock" as simulation progresses (like in other frameworks). <a class="el" href="classsparta_1_1Clock.html" title="A representation of simulated time.">sparta::Clock</a> objects are simply available to convert simulation time (from the <a class="el" href="classsparta_1_1Scheduler.html" title="A class that lets you schedule events now and in the future.">sparta::Scheduler</a>) to clock time based on that clock's frequency. Therefor, in simulation, <a class="el" href="classsparta_1_1Clock.html" title="A representation of simulated time.">sparta::Clock</a> objects are passed around as constant objects. In addition, there is no notion of a "rising edge" nor a "falling edge" in simulation (however, the <a class="el" href="classsparta_1_1Clock.html" title="A representation of simulated time.">sparta::Clock</a> supports this notion if absolutely needed). Instead, the Clocks are used to simply answer the question, what time (in NS) on the Scheduler should Event X be scheduled?</p>
<p>Using the <a class="el" href="classsparta_1_1ClockManager.html" title="Manages building a clock tree.">sparta::ClockManager</a> and the <a class="el" href="classsparta_1_1Clock.html" title="A representation of simulated time.">sparta::Clock</a> classes are pretty straight-forward. By default the <a class="el" href="classsparta_1_1ClockManager.html" title="Manages building a clock tree.">sparta::ClockManager</a> contains a root clock that runs at the Scheduler frequency: 1 cycle == 1 NS. This is called the master clock (and denotes the "hypercycle"). From the master clock, more clocks can be created and then associated with <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">sparta::TreeNode</a> objects that Device objects hang off of:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsparta_1_1RootTreeNode.html">sparta::RootTreeNode</a> root_clks(<span class="stringliteral">&quot;clocks&quot;</span>,</div>
<div class="line">                              <span class="stringliteral">&quot;Clock Tree Root&quot;</span>,</div>
<div class="line">                              root_node.getSearchScope());</div>
<div class="line"><a class="code hl_class" href="classsparta_1_1ClockManager.html">sparta::ClockManager</a> cm;</div>
<div class="line">sparta::Clock::Handle root_clk = cm.<a class="code hl_function" href="classsparta_1_1ClockManager.html#ab8957cecec6faa5fb61fd7d08b6fbbd7">makeRoot</a>(&amp;root_clks);</div>
<div class="line">sparta::Clock::Handle clk_1000 = cm.<a class="code hl_function" href="classsparta_1_1ClockManager.html#aee425829935a2f92efa250f07cc6451b">makeClock</a>(<span class="stringliteral">&quot;clk_1000&quot;</span>, root_clk, 1000.0);</div>
<div class="line">sparta::Clock::Handle clk_100  = cm.<a class="code hl_function" href="classsparta_1_1ClockManager.html#aee425829935a2f92efa250f07cc6451b">makeClock</a>(<span class="stringliteral">&quot;clk_100&quot;</span>,  root_clk,  100.0);</div>
<div class="line">sparta::Clock::Handle clk_10   = cm.<a class="code hl_function" href="classsparta_1_1ClockManager.html#aee425829935a2f92efa250f07cc6451b">makeClock</a>(<span class="stringliteral">&quot;clk_10&quot;</span>,   root_clk, 10.0);</div>
<div class="line"> </div>
<div class="line">root_tree_node_.setClock(root_clk.get()); <span class="comment">// The root is at highest freq</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// The device &quot;runs&quot; at 1GHz.  I.e. it&#39;s events are scheduled at that</span></div>
<div class="line"><span class="comment">// time frame.</span></div>
<div class="line">my_device_node_.setClock(clk_1000.get());</div>
<div class="ttc" id="aclasssparta_1_1ClockManager_html"><div class="ttname"><a href="classsparta_1_1ClockManager.html">sparta::ClockManager</a></div><div class="ttdoc">Manages building a clock tree.</div><div class="ttdef"><b>Definition</b> <a href="ClockManager_8hpp_source.html#l00028">ClockManager.hpp:29</a></div></div>
<div class="ttc" id="aclasssparta_1_1ClockManager_html_ab8957cecec6faa5fb61fd7d08b6fbbd7"><div class="ttname"><a href="classsparta_1_1ClockManager.html#ab8957cecec6faa5fb61fd7d08b6fbbd7">sparta::ClockManager::makeRoot</a></div><div class="ttdeci">Clock::Handle makeRoot(RootTreeNode *parent=nullptr, const std::string &amp;name=&quot;Root&quot;)</div><div class="ttdoc">Construct a root clock.</div><div class="ttdef"><b>Definition</b> <a href="ClockManager_8hpp_source.html#l00058">ClockManager.hpp:58</a></div></div>
<div class="ttc" id="aclasssparta_1_1ClockManager_html_aee425829935a2f92efa250f07cc6451b"><div class="ttname"><a href="classsparta_1_1ClockManager.html#aee425829935a2f92efa250f07cc6451b">sparta::ClockManager::makeClock</a></div><div class="ttdeci">Clock::Handle makeClock(const std::string &amp;name, const Clock::Handle &amp;parent, const uint32_t &amp;p_rat, const uint32_t &amp;c_rat)</div><div class="ttdoc">Create a new clock with a given ratio to a parent clock.</div><div class="ttdef"><b>Definition</b> <a href="ClockManager_8hpp_source.html#l00075">ClockManager.hpp:75</a></div></div>
<div class="ttc" id="aclasssparta_1_1RootTreeNode_html"><div class="ttname"><a href="classsparta_1_1RootTreeNode.html">sparta::RootTreeNode</a></div><div class="ttdoc">TreeNode which represents the root (&quot;top&quot;) of a device tree.</div><div class="ttdef"><b>Definition</b> <a href="RootTreeNode_8hpp_source.html#l00049">RootTreeNode.hpp:50</a></div></div>
</div><!-- fragment --><hr  />
 <h1><a class="anchor" id="comm_schedulers"></a>
Scheduling</h1>
<h2><a class="anchor" id="sparta_Scheduler"></a>
sparta::Scheduler</h2>
<p>The <a class="el" href="classsparta_1_1Scheduler.html" title="A class that lets you schedule events now and in the future.">sparta::Scheduler</a> class simply schedules callback methods for some time in the future. These callbacks are typically scheduled by <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">sparta::Scheduleable</a> class and its derivatives, but the sparta::scheduler is open to anyone who wishes to schedule a callback (but this is highly discouraged).</p>
<p>The callback type is sparta::SpartaHandler, a copyable method delegate that allows a user to specify a function of their class as a callback point. The callback form is expected to be of the following:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> func(); </div>
</div><!-- fragment --><p>Time in the <a class="el" href="classsparta_1_1Scheduler.html" title="A class that lets you schedule events now and in the future.">sparta::Scheduler</a> can be interpreted anyway the user wishes, but the base unit is a <a class="el" href="classsparta_1_1Scheduler.html#a2c6114226a2d41fb22ac0395520b56c3" title="Typedef for our unit of time.">sparta::Scheduler::Tick</a>. For most simulation uses, the Tick is considered a PS of time. To convert a Tick to a higher-order unit such as a clock cycle, use a <a class="el" href="classsparta_1_1Clock.html" title="A representation of simulated time.">sparta::Clock</a> made from a <a class="el" href="classsparta_1_1ClockManager.html" title="Manages building a clock tree.">sparta::ClockManager</a> to perform the conversions.</p>
<p>A typical flow for scheduling events is:</p>
<ol type="1">
<li>Create an <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">sparta::Scheduleable</a> (or derivative <a class="el" href="classsparta_1_1Event.html" title="Event is a simple class for scheduling random events on the Scheduler.">sparta::Event</a>, <a class="el" href="classsparta_1_1UniqueEvent.html" title="A type of Event that uniquely schedules itself on the schedule within a single time quantum....">sparta::UniqueEvent</a>, <a class="el" href="classsparta_1_1PayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...">sparta::PayloadEvent</a>) object with a given handler and a <a class="el" href="classsparta_1_1EventSet.html" title="Set of Events that a unit (or sparta::TreeNode, sparta::Resource) contains and are visible through a ...">sparta::EventSet</a> (that contains a <a class="el" href="classsparta_1_1Clock.html" title="A representation of simulated time.">sparta::Clock</a>)</li>
<li>Schedule the event using the event's schedule method, which will place the event on the <a class="el" href="classsparta_1_1Scheduler.html" title="A class that lets you schedule events now and in the future.">sparta::Scheduler</a> at the appropriate Tick using the <a class="el" href="classsparta_1_1Clock.html" title="A representation of simulated time.">sparta::Clock</a> it got from the <a class="el" href="classsparta_1_1EventSet.html" title="Set of Events that a unit (or sparta::TreeNode, sparta::Resource) contains and are visible through a ...">sparta::EventSet</a></li>
<li>Wait for the <a class="el" href="classsparta_1_1Scheduler.html" title="A class that lets you schedule events now and in the future.">sparta::Scheduler</a> to get around to calling the method during the <a class="el" href="classsparta_1_1Scheduler.html#ac8b6c6c9118216f12c31e4870f69e794" title="Enter running state and runs the scheduler until running is stopped (e.g. through a stop event) or th...">sparta::Scheduler::run</a> call</li>
</ol>
<p>The <a class="el" href="classsparta_1_1Scheduler.html" title="A class that lets you schedule events now and in the future.">sparta::Scheduler</a> is a <a class="el" href="classsparta_1_1RootTreeNode.html" title="TreeNode which represents the root (&quot;top&quot;) of a device tree.">sparta::RootTreeNode</a> so that it can be seen in a global search scope, and loggers can be attached. For example, try this on the CoreExample:</p>
<div class="fragment"><div class="line">&lt;build-dir&gt;/example/CoreExample/sparta_core_example -r 1000 -l scheduler debug 1</div>
</div><!-- fragment --><p>Or do this in your C++ code: </p><div class="fragment"><div class="line"><span class="keyword">new</span> <a class="code hl_class" href="classsparta_1_1log_1_1Tap.html">sparta::log::Tap</a>(&amp;my_scheduler_, <span class="stringliteral">&quot;debug&quot;</span>, std::cout);</div>
<div class="ttc" id="aclasssparta_1_1log_1_1Tap_html"><div class="ttname"><a href="classsparta_1_1log_1_1Tap.html">sparta::log::Tap</a></div><div class="ttdoc">Logging Tap. Attach to a TreeNode to intercept logging messages from any NotificationSource nodes in ...</div><div class="ttdef"><b>Definition</b> <a href="Tap_8hpp_source.html#l00027">Tap.hpp:28</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="event_ordering"></a>
Event Ordering</h1>
<p>The <a class="el" href="classsparta_1_1Scheduler.html" title="A class that lets you schedule events now and in the future.">sparta::Scheduler</a> has a concept of "phased grouping" that allows a user to specify which callback they want called before another in time. Each SPARTA event type has an associated <a class="el" href="namespacesparta.html#aeec80d237ace9f07634c3d24c9aed9a0" title="The SchedulingPhases used for events (Tick, Update, PortUpdate, etc)">sparta::SchedulingPhase</a> phase in its template parameter list that the event will always be placed in. In that phase, the event will always come before a "higher priority phase" and always after a "lower priority phase." But, <em>within</em> its assigned phase, the event will still be semi-random with respect to other events. It's "semi-random," meaning order will be indentical between simulation runs, but possibly different once the simulator is modified at the source-code level. This can be annoying.</p>
<p>Ordering within a phase is provided by a Direct Acyclic Graph or <a class="el" href="classsparta_1_1DAG.html">sparta::DAG</a>. The DAG uses a class called <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">sparta::Scheduleable</a> that represents a position within the DAG and an ordering group within a SchedulingPhase. By default the <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">sparta::Scheduleable</a> is not in a group and is standalone within its assigned <a class="el" href="namespacesparta.html#aeec80d237ace9f07634c3d24c9aed9a0" title="The SchedulingPhases used for events (Tick, Update, PortUpdate, etc)">sparta::SchedulingPhase</a>. Once a precedence between two <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">sparta::Scheduleable</a> objects is established, an ordering with assigned. This results in each <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">sparta::Scheduleable</a> being designated into an ordering group by the DAG. Event types (<a class="el" href="classsparta_1_1Event.html" title="Event is a simple class for scheduling random events on the Scheduler.">sparta::Event</a>, <a class="el" href="classsparta_1_1UniqueEvent.html" title="A type of Event that uniquely schedules itself on the schedule within a single time quantum....">sparta::UniqueEvent</a>, <a class="el" href="classsparta_1_1PayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...">sparta::PayloadEvent</a>) provide this support. The developer can order an event type to precede another event, but only if the events are in the same SchedulingPhase:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsparta_1_1EventSet.html">sparta::EventSet</a> my_ev_set;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// These events are created in the SchedulingPhase::Tick by default.</span></div>
<div class="line"><a class="code hl_class" href="classsparta_1_1Event.html">sparta::Event&lt;&gt;</a> my_go_first_event(&amp;my_ev_set, <span class="stringliteral">&quot;my_go_first_event&quot;</span>,</div>
<div class="line">                       <a class="code hl_define" href="SpartaHandler_8hpp.html#aa0cfa5521686f6c2ca417e1d972ebc45">CREATE_SPARTA_HANDLER</a>(MyClass, myFirstMethod));</div>
<div class="line"><a class="code hl_class" href="classsparta_1_1Event.html">sparta::Event&lt;&gt;</a> my_go_second_event(&amp;my_ev_set, <span class="stringliteral">&quot;my_go_second_event&quot;</span>,</div>
<div class="line">                       <a class="code hl_define" href="SpartaHandler_8hpp.html#aa0cfa5521686f6c2ca417e1d972ebc45">CREATE_SPARTA_HANDLER</a>(MyClass, mySecondMethod));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Make myFirstMethod always get called before mySecondMethod.</span></div>
<div class="line"><span class="comment">// This can be done since both my_go events fall into the</span></div>
<div class="line"><span class="comment">// SchedulingPhase::Tick</span></div>
<div class="line">my_go_first_event.precedes(my_go_second_event);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Likewise, you can do this to set up precedence:</span></div>
<div class="line"><span class="comment">// my_go_first_event &gt;&gt; my_go_second_event;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsparta_1_1Event.html">sparta::Event&lt;sparta::SchedulingPhase::Update&gt;</a> my_update_event(&amp;my_ev_set_, <span class="stringliteral">&quot;my_update_event&quot;</span>,</div>
<div class="line">                       <a class="code hl_define" href="SpartaHandler_8hpp.html#aa0cfa5521686f6c2ca417e1d972ebc45">CREATE_SPARTA_HANDLER</a>(MyClass, myUpdateMethod));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// COMPILER ERROR!  The update event is in a different phase than</span></div>
<div class="line"><span class="comment">// the my_go_first_event -- these events automatically happen in</span></div>
<div class="line"><span class="comment">// order.</span></div>
<div class="line">my_update_event &gt;&gt; my_go_first_event;</div>
<div class="ttc" id="aclasssparta_1_1EventSet_html"><div class="ttname"><a href="classsparta_1_1EventSet.html">sparta::EventSet</a></div><div class="ttdoc">Set of Events that a unit (or sparta::TreeNode, sparta::Resource) contains and are visible through a ...</div><div class="ttdef"><b>Definition</b> <a href="EventSet_8hpp_source.html#l00025">EventSet.hpp:26</a></div></div>
</div><!-- fragment --><p>The <a class="el" href="classsparta_1_1Scheduler.html" title="A class that lets you schedule events now and in the future.">sparta::Scheduler</a> is responsible for finalizing the DAG. The DAG is finalized when the <a class="el" href="classsparta_1_1Scheduler.html" title="A class that lets you schedule events now and in the future.">sparta::Scheduler</a> is finalized through the <a class="el" href="classsparta_1_1Scheduler.html#aca7e231926084413a1f055cce670cc00" title="Finalize the scheduler and allow running.">sparta::Scheduler::finalize</a> method called by the framework. Therefor, all events can only be scheduled after the sparta::scheduler is finalized. It is illegal to schedule events before the dag is finalized because precedence has not been fully established. Any startup work can be scheduled via the <a class="el" href="classsparta_1_1StartupEvent.html" title="StartupEvent is a simple class for scheduling a starting event on the Scheduler. It does not support ...">sparta::StartupEvent</a> class before <a class="el" href="classsparta_1_1Scheduler.html" title="A class that lets you schedule events now and in the future.">sparta::Scheduler</a> finalization.</p>
<p>The expected usage is something like: </p><div class="fragment"><div class="line">sched.finalize();</div>
<div class="line">producer.scheduleMyStuff(); <span class="comment">//a method that puts events on the scheduler.</span></div>
<div class="line">sched.run(100); <span class="comment">// will run up to at most 99 ticks</span></div>
<div class="line"><span class="comment">// sched.run(100, true); // will run to exactly 99 ticks</span></div>
</div><!-- fragment -->   <h2><a class="anchor" id="sysc_scheduler"></a>
sparta::SysCSpartaSchedulerAdapter</h2>
<p>This class will allow a Sparta developer to interoperate a Sparta-based simulator with the SystemC kernel. The general rule of thumb is that the Sparta scheduler is either always equal to or 1 cycle ahead of the SystemC scheduler. The Sparta Scheduler will "sleep" waiting for SysC to catch up the next scheduled Sparta event.</p>
<p>There are two ways to stop simulation using this adapter:</p>
<ol type="1">
<li>In SystemC, find the event SC_SPARTA_STOP_EVENT_NAME and notify it when SystemC is complete</li>
<li>Register a <a class="el" href="classsparta_1_1Event.html" title="Event is a simple class for scheduling random events on the Scheduler.">sparta::Event</a> via registerSysCFinishQueryEvent that is called by Sparta to query the SystemC side</li>
</ol>
<p>There are some caveats to know about this adapter. See the todo.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000090">Todo</a></b></dt><dd>The Sparta scheduler is on its own SC_THREAD and is put to sleep between scheduled events. For example, if the Sparta scheduler has an event scheduled @ tick 1000, and time is currently 500, the Sparta scheduler thread will wait() for 500 ticks. However, if a SystemC component puts an event on the Sparta scheduler during this sleep window (say at 750 ticks), we do not have a mechanism to wake this thread early. </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Aug 22 2025 17:16:11 for The Sparta Modeling Framework by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
