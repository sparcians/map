<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Sparta Modeling Framework: sparta::TreeNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">The Sparta Modeling Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classsparta_1_1TreeNode.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classsparta_1_1TreeNode-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">sparta::TreeNode Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Node in a composite tree representing a sparta Tree item.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sparta::TreeNode:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1TreeNode__inherit__graph.png" border="0" usemap="#asparta_1_1TreeNode_inherit__map" alt="Inheritance graph"/></div>
<map name="asparta_1_1TreeNode_inherit__map" id="asparta_1_1TreeNode_inherit__map">
<area shape="rect" title="Node in a composite tree representing a sparta Tree item." alt="" coords="420,793,540,819"/>
<area shape="rect" href="classcore__example_1_1SimpleDL1.html" title=" " alt="" coords="609,5,780,31"/>
<area shape="poly" title=" " alt="" coords="479,778,481,625,494,404,507,290,526,185,552,99,568,66,586,40,607,25,610,30,590,44,573,69,557,101,532,187,513,291,500,405,486,626,484,778"/>
<area shape="rect" href="classsparta_1_1Baz.html" title=" " alt="" coords="652,55,737,80"/>
<area shape="poly" title=" " alt="" coords="479,778,483,635,497,428,511,322,529,225,554,145,569,113,586,90,600,78,617,71,651,64,652,69,618,76,603,83,590,93,574,116,559,146,534,226,516,323,503,429,488,635,484,778"/>
<area shape="rect" href="classsparta_1_1Bus.html" title="Class that defines a Bus type." alt="" coords="651,104,738,130"/>
<area shape="poly" title=" " alt="" coords="479,778,485,643,500,451,514,353,532,263,556,190,570,161,586,139,600,128,617,120,650,113,651,119,618,125,603,132,590,143,575,164,561,192,537,265,519,354,506,452,490,643,485,778"/>
<area shape="rect" href="classsparta_1_1BusSet.html" title="A TreeNode that represents a set of Buses." alt="" coords="641,153,748,179"/>
<area shape="poly" title=" " alt="" coords="480,778,486,652,503,475,517,385,535,302,558,235,571,208,586,188,611,172,640,164,642,169,614,176,590,192,576,211,563,237,540,304,522,386,509,476,492,652,485,778"/>
<area shape="rect" href="classsparta_1_1Clock.html" title="A representation of simulated time." alt="" coords="646,203,743,228"/>
<area shape="poly" title=" " alt="" coords="480,778,488,661,507,499,520,417,538,342,560,280,572,256,587,238,614,220,645,213,646,218,616,225,590,241,577,259,565,282,543,343,526,418,512,500,494,662,485,778"/>
<area shape="rect" href="classsparta_1_1CycleHistogramTreeNode.html" title="CycleHistogramTreeNode class for uint64_t values." alt="" coords="588,252,801,278"/>
<area shape="poly" title=" " alt="" coords="481,777,491,670,510,523,524,449,541,382,562,326,586,288,603,276,606,280,590,292,567,329,547,383,529,450,516,524,496,670,486,778"/>
<area shape="rect" href="classsparta_1_1DynamicResourceTreeNode.html" title="TreeNode subclass representing a node in the device tree which creates and owns a resource...." alt="" coords="596,302,793,342"/>
<area shape="poly" title=" " alt="" coords="482,778,494,683,516,556,546,435,565,387,586,354,602,341,605,345,590,357,570,389,551,436,521,558,500,684,487,778"/>
<area shape="rect" href="classsparta_1_1EnumCycleHistogram.html" title="EnumCycleHistogram class for C++ Enum values." alt="" coords="600,367,789,408"/>
<area shape="poly" title=" " alt="" coords="478,778,481,706,495,611,508,559,528,509,553,461,586,419,602,406,606,410,590,423,558,464,532,511,514,561,500,612,486,707,483,778"/>
<area shape="rect" href="classsparta_1_1EnumHistogram.html" title="EnumHistogram class for sparta::utils::Enum." alt="" coords="616,432,773,473"/>
<area shape="poly" title=" " alt="" coords="480,778,486,717,503,638,517,596,535,555,558,517,587,483,614,465,617,469,590,487,562,520,539,558,522,598,508,639,492,718,485,778"/>
<area shape="rect" href="classsparta_1_1EventNode.html" title="EventNode is the base class for all event types in SPARTA. Not to be used by the modeler...." alt="" coords="631,497,758,523"/>
<area shape="poly" title=" " alt="" coords="481,777,490,725,508,658,522,624,539,590,561,559,587,532,607,519,629,512,631,517,609,524,590,536,565,563,544,593,527,626,513,660,495,726,487,778"/>
<area shape="rect" href="classsparta_1_1EventSet.html" title="Set of Events that a unit (or sparta::TreeNode, sparta::Resource) contains and are visible through a ..." alt="" coords="636,547,753,572"/>
<area shape="poly" title=" " alt="" coords="484,778,495,734,515,681,545,627,564,603,587,581,610,568,635,561,637,566,612,573,590,586,568,606,549,630,520,683,501,736,489,779"/>
<area shape="rect" href="classsparta_1_1GlobalTreeNode.html" title="TreeNode which represents some &quot;global&quot; namespace of the device tree, containing only RootTreeNodes,..." alt="" coords="616,596,773,622"/>
<area shape="poly" title=" " alt="" coords="488,778,502,744,523,704,551,664,587,631,614,617,617,621,590,635,555,668,528,706,507,746,493,780"/>
<area shape="rect" href="classsparta_1_1HistogramTreeNode.html" title=" " alt="" coords="604,645,785,671"/>
<area shape="poly" title=" " alt="" coords="495,778,532,728,558,702,587,680,610,669,612,674,590,684,561,706,536,731,499,782"/>
<area shape="rect" href="classsparta_1_1InstrumentationNode.html" title="Base class requiring." alt="" coords="602,695,787,720"/>
<area shape="poly" title=" " alt="" coords="507,781,543,754,587,729,617,718,619,723,589,734,546,758,510,785"/>
<area shape="rect" href="classsparta_1_1NotificationSourceBase.html" title="A TreeNode that generates a single specific type of notification which propagates up a tree of TreeNo..." alt="" coords="595,744,794,770"/>
<area shape="poly" title=" " alt="" coords="552,787,588,778,634,768,635,773,589,783,553,792"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html" title="Non&#45;templated base class for generic parameter access and iteration." alt="" coords="618,793,771,819"/>
<area shape="poly" title=" " alt="" coords="555,804,617,804,617,809,555,809"/>
<area shape="rect" href="classsparta_1_1ParameterSet.html" title="Generic container of Parameters." alt="" coords="623,843,766,868"/>
<area shape="poly" title=" " alt="" coords="553,821,589,829,635,840,634,845,588,834,552,826"/>
<area shape="rect" href="classsparta_1_1Port.html" title="The port interface used to bind port types together and defines a port behavior." alt="" coords="651,892,738,918"/>
<area shape="poly" title=" " alt="" coords="510,827,546,854,589,878,620,889,651,896,650,902,619,894,587,883,543,859,507,831"/>
<area shape="rect" href="classsparta_1_1PortSet.html" title="A TreeNode that represents a set of ports used by a Resource." alt="" coords="641,941,748,967"/>
<area shape="poly" title=" " alt="" coords="499,831,536,881,561,907,590,928,615,939,641,946,640,951,613,944,587,932,558,911,532,885,495,834"/>
<area shape="rect" href="classsparta_1_1RegisterBase.html" title="Base class to represents an architected register of any size that is a power of 2 and greater than 0 ..." alt="" coords="624,991,765,1016"/>
<area shape="poly" title=" " alt="" coords="493,833,507,866,528,906,555,945,590,977,624,993,622,998,587,982,551,948,523,909,502,869,488,835"/>
<area shape="rect" href="classsparta_1_1RegisterBase_1_1Field.html" title="Register Field with masked access to owning register." alt="" coords="624,1040,765,1081"/>
<area shape="poly" title=" " alt="" coords="490,833,502,876,521,928,551,981,569,1006,590,1027,606,1038,625,1046,622,1051,604,1042,587,1031,565,1009,546,984,517,930,497,878,485,835"/>
<area shape="rect" href="classsparta_1_1RegisterSet.html" title="Holds and can create a set of Register objects having various names and groups." alt="" coords="629,1105,760,1131"/>
<area shape="poly" title=" " alt="" coords="486,834,494,889,511,959,525,995,542,1030,564,1063,590,1091,608,1103,629,1110,628,1115,606,1107,587,1095,560,1066,538,1033,520,997,506,960,489,890,481,835"/>
<area shape="rect" href="classsparta_1_1ResourceTreeNode.html" title="TreeNode subclass representing a node in the device tree which contains a single ResourceFactory and ..." alt="" coords="607,1155,782,1180"/>
<area shape="poly" title=" " alt="" coords="484,834,489,898,504,981,518,1025,536,1068,560,1107,590,1141,608,1153,605,1158,587,1146,556,1110,531,1070,513,1027,499,983,484,899,479,835"/>
<area shape="rect" href="classsparta_1_1RootTreeNode.html" title="TreeNode which represents the root (&quot;top&quot;) of a device tree." alt="" coords="621,1204,768,1230"/>
<area shape="poly" title=" " alt="" coords="488,834,502,916,524,1024,554,1126,572,1165,590,1191,605,1201,621,1208,619,1213,602,1206,586,1195,567,1168,549,1128,519,1025,497,917,483,835"/>
<area shape="rect" href="classsparta_1_1StateHistogram.html" title="StateHistogram class for uint64_t values." alt="" coords="617,1254,772,1294"/>
<area shape="poly" title=" " alt="" coords="487,834,500,926,522,1048,552,1165,570,1210,590,1240,618,1259,615,1263,586,1244,566,1212,547,1166,517,1049,495,927,482,835"/>
<area shape="rect" href="classsparta_1_1StateTimerUnit.html" title="A high level wrapper contains the StateTimerPool and StateTimerHistogram." alt="" coords="619,1319,770,1344"/>
<area shape="poly" title=" " alt="" coords="486,834,497,939,517,1080,531,1151,547,1216,567,1269,590,1304,604,1315,619,1322,617,1327,601,1319,586,1308,563,1271,542,1218,525,1153,511,1081,491,939,481,835"/>
<area shape="rect" href="classsparta_1_1StatisticSet.html" title="Set of StatisticDef and CounterBase&#45;derived objects for visiblility through a sparta Tree." alt="" coords="629,1368,760,1394"/>
<area shape="poly" title=" " alt="" coords="486,835,494,948,513,1105,527,1185,544,1257,565,1316,577,1338,590,1355,608,1368,629,1375,628,1380,606,1372,586,1359,573,1341,560,1318,539,1258,522,1186,508,1106,489,949,480,835"/>
<area shape="rect" href="classsparta_1_1VirtualGlobalTreeNode.html" title="Virtual global node for all device trees in a single simulation. This node acts a potential notificat..." alt="" coords="597,1417,792,1443"/>
<area shape="poly" title=" " alt="" coords="485,834,492,957,510,1129,523,1216,541,1296,563,1361,576,1386,590,1404,603,1415,600,1419,586,1408,572,1388,559,1363,536,1297,518,1217,504,1129,487,957,480,835"/>
<area shape="rect" href="classsparta_1_1collection_1_1CollectableTreeNode.html" title="An abstract type of TreeNode that has virtual calls to start collection on this node,..." alt="" coords="620,1467,769,1508"/>
<area shape="poly" title=" " alt="" coords="485,835,491,966,508,1152,522,1247,540,1334,563,1405,576,1433,590,1454,604,1466,621,1474,619,1479,601,1470,586,1457,571,1435,558,1407,535,1335,517,1248,503,1152,486,966,480,835"/>
<area shape="rect" href="classsparta_1_1memory_1_1BlockingMemoryIFNode.html" title="Pure&#45;virtual memory interface that builds on the BlockingMemoryIF, acting as a TreeNode in the SPARTA..." alt="" coords="612,1532,777,1573"/>
<area shape="poly" title=" " alt="" coords="485,834,489,977,505,1182,518,1287,536,1384,560,1464,575,1494,590,1518,613,1535,610,1539,586,1521,570,1497,555,1465,531,1385,513,1288,499,1182,484,977,479,835"/>
<area shape="rect" href="classsparta_1_1memory_1_1TranslationIFNode.html" title="TranslationIF extension that builds on TranslastionIF, acting as a TreeNode in the SPARTA device tree..." alt="" coords="605,1598,784,1638"/>
<area shape="poly" title=" " alt="" coords="484,834,487,988,501,1212,514,1329,533,1435,558,1523,573,1557,590,1583,606,1597,603,1601,586,1587,569,1560,553,1525,528,1436,509,1329,496,1213,482,988,479,834"/>
<area shape="rect" href="classsparta_1_1ResourceContainer.html" title="PhasedObject which can hold 0 or 1 Resource pointers to an associatedresource. Contains logic for set..." alt="" coords="199,768,372,794"/>
<area shape="poly" title=" " alt="" coords="388,791,420,796,419,801,387,797"/>
<area shape="rect" href="classsparta_1_1PhasedObject.html" title="Object having a specific phase in the sparta construction paradigm." alt="" coords="5,768,151,794"/>
<area shape="poly" title=" " alt="" coords="166,778,198,778,198,784,166,784"/>
<area shape="rect" href="classsparta_1_1ArchDataContainer.html" title="Container class for any number of ArchData pointers owned externally." alt="" coords="199,817,372,843"/>
<area shape="poly" title=" " alt="" coords="387,815,419,811,420,816,388,820"/>
<area shape="rect" href="classsparta_1_1Event.html" title=" " alt="" coords="873,66,1044,106"/>
<area shape="poly" title=" " alt="" coords="772,501,786,493,799,483,816,461,827,438,834,416,837,394,833,349,823,304,813,258,809,212,812,189,818,165,830,142,847,118,871,99,874,103,851,121,834,144,823,167,817,190,815,212,819,258,829,303,839,348,842,394,839,417,832,440,820,463,803,487,789,498,774,505"/>
<area shape="rect" href="classsparta_1_1PhasedPayloadEvent.html" title=" " alt="" coords="865,131,1052,172"/>
<area shape="poly" title=" " alt="" coords="772,500,787,493,799,483,813,465,823,447,832,410,830,374,823,336,816,299,814,261,822,222,847,183,863,169,866,174,851,187,827,224,819,261,821,298,828,335,835,373,837,411,828,449,818,468,803,487,789,498,774,505"/>
<area shape="rect" href="classsparta_1_1PhasedPayloadEvent.html" title=" " alt="" coords="865,196,1052,237"/>
<area shape="poly" title=" " alt="" coords="771,500,799,483,819,455,827,427,827,398,823,369,819,339,819,309,827,279,847,248,863,235,866,239,851,252,832,281,824,310,824,339,828,368,832,398,832,427,823,457,803,487,774,505"/>
<area shape="rect" href="classsparta_1_1PhasedPayloadEvent.html" title=" " alt="" coords="856,262,1061,302"/>
<area shape="poly" title=" " alt="" coords="771,499,799,483,814,463,822,443,823,401,823,357,831,335,847,314,863,301,866,305,851,317,836,338,829,358,828,401,827,444,819,466,802,487,774,504"/>
<area shape="rect" href="classsparta_1_1PhasedPayloadEvent.html" title=" " alt="" coords="865,327,1052,368"/>
<area shape="poly" title=" " alt="" coords="771,498,799,483,810,471,817,459,822,433,828,406,835,392,847,379,865,366,868,371,850,383,839,395,833,408,828,434,822,461,815,474,802,487,774,503"/>
<area shape="rect" href="classsparta_1_1PhasedPayloadEvent.html" title=" " alt="" coords="865,392,1052,433"/>
<area shape="poly" title=" " alt="" coords="772,493,799,482,813,473,823,464,833,454,847,444,876,431,878,436,850,448,836,458,827,468,817,478,802,487,774,498"/>
<area shape="rect" href="classsparta_1_1PhasedPayloadEvent.html" title=" " alt="" coords="849,458,1068,498"/>
<area shape="poly" title=" " alt="" coords="773,498,848,489,848,494,774,503"/>
<area shape="rect" href="classsparta_1_1Event.html" title="Event is a simple class for scheduling random events on the Scheduler." alt="" coords="887,523,1030,564"/>
<area shape="poly" title=" " alt="" coords="774,517,887,532,886,537,773,523"/>
<area shape="rect" href="classsparta_1_1PhasedPayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, but the class itself is not typed on t..." alt="" coords="865,588,1052,629"/>
<area shape="poly" title=" " alt="" coords="774,521,802,532,817,542,827,553,836,563,850,573,877,585,874,590,847,578,833,567,823,556,814,546,799,537,772,526"/>
<area shape="rect" href="classsparta_1_1PhasedSingleCycleUniqueEvent.html" title="An event that can only be schedule one cycle into the future." alt="" coords="871,654,1046,694"/>
<area shape="poly" title=" " alt="" coords="774,517,802,532,815,545,822,559,828,586,833,613,839,626,850,639,872,653,869,657,847,643,835,629,828,615,823,587,817,561,811,548,799,536,772,521"/>
<area shape="rect" href="classsparta_1_1PhasedUniqueEvent.html" title="A type of Event that uniquely schedules itself on the schedule within a single time quantum...." alt="" coords="868,719,1049,744"/>
<area shape="poly" title=" " alt="" coords="774,515,802,532,819,554,827,576,827,620,828,663,835,684,851,704,869,717,866,721,847,708,830,687,822,664,822,620,822,577,815,556,799,536,772,520"/>
<area shape="rect" href="classsparta_1_1CounterBase.html" title="The base class for all Counters." alt="" coords="889,768,1028,794"/>
<area shape="poly" title=" " alt="" coords="781,722,802,729,826,742,850,754,889,766,888,771,848,759,823,747,800,734,779,727"/>
<area shape="rect" href="classsparta_1_1StatisticDef.html" title="Contains a statistic definition (some useful information which can be computed)" alt="" coords="893,817,1024,843"/>
<area shape="poly" title=" " alt="" coords="796,726,802,729,820,748,827,768,834,787,850,804,871,815,893,822,891,827,869,820,847,808,830,790,822,770,815,751,799,734,793,730"/>
<area shape="rect" href="classsparta_1_1NotificationSource.html" title=" " alt="" coords="874,867,1043,908"/>
<area shape="poly" title=" " alt="" coords="796,775,802,779,820,797,827,817,835,836,850,853,874,867,872,872,847,858,830,838,822,819,815,800,799,783,793,779"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for sparta::TreeNode:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1TreeNode__coll__graph.png" border="0" usemap="#asparta_1_1TreeNode_coll__map" alt="Collaboration graph"/></div>
<map name="asparta_1_1TreeNode_coll__map" id="asparta_1_1TreeNode_coll__map">
<area shape="rect" title="Node in a composite tree representing a sparta Tree item." alt="" coords="130,153,251,178"/>
<area shape="rect" href="classsparta_1_1ResourceContainer.html" title="PhasedObject which can hold 0 or 1 Resource pointers to an associatedresource. Contains logic for set..." alt="" coords="5,79,179,105"/>
<area shape="poly" title=" " alt="" coords="123,112,176,150,173,154,119,116"/>
<area shape="rect" href="classsparta_1_1PhasedObject.html" title="Object having a specific phase in the sparta construction paradigm." alt="" coords="19,5,165,31"/>
<area shape="poly" title=" " alt="" coords="95,46,95,79,89,79,89,46"/>
<area shape="rect" href="classsparta_1_1ArchDataContainer.html" title="Container class for any number of ArchData pointers owned externally." alt="" coords="203,79,376,105"/>
<area shape="poly" title=" " alt="" coords="262,116,209,154,206,150,259,112"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsparta_1_1TreeNode_1_1ANY__TYPE.html">ANY_TYPE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for indicating that ANY notification source type should be included in a search performed by locateNotificationSources.  <a href="structsparta_1_1TreeNode_1_1ANY__TYPE.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode_1_1delegate.html">delegate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary delegate for notificaiton invokation until the implementation is working. This will then be merged with sparta::SpartaHandler.  <a href="classsparta_1_1TreeNode_1_1delegate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsparta_1_1TreeNode_1_1NotificationInfo.html">NotificationInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notification type/name information.  <a href="structsparta_1_1TreeNode_1_1NotificationInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode_1_1type__info__container.html">type_info_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for std::type_info.  <a href="classsparta_1_1TreeNode_1_1type__info__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Types</div></td></tr>
<tr class="memitem:af5075c9b90f28041b6a7f3f80132c1b3" id="r_af5075c9b90f28041b6a7f3f80132c1b3"><td class="memItemLeft" align="right" valign="top">typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5075c9b90f28041b6a7f3f80132c1b3">node_uid_type</a></td></tr>
<tr class="memdesc:af5075c9b90f28041b6a7f3f80132c1b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of unique-identifier assigned to every node.  <br /></td></tr>
<tr class="separator:af5075c9b90f28041b6a7f3f80132c1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a2fea735ac7c0116fd470ddb1b7744" id="r_af0a2fea735ac7c0116fd470ddb1b7744"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0a2fea735ac7c0116fd470ddb1b7744">ChildrenVector</a></td></tr>
<tr class="memdesc:af0a2fea735ac7c0116fd470ddb1b7744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> children.  <br /></td></tr>
<tr class="separator:af0a2fea735ac7c0116fd470ddb1b7744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991e1785f763d44925f4a53d89a44675" id="r_a991e1785f763d44925f4a53d89a44675"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a991e1785f763d44925f4a53d89a44675">AliasVector</a></td></tr>
<tr class="memdesc:a991e1785f763d44925f4a53d89a44675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of aliases (other names for this node)  <br /></td></tr>
<tr class="separator:a991e1785f763d44925f4a53d89a44675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa15383cc601098b76d0ef08eff4200" id="r_a8fa15383cc601098b76d0ef08eff4200"><td class="memItemLeft" align="right" valign="top">typedef std::multimap&lt; std::string, <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fa15383cc601098b76d0ef08eff4200">ChildNameMapping</a></td></tr>
<tr class="memdesc:a8fa15383cc601098b76d0ef08eff4200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapping of names, aliases, and groups to individual child nodes within one node. This must be in a deterministic order, so an ordered container (e.g. std::map) is required. A sorted contained is probably desirable, but not required.  <br /></td></tr>
<tr class="separator:a8fa15383cc601098b76d0ef08eff4200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa01f145455d583b8f16e0f923b7c7c" id="r_a7fa01f145455d583b8f16e0f923b7c7c"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fa01f145455d583b8f16e0f923b7c7c">group_idx_type</a></td></tr>
<tr class="memdesc:a7fa01f145455d583b8f16e0f923b7c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index within a group.  <br /></td></tr>
<tr class="separator:a7fa01f145455d583b8f16e0f923b7c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f21b18f9f50f70111730361eff6ddb" id="r_a91f21b18f9f50f70111730361eff6ddb"><td class="memItemLeft" align="right" valign="top">typedef std::weak_ptr&lt; <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91f21b18f9f50f70111730361eff6ddb">WeakPtr</a></td></tr>
<tr class="memdesc:a91f21b18f9f50f70111730361eff6ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weak pointer to a <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>. Acquire with getWeakPtr.  <br /></td></tr>
<tr class="separator:a91f21b18f9f50f70111730361eff6ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa43836f90c9203c7b2c09647a0707d3" id="r_afa43836f90c9203c7b2c09647a0707d3"><td class="memItemLeft" align="right" valign="top">typedef std::weak_ptr&lt; const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa43836f90c9203c7b2c09647a0707d3">ConstWeakPtr</a></td></tr>
<tr class="memdesc:afa43836f90c9203c7b2c09647a0707d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weak pointer to a const <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>. Acquire with getWeakPtr.  <br /></td></tr>
<tr class="separator:afa43836f90c9203c7b2c09647a0707d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5429faab680829656533d4cd5ff0bc0d" id="r_a5429faab680829656533d4cd5ff0bc0d"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5429faab680829656533d4cd5ff0bc0d">SharedPtr</a></td></tr>
<tr class="memdesc:a5429faab680829656533d4cd5ff0bc0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer to <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>. Acquire with WeakPtr::lock().  <br /></td></tr>
<tr class="separator:a5429faab680829656533d4cd5ff0bc0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda7e1fd5fa85a6b9b9e0cc413dae2a5" id="r_abda7e1fd5fa85a6b9b9e0cc413dae2a5"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; const std::string *, std::vector&lt; <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abda7e1fd5fa85a6b9b9e0cc413dae2a5">TagsMap</a></td></tr>
<tr class="memdesc:abda7e1fd5fa85a6b9b9e0cc413dae2a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of strings (interned in <a class="el" href="classsparta_1_1StringManager.html" title="Manages string internment for SPARTA. This allows strings to be compared by pointer once interned.">StringManager</a>) tags to TreeNodes.  <br /></td></tr>
<tr class="separator:abda7e1fd5fa85a6b9b9e0cc413dae2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classsparta_1_1PhasedObject"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_types_classsparta_1_1PhasedObject')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classsparta_1_1PhasedObject.html">sparta::PhasedObject</a></td></tr>
<tr class="memitem:afe9c78396c961fd96f0975867197b366 inherit pub_types_classsparta_1_1PhasedObject" id="r_afe9c78396c961fd96f0975867197b366"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1PhasedObject.html#afe9c78396c961fd96f0975867197b366">TreePhase</a> { <br />
&#160;&#160;<a class="el" href="classsparta_1_1PhasedObject.html#afe9c78396c961fd96f0975867197b366abd4d809ed80d002633d62a28b233d397">TREE_BUILDING</a> = 0
, <a class="el" href="classsparta_1_1PhasedObject.html#afe9c78396c961fd96f0975867197b366a4ad63ff1aeafd781623e5b9dd8e95dc1">TREE_CONFIGURING</a> = 1
, <a class="el" href="classsparta_1_1PhasedObject.html#afe9c78396c961fd96f0975867197b366a2f07c28e39e7339f7f0cf444aaee3f36">TREE_FINALIZING</a> = 2
, <a class="el" href="classsparta_1_1PhasedObject.html#afe9c78396c961fd96f0975867197b366ad3c0a8e691ca35c690e5055d2c888789">TREE_FINALIZED</a> = 3
, <br />
&#160;&#160;<a class="el" href="classsparta_1_1PhasedObject.html#afe9c78396c961fd96f0975867197b366a7ddcaa6221e3b5dbbe9c359203ff8ec7">TREE_TEARDOWN</a> = 4
<br />
 }</td></tr>
<tr class="memdesc:afe9c78396c961fd96f0975867197b366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current phase of tree construction (applies to node and entire tree).  <a href="classsparta_1_1PhasedObject.html#afe9c78396c961fd96f0975867197b366">More...</a><br /></td></tr>
<tr class="separator:afe9c78396c961fd96f0975867197b366 inherit pub_types_classsparta_1_1PhasedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aec70f36a682dadc1d571fcd723f12cd6" id="r_aec70f36a682dadc1d571fcd723f12cd6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsparta_1_1Clock.html">Clock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec70f36a682dadc1d571fcd723f12cd6">getClock</a> () override</td></tr>
<tr class="memdesc:aec70f36a682dadc1d571fcd723f12cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walks up parents (starting with self) until a parent with an associated local clock is found, then returns that clock.  <br /></td></tr>
<tr class="separator:aec70f36a682dadc1d571fcd723f12cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ceac50d187c3e2fefab08f590f6f3c" id="r_ad2ceac50d187c3e2fefab08f590f6f3c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsparta_1_1Clock.html">Clock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2ceac50d187c3e2fefab08f590f6f3c">getClock</a> () const</td></tr>
<tr class="separator:ad2ceac50d187c3e2fefab08f590f6f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883ef289de0f961e1d69a988b50338d8" id="r_a883ef289de0f961e1d69a988b50338d8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsparta_1_1Clock.html">Clock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a883ef289de0f961e1d69a988b50338d8">getLocalClock</a> ()</td></tr>
<tr class="memdesc:a883ef289de0f961e1d69a988b50338d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the clock associated directly with this Node. This is useful for configuration and simulator debug, but not at run-time.  <br /></td></tr>
<tr class="separator:a883ef289de0f961e1d69a988b50338d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1490e10061ce9dd5d53495f65b29f7d" id="r_ae1490e10061ce9dd5d53495f65b29f7d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsparta_1_1Clock.html">Clock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1490e10061ce9dd5d53495f65b29f7d">getLocalClock</a> () const</td></tr>
<tr class="separator:ae1490e10061ce9dd5d53495f65b29f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3077d3b25e965fd6924258b5eb77f61" id="r_aa3077d3b25e965fd6924258b5eb77f61"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3077d3b25e965fd6924258b5eb77f61">setClock</a> (const <a class="el" href="classsparta_1_1Clock.html">Clock</a> *clk)</td></tr>
<tr class="memdesc:aa3077d3b25e965fd6924258b5eb77f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a clock to this node. This clock will then be accessed by any descendant which has no assigned clock or an ancestor with an assigned clock between that descendant and this node. getClock returns the <a class="el" href="classsparta_1_1Clock.html" title="A representation of simulated time.">Clock</a> associated with the nearest ancestor.  <br /></td></tr>
<tr class="separator:aa3077d3b25e965fd6924258b5eb77f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6b76838262227a43b793429376f9a2" id="r_a7a6b76838262227a43b793429376f9a2"><td class="memItemLeft" align="right" valign="top"><a id="a7a6b76838262227a43b793429376f9a2" name="a7a6b76838262227a43b793429376f9a2"></a>
<a class="el" href="classsparta_1_1Scheduler.html">Scheduler</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getScheduler</b> (const bool must_exist=false)</td></tr>
<tr class="memdesc:a7a6b76838262227a43b793429376f9a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the scheduler associated with this tree node's root. <br /></td></tr>
<tr class="separator:a7a6b76838262227a43b793429376f9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d6995924a0f193b70c9d9a332c1887" id="r_ad1d6995924a0f193b70c9d9a332c1887"><td class="memItemLeft" align="right" valign="top"><a id="ad1d6995924a0f193b70c9d9a332c1887" name="ad1d6995924a0f193b70c9d9a332c1887"></a>
const <a class="el" href="classsparta_1_1Scheduler.html">Scheduler</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getScheduler</b> (const bool must_exist=false) const</td></tr>
<tr class="separator:ad1d6995924a0f193b70c9d9a332c1887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb544ebd5bc75612acc891758d49ecc" id="r_a9cb544ebd5bc75612acc891758d49ecc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a91f21b18f9f50f70111730361eff6ddb">WeakPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cb544ebd5bc75612acc891758d49ecc">getWeakPtr</a> ()</td></tr>
<tr class="memdesc:a9cb544ebd5bc75612acc891758d49ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a weak pointer to this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>. This weak pointer is guaranteed to expire when this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> is destructed unless locked.  <br /></td></tr>
<tr class="separator:a9cb544ebd5bc75612acc891758d49ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af492b13a1f98347d9e9c519bd35bb1f0" id="r_af492b13a1f98347d9e9c519bd35bb1f0"><td class="memItemLeft" align="right" valign="top"><a id="af492b13a1f98347d9e9c519bd35bb1f0" name="af492b13a1f98347d9e9c519bd35bb1f0"></a>
<a class="el" href="#afa43836f90c9203c7b2c09647a0707d3">ConstWeakPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getWeakPtr</b> () const</td></tr>
<tr class="memdesc:af492b13a1f98347d9e9c519bd35bb1f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const variant of getWeakPtr. <br /></td></tr>
<tr class="separator:af492b13a1f98347d9e9c519bd35bb1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413b70f45db0a7182347c109322b3b99" id="r_a413b70f45db0a7182347c109322b3b99"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a413b70f45db0a7182347c109322b3b99">addLink</a> (<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *node, const std::string &amp;label)</td></tr>
<tr class="memdesc:a413b70f45db0a7182347c109322b3b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link this tree node with another tree node.  <br /></td></tr>
<tr class="separator:a413b70f45db0a7182347c109322b3b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955dd570e1c3f926d2371956535745e0" id="r_a955dd570e1c3f926d2371956535745e0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a955dd570e1c3f926d2371956535745e0">activateLink</a> (const std::string &amp;label)</td></tr>
<tr class="memdesc:a955dd570e1c3f926d2371956535745e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate one of the links added with addLink.  <br /></td></tr>
<tr class="separator:a955dd570e1c3f926d2371956535745e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction</div></td></tr>
<tr class="memitem:a6366a494319eca35f13323d0934cbf07" id="r_a6366a494319eca35f13323d0934cbf07"><td class="memItemLeft" align="right" valign="top"><a id="a6366a494319eca35f13323d0934cbf07" name="a6366a494319eca35f13323d0934cbf07"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TreeNode</b> ()=delete</td></tr>
<tr class="memdesc:a6366a494319eca35f13323d0934cbf07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not default-constructable. <br /></td></tr>
<tr class="separator:a6366a494319eca35f13323d0934cbf07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559893cd7399ca8b98a6737ba4e7209a" id="r_a559893cd7399ca8b98a6737ba4e7209a"><td class="memItemLeft" align="right" valign="top"><a id="a559893cd7399ca8b98a6737ba4e7209a" name="a559893cd7399ca8b98a6737ba4e7209a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TreeNode</b> (const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &amp;)=delete</td></tr>
<tr class="memdesc:a559893cd7399ca8b98a6737ba4e7209a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not copy-constructable. <br /></td></tr>
<tr class="separator:a559893cd7399ca8b98a6737ba4e7209a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fdce693f0f3255e5fdb45ac6615cbe6" id="r_a6fdce693f0f3255e5fdb45ac6615cbe6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fdce693f0f3255e5fdb45ac6615cbe6">TreeNode</a> (<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &amp;&amp;rhp)</td></tr>
<tr class="memdesc:a6fdce693f0f3255e5fdb45ac6615cbe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="separator:a6fdce693f0f3255e5fdb45ac6615cbe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead61f7ca2ab7f2510a4920682d558e5" id="r_aead61f7ca2ab7f2510a4920682d558e5"><td class="memItemLeft" align="right" valign="top"><a id="aead61f7ca2ab7f2510a4920682d558e5" name="aead61f7ca2ab7f2510a4920682d558e5"></a>
<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &amp;)=delete</td></tr>
<tr class="memdesc:aead61f7ca2ab7f2510a4920682d558e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not assign-constructable. <br /></td></tr>
<tr class="separator:aead61f7ca2ab7f2510a4920682d558e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3026dd9b5648f0614dcc27b97b4b61c7" id="r_a3026dd9b5648f0614dcc27b97b4b61c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3026dd9b5648f0614dcc27b97b4b61c7">TreeNode</a> (<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *parent, const std::string &amp;name, const std::string &amp;group, <a class="el" href="#a7fa01f145455d583b8f16e0f923b7c7c">group_idx_type</a> group_idx, const std::string &amp;desc, bool is_indexable)</td></tr>
<tr class="memdesc:a3026dd9b5648f0614dcc27b97b4b61c7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> full constructor. Initializes node and adds it as a child of an existing tree node (if parent is not null).  <br /></td></tr>
<tr class="separator:a3026dd9b5648f0614dcc27b97b4b61c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c65ab7c0b7170ef60b279f05fc0cab" id="r_a80c65ab7c0b7170ef60b279f05fc0cab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80c65ab7c0b7170ef60b279f05fc0cab">TreeNode</a> (<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *parent, const std::string &amp;name, const std::string &amp;group, <a class="el" href="#a7fa01f145455d583b8f16e0f923b7c7c">group_idx_type</a> group_idx, const std::string &amp;desc)</td></tr>
<tr class="memdesc:a80c65ab7c0b7170ef60b279f05fc0cab"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> constructor with no is_indexable parameter [defaults to true].  <br /></td></tr>
<tr class="separator:a80c65ab7c0b7170ef60b279f05fc0cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eea7ebab08a4ed9aa079ece5b759211" id="r_a9eea7ebab08a4ed9aa079ece5b759211"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9eea7ebab08a4ed9aa079ece5b759211">TreeNode</a> (const std::string &amp;name, const std::string &amp;group, <a class="el" href="#a7fa01f145455d583b8f16e0f923b7c7c">group_idx_type</a> group_idx, const std::string &amp;desc)</td></tr>
<tr class="memdesc:a9eea7ebab08a4ed9aa079ece5b759211"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> constructor with no parent Node.  <br /></td></tr>
<tr class="separator:a9eea7ebab08a4ed9aa079ece5b759211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34262fa0ae9db707bda24e1c5728482e" id="r_a34262fa0ae9db707bda24e1c5728482e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34262fa0ae9db707bda24e1c5728482e">TreeNode</a> (<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *parent, const std::string &amp;name, const std::string &amp;desc)</td></tr>
<tr class="memdesc:a34262fa0ae9db707bda24e1c5728482e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> constructor with no group information.  <br /></td></tr>
<tr class="separator:a34262fa0ae9db707bda24e1c5728482e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d7ec9960d8d6196c39e4d8e3721bd3" id="r_a98d7ec9960d8d6196c39e4d8e3721bd3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98d7ec9960d8d6196c39e4d8e3721bd3">TreeNode</a> (<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *parent, const std::string &amp;group, <a class="el" href="#a7fa01f145455d583b8f16e0f923b7c7c">group_idx_type</a> group_idx, const std::string &amp;desc)</td></tr>
<tr class="memdesc:a98d7ec9960d8d6196c39e4d8e3721bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> constructor for anonymous node with group information.  <br /></td></tr>
<tr class="separator:a98d7ec9960d8d6196c39e4d8e3721bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae136cf4e22a254e02ab08d632145ed31" id="r_ae136cf4e22a254e02ab08d632145ed31"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae136cf4e22a254e02ab08d632145ed31">TreeNode</a> (const std::string &amp;name, const std::string &amp;desc)</td></tr>
<tr class="memdesc:ae136cf4e22a254e02ab08d632145ed31"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> constructor with no parent node or group information.  <br /></td></tr>
<tr class="separator:ae136cf4e22a254e02ab08d632145ed31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e2a24a1cee8725161eee61a9a8af70" id="r_ae6e2a24a1cee8725161eee61a9a8af70"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6e2a24a1cee8725161eee61a9a8af70">~TreeNode</a> ()</td></tr>
<tr class="memdesc:ae6e2a24a1cee8725161eee61a9a8af70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <br /></td></tr>
<tr class="separator:ae6e2a24a1cee8725161eee61a9a8af70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Identification</div></td></tr>
<tr class="memitem:a4f2b4d2e10e2e64ecdf35f4d040f1117" id="r_a4f2b4d2e10e2e64ecdf35f4d040f1117"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f2b4d2e10e2e64ecdf35f4d040f1117">addAlias</a> (const std::string &amp;alias)</td></tr>
<tr class="memdesc:a4f2b4d2e10e2e64ecdf35f4d040f1117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a single alias for this node.  <br /></td></tr>
<tr class="separator:a4f2b4d2e10e2e64ecdf35f4d040f1117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee6f68fd41da3956ef2201ca9de14ad" id="r_adee6f68fd41da3956ef2201ca9de14ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adee6f68fd41da3956ef2201ca9de14ad">addAliases</a> (const <a class="el" href="#a991e1785f763d44925f4a53d89a44675">AliasVector</a> &amp;v)</td></tr>
<tr class="memdesc:adee6f68fd41da3956ef2201ca9de14ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds each element of a vector of aliases to this node..  <br /></td></tr>
<tr class="separator:adee6f68fd41da3956ef2201ca9de14ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00f8c73f0a3a25df7bf68a5bc19c524" id="r_ae00f8c73f0a3a25df7bf68a5bc19c524"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae00f8c73f0a3a25df7bf68a5bc19c524">addTag</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:ae00f8c73f0a3a25df7bf68a5bc19c524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds single tag to this node.  <br /></td></tr>
<tr class="separator:ae00f8c73f0a3a25df7bf68a5bc19c524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87c7a582545956ccdcab95b259ec3ae" id="r_ac87c7a582545956ccdcab95b259ec3ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac87c7a582545956ccdcab95b259ec3ae">addTags</a> (const std::vector&lt; std::string &gt; &amp;v)</td></tr>
<tr class="memdesc:ac87c7a582545956ccdcab95b259ec3ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds each elements of a vector of tags to this node.  <br /></td></tr>
<tr class="separator:ac87c7a582545956ccdcab95b259ec3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Node-Representation</div></td></tr>
<tr class="memitem:ab76a73f2f862a47e969c212f2ac16d85" id="r_ab76a73f2f862a47e969c212f2ac16d85"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab76a73f2f862a47e969c212f2ac16d85">stringize</a> (bool pretty=false) const</td></tr>
<tr class="memdesc:ab76a73f2f862a47e969c212f2ac16d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a string representation of this node.  <br /></td></tr>
<tr class="separator:ab76a73f2f862a47e969c212f2ac16d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb9301d222aa616093a280921f65d4a" id="r_abeb9301d222aa616093a280921f65d4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abeb9301d222aa616093a280921f65d4a">stringizeTags</a> (std::stringstream &amp;ss) const</td></tr>
<tr class="memdesc:abeb9301d222aa616093a280921f65d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render tags to a string in the form: " tags:[tag0, tag1]" If there are any tags. The leading space makes this a useful sub-utility of stringize because if there are no tags, returns empty string with no leading space.  <br /></td></tr>
<tr class="separator:abeb9301d222aa616093a280921f65d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Node Attributes</div></td></tr>
<tr class="memitem:a0e16aaf48db706d4ed5f1a8f696310d7" id="r_a0e16aaf48db706d4ed5f1a8f696310d7"><td class="memItemLeft" align="right" valign="top"><a id="a0e16aaf48db706d4ed5f1a8f696310d7" name="a0e16aaf48db706d4ed5f1a8f696310d7"></a>
<a class="el" href="#af5075c9b90f28041b6a7f3f80132c1b3">node_uid_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getNodeUID</b> () const</td></tr>
<tr class="memdesc:a0e16aaf48db706d4ed5f1a8f696310d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the unique ID of this node. <br /></td></tr>
<tr class="separator:a0e16aaf48db706d4ed5f1a8f696310d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa3602a9ab827b1351ef8f518c32576" id="r_abfa3602a9ab827b1351ef8f518c32576"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfa3602a9ab827b1351ef8f518c32576">getName</a> () const override</td></tr>
<tr class="memdesc:abfa3602a9ab827b1351ef8f518c32576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of this node.  <br /></td></tr>
<tr class="separator:abfa3602a9ab827b1351ef8f518c32576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afd83be527cc01da733615ce85726dc" id="r_a7afd83be527cc01da733615ce85726dc"><td class="memItemLeft" align="right" valign="top">const std::string *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7afd83be527cc01da733615ce85726dc">getNamePtr</a> () const</td></tr>
<tr class="memdesc:a7afd83be527cc01da733615ce85726dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of this node's string pointer which isinterned in <a class="el" href="classsparta_1_1StringManager.html" title="Manages string internment for SPARTA. This allows strings to be compared by pointer once interned.">StringManager</a>)  <br /></td></tr>
<tr class="separator:a7afd83be527cc01da733615ce85726dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec143fde6eb7584c343c98e62bba1aa4" id="r_aec143fde6eb7584c343c98e62bba1aa4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec143fde6eb7584c343c98e62bba1aa4">isAnonymous</a> () const</td></tr>
<tr class="memdesc:aec143fde6eb7584c343c98e62bba1aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this node anonymous.  <br /></td></tr>
<tr class="separator:aec143fde6eb7584c343c98e62bba1aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a85c2485062f0e5ba383bb8d94fd3f" id="r_aa7a85c2485062f0e5ba383bb8d94fd3f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7a85c2485062f0e5ba383bb8d94fd3f">isExpired</a> () const</td></tr>
<tr class="memdesc:aa7a85c2485062f0e5ba383bb8d94fd3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this expired (i.e. has it been the rhp of a move constructor)  <br /></td></tr>
<tr class="separator:aa7a85c2485062f0e5ba383bb8d94fd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc60d1830eb57047f1f71bf1968588a" id="r_a3cc60d1830eb57047f1f71bf1968588a"><td class="memItemLeft" align="right" valign="top"><a id="a3cc60d1830eb57047f1f71bf1968588a" name="a3cc60d1830eb57047f1f71bf1968588a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isIndexableByGroup</b> () const</td></tr>
<tr class="memdesc:a3cc60d1830eb57047f1f71bf1968588a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this object is accessible through its parent's interfaces for getting children by group and index. <br /></td></tr>
<tr class="separator:a3cc60d1830eb57047f1f71bf1968588a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcc01a3bfce8b3830e39aba1e63d9f6" id="r_aebcc01a3bfce8b3830e39aba1e63d9f6"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebcc01a3bfce8b3830e39aba1e63d9f6">getGroup</a> () const</td></tr>
<tr class="memdesc:aebcc01a3bfce8b3830e39aba1e63d9f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the group name of this node.  <br /></td></tr>
<tr class="separator:aebcc01a3bfce8b3830e39aba1e63d9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd50034f379a6e442d479535def905e" id="r_a6cd50034f379a6e442d479535def905e"><td class="memItemLeft" align="right" valign="top">const std::string *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cd50034f379a6e442d479535def905e">getGroupNamePtr</a> () const</td></tr>
<tr class="memdesc:a6cd50034f379a6e442d479535def905e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the group name string pointer (interned in <a class="el" href="classsparta_1_1StringManager.html" title="Manages string internment for SPARTA. This allows strings to be compared by pointer once interned.">StringManager</a> singleton) of this node.  <br /></td></tr>
<tr class="separator:a6cd50034f379a6e442d479535def905e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc69fe186075177c6559e84188982e9" id="r_aadc69fe186075177c6559e84188982e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a7fa01f145455d583b8f16e0f923b7c7c">group_idx_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aadc69fe186075177c6559e84188982e9">getGroupIdx</a> () const</td></tr>
<tr class="memdesc:aadc69fe186075177c6559e84188982e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the group index of this node.  <br /></td></tr>
<tr class="separator:aadc69fe186075177c6559e84188982e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18cf1df166a0430f1ffd56b1f16ce732" id="r_a18cf1df166a0430f1ffd56b1f16ce732"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; const std::string * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18cf1df166a0430f1ffd56b1f16ce732">getTags</a> () const</td></tr>
<tr class="memdesc:a18cf1df166a0430f1ffd56b1f16ce732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the set of tags associated with this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>.  <br /></td></tr>
<tr class="separator:a18cf1df166a0430f1ffd56b1f16ce732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790acc1b3b08263b8f1941dc33fbb012" id="r_a790acc1b3b08263b8f1941dc33fbb012"><td class="memItemLeft" align="right" valign="top"><a id="a790acc1b3b08263b8f1941dc33fbb012" name="a790acc1b3b08263b8f1941dc33fbb012"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasTag</b> (const std::string &amp;tag) const</td></tr>
<tr class="memdesc:a790acc1b3b08263b8f1941dc33fbb012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this node have a specific tag (by name) <br /></td></tr>
<tr class="separator:a790acc1b3b08263b8f1941dc33fbb012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b28db0c7afcacd7ef77c0243ef32364" id="r_a8b28db0c7afcacd7ef77c0243ef32364"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b28db0c7afcacd7ef77c0243ef32364">hasTag</a> (const std::string *interned_tag_name) const</td></tr>
<tr class="memdesc:a8b28db0c7afcacd7ef77c0243ef32364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this node have a specific tag (by string pointer interned with <a class="el" href="classsparta_1_1StringManager.html" title="Manages string internment for SPARTA. This allows strings to be compared by pointer once interned.">StringManager</a>). This is faster than the alternate hasTag method because it relies only on pointer comparisons.  <br /></td></tr>
<tr class="separator:a8b28db0c7afcacd7ef77c0243ef32364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e94c653b4d23af19a26ad92b8a17bba" id="r_a2e94c653b4d23af19a26ad92b8a17bba"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e94c653b4d23af19a26ad92b8a17bba">getDesc</a> () const</td></tr>
<tr class="memdesc:a2e94c653b4d23af19a26ad92b8a17bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the description of this node.  <br /></td></tr>
<tr class="separator:a2e94c653b4d23af19a26ad92b8a17bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5faf0ebba15c75ea7e421b0b552e2de9" id="r_a5faf0ebba15c75ea7e421b0b552e2de9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5faf0ebba15c75ea7e421b0b552e2de9">isBuiltin</a> () const</td></tr>
<tr class="memdesc:a5faf0ebba15c75ea7e421b0b552e2de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this node in the builtins group.  <br /></td></tr>
<tr class="separator:a5faf0ebba15c75ea7e421b0b552e2de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340ab05847517f7e813da70275f8fc34" id="r_a340ab05847517f7e813da70275f8fc34"><td class="memItemLeft" align="right" valign="top"><a id="a340ab05847517f7e813da70275f8fc34" name="a340ab05847517f7e813da70275f8fc34"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>markHidden</b> (bool hidden=true)</td></tr>
<tr class="memdesc:a340ab05847517f7e813da70275f8fc34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> hidden for the purposes of printint out nodes. This does not make the node inaccessible, but causes it (and its subtree) to be hidden from typical recursive tree printouts. <br /></td></tr>
<tr class="separator:a340ab05847517f7e813da70275f8fc34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3780c614eaa9c18ba2a162c32c2fa24" id="r_ad3780c614eaa9c18ba2a162c32c2fa24"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3780c614eaa9c18ba2a162c32c2fa24">isHidden</a> () const</td></tr>
<tr class="memdesc:ad3780c614eaa9c18ba2a162c32c2fa24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> supposed to be hidden during tree printouts This value does not have to be respected by anything using <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> and is mainly a UI/printout convenience.  <br /></td></tr>
<tr class="separator:ad3780c614eaa9c18ba2a162c32c2fa24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Node Validation</div></td></tr>
<tr class="memitem:ad250972578e11008fb7e3c8258945358" id="r_ad250972578e11008fb7e3c8258945358"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad250972578e11008fb7e3c8258945358">validateName</a> (const std::string &amp;nm)</td></tr>
<tr class="memdesc:ad250972578e11008fb7e3c8258945358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the given name string for this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>. Does not consider context (e.g. name collisions)  <br /></td></tr>
<tr class="separator:ad250972578e11008fb7e3c8258945358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7400a57b30c63a2196d1c3f1bbf4466d" id="r_a7400a57b30c63a2196d1c3f1bbf4466d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7400a57b30c63a2196d1c3f1bbf4466d">validateGroup</a> (const std::string &amp;name, const std::string &amp;group, <a class="el" href="#a7fa01f145455d583b8f16e0f923b7c7c">group_idx_type</a> idx)</td></tr>
<tr class="memdesc:a7400a57b30c63a2196d1c3f1bbf4466d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the given group name string and group index for this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>. Does not consider context (e.g. name collisions)  <br /></td></tr>
<tr class="separator:a7400a57b30c63a2196d1c3f1bbf4466d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7946a8167a01fb800e2bc3eccab14bc2" id="r_a7946a8167a01fb800e2bc3eccab14bc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7946a8167a01fb800e2bc3eccab14bc2">validateDesc</a> (const std::string &amp;desc)</td></tr>
<tr class="memdesc:a7946a8167a01fb800e2bc3eccab14bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the given description string for this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>.  <br /></td></tr>
<tr class="separator:a7946a8167a01fb800e2bc3eccab14bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Tree-Building</div></td></tr>
<tr class="memitem:a7b6ca285ffd1077f9622662c167315e9" id="r_a7b6ca285ffd1077f9622662c167315e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b6ca285ffd1077f9622662c167315e9">addChild</a> (<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *child, bool inherit_phase=true)</td></tr>
<tr class="memdesc:a7b6ca285ffd1077f9622662c167315e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> to this node as a child.  <br /></td></tr>
<tr class="separator:a7b6ca285ffd1077f9622662c167315e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ee86186cf09b8dada20df11d635f37" id="r_a57ee86186cf09b8dada20df11d635f37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57ee86186cf09b8dada20df11d635f37">addChild</a> (<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &amp;child)</td></tr>
<tr class="memdesc:a57ee86186cf09b8dada20df11d635f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">AddChild by reference for convenience.  <br /></td></tr>
<tr class="separator:a57ee86186cf09b8dada20df11d635f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc0097b5c5a5eda666d42846fc0d655" id="r_aefc0097b5c5a5eda666d42846fc0d655"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefc0097b5c5a5eda666d42846fc0d655">makeSubtreePrivate</a> ()</td></tr>
<tr class="memdesc:aefc0097b5c5a5eda666d42846fc0d655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the entire subtree private.  <br /></td></tr>
<tr class="separator:aefc0097b5c5a5eda666d42846fc0d655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c72f80e1e5b0847930c4067b22657b1" id="r_a0c72f80e1e5b0847930c4067b22657b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c72f80e1e5b0847930c4067b22657b1">setScopeRoot</a> ()</td></tr>
<tr class="separator:a0c72f80e1e5b0847930c4067b22657b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b54fb21d8426f14d54c7388f68d2b4" id="r_a73b54fb21d8426f14d54c7388f68d2b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73b54fb21d8426f14d54c7388f68d2b4">isScopeRoot</a> () const</td></tr>
<tr class="separator:a73b54fb21d8426f14d54c7388f68d2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsparta_1_1ResourceContainer"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classsparta_1_1ResourceContainer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsparta_1_1ResourceContainer.html">sparta::ResourceContainer</a></td></tr>
<tr class="memitem:a8a479c2bec0574b1dcf850aeca787b8d inherit pub_methods_classsparta_1_1ResourceContainer" id="r_a8a479c2bec0574b1dcf850aeca787b8d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceContainer.html#a8a479c2bec0574b1dcf850aeca787b8d">ResourceContainer</a> ()</td></tr>
<tr class="memdesc:a8a479c2bec0574b1dcf850aeca787b8d inherit pub_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consturct with a null, unlocked resource.  <br /></td></tr>
<tr class="separator:a8a479c2bec0574b1dcf850aeca787b8d inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41702e667255a5ebe25bf3490f4c5b9 inherit pub_methods_classsparta_1_1ResourceContainer" id="r_ac41702e667255a5ebe25bf3490f4c5b9"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>ResourceContainer</b> (const <a class="el" href="classsparta_1_1ResourceContainer.html">ResourceContainer</a> &amp;)=delete</td></tr>
<tr class="memdesc:ac41702e667255a5ebe25bf3490f4c5b9 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy construction disbled. <br /></td></tr>
<tr class="separator:ac41702e667255a5ebe25bf3490f4c5b9 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0813d7f0d4d4854c4416f5d1273b5e23 inherit pub_methods_classsparta_1_1ResourceContainer" id="r_a0813d7f0d4d4854c4416f5d1273b5e23"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>ResourceContainer</b> (<a class="el" href="classsparta_1_1ResourceContainer.html">ResourceContainer</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a0813d7f0d4d4854c4416f5d1273b5e23 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:a0813d7f0d4d4854c4416f5d1273b5e23 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977139ced57391b242cbf5a7c9f0057e inherit pub_methods_classsparta_1_1ResourceContainer" id="r_a977139ced57391b242cbf5a7c9f0057e"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceContainer.html#a977139ced57391b242cbf5a7c9f0057e">~ResourceContainer</a> ()</td></tr>
<tr class="memdesc:a977139ced57391b242cbf5a7c9f0057e inherit pub_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a977139ced57391b242cbf5a7c9f0057e inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e1258a847b8f0f7fefa5c9831a7b30 inherit pub_methods_classsparta_1_1ResourceContainer" id="r_aa3e1258a847b8f0f7fefa5c9831a7b30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Resource.html">Resource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceContainer.html#aa3e1258a847b8f0f7fefa5c9831a7b30">getResource</a> ()</td></tr>
<tr class="memdesc:aa3e1258a847b8f0f7fefa5c9831a7b30 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the resource contained by this node if any. May only be called after finalization begins or during teardown.  <br /></td></tr>
<tr class="separator:aa3e1258a847b8f0f7fefa5c9831a7b30 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82fd8bcb21af2b6346a7456248ee8804 inherit pub_methods_classsparta_1_1ResourceContainer" id="r_a82fd8bcb21af2b6346a7456248ee8804"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsparta_1_1Resource.html">Resource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceContainer.html#a82fd8bcb21af2b6346a7456248ee8804">getResource</a> () const</td></tr>
<tr class="memdesc:a82fd8bcb21af2b6346a7456248ee8804 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const variant of getResource.  <br /></td></tr>
<tr class="separator:a82fd8bcb21af2b6346a7456248ee8804 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c09a05a5ec552674712e70c9d44ca9 inherit pub_methods_classsparta_1_1ResourceContainer" id="r_ac1c09a05a5ec552674712e70c9d44ca9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceContainer.html#ac1c09a05a5ec552674712e70c9d44ca9">hasResource</a> () const</td></tr>
<tr class="memdesc:ac1c09a05a5ec552674712e70c9d44ca9 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this node has a resource. This method exists in case the <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> is being explored by a tool or interactive UI. Typical <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> clients (such as Resources) will assume that there is a resource if they are expecting one.  <br /></td></tr>
<tr class="separator:ac1c09a05a5ec552674712e70c9d44ca9 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6dc7a027715d3981f50bc0823bde07 inherit pub_methods_classsparta_1_1ResourceContainer" id="r_a8a6dc7a027715d3981f50bc0823bde07"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a8a6dc7a027715d3981f50bc0823bde07 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memTemplItemLeft" align="right" valign="top">const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceContainer.html#a8a6dc7a027715d3981f50bc0823bde07">getResourceAs</a> () const</td></tr>
<tr class="memdesc:a8a6dc7a027715d3981f50bc0823bde07 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the resource contained by this node (if any) as the given type.  <br /></td></tr>
<tr class="separator:a8a6dc7a027715d3981f50bc0823bde07 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822ceaa97abb81b3b1a94b168662ab02 inherit pub_methods_classsparta_1_1ResourceContainer" id="r_a822ceaa97abb81b3b1a94b168662ab02"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;!std::is_pointer&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a822ceaa97abb81b3b1a94b168662ab02 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceContainer.html#a822ceaa97abb81b3b1a94b168662ab02">getResourceAs</a> () const</td></tr>
<tr class="memdesc:a822ceaa97abb81b3b1a94b168662ab02 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of getResourceAs for const access with a non-pointer template type.  <br /></td></tr>
<tr class="separator:a822ceaa97abb81b3b1a94b168662ab02 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1947e9a45d8d05360358f320df932f8c inherit pub_methods_classsparta_1_1ResourceContainer" id="r_a1947e9a45d8d05360358f320df932f8c"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a1947e9a45d8d05360358f320df932f8c inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceContainer.html#a1947e9a45d8d05360358f320df932f8c">getResourceAs</a> ()</td></tr>
<tr class="memdesc:a1947e9a45d8d05360358f320df932f8c inherit pub_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-const overload of getResourceAs.  <br /></td></tr>
<tr class="separator:a1947e9a45d8d05360358f320df932f8c inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1099102e1ae7b48a4c82ac552e00bebe inherit pub_methods_classsparta_1_1ResourceContainer" id="r_a1099102e1ae7b48a4c82ac552e00bebe"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;!std::is_pointer&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a1099102e1ae7b48a4c82ac552e00bebe inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceContainer.html#a1099102e1ae7b48a4c82ac552e00bebe">getResourceAs</a> ()</td></tr>
<tr class="memdesc:a1099102e1ae7b48a4c82ac552e00bebe inherit pub_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-const overload of getResourceAs.  <br /></td></tr>
<tr class="separator:a1099102e1ae7b48a4c82ac552e00bebe inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be07910a07b37568990abe61bdf25a8 inherit pub_methods_classsparta_1_1ResourceContainer" id="r_a3be07910a07b37568990abe61bdf25a8"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceContainer.html#a3be07910a07b37568990abe61bdf25a8">getResourceType</a> () const</td></tr>
<tr class="memdesc:a3be07910a07b37568990abe61bdf25a8 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the typename of the resource that this node will eventually contain.  <br /></td></tr>
<tr class="separator:a3be07910a07b37568990abe61bdf25a8 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae244126daf829d0ef231a1f7707a6c3b inherit pub_methods_classsparta_1_1ResourceContainer" id="r_ae244126daf829d0ef231a1f7707a6c3b"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceContainer.html#ae244126daf829d0ef231a1f7707a6c3b">getResourceTypeRaw</a> () const</td></tr>
<tr class="memdesc:ae244126daf829d0ef231a1f7707a6c3b inherit pub_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the typename of the resource that this node will eventually contain.  <br /></td></tr>
<tr class="separator:ae244126daf829d0ef231a1f7707a6c3b inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsparta_1_1PhasedObject"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classsparta_1_1PhasedObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsparta_1_1PhasedObject.html">sparta::PhasedObject</a></td></tr>
<tr class="memitem:adc31c312d56f17422baba4fb5c6f92c1 inherit pub_methods_classsparta_1_1PhasedObject" id="r_adc31c312d56f17422baba4fb5c6f92c1"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>PhasedObject</b> (<a class="el" href="classsparta_1_1PhasedObject.html">PhasedObject</a> &amp;&amp;)=default</td></tr>
<tr class="separator:adc31c312d56f17422baba4fb5c6f92c1 inherit pub_methods_classsparta_1_1PhasedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade690bdb9df72fd6bad8847fbdf226f1 inherit pub_methods_classsparta_1_1PhasedObject" id="r_ade690bdb9df72fd6bad8847fbdf226f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1PhasedObject.html#afe9c78396c961fd96f0975867197b366">TreePhase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1PhasedObject.html#ade690bdb9df72fd6bad8847fbdf226f1">getPhase</a> () const</td></tr>
<tr class="memdesc:ade690bdb9df72fd6bad8847fbdf226f1 inherit pub_methods_classsparta_1_1PhasedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the trees current phase.  <br /></td></tr>
<tr class="separator:ade690bdb9df72fd6bad8847fbdf226f1 inherit pub_methods_classsparta_1_1PhasedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05218ff46e1e188b655c4da0a4719085 inherit pub_methods_classsparta_1_1PhasedObject" id="r_a05218ff46e1e188b655c4da0a4719085"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1PhasedObject.html#a05218ff46e1e188b655c4da0a4719085">isBuilding</a> () const</td></tr>
<tr class="memdesc:a05218ff46e1e188b655c4da0a4719085 inherit pub_methods_classsparta_1_1PhasedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this node (and thus the entire tree above and below it) currently in the TREE_BUILDING phase.  <br /></td></tr>
<tr class="separator:a05218ff46e1e188b655c4da0a4719085 inherit pub_methods_classsparta_1_1PhasedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4b14b23643204798dbc994f3cca77e inherit pub_methods_classsparta_1_1PhasedObject" id="r_aba4b14b23643204798dbc994f3cca77e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1PhasedObject.html#aba4b14b23643204798dbc994f3cca77e">isBuilt</a> () const</td></tr>
<tr class="memdesc:aba4b14b23643204798dbc994f3cca77e inherit pub_methods_classsparta_1_1PhasedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this node (and thus the entire tree above it) "built". Checks that getPhase has passed TREE_BUILDING.  <br /></td></tr>
<tr class="separator:aba4b14b23643204798dbc994f3cca77e inherit pub_methods_classsparta_1_1PhasedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693545aae3e991b023459d03250ec92b inherit pub_methods_classsparta_1_1PhasedObject" id="r_a693545aae3e991b023459d03250ec92b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1PhasedObject.html#a693545aae3e991b023459d03250ec92b">isConfigured</a> () const</td></tr>
<tr class="memdesc:a693545aae3e991b023459d03250ec92b inherit pub_methods_classsparta_1_1PhasedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this node (and thus the entire tree above it) "configured". Checks that getPhase has <em>passed</em> TREE_CONFIGURING (i.e. FINALIZED, FINALIZING, TEARDOWN, etc).  <br /></td></tr>
<tr class="separator:a693545aae3e991b023459d03250ec92b inherit pub_methods_classsparta_1_1PhasedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a8f0a9a0e2bdd7437b7a8a13b48e93 inherit pub_methods_classsparta_1_1PhasedObject" id="r_af8a8f0a9a0e2bdd7437b7a8a13b48e93"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1PhasedObject.html#af8a8f0a9a0e2bdd7437b7a8a13b48e93">isConfiguring</a> () const</td></tr>
<tr class="memdesc:af8a8f0a9a0e2bdd7437b7a8a13b48e93 inherit pub_methods_classsparta_1_1PhasedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this node (and thus the entire tree above it) currently in the TREE_CONFIGURING phase.  <br /></td></tr>
<tr class="separator:af8a8f0a9a0e2bdd7437b7a8a13b48e93 inherit pub_methods_classsparta_1_1PhasedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c50c75766fa4096ba77b12c3a53edd1 inherit pub_methods_classsparta_1_1PhasedObject" id="r_a5c50c75766fa4096ba77b12c3a53edd1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1PhasedObject.html#a5c50c75766fa4096ba77b12c3a53edd1">isFinalizing</a> () const</td></tr>
<tr class="memdesc:a5c50c75766fa4096ba77b12c3a53edd1 inherit pub_methods_classsparta_1_1PhasedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this node (and thus the entire tree above it) "finalized".  <br /></td></tr>
<tr class="separator:a5c50c75766fa4096ba77b12c3a53edd1 inherit pub_methods_classsparta_1_1PhasedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8edefaf47c41a0be179827e657955d5 inherit pub_methods_classsparta_1_1PhasedObject" id="r_ac8edefaf47c41a0be179827e657955d5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1PhasedObject.html#ac8edefaf47c41a0be179827e657955d5">isFinalized</a> () const</td></tr>
<tr class="memdesc:ac8edefaf47c41a0be179827e657955d5 inherit pub_methods_classsparta_1_1PhasedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this node (and thus the entire tree above it) "finalized".  <br /></td></tr>
<tr class="separator:ac8edefaf47c41a0be179827e657955d5 inherit pub_methods_classsparta_1_1PhasedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8555fc19699141ca78722846bd2e2dc3 inherit pub_methods_classsparta_1_1PhasedObject" id="r_a8555fc19699141ca78722846bd2e2dc3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1PhasedObject.html#a8555fc19699141ca78722846bd2e2dc3">isTearingDown</a> () const</td></tr>
<tr class="memdesc:a8555fc19699141ca78722846bd2e2dc3 inherit pub_methods_classsparta_1_1PhasedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this node (and thus the entire tree above it) in the "teardown" phase.  <br /></td></tr>
<tr class="separator:a8555fc19699141ca78722846bd2e2dc3 inherit pub_methods_classsparta_1_1PhasedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsparta_1_1ArchDataContainer"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classsparta_1_1ArchDataContainer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsparta_1_1ArchDataContainer.html">sparta::ArchDataContainer</a></td></tr>
<tr class="memitem:a500b3d7a15538143d9e7d6fdea994e30 inherit pub_methods_classsparta_1_1ArchDataContainer" id="r_a500b3d7a15538143d9e7d6fdea994e30"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classsparta_1_1ArchData.html">ArchData</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ArchDataContainer.html#a500b3d7a15538143d9e7d6fdea994e30">getAssociatedArchDatas</a> ()</td></tr>
<tr class="memdesc:a500b3d7a15538143d9e7d6fdea994e30 inherit pub_methods_classsparta_1_1ArchDataContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves all ArchDatas associated with this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> so that children can use it to allocate their data.  <br /></td></tr>
<tr class="separator:a500b3d7a15538143d9e7d6fdea994e30 inherit pub_methods_classsparta_1_1ArchDataContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c55bc976fbc40ab4eee8cda5bcf6851 inherit pub_methods_classsparta_1_1ArchDataContainer" id="r_a3c55bc976fbc40ab4eee8cda5bcf6851"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classsparta_1_1ArchData.html">ArchData</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ArchDataContainer.html#a3c55bc976fbc40ab4eee8cda5bcf6851">getAssociatedArchDatas</a> () const</td></tr>
<tr class="memdesc:a3c55bc976fbc40ab4eee8cda5bcf6851 inherit pub_methods_classsparta_1_1ArchDataContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const variant of getAssociatedArchDatas.  <br /></td></tr>
<tr class="separator:a3c55bc976fbc40ab4eee8cda5bcf6851 inherit pub_methods_classsparta_1_1ArchDataContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4bff55ea4a5703b720aea8c66f7f3e6 inherit pub_methods_classsparta_1_1ArchDataContainer" id="r_af4bff55ea4a5703b720aea8c66f7f3e6"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>ArchDataContainer</b> ()=default</td></tr>
<tr class="memdesc:af4bff55ea4a5703b720aea8c66f7f3e6 inherit pub_methods_classsparta_1_1ArchDataContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:af4bff55ea4a5703b720aea8c66f7f3e6 inherit pub_methods_classsparta_1_1ArchDataContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba47c80ce109e690f35171781201153 inherit pub_methods_classsparta_1_1ArchDataContainer" id="r_a2ba47c80ce109e690f35171781201153"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>ArchDataContainer</b> (<a class="el" href="classsparta_1_1ArchDataContainer.html">ArchDataContainer</a> &amp;)=delete</td></tr>
<tr class="memdesc:a2ba47c80ce109e690f35171781201153 inherit pub_methods_classsparta_1_1ArchDataContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy construction disabled. <br /></td></tr>
<tr class="separator:a2ba47c80ce109e690f35171781201153 inherit pub_methods_classsparta_1_1ArchDataContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22e5fc7d2ce25293f53a5c808dbea4c inherit pub_methods_classsparta_1_1ArchDataContainer" id="r_ac22e5fc7d2ce25293f53a5c808dbea4c"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>ArchDataContainer</b> (<a class="el" href="classsparta_1_1ArchDataContainer.html">ArchDataContainer</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:ac22e5fc7d2ce25293f53a5c808dbea4c inherit pub_methods_classsparta_1_1ArchDataContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:ac22e5fc7d2ce25293f53a5c808dbea4c inherit pub_methods_classsparta_1_1ArchDataContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3b7270932f010fbe0613bf7e862dfb inherit pub_methods_classsparta_1_1ArchDataContainer" id="r_abb3b7270932f010fbe0613bf7e862dfb"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ArchDataContainer.html#abb3b7270932f010fbe0613bf7e862dfb">~ArchDataContainer</a> ()</td></tr>
<tr class="memdesc:abb3b7270932f010fbe0613bf7e862dfb inherit pub_methods_classsparta_1_1ArchDataContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <br /></td></tr>
<tr class="separator:abb3b7270932f010fbe0613bf7e862dfb inherit pub_methods_classsparta_1_1ArchDataContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aacb943215632699fbddc6554dacfbdf7" id="r_aacb943215632699fbddc6554dacfbdf7"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacb943215632699fbddc6554dacfbdf7">createSearchRegexPattern</a> (const std::string &amp;pat)</td></tr>
<tr class="memdesc:aacb943215632699fbddc6554dacfbdf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a regex pattern for a node child path containing any number of wildcard characters (not a dot-separated location) which can be used to test against child node names.  <br /></td></tr>
<tr class="separator:aacb943215632699fbddc6554dacfbdf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cac07d5f406fa1300d0e283e2a1f498" id="r_a2cac07d5f406fa1300d0e283e2a1f498"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cac07d5f406fa1300d0e283e2a1f498">hasWildcardCharacters</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a2cac07d5f406fa1300d0e283e2a1f498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a given node name has any wildcard characters which will be substituted in createSearchRegexPattern.  <br /></td></tr>
<tr class="separator:a2cac07d5f406fa1300d0e283e2a1f498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef80729c2131ffb68b5e62b5002c321" id="r_a1ef80729c2131ffb68b5e62b5002c321"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ef80729c2131ffb68b5e62b5002c321">getNextName</a> (const std::string &amp;name, size_t &amp;pos)</td></tr>
<tr class="memdesc:a1ef80729c2131ffb68b5e62b5002c321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next name between two '.' chars in a string starting at <em>pos</em>.  <br /></td></tr>
<tr class="separator:a1ef80729c2131ffb68b5e62b5002c321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b06f89a9d37325701620637e44f2e2" id="r_a83b06f89a9d37325701620637e44f2e2"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83b06f89a9d37325701620637e44f2e2">matchesGlobLike</a> (const std::string &amp;pattern, const std::string &amp;other)</td></tr>
<tr class="memdesc:a83b06f89a9d37325701620637e44f2e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a glob-like search pattern matches some other string.  <br /></td></tr>
<tr class="separator:a83b06f89a9d37325701620637e44f2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constants</div></td></tr>
<tr class="memitem:a0c31b9fc57737636c1b76f7ec7ed0315" id="r_a0c31b9fc57737636c1b76f7ec7ed0315"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="#a7fa01f145455d583b8f16e0f923b7c7c">group_idx_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c31b9fc57737636c1b76f7ec7ed0315">GROUP_IDX_NONE</a> = (<a class="el" href="#a7fa01f145455d583b8f16e0f923b7c7c">group_idx_type</a>)-1</td></tr>
<tr class="memdesc:a0c31b9fc57737636c1b76f7ec7ed0315"><td class="mdescLeft">&#160;</td><td class="mdescRight">GroupIndex indicating that a node has no group index because it belongs to no group.  <br /></td></tr>
<tr class="separator:a0c31b9fc57737636c1b76f7ec7ed0315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d729b6c83cfc71c7cff6a4017ab690" id="r_a21d729b6c83cfc71c7cff6a4017ab690"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="#af5075c9b90f28041b6a7f3f80132c1b3">node_uid_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21d729b6c83cfc71c7cff6a4017ab690">MAX_NODE_UID</a></td></tr>
<tr class="memdesc:a21d729b6c83cfc71c7cff6a4017ab690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value of node_uid_ before the framework throws an exception.  <br /></td></tr>
<tr class="separator:a21d729b6c83cfc71c7cff6a4017ab690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361467ba0817226281612c6cfdf1671b" id="r_a361467ba0817226281612c6cfdf1671b"><td class="memItemLeft" align="right" valign="top">static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a361467ba0817226281612c6cfdf1671b">GROUP_NAME_NONE</a> [] = &quot;&quot;</td></tr>
<tr class="memdesc:a361467ba0817226281612c6cfdf1671b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group name indicating that a node belongs to no group.  <br /></td></tr>
<tr class="separator:a361467ba0817226281612c6cfdf1671b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8d1112f2f15f5709e2fe10077443a5" id="r_a2c8d1112f2f15f5709e2fe10077443a5"><td class="memItemLeft" align="right" valign="top">static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c8d1112f2f15f5709e2fe10077443a5">NODE_NAME_NONE</a> [] = &quot;&quot;</td></tr>
<tr class="memdesc:a2c8d1112f2f15f5709e2fe10077443a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node name for anonymous node.  <br /></td></tr>
<tr class="separator:a2c8d1112f2f15f5709e2fe10077443a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2736aba2c285e0c9eb56bd5ad219aac1" id="r_a2736aba2c285e0c9eb56bd5ad219aac1"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2736aba2c285e0c9eb56bd5ad219aac1">DEBUG_DUMP_SECTION_DIVIDER</a></td></tr>
<tr class="memdesc:a2736aba2c285e0c9eb56bd5ad219aac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">String dividing sections in a debug dump file.  <br /></td></tr>
<tr class="separator:a2736aba2c285e0c9eb56bd5ad219aac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08dafe7762de39f9cf9448d58b238bd6" id="r_a08dafe7762de39f9cf9448d58b238bd6"><td class="memItemLeft" align="right" valign="top">static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08dafe7762de39f9cf9448d58b238bd6">NODE_NAME_VIRTUAL_GLOBAL</a> [] = &quot;_SPARTA_virtual_global_&quot;</td></tr>
<tr class="memdesc:a08dafe7762de39f9cf9448d58b238bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node name for the virtual glopbal node.  <br /></td></tr>
<tr class="separator:a08dafe7762de39f9cf9448d58b238bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7414db91285d570ee6de31f33f2d318a" id="r_a7414db91285d570ee6de31f33f2d318a"><td class="memItemLeft" align="right" valign="top">static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7414db91285d570ee6de31f33f2d318a">LOCATION_NODE_SEPARATOR_ATTACHED</a> = '.'</td></tr>
<tr class="memdesc:a7414db91285d570ee6de31f33f2d318a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separator character between node identifiers in a location string when the child is attached to the parent.  <br /></td></tr>
<tr class="separator:a7414db91285d570ee6de31f33f2d318a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5616cd3a24c63ea04e9a54379a48ea" id="r_a4a5616cd3a24c63ea04e9a54379a48ea"><td class="memItemLeft" align="right" valign="top">static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a5616cd3a24c63ea04e9a54379a48ea">LOCATION_NODE_SEPARATOR_EXPECTING</a> = ','</td></tr>
<tr class="memdesc:a4a5616cd3a24c63ea04e9a54379a48ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separator character between node identifiers in a location string when the child is being attached to the parent but has not been entirely attached (i.g. during construction of the child node)  <br /></td></tr>
<tr class="separator:a4a5616cd3a24c63ea04e9a54379a48ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dcff9c08bb51455a8ee1ad0a065b9ed" id="r_a9dcff9c08bb51455a8ee1ad0a065b9ed"><td class="memItemLeft" align="right" valign="top">static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9dcff9c08bb51455a8ee1ad0a065b9ed">LOCATION_NODE_SEPARATOR_UNATTACHED</a> = '~'</td></tr>
<tr class="memdesc:a9dcff9c08bb51455a8ee1ad0a065b9ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separator character preceding a node identifiers in a location string when that node has no parent and is not in the process of being attached to one.  <br /></td></tr>
<tr class="separator:a9dcff9c08bb51455a8ee1ad0a065b9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0207cd37def4befc0825fa4e2118d861" id="r_a0207cd37def4befc0825fa4e2118d861"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0207cd37def4befc0825fa4e2118d861">RENDER_SUBTREE_INDENT</a> = 2</td></tr>
<tr class="memdesc:a0207cd37def4befc0825fa4e2118d861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spaces to indent for each tree level in <a class="el" href="#a664c9d3ec69cbbfa5993e9b698e65518" title="Renders the subtree starting at this node as a string containing an indentation-based depth-first rep...">sparta::TreeNode::renderSubtree</a>.  <br /></td></tr>
<tr class="separator:a0207cd37def4befc0825fa4e2118d861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb0eed181c22d020796770813cff2ff" id="r_a2cb0eed181c22d020796770813cff2ff"><td class="memItemLeft" align="right" valign="top">static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cb0eed181c22d020796770813cff2ff">GROUP_NAME_BUILTIN</a> [] = &quot;_SPARTA_builtin_group_&quot;</td></tr>
<tr class="memdesc:a2cb0eed181c22d020796770813cff2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserved name for built-in nodes.  <br /></td></tr>
<tr class="separator:a2cb0eed181c22d020796770813cff2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb91033f1351c5dc6b31c35d4c2ae9a" id="r_adfb91033f1351c5dc6b31c35d4c2ae9a"><td class="memItemLeft" align="right" valign="top">static const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfb91033f1351c5dc6b31c35d4c2ae9a">CHILD_FIND_THRESHOLD</a> = 100000</td></tr>
<tr class="memdesc:adfb91033f1351c5dc6b31c35d4c2ae9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threshold for number of findChildren calls after finalization before a warning message is printed about framework misuse.  <br /></td></tr>
<tr class="separator:adfb91033f1351c5dc6b31c35d4c2ae9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8830a6be5d9f6e60e4bff8124d19b289" id="r_a8830a6be5d9f6e60e4bff8124d19b289"><td class="memItemLeft" align="right" valign="top">static const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8830a6be5d9f6e60e4bff8124d19b289">CHILD_GET_THRESHOLD</a> = 100000</td></tr>
<tr class="memdesc:a8830a6be5d9f6e60e4bff8124d19b289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threshold for number of getChild calls after finalization before a warning message is printed about framework misuse.  <br /></td></tr>
<tr class="separator:a8830a6be5d9f6e60e4bff8124d19b289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462dd7d49771534977161285834213ad" id="r_a462dd7d49771534977161285834213ad"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a462dd7d49771534977161285834213ad">TEARDOWN_ERROR_LIMIT</a> = 5</td></tr>
<tr class="memdesc:a462dd7d49771534977161285834213ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of teardown-phase-related messages that can be printed before the rest will be suppressed.  <br /></td></tr>
<tr class="separator:a462dd7d49771534977161285834213ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbbbe78bdb65b46ed07ca8de5e4da89" id="r_a5fbbbe78bdb65b46ed07ca8de5e4da89"><td class="memItemLeft" align="right" valign="top">static const std::vector&lt; std::pair&lt; const char *, std::function&lt; void(std::string &amp;)&gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fbbbe78bdb65b46ed07ca8de5e4da89">TREE_NODE_PATTERN_SUBS</a></td></tr>
<tr class="memdesc:a5fbbbe78bdb65b46ed07ca8de5e4da89"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of pattern susbtitutions when creating a search pattern from a <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> name containing wildcards.  <br /></td></tr>
<tr class="separator:a5fbbbe78bdb65b46ed07ca8de5e4da89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa662b6ea451b3f69664881508e048f8a" id="r_aa662b6ea451b3f69664881508e048f8a"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint32_t, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa662b6ea451b3f69664881508e048f8a">recursGetDeepestMatchingPath_</a> (const std::string &amp;path, size_t name_pos) const</td></tr>
<tr class="memdesc:aa662b6ea451b3f69664881508e048f8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the deepest node path mathing the input <em>path</em>. Implements getDeepestMatchingPath.  <br /></td></tr>
<tr class="separator:aa662b6ea451b3f69664881508e048f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeefcb776a4574cd8075f92caaeb4676d" id="r_aeefcb776a4574cd8075f92caaeb4676d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeefcb776a4574cd8075f92caaeb4676d">setExpectedParent_</a> (const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *parent)</td></tr>
<tr class="memdesc:aeefcb776a4574cd8075f92caaeb4676d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks a node as an expected parent without actually adding this node as a child. This is used almost exclusively for printing error messages which include a device-tree location BEFORE actually inserting this node into the device tree since node construction can fail.  <br /></td></tr>
<tr class="separator:aeefcb776a4574cd8075f92caaeb4676d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774d31f6b6d00ff9d18dbcba38785657" id="r_a774d31f6b6d00ff9d18dbcba38785657"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a774d31f6b6d00ff9d18dbcba38785657">enterFinalizing_</a> ()</td></tr>
<tr class="memdesc:a774d31f6b6d00ff9d18dbcba38785657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively enter TREE_FINALIZING phase.  <br /></td></tr>
<tr class="separator:a774d31f6b6d00ff9d18dbcba38785657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9928daa22b0eba5897a854a266dc6684" id="r_a9928daa22b0eba5897a854a266dc6684"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9928daa22b0eba5897a854a266dc6684">finalizeTree_</a> ()</td></tr>
<tr class="memdesc:a9928daa22b0eba5897a854a266dc6684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively create resources based on tree configuration. enter_finalize_ should be invoked after this method successfully completes for an entire tree. Finalizes in the order of construction.  <br /></td></tr>
<tr class="separator:a9928daa22b0eba5897a854a266dc6684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22142bfb1cc678347ae0e371aeb8520a" id="r_a22142bfb1cc678347ae0e371aeb8520a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22142bfb1cc678347ae0e371aeb8520a">validateTree_</a> ()</td></tr>
<tr class="memdesc:a22142bfb1cc678347ae0e371aeb8520a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates the finalized tree and validates each node (e.g. ensures statistics can be evaluated)  <br /></td></tr>
<tr class="separator:a22142bfb1cc678347ae0e371aeb8520a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8744a27ae66472ac72860f0fdc9b0149" id="r_a8744a27ae66472ac72860f0fdc9b0149"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8744a27ae66472ac72860f0fdc9b0149">enterFinalized_</a> ()</td></tr>
<tr class="memdesc:a8744a27ae66472ac72860f0fdc9b0149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively enter TREE_FINALIZED phase.  <br /></td></tr>
<tr class="separator:a8744a27ae66472ac72860f0fdc9b0149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2cab43bc4edc2befcfab06e08c4797e" id="r_ac2cab43bc4edc2befcfab06e08c4797e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2cab43bc4edc2befcfab06e08c4797e">enterConfig_</a> () noexcept</td></tr>
<tr class="memdesc:ac2cab43bc4edc2befcfab06e08c4797e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively enter TREE_CONFIGURING phase.  <br /></td></tr>
<tr class="separator:ac2cab43bc4edc2befcfab06e08c4797e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed70a4d3e810f583e394752685233c69" id="r_aed70a4d3e810f583e394752685233c69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed70a4d3e810f583e394752685233c69">bindTreeEarly_</a> ()</td></tr>
<tr class="memdesc:aed70a4d3e810f583e394752685233c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively invoke TreeNode::onBindTreeEarly_ and Resource::onBindTreeEarly_ (in that order for each node)  <br /></td></tr>
<tr class="separator:aed70a4d3e810f583e394752685233c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3865c3ca676372326557b644bc1c305" id="r_ae3865c3ca676372326557b644bc1c305"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3865c3ca676372326557b644bc1c305">bindTreeLate_</a> ()</td></tr>
<tr class="memdesc:ae3865c3ca676372326557b644bc1c305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively invoke TreeNode::onBindTreeEarly_ and Resource::onBindTreeLate_ (in that order for each node)  <br /></td></tr>
<tr class="separator:ae3865c3ca676372326557b644bc1c305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c82ded98e4ee01463a9fbd05a56d5f" id="r_a36c82ded98e4ee01463a9fbd05a56d5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36c82ded98e4ee01463a9fbd05a56d5f">simulationTerminating_</a> ()</td></tr>
<tr class="memdesc:a36c82ded98e4ee01463a9fbd05a56d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hook to allow simulation resources to clean-up before simulation is ended.  <br /></td></tr>
<tr class="separator:a36c82ded98e4ee01463a9fbd05a56d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7234b200ace13c97244698a7370d0971" id="r_a7234b200ace13c97244698a7370d0971"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7234b200ace13c97244698a7370d0971">validatePostRun_</a> (const <a class="el" href="classsparta_1_1PostRunValidationInfo.html">PostRunValidationInfo</a> &amp;info) const</td></tr>
<tr class="memdesc:a7234b200ace13c97244698a7370d0971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hook to check the state of the simulator post-run and throw exceptions if something is incorrect.  <br /></td></tr>
<tr class="separator:a7234b200ace13c97244698a7370d0971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac08b48b8d658459cd947170e0b92a0b" id="r_aac08b48b8d658459cd947170e0b92a0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac08b48b8d658459cd947170e0b92a0b">dumpDebugContent_</a> (std::ostream &amp;out) const noexcept</td></tr>
<tr class="memdesc:aac08b48b8d658459cd947170e0b92a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows resources to write out detailed textual debugging information about the node. This is typically called by a simulator when shutting down due to an exception (or depending on simulator config). However, it could also be called at other times.  <br /></td></tr>
<tr class="separator:aac08b48b8d658459cd947170e0b92a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7ae09a1aa188a5570ec00d90a37d21" id="r_a3f7ae09a1aa188a5570ec00d90a37d21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f7ae09a1aa188a5570ec00d90a37d21">enterTeardown_</a> () noexcept</td></tr>
<tr class="memdesc:a3f7ae09a1aa188a5570ec00d90a37d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively enter TREE_TEARDOWN phase while alerting nodes through onEnteringTeardown_ and alterting Resources through Resource::onStartingTeardown_. Nodes already in TREE_TEARDOWN phase will not be alerted (neither will their associated Resources). All nodes are visited regardless of their parent's phase.  <br /></td></tr>
<tr class="separator:a3f7ae09a1aa188a5570ec00d90a37d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0f48ca47859f290f346425fea67443" id="r_a6b0f48ca47859f290f346425fea67443"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b0f48ca47859f290f346425fea67443">verifyUniqueChildIdentifier_</a> (const std::string &amp;ident, bool ignore_group_collision=false)</td></tr>
<tr class="memdesc:a6b0f48ca47859f290f346425fea67443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies that the given identifier is unique for all children of this node by comparing against names, groups, and aliases. Throws <a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a> if not unique.  <br /></td></tr>
<tr class="separator:a6b0f48ca47859f290f346425fea67443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad747a7ea6e0fdfb7421fc2bcc4db9e8f" id="r_ad747a7ea6e0fdfb7421fc2bcc4db9e8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad747a7ea6e0fdfb7421fc2bcc4db9e8f">removeChildForTeardown_</a> (<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *child)</td></tr>
<tr class="memdesc:ad747a7ea6e0fdfb7421fc2bcc4db9e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Removes" the given child by invoking onDestroyingChild_ then removing this child from the children_ list  <br /></td></tr>
<tr class="separator:ad747a7ea6e0fdfb7421fc2bcc4db9e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52ced91b3e4228df74f70678e0e9f7e" id="r_af52ced91b3e4228df74f70678e0e9f7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af52ced91b3e4228df74f70678e0e9f7e">removeFromParentForTeardown_</a> (<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *parent)</td></tr>
<tr class="memdesc:af52ced91b3e4228df74f70678e0e9f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protected Wrapper for <a class="el" href="#aa8958d72a1f5aeff2ec36012913ac09c" title="Gets immediate parent of this node if one exists.">getParent()</a>-&gt;removeChildForTeardown_ which allows subclases of <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> to indirectly invoke removeChildForTeardown_ with themselves as the argument.  <br /></td></tr>
<tr class="separator:af52ced91b3e4228df74f70678e0e9f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de0d978208d5a7f050a829da9db6558" id="r_a6de0d978208d5a7f050a829da9db6558"><td class="memItemLeft" align="right" valign="top"><a id="a6de0d978208d5a7f050a829da9db6558" name="a6de0d978208d5a7f050a829da9db6558"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>detachFromParent_</b> ()</td></tr>
<tr class="memdesc:a6de0d978208d5a7f050a829da9db6558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a node from its parent with the expectation this node will be immediately destroyed (i.e. is an xvalue) <br /></td></tr>
<tr class="separator:a6de0d978208d5a7f050a829da9db6558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ceb5bf7eed5807a8cfd36e36d7919e" id="r_a26ceb5bf7eed5807a8cfd36e36d7919e"><td class="memItemLeft" align="right" valign="top"><a id="a26ceb5bf7eed5807a8cfd36e36d7919e" name="a26ceb5bf7eed5807a8cfd36e36d7919e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>detachFromChildren_</b> ()</td></tr>
<tr class="memdesc:a26ceb5bf7eed5807a8cfd36e36d7919e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a node from its children with the expectation this node will be immediately destroyed (i.e. is an xvalue) <br /></td></tr>
<tr class="separator:a26ceb5bf7eed5807a8cfd36e36d7919e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811cf5ec3c1f09465768fba8bce6788e" id="r_a811cf5ec3c1f09465768fba8bce6788e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a811cf5ec3c1f09465768fba8bce6788e">areParametersLocked_</a> () const</td></tr>
<tr class="memdesc:a811cf5ec3c1f09465768fba8bce6788e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method informs whether the tree is past the lockdown phase for all LOCKED and HIDDEN parameters. Modifying LOCKED and HIDDEN parameters after this phase is disallowed. Tree can be locked down during TREE_BUILDING phase or TREE_CONFIGURING phase. During TREE_FINALIZING phase, all parameters are locked down as is.  <br /></td></tr>
<tr class="separator:a811cf5ec3c1f09465768fba8bce6788e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classsparta_1_1ResourceContainer"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classsparta_1_1ResourceContainer')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classsparta_1_1ResourceContainer.html">sparta::ResourceContainer</a></td></tr>
<tr class="memitem:af399ae644f27a3982dd3a2a788ae8d24 inherit pro_methods_classsparta_1_1ResourceContainer" id="r_af399ae644f27a3982dd3a2a788ae8d24"><td class="memItemLeft" align="right" valign="top">
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getResourceTypeName_</b> () const</td></tr>
<tr class="memdesc:af399ae644f27a3982dd3a2a788ae8d24 inherit pro_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the rtti type name (demangled) of the resource type held by this container. If there is no resource held, returns empty string. <br /></td></tr>
<tr class="separator:af399ae644f27a3982dd3a2a788ae8d24 inherit pro_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7941bfaff4076700bbf155f9a600a8f inherit pro_methods_classsparta_1_1ResourceContainer" id="r_ae7941bfaff4076700bbf155f9a600a8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceContainer.html#ae7941bfaff4076700bbf155f9a600a8f">setResource_</a> (<a class="el" href="classsparta_1_1Resource.html">Resource</a> *r)</td></tr>
<tr class="memdesc:ae7941bfaff4076700bbf155f9a600a8f inherit pro_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows subclasses to assign the resource associated with this node.  <br /></td></tr>
<tr class="separator:ae7941bfaff4076700bbf155f9a600a8f inherit pro_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22867f593bad8970c253325b7a3543c8 inherit pro_methods_classsparta_1_1ResourceContainer" id="r_a22867f593bad8970c253325b7a3543c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceContainer.html#a22867f593bad8970c253325b7a3543c8">unsetResource_</a> ()</td></tr>
<tr class="memdesc:a22867f593bad8970c253325b7a3543c8 inherit pro_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows a resource to unset the resource set with setResource_.  <br /></td></tr>
<tr class="separator:a22867f593bad8970c253325b7a3543c8 inherit pro_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20cbff011fb2cf11ffd35b167445e79d inherit pro_methods_classsparta_1_1ResourceContainer" id="r_a20cbff011fb2cf11ffd35b167445e79d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceContainer.html#a20cbff011fb2cf11ffd35b167445e79d">lockResource_</a> ()</td></tr>
<tr class="memdesc:a20cbff011fb2cf11ffd35b167445e79d inherit pro_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows subclasses to assign the resource associated with this node.  <br /></td></tr>
<tr class="separator:a20cbff011fb2cf11ffd35b167445e79d inherit pro_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854becbfda6c01a57fb00d02372b54b7 inherit pro_methods_classsparta_1_1ResourceContainer" id="r_a854becbfda6c01a57fb00d02372b54b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Resource.html">Resource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceContainer.html#a854becbfda6c01a57fb00d02372b54b7">getResource_</a> () noexcept</td></tr>
<tr class="memdesc:a854becbfda6c01a57fb00d02372b54b7 inherit pro_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the currently held resource of this node (if any). This method can be called at any time.  <br /></td></tr>
<tr class="separator:a854becbfda6c01a57fb00d02372b54b7 inherit pro_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f96706c7bdcd9d6b61d4bd9ef88e4a5 inherit pro_methods_classsparta_1_1ResourceContainer" id="r_a6f96706c7bdcd9d6b61d4bd9ef88e4a5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsparta_1_1Resource.html">Resource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceContainer.html#a6f96706c7bdcd9d6b61d4bd9ef88e4a5">getResource_</a> () const noexcept</td></tr>
<tr class="memdesc:a6f96706c7bdcd9d6b61d4bd9ef88e4a5 inherit pro_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const variant of getResource_.  <br /></td></tr>
<tr class="separator:a6f96706c7bdcd9d6b61d4bd9ef88e4a5 inherit pro_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classsparta_1_1PhasedObject"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classsparta_1_1PhasedObject')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classsparta_1_1PhasedObject.html">sparta::PhasedObject</a></td></tr>
<tr class="memitem:a59b0c6f93493d362a720a665ce443ccd inherit pro_methods_classsparta_1_1PhasedObject" id="r_a59b0c6f93493d362a720a665ce443ccd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1PhasedObject.html#a59b0c6f93493d362a720a665ce443ccd">setPhase_</a> (<a class="el" href="classsparta_1_1PhasedObject.html#afe9c78396c961fd96f0975867197b366">TreePhase</a> phase)</td></tr>
<tr class="memdesc:a59b0c6f93493d362a720a665ce443ccd inherit pro_methods_classsparta_1_1PhasedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current phase.  <br /></td></tr>
<tr class="separator:a59b0c6f93493d362a720a665ce443ccd inherit pro_methods_classsparta_1_1PhasedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ab50c28d990477787fe2a043555302120" id="r_ab50c28d990477787fe2a043555302120"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab50c28d990477787fe2a043555302120">identityMatchesPattern_</a> (const std::string &amp;ident, std::regex &amp;expr, std::vector&lt; std::string &gt; &amp;replacements)</td></tr>
<tr class="memdesc:ab50c28d990477787fe2a043555302120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs pattern matching on a identity string.  <br /></td></tr>
<tr class="separator:ab50c28d990477787fe2a043555302120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe31e2005a4befa9fe1ab92f04d3e666" id="r_afe31e2005a4befa9fe1ab92f04d3e666"><td class="memItemLeft" align="right" valign="top"><a id="afe31e2005a4befa9fe1ab92f04d3e666" name="afe31e2005a4befa9fe1ab92f04d3e666"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>identityMatchesPattern_</b> (const std::string &amp;ident, std::regex &amp;expr)</td></tr>
<tr class="memdesc:afe31e2005a4befa9fe1ab92f04d3e666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of identityMatchesPattern_ with no replacements vector. <br /></td></tr>
<tr class="separator:afe31e2005a4befa9fe1ab92f04d3e666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a42a6710fd8458fb5699c259229e6a" id="r_a84a42a6710fd8458fb5699c259229e6a"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84a42a6710fd8458fb5699c259229e6a">getPreviousName_</a> (const std::string &amp;name, size_t &amp;pos)</td></tr>
<tr class="memdesc:a84a42a6710fd8458fb5699c259229e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the previous name between two '.' chars in a string starting at <em>pos</em>.  <br /></td></tr>
<tr class="separator:a84a42a6710fd8458fb5699c259229e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af9491929126414c21425d895196e0cbf" id="r_af9491929126414c21425d895196e0cbf"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9491929126414c21425d895196e0cbf">VirtualGlobalTreeNode</a></td></tr>
<tr class="memdesc:af9491929126414c21425d895196e0cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow this class access internals for handling notification observation registration/deregistration broadcasts in a way that does not fit the composite tree pattern.  <br /></td></tr>
<tr class="separator:af9491929126414c21425d895196e0cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f23c76add152bf5c5cd059cf3efaa1" id="r_aa9f23c76add152bf5c5cd059cf3efaa1"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9f23c76add152bf5c5cd059cf3efaa1">ClockManager</a></td></tr>
<tr class="memdesc:aa9f23c76add152bf5c5cd059cf3efaa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow <a class="el" href="classsparta_1_1ClockManager.html" title="Manages building a clock tree.">ClockManager</a> to directly change phase on nodes.  <br /></td></tr>
<tr class="separator:aa9f23c76add152bf5c5cd059cf3efaa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7324f36a680eecafcd1a2d0de19b0d09" id="r_a7324f36a680eecafcd1a2d0de19b0d09"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7324f36a680eecafcd1a2d0de19b0d09">SpartaStaticInitializer</a></td></tr>
<tr class="memdesc:a7324f36a680eecafcd1a2d0de19b0d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is responsible for instantiating the static container held by this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>.  <br /></td></tr>
<tr class="separator:a7324f36a680eecafcd1a2d0de19b0d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651be440effba7234b368631d4a346db" id="r_a651be440effba7234b368631d4a346db"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a651be440effba7234b368631d4a346db">TreeNodePrivateAttorney</a></td></tr>
<tr class="memdesc:a651be440effba7234b368631d4a346db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Friend an attorney pattern that can expose access to getAllChildren_ or other methods that bypass privacy_level_.  <br /></td></tr>
<tr class="separator:a651be440effba7234b368631d4a346db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">TreeNode extensions</h2></td></tr>
<tr class="memitem:abb004c7a919bb15eb9113b7ac6dae777" id="r_abb004c7a919bb15eb9113b7ac6dae777"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb004c7a919bb15eb9113b7ac6dae777">ExtensionsBase</a> = detail::ExtensionsBase</td></tr>
<tr class="separator:abb004c7a919bb15eb9113b7ac6dae777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46abf404b2bc1fff08e6d6bba27bd3ac" id="r_a46abf404b2bc1fff08e6d6bba27bd3ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46abf404b2bc1fff08e6d6bba27bd3ac">addExtensionFactory</a> (const std::string &amp;extension_name, std::function&lt; ExtensionsBase *()&gt; factory)</td></tr>
<tr class="memdesc:a46abf404b2bc1fff08e6d6bba27bd3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an extension factory to this tree node by its type (name).  <br /></td></tr>
<tr class="separator:a46abf404b2bc1fff08e6d6bba27bd3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2433c4a7d26a10420ff908fdfe59ee01" id="r_a2433c4a7d26a10420ff908fdfe59ee01"><td class="memItemLeft" align="right" valign="top">ExtensionsBase *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2433c4a7d26a10420ff908fdfe59ee01">getExtension</a> (const std::string &amp;extension_name, bool no_factory_ok=false)</td></tr>
<tr class="memdesc:a2433c4a7d26a10420ff908fdfe59ee01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an extension object by type string. Returns nullptr if not found (unrecognized).  <br /></td></tr>
<tr class="separator:a2433c4a7d26a10420ff908fdfe59ee01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5469acef24d1a7d7058ce18cfb76c725" id="r_a5469acef24d1a7d7058ce18cfb76c725"><td class="memItemLeft" align="right" valign="top">const ExtensionsBase *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5469acef24d1a7d7058ce18cfb76c725">getExtension</a> (const std::string &amp;extension_name) const</td></tr>
<tr class="memdesc:a5469acef24d1a7d7058ce18cfb76c725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an extension object by type string. Returns nullptr if not found (unrecognized).  <br /></td></tr>
<tr class="separator:a5469acef24d1a7d7058ce18cfb76c725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd23bf68d7472b74099c35a5aafe0b9e" id="r_acd23bf68d7472b74099c35a5aafe0b9e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acd23bf68d7472b74099c35a5aafe0b9e"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acd23bf68d7472b74099c35a5aafe0b9e">getExtensionAs</a> (const std::string &amp;extension_name)</td></tr>
<tr class="memdesc:acd23bf68d7472b74099c35a5aafe0b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an extension, downcast to the given type.  <br /></td></tr>
<tr class="separator:acd23bf68d7472b74099c35a5aafe0b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ecd57d84a123959187276ee2404c475" id="r_a1ecd57d84a123959187276ee2404c475"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1ecd57d84a123959187276ee2404c475"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1ecd57d84a123959187276ee2404c475">getExtensionAs</a> (const std::string &amp;extension_name) const</td></tr>
<tr class="memdesc:a1ecd57d84a123959187276ee2404c475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an extension, downcast to the given type.  <br /></td></tr>
<tr class="separator:a1ecd57d84a123959187276ee2404c475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c99280dc2adae048d57fb001d05de61" id="r_a8c99280dc2adae048d57fb001d05de61"><td class="memItemLeft" align="right" valign="top">ExtensionsBase *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c99280dc2adae048d57fb001d05de61">getExtension</a> ()</td></tr>
<tr class="memdesc:a8c99280dc2adae048d57fb001d05de61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an extension without needing to specify any particular extension name. If no extensions exist, returns nullptr. If only one extension exists, returns that extension. If more than one extension exists, throws an exception.  <br /></td></tr>
<tr class="separator:a8c99280dc2adae048d57fb001d05de61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4107352f9e07846b812d794d5a38a5" id="r_a9d4107352f9e07846b812d794d5a38a5"><td class="memItemLeft" align="right" valign="top">const ExtensionsBase *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d4107352f9e07846b812d794d5a38a5">getExtension</a> () const</td></tr>
<tr class="memdesc:a9d4107352f9e07846b812d794d5a38a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an extension without needing to specify any particular extension name. If no extensions exist, returns nullptr. If only one extension exists, returns that extension. If more than one extension exists, throws an exception.  <br /></td></tr>
<tr class="separator:a9d4107352f9e07846b812d794d5a38a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb4f3d69315bfb965489d00f7be5148" id="r_a5bb4f3d69315bfb965489d00f7be5148"><td class="memItemLeft" align="right" valign="top">ExtensionsBase *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bb4f3d69315bfb965489d00f7be5148">createExtension</a> (const std::string &amp;extension_name, bool replace=false)</td></tr>
<tr class="memdesc:a5bb4f3d69315bfb965489d00f7be5148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an extension on demand. This is useful if you want to add an extension to a node that was not specified in any of the &ndash;extension-file, &ndash;arch, &ndash;config-file, or &ndash;node-config-file YAML files.  <br /></td></tr>
<tr class="separator:a5bb4f3d69315bfb965489d00f7be5148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95a9a2b043fc39a1972871380d09eac" id="r_af95a9a2b043fc39a1972871380d09eac"><td class="memItemLeft" align="right" valign="top">ExtensionsBase *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af95a9a2b043fc39a1972871380d09eac">createExtension</a> (bool replace=false)</td></tr>
<tr class="memdesc:af95a9a2b043fc39a1972871380d09eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an extension on demand without needing to specify any particular extension name. If the arch/config/extension YAML input files have exactly one extension configured for this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>, that extension will be created.  <br /></td></tr>
<tr class="separator:af95a9a2b043fc39a1972871380d09eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be07418bc8582d96fe2c3fb89ff4d94" id="r_a1be07418bc8582d96fe2c3fb89ff4d94"><td class="memItemLeft" align="right" valign="top">ExtensionsBase *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1be07418bc8582d96fe2c3fb89ff4d94">createExtension</a> (const char *extension_name, bool replace=false)</td></tr>
<tr class="separator:a1be07418bc8582d96fe2c3fb89ff4d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc907c86ba95d84c6e97f9421cbbc85" id="r_a1dc907c86ba95d84c6e97f9421cbbc85"><td class="memTemplParams" colspan="2">template&lt;typename Extension , typename... Args&gt; </td></tr>
<tr class="memitem:a1dc907c86ba95d84c6e97f9421cbbc85"><td class="memTemplItemLeft" align="right" valign="top">Extension *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1dc907c86ba95d84c6e97f9421cbbc85">addExtension</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a1dc907c86ba95d84c6e97f9421cbbc85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an extension, specifying the ExtensionsBase subclass type. Forward any arguments needed to your subclass extension's constructor. The typical use case for <a class="el" href="#a1dc907c86ba95d84c6e97f9421cbbc85" title="Add an extension, specifying the ExtensionsBase subclass type. Forward any arguments needed to your s...">addExtension()</a> over the other apis is that these extensions are meant to be dynamic-only (on-demand only), bypassing the finalizeTree() checks that all extension parameters have been read. You can call <a class="el" href="#a1dc907c86ba95d84c6e97f9421cbbc85" title="Add an extension, specifying the ExtensionsBase subclass type. Forward any arguments needed to your s...">addExtension()</a> whenever you want.  <br /></td></tr>
<tr class="separator:a1dc907c86ba95d84c6e97f9421cbbc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80b64d2c78346e93c5513dda617f547" id="r_ac80b64d2c78346e93c5513dda617f547"><td class="memTemplParams" colspan="2">template&lt;typename Extension , typename... Args&gt; </td></tr>
<tr class="memitem:ac80b64d2c78346e93c5513dda617f547"><td class="memTemplItemLeft" align="right" valign="top">Extension *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac80b64d2c78346e93c5513dda617f547">replaceExtension</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac80b64d2c78346e93c5513dda617f547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace an extension, specifying the ExtensionsBase subclass type. This api is similar to <a class="el" href="#a1dc907c86ba95d84c6e97f9421cbbc85" title="Add an extension, specifying the ExtensionsBase subclass type. Forward any arguments needed to your s...">addExtension()</a> in that you do not have to read these parameters prior to finalizeTree() to avoid "unread unbound parameter" exceptions.  <br /></td></tr>
<tr class="separator:ac80b64d2c78346e93c5513dda617f547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91d6baf74fae76dd391c4e68b04a936" id="r_ac91d6baf74fae76dd391c4e68b04a936"><td class="memItemLeft" align="right" valign="top"><a id="ac91d6baf74fae76dd391c4e68b04a936" name="ac91d6baf74fae76dd391c4e68b04a936"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>removeExtension</b> (const std::string &amp;extension_name)</td></tr>
<tr class="memdesc:ac91d6baf74fae76dd391c4e68b04a936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an extension by its name. Returns true if successful, false if the extension was not found. <br /></td></tr>
<tr class="separator:ac91d6baf74fae76dd391c4e68b04a936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b99ce49b9d44c9cc8e7b738601ef4b" id="r_a00b99ce49b9d44c9cc8e7b738601ef4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00b99ce49b9d44c9cc8e7b738601ef4b">hasExtension</a> (const std::string &amp;extension_name) const</td></tr>
<tr class="memdesc:a00b99ce49b9d44c9cc8e7b738601ef4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this tree node has an extension by the given name.  <br /></td></tr>
<tr class="separator:a00b99ce49b9d44c9cc8e7b738601ef4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5a8c3649144eeeec5acacbba4f2b37" id="r_aca5a8c3649144eeeec5acacbba4f2b37"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca5a8c3649144eeeec5acacbba4f2b37"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aca5a8c3649144eeeec5acacbba4f2b37">hasExtensionOfType</a> (const std::string &amp;extension_name) const noexcept</td></tr>
<tr class="memdesc:aca5a8c3649144eeeec5acacbba4f2b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this tree node has an extension by the given name and type.  <br /></td></tr>
<tr class="separator:aca5a8c3649144eeeec5acacbba4f2b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e9902e2233c6c0781c53652c0474c4" id="r_af9e9902e2233c6c0781c53652c0474c4"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9e9902e2233c6c0781c53652c0474c4">getAllInstantiatedExtensionNames</a> () const</td></tr>
<tr class="memdesc:af9e9902e2233c6c0781c53652c0474c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of extension names for all <b>instantiated</b> extensions on this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>.  <br /></td></tr>
<tr class="separator:af9e9902e2233c6c0781c53652c0474c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae350a6316e5fc067d71de021b9d76d71" id="r_ae350a6316e5fc067d71de021b9d76d71"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae350a6316e5fc067d71de021b9d76d71">getAllConfigExtensionNames</a> () const</td></tr>
<tr class="memdesc:ae350a6316e5fc067d71de021b9d76d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of extension names found for this node in all arch/config/extension files.  <br /></td></tr>
<tr class="separator:ae350a6316e5fc067d71de021b9d76d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319509d49b71536682de2c35856ae24c" id="r_a319509d49b71536682de2c35856ae24c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a319509d49b71536682de2c35856ae24c">getNumExtensions</a> () const</td></tr>
<tr class="memdesc:a319509d49b71536682de2c35856ae24c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of extensions for this node.  <br /></td></tr>
<tr class="separator:a319509d49b71536682de2c35856ae24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d555432f77343119f980c47ac3768dc" id="r_a1d555432f77343119f980c47ac3768dc"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, const ExtensionsBase * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d555432f77343119f980c47ac3768dc">getAllExtensions</a> () const</td></tr>
<tr class="memdesc:a1d555432f77343119f980c47ac3768dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a map of extensions for this node.  <br /></td></tr>
<tr class="separator:a1d555432f77343119f980c47ac3768dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Internal Notification System</h2></td></tr>
<tr class="memitem:ab92c3c0688d1c33036a224f4ce57b715" id="r_ab92c3c0688d1c33036a224f4ce57b715"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="classsparta_1_1TreeNode_1_1delegate.html">delegate</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab92c3c0688d1c33036a224f4ce57b715">DelegateVector</a></td></tr>
<tr class="memdesc:ab92c3c0688d1c33036a224f4ce57b715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of delegates representing a list of observers to notify.  <br /></td></tr>
<tr class="separator:ab92c3c0688d1c33036a224f4ce57b715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdceb31f74d5a8e554defe592af90f54" id="r_abdceb31f74d5a8e554defe592af90f54"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; <a class="el" href="classsparta_1_1TreeNode_1_1type__info__container.html">type_info_container</a>, <a class="el" href="#ab92c3c0688d1c33036a224f4ce57b715">DelegateVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abdceb31f74d5a8e554defe592af90f54">NotificationObserverMap</a></td></tr>
<tr class="memdesc:abdceb31f74d5a8e554defe592af90f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of delegate vectors containing all observers.  <br /></td></tr>
<tr class="separator:abdceb31f74d5a8e554defe592af90f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859010859da20b3dd6e1d300b12a90d4" id="r_a859010859da20b3dd6e1d300b12a90d4"><td class="memTemplParams" colspan="2">template&lt;typename DataT &gt; </td></tr>
<tr class="memitem:a859010859da20b3dd6e1d300b12a90d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a859010859da20b3dd6e1d300b12a90d4">postPropagatingNotification_</a> (const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *origin, const DataT &amp;data, const std::string *name_id)</td></tr>
<tr class="memdesc:a859010859da20b3dd6e1d300b12a90d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a notification propagating up the tree.  <br /></td></tr>
<tr class="separator:a859010859da20b3dd6e1d300b12a90d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754479f743ac2addfcce2747ef1afb3f" id="r_a754479f743ac2addfcce2747ef1afb3f"><td class="memTemplParams" colspan="2">template&lt;typename DataT , typename T , void(T::*)(const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &amp;, const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &amp;, const DataT &amp;) TMethod&gt; </td></tr>
<tr class="memitem:a754479f743ac2addfcce2747ef1afb3f"><td class="memTemplItemLeft" align="right" valign="top">DelegateVector::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a754479f743ac2addfcce2747ef1afb3f">findDelegate_</a> (<a class="el" href="#ab92c3c0688d1c33036a224f4ce57b715">DelegateVector</a> &amp;dvec, T *obj, const std::string &amp;target_name)</td></tr>
<tr class="memdesc:a754479f743ac2addfcce2747ef1afb3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a delegate associated with the given type T, object pointer, DataT, and TMethod within a DelevateVector. The intent of this function is to help see if a delegate is already registered with a calback by checking all known information associated with that callback against the input arguments.  <br /></td></tr>
<tr class="separator:a754479f743ac2addfcce2747ef1afb3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754479f743ac2addfcce2747ef1afb3f" id="r_a754479f743ac2addfcce2747ef1afb3f"><td class="memTemplParams" colspan="2">template&lt;typename DataT , typename T , void(T::*)(const DataT &amp;) TMethod&gt; </td></tr>
<tr class="memitem:a754479f743ac2addfcce2747ef1afb3f"><td class="memTemplItemLeft" align="right" valign="top">DelegateVector::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a754479f743ac2addfcce2747ef1afb3f">findDelegate_</a> (<a class="el" href="#ab92c3c0688d1c33036a224f4ce57b715">DelegateVector</a> &amp;dvec, T *obj, const std::string &amp;target_name)</td></tr>
<tr class="separator:a754479f743ac2addfcce2747ef1afb3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d32cacde7a58997e485ab87a50e961" id="r_a01d32cacde7a58997e485ab87a50e961"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01d32cacde7a58997e485ab87a50e961">broadcastRegistrationForNotificationToChildren_</a> (const std::type_info &amp;tinfo, const std::vector&lt; const std::string * &gt; &amp;name_ids, <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *obs_node, const <a class="el" href="classsparta_1_1TreeNode_1_1delegate.html">delegate</a> *del, const bool allow_private)</td></tr>
<tr class="memdesc:a01d32cacde7a58997e485ab87a50e961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively notifies children that the notification described is now (or still is) being observed at the observation point <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> <em>obs_node</em> with the newly registered delegate <em>del</em>.  <br /></td></tr>
<tr class="separator:a01d32cacde7a58997e485ab87a50e961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746152de43052580e24b26d3f890f1a2" id="r_a746152de43052580e24b26d3f890f1a2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a746152de43052580e24b26d3f890f1a2">broadcastDeregistrationForNotificationToChildren_</a> (const std::type_info &amp;tinfo, const std::vector&lt; const std::string * &gt; &amp;name_ids, <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *obs_node, const <a class="el" href="classsparta_1_1TreeNode_1_1delegate.html">delegate</a> *del, const bool allow_private)</td></tr>
<tr class="memdesc:a746152de43052580e24b26d3f890f1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively notifies children that the notification described has lost one particular observer (<em>del</em>) which was observing at the observation point <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> <em>obs_node</em> with the delegate <em>del</em>.  <br /></td></tr>
<tr class="separator:a746152de43052580e24b26d3f890f1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b778eda31fa56c9a66bd79bc77b01eb" id="r_a5b778eda31fa56c9a66bd79bc77b01eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b778eda31fa56c9a66bd79bc77b01eb">broadcastRegistrationForNotificationListStringToChildren_</a> (const std::type_info &amp;tinfo, const std::string &amp;name, <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *obs_node, const <a class="el" href="classsparta_1_1TreeNode_1_1delegate.html">delegate</a> *del, const bool private_only)</td></tr>
<tr class="memdesc:a5b778eda31fa56c9a66bd79bc77b01eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point to broadcastRegistrationForNotificationToChildren_ recursion. Breaks a name string.  <br /></td></tr>
<tr class="separator:a5b778eda31fa56c9a66bd79bc77b01eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c939995118db03f0a3fba145eab1aa" id="r_a59c939995118db03f0a3fba145eab1aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59c939995118db03f0a3fba145eab1aa">broadcastDeregistrationForNotificationListStringToChildren_</a> (const std::type_info &amp;tinfo, const std::string &amp;name, <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *obs_node, const <a class="el" href="classsparta_1_1TreeNode_1_1delegate.html">delegate</a> *del, const bool private_only)</td></tr>
<tr class="memdesc:a59c939995118db03f0a3fba145eab1aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symmetric oppostie of broadcastRegistrationForNotificationListStringToChildren_.  <br /></td></tr>
<tr class="separator:a59c939995118db03f0a3fba145eab1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ec15f8443eb1f90447942deb20d26f" id="r_a62ec15f8443eb1f90447942deb20d26f"><td class="memTemplParams" colspan="2">template&lt;typename DataT &gt; </td></tr>
<tr class="memitem:a62ec15f8443eb1f90447942deb20d26f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a62ec15f8443eb1f90447942deb20d26f">invokeDelegatesOn_</a> (<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *to_invoke, const DataT &amp;data, const std::string *name_id)</td></tr>
<tr class="memdesc:a62ec15f8443eb1f90447942deb20d26f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protected wrapper for invokeDelegates_ which allows a <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> to invoke delegates on another <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> using itself as the origin.  <br /></td></tr>
<tr class="separator:a62ec15f8443eb1f90447942deb20d26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Diagnostics</h2></td></tr>
<tr class="memitem:aac64404e9cbc67844ce87a0507b73fd8" id="r_aac64404e9cbc67844ce87a0507b73fd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac64404e9cbc67844ce87a0507b73fd8">lockdownParameters</a> ()</td></tr>
<tr class="memdesc:aac64404e9cbc67844ce87a0507b73fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to put the device tree in lockdown phase. All LOCKED and HIDDEN parameters are frozen after this point. Regular parameters are not affected by this phase. This method requires a Simulation pointer and will assert at compile time if anyone tries to lockdown the tree without the context of a Simulation.  <br /></td></tr>
<tr class="separator:aac64404e9cbc67844ce87a0507b73fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001153882adf23d6f32cfbffe9af861a" id="r_a001153882adf23d6f32cfbffe9af861a"><td class="memItemLeft" align="right" valign="top"><a id="a001153882adf23d6f32cfbffe9af861a" name="a001153882adf23d6f32cfbffe9af861a"></a>
static const std::map&lt; const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *, <a class="el" href="#a91f21b18f9f50f70111730361eff6ddb">WeakPtr</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getParentlessNodes</b> ()</td></tr>
<tr class="separator:a001153882adf23d6f32cfbffe9af861a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77344269c5bac67061d2f85756579fbe" id="r_a77344269c5bac67061d2f85756579fbe"><td class="memItemLeft" align="right" valign="top"><a id="a77344269c5bac67061d2f85756579fbe" name="a77344269c5bac67061d2f85756579fbe"></a>
static const std::map&lt; const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *, <a class="el" href="#a91f21b18f9f50f70111730361eff6ddb">WeakPtr</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getAllNodes</b> ()</td></tr>
<tr class="memdesc:a77344269c5bac67061d2f85756579fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the vector of all TreeNodes currently known to be constructed. <br /></td></tr>
<tr class="separator:a77344269c5bac67061d2f85756579fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66d5a9570ecf75c70a23c052254ccc7" id="r_ad66d5a9570ecf75c70a23c052254ccc7"><td class="memItemLeft" align="right" valign="top"><a id="ad66d5a9570ecf75c70a23c052254ccc7" name="ad66d5a9570ecf75c70a23c052254ccc7"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>formatAllNodes</b> ()</td></tr>
<tr class="memdesc:ad66d5a9570ecf75c70a23c052254ccc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the list of all TreeNodes currently known to be constructed. <br /></td></tr>
<tr class="separator:ad66d5a9570ecf75c70a23c052254ccc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae614c29aa798fd41da2dd178a359272f" id="r_ae614c29aa798fd41da2dd178a359272f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae614c29aa798fd41da2dd178a359272f">isNodeConstructed</a> (const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *)</td></tr>
<tr class="memdesc:ae614c29aa798fd41da2dd178a359272f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a given node constructed?  <br /></td></tr>
<tr class="separator:ae614c29aa798fd41da2dd178a359272f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Tree Navigation &amp; State</h2></td></tr>
<tr class="memitem:a5e430f72fd1a922df3c8dbc7be3f7d00" id="r_a5e430f72fd1a922df3c8dbc7be3f7d00"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e430f72fd1a922df3c8dbc7be3f7d00">isAttached</a> () const</td></tr>
<tr class="memdesc:a5e430f72fd1a922df3c8dbc7be3f7d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this node part of a device tree with a proper <a class="el" href="classsparta_1_1RootTreeNode.html" title="TreeNode which represents the root (&quot;top&quot;) of a device tree.">RootTreeNode</a> at the root.  <br /></td></tr>
<tr class="separator:a5e430f72fd1a922df3c8dbc7be3f7d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8958d72a1f5aeff2ec36012913ac09c" id="r_aa8958d72a1f5aeff2ec36012913ac09c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8958d72a1f5aeff2ec36012913ac09c">getParent</a> ()</td></tr>
<tr class="memdesc:aa8958d72a1f5aeff2ec36012913ac09c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets immediate parent of this node if one exists.  <br /></td></tr>
<tr class="separator:aa8958d72a1f5aeff2ec36012913ac09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad888851269c4ccd2009b66b5d6cb111" id="r_aad888851269c4ccd2009b66b5d6cb111"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad888851269c4ccd2009b66b5d6cb111">getParent</a> () const</td></tr>
<tr class="separator:aad888851269c4ccd2009b66b5d6cb111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e274bfe8a716d699ad67e74212c87b9" id="r_a3e274bfe8a716d699ad67e74212c87b9"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a3e274bfe8a716d699ad67e74212c87b9"><td class="memTemplItemLeft" align="right" valign="top">const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3e274bfe8a716d699ad67e74212c87b9">getParentAs</a> (bool must_exist=true) const</td></tr>
<tr class="memdesc:a3e274bfe8a716d699ad67e74212c87b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a parent casted to type T* if this node has a parent.  <br /></td></tr>
<tr class="separator:a3e274bfe8a716d699ad67e74212c87b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcfcd5236cbc9208cbcbbbfadd73ec37" id="r_adcfcd5236cbc9208cbcbbbfadd73ec37"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;!std::is_pointer&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:adcfcd5236cbc9208cbcbbbfadd73ec37"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adcfcd5236cbc9208cbcbbbfadd73ec37">getParentAs</a> (bool must_exist=true) const</td></tr>
<tr class="separator:adcfcd5236cbc9208cbcbbbfadd73ec37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c4ab072677438d088d7d99c1f585f6" id="r_a05c4ab072677438d088d7d99c1f585f6"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a05c4ab072677438d088d7d99c1f585f6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a05c4ab072677438d088d7d99c1f585f6">getParentAs</a> (bool must_exist=true)</td></tr>
<tr class="separator:a05c4ab072677438d088d7d99c1f585f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51788dafac480f1e80ee6167e2c3da06" id="r_a51788dafac480f1e80ee6167e2c3da06"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;!std::is_pointer&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a51788dafac480f1e80ee6167e2c3da06"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a51788dafac480f1e80ee6167e2c3da06">getParentAs</a> (bool must_exist=true)</td></tr>
<tr class="separator:a51788dafac480f1e80ee6167e2c3da06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31666fa4b498cd468991f2099e3fbbf7" id="r_a31666fa4b498cd468991f2099e3fbbf7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31666fa4b498cd468991f2099e3fbbf7">getRoot</a> ()</td></tr>
<tr class="memdesc:a31666fa4b498cd468991f2099e3fbbf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets farthest ancestor of this node.  <br /></td></tr>
<tr class="separator:a31666fa4b498cd468991f2099e3fbbf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6461997acf50ce6caa9ca2815a3a0e" id="r_a5e6461997acf50ce6caa9ca2815a3a0e"><td class="memItemLeft" align="right" valign="top"><a id="a5e6461997acf50ce6caa9ca2815a3a0e" name="a5e6461997acf50ce6caa9ca2815a3a0e"></a>
virtual const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getRoot</b> () const</td></tr>
<tr class="separator:a5e6461997acf50ce6caa9ca2815a3a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7432fe0422eaa5afed7848effbc7d8f" id="r_ad7432fe0422eaa5afed7848effbc7d8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7432fe0422eaa5afed7848effbc7d8f">getScopeRoot</a> ()</td></tr>
<tr class="separator:ad7432fe0422eaa5afed7848effbc7d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817663bb26d61b4970378614ed8a0908" id="r_a817663bb26d61b4970378614ed8a0908"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a817663bb26d61b4970378614ed8a0908">getScopeRoot</a> () const</td></tr>
<tr class="separator:a817663bb26d61b4970378614ed8a0908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f2e3a443fafcf26682291cfdeb19f1" id="r_a55f2e3a443fafcf26682291cfdeb19f1"><td class="memItemLeft" align="right" valign="top"><a id="a55f2e3a443fafcf26682291cfdeb19f1" name="a55f2e3a443fafcf26682291cfdeb19f1"></a>
const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getExpectedRoot</b> () const</td></tr>
<tr class="memdesc:a55f2e3a443fafcf26682291cfdeb19f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">build-time equivalent to getRoot before an object is actually attached to a tree. This is a mainly a framework and debugging tool for determining what the root of a node being constructed will be when complete <br /></td></tr>
<tr class="separator:a55f2e3a443fafcf26682291cfdeb19f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0074a4a62b20d8b414fe52939feaf9ca" id="r_a0074a4a62b20d8b414fe52939feaf9ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1app_1_1Simulation.html">app::Simulation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0074a4a62b20d8b414fe52939feaf9ca">getSimulation</a> () const</td></tr>
<tr class="memdesc:a0074a4a62b20d8b414fe52939feaf9ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the simulation (if any) associated with this tree.  <br /></td></tr>
<tr class="separator:a0074a4a62b20d8b414fe52939feaf9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58ee3afd3ce00f3d8c42cd75a65c097" id="r_ac58ee3afd3ce00f3d8c42cd75a65c097"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac58ee3afd3ce00f3d8c42cd75a65c097">getNumChildren</a> () const</td></tr>
<tr class="memdesc:ac58ee3afd3ce00f3d8c42cd75a65c097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of children that this node has including those in the sparta builtins group.  <br /></td></tr>
<tr class="separator:ac58ee3afd3ce00f3d8c42cd75a65c097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d156d0d58625322688c5db23d7abcd6" id="r_a4d156d0d58625322688c5db23d7abcd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d156d0d58625322688c5db23d7abcd6">getChildAt</a> (uint32_t idx) const</td></tr>
<tr class="memdesc:a4d156d0d58625322688c5db23d7abcd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a child at a position in the children vector in the order in which they were added to this node.  <br /></td></tr>
<tr class="separator:a4d156d0d58625322688c5db23d7abcd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63eb06c6b97cc1d58dde858e4d761550" id="r_a63eb06c6b97cc1d58dde858e4d761550"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#af0a2fea735ac7c0116fd470ddb1b7744">ChildrenVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63eb06c6b97cc1d58dde858e4d761550">getChildren</a> () const</td></tr>
<tr class="memdesc:a63eb06c6b97cc1d58dde858e4d761550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a vector of all children of this node in any group in the order in which they were added to this node.  <br /></td></tr>
<tr class="separator:a63eb06c6b97cc1d58dde858e4d761550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d8ac46557b407b8fb15b70a831cce6" id="r_a71d8ac46557b407b8fb15b70a831cce6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71d8ac46557b407b8fb15b70a831cce6">getChildren</a> (std::vector&lt; <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &amp;results, bool ignore_builtin_group=true, bool ignore_anonymous_nodes=true)</td></tr>
<tr class="memdesc:a71d8ac46557b407b8fb15b70a831cce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all children of this node in the order in which they were added to this node.  <br /></td></tr>
<tr class="separator:a71d8ac46557b407b8fb15b70a831cce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea0200191d0c9e5dc04bb558e6fda99" id="r_acea0200191d0c9e5dc04bb558e6fda99"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:acea0200191d0c9e5dc04bb558e6fda99"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acea0200191d0c9e5dc04bb558e6fda99">getChildrenOfType</a> (std::vector&lt; T * &gt; &amp;results) const</td></tr>
<tr class="memdesc:acea0200191d0c9e5dc04bb558e6fda99"><td class="mdescLeft">&#160;</td><td class="mdescRight">return all the children matching a particular type using dynamic cast.  <br /></td></tr>
<tr class="separator:acea0200191d0c9e5dc04bb558e6fda99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71fca4d66ac8dee9f524fd3472c4bf8b" id="r_a71fca4d66ac8dee9f524fd3472c4bf8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71fca4d66ac8dee9f524fd3472c4bf8b">findAncestorByName</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a71fca4d66ac8dee9f524fd3472c4bf8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find ancestor by name.  <br /></td></tr>
<tr class="separator:a71fca4d66ac8dee9f524fd3472c4bf8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70953b54ed0fe69a3f13af671b68e53" id="r_ae70953b54ed0fe69a3f13af671b68e53"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae70953b54ed0fe69a3f13af671b68e53"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae70953b54ed0fe69a3f13af671b68e53">findAncestorByType</a> ()</td></tr>
<tr class="memdesc:ae70953b54ed0fe69a3f13af671b68e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find ancestor by type.  <br /></td></tr>
<tr class="separator:ae70953b54ed0fe69a3f13af671b68e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e8b9f4aa2cc56fcba09b88ddf1f626" id="r_ac4e8b9f4aa2cc56fcba09b88ddf1f626"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4e8b9f4aa2cc56fcba09b88ddf1f626">findAncestorByTag</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:ac4e8b9f4aa2cc56fcba09b88ddf1f626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first ancestor with a particular tag.  <br /></td></tr>
<tr class="separator:ac4e8b9f4aa2cc56fcba09b88ddf1f626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf510819cee4ea78d009b01ea324474" id="r_aedf510819cee4ea78d009b01ea324474"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aedf510819cee4ea78d009b01ea324474"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aedf510819cee4ea78d009b01ea324474">findAncestorResourceByType</a> ()</td></tr>
<tr class="memdesc:aedf510819cee4ea78d009b01ea324474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an ancestor's resource with a certain type.  <br /></td></tr>
<tr class="separator:aedf510819cee4ea78d009b01ea324474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1b9b2ae0628d9339688665fe1c2111" id="r_a8b1b9b2ae0628d9339688665fe1c2111"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a991e1785f763d44925f4a53d89a44675">AliasVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b1b9b2ae0628d9339688665fe1c2111">getAliases</a> () const</td></tr>
<tr class="memdesc:a8b1b9b2ae0628d9339688665fe1c2111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a vector of all aliases of this node.  <br /></td></tr>
<tr class="separator:a8b1b9b2ae0628d9339688665fe1c2111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53352d950db4b085566de453e0d2e00" id="r_ae53352d950db4b085566de453e0d2e00"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae53352d950db4b085566de453e0d2e00">getChildrenIdentifiers</a> (std::vector&lt; std::string &gt; &amp;idents, bool ignore_builtin_group=true) const</td></tr>
<tr class="memdesc:ae53352d950db4b085566de453e0d2e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all child identifiers, aliases, group names, and group-aliases which can be used to refer to a child of this node.  <br /></td></tr>
<tr class="separator:ae53352d950db4b085566de453e0d2e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa799fcb616aca8d0e88e7c509bfbbb77" id="r_aa799fcb616aca8d0e88e7c509bfbbb77"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const std::string * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa799fcb616aca8d0e88e7c509bfbbb77">getIdentifiers</a> () const</td></tr>
<tr class="memdesc:aa799fcb616aca8d0e88e7c509bfbbb77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all the identifiers for this node (excluding groups)  <br /></td></tr>
<tr class="separator:aa799fcb616aca8d0e88e7c509bfbbb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace29f38285cf6318c8c2973e028c1588" id="r_ace29f38285cf6318c8c2973e028c1588"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace29f38285cf6318c8c2973e028c1588">getGroupSize</a> (const std::string &amp;group)</td></tr>
<tr class="memdesc:ace29f38285cf6318c8c2973e028c1588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of nodes in a group.  <br /></td></tr>
<tr class="separator:ace29f38285cf6318c8c2973e028c1588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8509bfb982375b090e6e2d280bc0dd" id="r_a6a8509bfb982375b090e6e2d280bc0dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a7fa01f145455d583b8f16e0f923b7c7c">group_idx_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a8509bfb982375b090e6e2d280bc0dd">getGroupIndexMax</a> (const std::string &amp;group)</td></tr>
<tr class="memdesc:a6a8509bfb982375b090e6e2d280bc0dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the largest index of a node in the given group.  <br /></td></tr>
<tr class="separator:a6a8509bfb982375b090e6e2d280bc0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28436401cbe813f5ea99f4c09615fef4" id="r_a28436401cbe813f5ea99f4c09615fef4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28436401cbe813f5ea99f4c09615fef4">getGroup</a> (const std::string &amp;group, std::vector&lt; <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &amp;results)</td></tr>
<tr class="memdesc:a28436401cbe813f5ea99f4c09615fef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all nodes in a child group.  <br /></td></tr>
<tr class="separator:a28436401cbe813f5ea99f4c09615fef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae707e1cdf8038ea8aeac03ca2620d1e1" id="r_ae707e1cdf8038ea8aeac03ca2620d1e1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae707e1cdf8038ea8aeac03ca2620d1e1">findChildren</a> (const std::string &amp;pattern, std::vector&lt; <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &amp;results, std::vector&lt; std::vector&lt; std::string &gt; &gt; &amp;replacements)</td></tr>
<tr class="memdesc:ae707e1cdf8038ea8aeac03ca2620d1e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all children starting at this node with a given pattern relative to this node by matching names an aliases. Appends each found child to &lt;results&gt;.  <br /></td></tr>
<tr class="separator:ae707e1cdf8038ea8aeac03ca2620d1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e9cb392ac4901bc21ce583b36d0e01" id="r_a34e9cb392ac4901bc21ce583b36d0e01"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34e9cb392ac4901bc21ce583b36d0e01">findChildren</a> (const std::string &amp;pattern, std::vector&lt; <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &amp;results)</td></tr>
<tr class="memdesc:a34e9cb392ac4901bc21ce583b36d0e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of findChildren with no replacements vector.  <br /></td></tr>
<tr class="separator:a34e9cb392ac4901bc21ce583b36d0e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac4c7b95e6ce15d29464218e989ffd5" id="r_a9ac4c7b95e6ce15d29464218e989ffd5"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ac4c7b95e6ce15d29464218e989ffd5">findImmediateChildren_</a> (std::regex &amp;expr, std::vector&lt; <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &amp;found, std::vector&lt; std::vector&lt; std::string &gt; &gt; &amp;replacements, bool allow_private=false)</td></tr>
<tr class="memdesc:a9ac4c7b95e6ce15d29464218e989ffd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds immediate children with some identity (name or alias) matching a regex.  <br /></td></tr>
<tr class="separator:a9ac4c7b95e6ce15d29464218e989ffd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a126851828a964a6c0890a343066a20" id="r_a0a126851828a964a6c0890a343066a20"><td class="memItemLeft" align="right" valign="top"><a id="a0a126851828a964a6c0890a343066a20" name="a0a126851828a964a6c0890a343066a20"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>findImmediateChildren_</b> (std::regex &amp;expr, std::vector&lt; <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &amp;found, bool allow_private=false)</td></tr>
<tr class="memdesc:a0a126851828a964a6c0890a343066a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of findImmediateChildren_ with no replacements vector. <br /></td></tr>
<tr class="separator:a0a126851828a964a6c0890a343066a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244fd94fe20fad6c06500c6474522d1c" id="r_a244fd94fe20fad6c06500c6474522d1c"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a244fd94fe20fad6c06500c6474522d1c">findImmediateChildren_</a> (std::regex &amp;expr, std::vector&lt; const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &amp;found, std::vector&lt; std::vector&lt; std::string &gt; &gt; &amp;replacements, bool allow_private=false) const</td></tr>
<tr class="memdesc:a244fd94fe20fad6c06500c6474522d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const-qualified variant of findImmediateChildren_.  <br /></td></tr>
<tr class="separator:a244fd94fe20fad6c06500c6474522d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6b8ae3870d202776e4e404d674eb82" id="r_aef6b8ae3870d202776e4e404d674eb82"><td class="memItemLeft" align="right" valign="top"><a id="aef6b8ae3870d202776e4e404d674eb82" name="aef6b8ae3870d202776e4e404d674eb82"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>findImmediateChildren_</b> (std::regex &amp;expr, std::vector&lt; const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &amp;found, bool allow_private=false) const</td></tr>
<tr class="memdesc:aef6b8ae3870d202776e4e404d674eb82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of const-qualified findImmediateChildren_ with no replacements vector. <br /></td></tr>
<tr class="separator:aef6b8ae3870d202776e4e404d674eb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61c4f67a5045b80c62fd331519b969d" id="r_af61c4f67a5045b80c62fd331519b969d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af61c4f67a5045b80c62fd331519b969d">locationMatchesPattern</a> (const std::string &amp;pattern, const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *pat_loc) const</td></tr>
<tr class="memdesc:af61c4f67a5045b80c62fd331519b969d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given pattern (which may contain wildcards) can describe this node.  <br /></td></tr>
<tr class="separator:af61c4f67a5045b80c62fd331519b969d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac598185049018290d5ea6cb674d10473" id="r_ac598185049018290d5ea6cb674d10473"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac598185049018290d5ea6cb674d10473">getChild</a> (const std::string &amp;name, bool must_exist=true)</td></tr>
<tr class="memdesc:ac598185049018290d5ea6cb674d10473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a child with this dotted path name.  <br /></td></tr>
<tr class="separator:ac598185049018290d5ea6cb674d10473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0acc7bdbe1cde5dd450e2a5677316f" id="r_a6e0acc7bdbe1cde5dd450e2a5677316f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e0acc7bdbe1cde5dd450e2a5677316f">getChild</a> (const std::string &amp;name, bool must_exist=true) const</td></tr>
<tr class="memdesc:a6e0acc7bdbe1cde5dd450e2a5677316f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded const-qualified.  <br /></td></tr>
<tr class="separator:a6e0acc7bdbe1cde5dd450e2a5677316f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0703ca8742ef2de67a0d876ccb0c6e" id="r_a8e0703ca8742ef2de67a0d876ccb0c6e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e0703ca8742ef2de67a0d876ccb0c6e">getDeepestMatchingPath</a> (const std::string &amp;path) const</td></tr>
<tr class="memdesc:a8e0703ca8742ef2de67a0d876ccb0c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the deepest whole node location starting from <em>this</em> node that matches some part of <em>path</em> starting at its beginning.  <br /></td></tr>
<tr class="separator:a8e0703ca8742ef2de67a0d876ccb0c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdb43d52e9eb2d550b2ab40c4b2722c" id="r_affdb43d52e9eb2d550b2ab40c4b2722c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affdb43d52e9eb2d550b2ab40c4b2722c">hasChild</a> (const std::string &amp;name) const noexcept</td></tr>
<tr class="memdesc:affdb43d52e9eb2d550b2ab40c4b2722c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a child can be found with the given dotted path.  <br /></td></tr>
<tr class="separator:affdb43d52e9eb2d550b2ab40c4b2722c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8132a8fd4d313c333a49979726a9b0b" id="r_ad8132a8fd4d313c333a49979726a9b0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8132a8fd4d313c333a49979726a9b0b">hasImmediateChild</a> (const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *n) const noexcept</td></tr>
<tr class="memdesc:ad8132a8fd4d313c333a49979726a9b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the node <em>n</em> is an immediate child of this node.  <br /></td></tr>
<tr class="separator:ad8132a8fd4d313c333a49979726a9b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18a936bf3a826ff18bd374d2a6b531d" id="r_ab18a936bf3a826ff18bd374d2a6b531d"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value&gt;::type, class ConstT  = typename ptr_to_const_obj_ptr&lt;T&gt;::type&gt; </td></tr>
<tr class="memitem:ab18a936bf3a826ff18bd374d2a6b531d"><td class="memTemplItemLeft" align="right" valign="top">const ConstT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab18a936bf3a826ff18bd374d2a6b531d">getChildAs</a> (const std::string &amp;name, bool must_exist=true) const</td></tr>
<tr class="memdesc:ab18a936bf3a826ff18bd374d2a6b531d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a child that is castable to T with the given dotted path.  <br /></td></tr>
<tr class="separator:ab18a936bf3a826ff18bd374d2a6b531d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b665db735ea8bea394d85afd203fc0" id="r_a95b665db735ea8bea394d85afd203fc0"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;!std::is_pointer&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a95b665db735ea8bea394d85afd203fc0"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a95b665db735ea8bea394d85afd203fc0">getChildAs</a> (const std::string &amp;name, bool must_exist=true) const</td></tr>
<tr class="separator:a95b665db735ea8bea394d85afd203fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f94b930f3b83dc49d0a114b79f725bf" id="r_a0f94b930f3b83dc49d0a114b79f725bf"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a0f94b930f3b83dc49d0a114b79f725bf"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0f94b930f3b83dc49d0a114b79f725bf">getChildAs</a> (const std::string &amp;name, bool must_exist=true)</td></tr>
<tr class="separator:a0f94b930f3b83dc49d0a114b79f725bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51613b9aa45cc84a764c07ec34fb0043" id="r_a51613b9aa45cc84a764c07ec34fb0043"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;!std::is_pointer&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a51613b9aa45cc84a764c07ec34fb0043"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a51613b9aa45cc84a764c07ec34fb0043">getChildAs</a> (const std::string &amp;name, bool must_exist=true)</td></tr>
<tr class="separator:a51613b9aa45cc84a764c07ec34fb0043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164eb7014e7e50a5b4921c139f712056" id="r_a164eb7014e7e50a5b4921c139f712056"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value&gt;::type, class ConstT  = typename ptr_to_const_obj_ptr&lt;T&gt;::type&gt; </td></tr>
<tr class="memitem:a164eb7014e7e50a5b4921c139f712056"><td class="memTemplItemLeft" align="right" valign="top">ConstT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a164eb7014e7e50a5b4921c139f712056">getAs</a> () const</td></tr>
<tr class="memdesc:a164eb7014e7e50a5b4921c139f712056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves this node after casting to type T.  <br /></td></tr>
<tr class="separator:a164eb7014e7e50a5b4921c139f712056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8976dc0bb4634cc07e51f7f66d64a17" id="r_ab8976dc0bb4634cc07e51f7f66d64a17"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;!std::is_pointer&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ab8976dc0bb4634cc07e51f7f66d64a17"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab8976dc0bb4634cc07e51f7f66d64a17">getAs</a> () const</td></tr>
<tr class="memdesc:ab8976dc0bb4634cc07e51f7f66d64a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves this node after casting to type const T.  <br /></td></tr>
<tr class="separator:ab8976dc0bb4634cc07e51f7f66d64a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a5d5c788727dfd1d382872e2711c0e" id="r_ad4a5d5c788727dfd1d382872e2711c0e"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ad4a5d5c788727dfd1d382872e2711c0e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad4a5d5c788727dfd1d382872e2711c0e">getAs</a> ()</td></tr>
<tr class="memdesc:ad4a5d5c788727dfd1d382872e2711c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves this node after casting to type const T.  <br /></td></tr>
<tr class="separator:ad4a5d5c788727dfd1d382872e2711c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea061c7abb323917f0046feaca92545c" id="r_aea061c7abb323917f0046feaca92545c"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;!std::is_pointer&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aea061c7abb323917f0046feaca92545c"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aea061c7abb323917f0046feaca92545c">getAs</a> ()</td></tr>
<tr class="memdesc:aea061c7abb323917f0046feaca92545c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves this node after casting to type const T.  <br /></td></tr>
<tr class="separator:aea061c7abb323917f0046feaca92545c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454fb71960c232bad1413c749c407a3b" id="r_a454fb71960c232bad1413c749c407a3b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a454fb71960c232bad1413c749c407a3b">findChildrenByTag</a> (const std::string &amp;tag, std::vector&lt; <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &amp;results, int32_t max_depth=-1)</td></tr>
<tr class="memdesc:a454fb71960c232bad1413c749c407a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a set of all children having the selected tag which this node or descendants of this node within a distance of the given max_depth.  <br /></td></tr>
<tr class="separator:a454fb71960c232bad1413c749c407a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cff588af283f20b1c3dc6f3b52053f" id="r_aa8cff588af283f20b1c3dc6f3b52053f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8cff588af283f20b1c3dc6f3b52053f">isDescendantOf</a> (const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *ancestor, int32_t max_depth=-1) const</td></tr>
<tr class="memdesc:aa8cff588af283f20b1c3dc6f3b52053f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this node is a descendant of the specified ancestor node within some number of generations (depth).  <br /></td></tr>
<tr class="separator:aa8cff588af283f20b1c3dc6f3b52053f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6d4aac10bfa5345b587d84170441de" id="r_a1a6d4aac10bfa5345b587d84170441de"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a6d4aac10bfa5345b587d84170441de">getLocation</a> () const override final</td></tr>
<tr class="separator:a1a6d4aac10bfa5345b587d84170441de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3290748a9c922f7c9c9dc1f919e0418" id="r_aa3290748a9c922f7c9c9dc1f919e0418"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3290748a9c922f7c9c9dc1f919e0418">getDisplayLocation</a> () const</td></tr>
<tr class="memdesc:aa3290748a9c922f7c9c9dc1f919e0418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the location of this node in the device tree which <em>might</em> not be usable for navigating the device tree (it cannot be used as an argument for getChild/findChildren).  <br /></td></tr>
<tr class="separator:aa3290748a9c922f7c9c9dc1f919e0418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad379d898cbd9b2b182b6c349650c8b6e" id="r_ad379d898cbd9b2b182b6c349650c8b6e"><td class="memItemLeft" align="right" valign="top"><a id="ad379d898cbd9b2b182b6c349650c8b6e" name="ad379d898cbd9b2b182b6c349650c8b6e"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getExpectedLocation</b> () const</td></tr>
<tr class="memdesc:ad379d898cbd9b2b182b6c349650c8b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">build-time equivalent to getLocation before an object is actually attached to a tree. This is a mainly a framework and debugging tool for determining what the location of a node currently being constructed will be when complete. <br /></td></tr>
<tr class="separator:ad379d898cbd9b2b182b6c349650c8b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664c9d3ec69cbbfa5993e9b698e65518" id="r_a664c9d3ec69cbbfa5993e9b698e65518"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a664c9d3ec69cbbfa5993e9b698e65518">renderSubtree</a> (int32_t max_depth=-1, bool show_builtins=false, bool names_only=false, bool hide_hidden=false, bool(*leaf_filt_fxn)(const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *)=nullptr) const</td></tr>
<tr class="memdesc:a664c9d3ec69cbbfa5993e9b698e65518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders the subtree starting at this node as a string containing an indentation-based depth-first representation.  <br /></td></tr>
<tr class="separator:a664c9d3ec69cbbfa5993e9b698e65518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7081d66107154ff903323fd174795340" id="r_a7081d66107154ff903323fd174795340"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7081d66107154ff903323fd174795340">getLevel</a> () const</td></tr>
<tr class="memdesc:a7081d66107154ff903323fd174795340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the level of this node. 0 is root.  <br /></td></tr>
<tr class="separator:a7081d66107154ff903323fd174795340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab113915ff2dc4b8ebfee5380eb912994" id="r_ab113915ff2dc4b8ebfee5380eb912994"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab113915ff2dc4b8ebfee5380eb912994"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab113915ff2dc4b8ebfee5380eb912994">getRecursiveNodeCount</a> () const</td></tr>
<tr class="memdesc:ab113915ff2dc4b8ebfee5380eb912994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively gets the count of a nodes that are a subclass of a particular type (determined by dynamic_cast). Includes all descendants of this node in the tree, but excludes this node.  <br /></td></tr>
<tr class="separator:ab113915ff2dc4b8ebfee5380eb912994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9faa603b824c850070637195f6d4e2a9" id="r_a9faa603b824c850070637195f6d4e2a9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9faa603b824c850070637195f6d4e2a9">getVirtualGlobalNode</a> ()</td></tr>
<tr class="memdesc:a9faa603b824c850070637195f6d4e2a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the virtual global node singleton. This node can have no parent and no children. It receives notifications from all nodes in the simulator as if it were the parent of every node in the simulation that has no parent.  <br /></td></tr>
<tr class="separator:a9faa603b824c850070637195f6d4e2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Notification System</h2></td></tr>
<tr class="memitem:af31ac794edcf81e88d28157056e91292" id="r_af31ac794edcf81e88d28157056e91292"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af31ac794edcf81e88d28157056e91292">getPossibleNotifications</a> (std::vector&lt; <a class="el" href="structsparta_1_1TreeNode_1_1NotificationInfo.html">NotificationInfo</a> &gt; &amp;infos) const</td></tr>
<tr class="memdesc:af31ac794edcf81e88d28157056e91292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets information on the possible notifications generated by this node (excludes children).  <br /></td></tr>
<tr class="separator:af31ac794edcf81e88d28157056e91292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae14d74895ad69d6e8ce3f767342800" id="r_a2ae14d74895ad69d6e8ce3f767342800"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ae14d74895ad69d6e8ce3f767342800">dumpPossibleNotifications</a> (std::ostream &amp;o) const noexcept</td></tr>
<tr class="memdesc:a2ae14d74895ad69d6e8ce3f767342800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps a listing of the notifications which this node can generate to the ostream o.  <br /></td></tr>
<tr class="separator:a2ae14d74895ad69d6e8ce3f767342800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ccf18c0631ba2d1a665567db7618a6" id="r_aa6ccf18c0631ba2d1a665567db7618a6"><td class="memTemplParams" colspan="2">template&lt;typename DataT  = ANY_TYPE&gt; </td></tr>
<tr class="memitem:aa6ccf18c0631ba2d1a665567db7618a6"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa6ccf18c0631ba2d1a665567db7618a6">locateNotificationSources</a> (std::vector&lt; <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &amp;nodes, const std::string &amp;name=&quot;&quot;)</td></tr>
<tr class="memdesc:aa6ccf18c0631ba2d1a665567db7618a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all possible notification info from NotificationSources within this node's subtree.  <br /></td></tr>
<tr class="separator:aa6ccf18c0631ba2d1a665567db7618a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9dfcfbc1e6b004ff0d80ec3d38cbbd2" id="r_af9dfcfbc1e6b004ff0d80ec3d38cbbd2"><td class="memTemplParams" colspan="2">template&lt;typename DataT  = ANY_TYPE&gt; </td></tr>
<tr class="memitem:af9dfcfbc1e6b004ff0d80ec3d38cbbd2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af9dfcfbc1e6b004ff0d80ec3d38cbbd2">dumpLocatedNotificationSources</a> (std::ostream &amp;o, const std::string &amp;name=&quot;&quot;)</td></tr>
<tr class="memdesc:af9dfcfbc1e6b004ff0d80ec3d38cbbd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the relevant NotificationSources from locateNotificationSources and prints them to the output <em>o</em>.  <br /></td></tr>
<tr class="separator:af9dfcfbc1e6b004ff0d80ec3d38cbbd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f97e7a78ab1d0874515d2752381561" id="r_a53f97e7a78ab1d0874515d2752381561"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53f97e7a78ab1d0874515d2752381561">getPossibleSubtreeNotifications</a> (std::vector&lt; <a class="el" href="structsparta_1_1TreeNode_1_1NotificationInfo.html">NotificationInfo</a> &gt; &amp;infos) const noexcept</td></tr>
<tr class="memdesc:a53f97e7a78ab1d0874515d2752381561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets information on the possible notifications generated by this node and all its descendants.  <br /></td></tr>
<tr class="separator:a53f97e7a78ab1d0874515d2752381561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c94c97462083a4d9f1892c72cc14c40" id="r_a3c94c97462083a4d9f1892c72cc14c40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c94c97462083a4d9f1892c72cc14c40">dumpPossibleSubtreeNotifications</a> (std::ostream &amp;o) const noexcept</td></tr>
<tr class="memdesc:a3c94c97462083a4d9f1892c72cc14c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps a listing of the notifications which this node and its descendants can generate to the ostream o.  <br /></td></tr>
<tr class="separator:a3c94c97462083a4d9f1892c72cc14c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91bb3b5d18785bd49e3933847eab1011" id="r_a91bb3b5d18785bd49e3933847eab1011"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91bb3b5d18785bd49e3933847eab1011">canGenerateNotification</a> (const std::type_info &amp;tinfo, const std::string *name) const</td></tr>
<tr class="memdesc:a91bb3b5d18785bd49e3933847eab1011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> generate a notification of the given type having the given name or pattern.  <br /></td></tr>
<tr class="separator:a91bb3b5d18785bd49e3933847eab1011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1acb8b497a9e8d9f3fc5ecae88cf1700" id="r_a1acb8b497a9e8d9f3fc5ecae88cf1700"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1acb8b497a9e8d9f3fc5ecae88cf1700">canGenerateNotification</a> (const std::type_info &amp;tinfo, const std::string &amp;name) const</td></tr>
<tr class="memdesc:a1acb8b497a9e8d9f3fc5ecae88cf1700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> generate a notification of the given type having the given name (does not require interned string - will intern automatically with <a class="el" href="classsparta_1_1StringManager.html" title="Manages string internment for SPARTA. This allows strings to be compared by pointer once interned.">StringManager</a>).  <br /></td></tr>
<tr class="separator:a1acb8b497a9e8d9f3fc5ecae88cf1700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace577b7bae0092cb2dc2f54b37b24273" id="r_ace577b7bae0092cb2dc2f54b37b24273"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace577b7bae0092cb2dc2f54b37b24273">canGenerateNotification</a> (const <a class="el" href="structsparta_1_1TreeNode_1_1NotificationInfo.html">NotificationInfo</a> &amp;info) const</td></tr>
<tr class="memdesc:ace577b7bae0092cb2dc2f54b37b24273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> generate a notification of the given <a class="el" href="structsparta_1_1TreeNode_1_1NotificationInfo.html" title="Notification type/name information.">NotificationInfo</a>.  <br /></td></tr>
<tr class="separator:ace577b7bae0092cb2dc2f54b37b24273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae324a0d15005548d4c2ed44147d100e3" id="r_ae324a0d15005548d4c2ed44147d100e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae324a0d15005548d4c2ed44147d100e3">canSubtreeGenerateNotification</a> (const std::type_info &amp;tinfo, const std::string *name) const</td></tr>
<tr class="memdesc:ae324a0d15005548d4c2ed44147d100e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> or its descendants (of any distance) generate a notification of the given type having the given name.  <br /></td></tr>
<tr class="separator:ae324a0d15005548d4c2ed44147d100e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed2ede13a267a23e4794c085be6621d" id="r_a5ed2ede13a267a23e4794c085be6621d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ed2ede13a267a23e4794c085be6621d">canSubtreeGenerateNotification</a> (const std::type_info &amp;tinfo, const std::string &amp;name) const</td></tr>
<tr class="memdesc:a5ed2ede13a267a23e4794c085be6621d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> or its descendants (of any distance) generate a notification of the given type having the given name (does not require interned string)  <br /></td></tr>
<tr class="separator:a5ed2ede13a267a23e4794c085be6621d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42372c597a4836b2505a1200c5aaf08f" id="r_a42372c597a4836b2505a1200c5aaf08f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42372c597a4836b2505a1200c5aaf08f">canSubtreeGenerateNotifications</a> (const std::type_info &amp;tinfo, const std::vector&lt; const std::string * &gt; &amp;names) const</td></tr>
<tr class="memdesc:a42372c597a4836b2505a1200c5aaf08f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if any a subtree can generate any of several notification names which may be patterns.  <br /></td></tr>
<tr class="separator:a42372c597a4836b2505a1200c5aaf08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6260f885d559f61593a2158545d275fb" id="r_a6260f885d559f61593a2158545d275fb"><td class="memTemplParams" colspan="2">template&lt;typename DataT , typename T , void(T::*)(const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &amp;, const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &amp;, const DataT &amp;) TMethod&gt; </td></tr>
<tr class="memitem:a6260f885d559f61593a2158545d275fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6260f885d559f61593a2158545d275fb">registerForNotification</a> (T *obj, const std::string &amp;name, bool ensure_possible=true)</td></tr>
<tr class="memdesc:a6260f885d559f61593a2158545d275fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a callback method to listen for all notifications having the specified data type DataT and name (or any name if name is "") occuring on this node or any descendant (subtree).  <br /></td></tr>
<tr class="separator:a6260f885d559f61593a2158545d275fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6260f885d559f61593a2158545d275fb" id="r_a6260f885d559f61593a2158545d275fb"><td class="memTemplParams" colspan="2">template&lt;typename DataT , typename T , void(T::*)(const DataT &amp;) TMethod&gt; </td></tr>
<tr class="memitem:a6260f885d559f61593a2158545d275fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6260f885d559f61593a2158545d275fb">registerForNotification</a> (T *obj, const std::string &amp;name, bool ensure_possible=true)</td></tr>
<tr class="separator:a6260f885d559f61593a2158545d275fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4da13fd6f93c76c3df9ded6a20b6b2" id="r_a8f4da13fd6f93c76c3df9ded6a20b6b2"><td class="memTemplParams" colspan="2">template&lt;typename DataT , typename T , void(T::*)(const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &amp;, const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &amp;, const DataT &amp;) TMethod&gt; </td></tr>
<tr class="memitem:a8f4da13fd6f93c76c3df9ded6a20b6b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8f4da13fd6f93c76c3df9ded6a20b6b2">deregisterForNotification</a> (T *obj, const std::string &amp;name)</td></tr>
<tr class="memdesc:a8f4da13fd6f93c76c3df9ded6a20b6b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes at most one registration made with registerForNotification.  <br /></td></tr>
<tr class="separator:a8f4da13fd6f93c76c3df9ded6a20b6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4da13fd6f93c76c3df9ded6a20b6b2" id="r_a8f4da13fd6f93c76c3df9ded6a20b6b2"><td class="memTemplParams" colspan="2">template&lt;typename DataT , typename T , void(T::*)(const DataT &amp;) TMethod&gt; </td></tr>
<tr class="memitem:a8f4da13fd6f93c76c3df9ded6a20b6b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8f4da13fd6f93c76c3df9ded6a20b6b2">deregisterForNotification</a> (T *obj, const std::string &amp;name)</td></tr>
<tr class="separator:a8f4da13fd6f93c76c3df9ded6a20b6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7b4d01402471a3021541fb7b6794c1" id="r_a0e7b4d01402471a3021541fb7b6794c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e7b4d01402471a3021541fb7b6794c1">hasObserversRegisteredForNotification</a> (const std::type_info &amp;tinfo, const std::string *name) const noexcept</td></tr>
<tr class="memdesc:a0e7b4d01402471a3021541fb7b6794c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> (not descendants) has any observers for this type of event and name.  <br /></td></tr>
<tr class="separator:a0e7b4d01402471a3021541fb7b6794c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7191a8362fd6e301d2e6f8c37922a87" id="r_aa7191a8362fd6e301d2e6f8c37922a87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7191a8362fd6e301d2e6f8c37922a87">getDelegatesRegisteredForNotification</a> (const std::type_info &amp;tinfo, const std::string *name, std::vector&lt; <a class="el" href="classsparta_1_1TreeNode_1_1delegate.html">delegate</a> &gt; &amp;dels) noexcept</td></tr>
<tr class="memdesc:aa7191a8362fd6e301d2e6f8c37922a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the vector of delegates registered for a notification on this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>.  <br /></td></tr>
<tr class="separator:aa7191a8362fd6e301d2e6f8c37922a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2e0aceb5596a4f21fc5e1ad34c2ac7" id="r_a4c2e0aceb5596a4f21fc5e1ad34c2ac7"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; const std::string * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c2e0aceb5596a4f21fc5e1ad34c2ac7">parseNotificationNameString</a> (const std::string &amp;csl)</td></tr>
<tr class="memdesc:a4c2e0aceb5596a4f21fc5e1ad34c2ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a comma-separated list of notification names (or patterns) separated by commas and ignoring whitespace around commas.  <br /></td></tr>
<tr class="separator:a4c2e0aceb5596a4f21fc5e1ad34c2ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba01f766f0b8212967d2a25ceae475a" id="r_a3ba01f766f0b8212967d2a25ceae475a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ba01f766f0b8212967d2a25ceae475a">notificationCategoryMatch</a> (const std::string *query_id, const std::string *node_id)</td></tr>
<tr class="memdesc:a3ba01f766f0b8212967d2a25ceae475a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two notification categories match where one is an actual category.  <br /></td></tr>
<tr class="separator:a3ba01f766f0b8212967d2a25ceae475a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Node in a composite tree representing a sparta Tree item. </p>
<dl class="section warning"><dt>Warning</dt><dd><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> construction is NOT thread-safe </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Children cannot be removed from their parents once attached </dd>
<dd>
Not all TreeNodes in existance are required to be part of the same tree. </dd>
<dd>
TreeNodes expect to be attached to a root node. See <a class="el" href="classsparta_1_1RootTreeNode.html" title="TreeNode which represents the root (&quot;top&quot;) of a device tree.">sparta::RootTreeNode</a> for details. This root is required to act on the tree and hold some tree-wide properties. Multiple RootTreeNodes are expected to exist.</dd></dl>
<p>Because this class expects to be used with a composite pattern, several refinements exist elsewhere in sparta.</p>
<h4>Important</h4>
<p>Searching and getting child nodes is done by getChild, findChildren, and getChildAt only.</p>
<h4>Teardown</h4>
<p>TreeNodes cannot be removed from the tree once added until the Tree enters the TREE_TEARDOWN phase (see isTearingDown). Place the Tree's <a class="el" href="classsparta_1_1RootTreeNode.html" title="TreeNode which represents the root (&quot;top&quot;) of a device tree.">RootTreeNode</a> into the teardown phase using <a class="el" href="classsparta_1_1RootTreeNode.html#a692d0cc37d2d242afa2a250dc2287642" title="Places this tree into TREE_TEARDOWN phase so that nodes may be deleted without errors.">sparta::RootTreeNode::enterTeardown</a>. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00203">203</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a991e1785f763d44925f4a53d89a44675" name="a991e1785f763d44925f4a53d89a44675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991e1785f763d44925f4a53d89a44675">&#9670;&#160;</a></span>AliasVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; <a class="el" href="#a991e1785f763d44925f4a53d89a44675">sparta::TreeNode::AliasVector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector of aliases (other names for this node) </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00247">247</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a8fa15383cc601098b76d0ef08eff4200" name="a8fa15383cc601098b76d0ef08eff4200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa15383cc601098b76d0ef08eff4200">&#9670;&#160;</a></span>ChildNameMapping</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::multimap&lt;std::string, <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a>*&gt; <a class="el" href="#a8fa15383cc601098b76d0ef08eff4200">sparta::TreeNode::ChildNameMapping</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mapping of names, aliases, and groups to individual child nodes within one node. This must be in a deterministic order, so an ordered container (e.g. std::map) is required. A sorted contained is probably desirable, but not required. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00255">255</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="af0a2fea735ac7c0116fd470ddb1b7744" name="af0a2fea735ac7c0116fd470ddb1b7744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0a2fea735ac7c0116fd470ddb1b7744">&#9670;&#160;</a></span>ChildrenVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a>*&gt; <a class="el" href="#af0a2fea735ac7c0116fd470ddb1b7744">sparta::TreeNode::ChildrenVector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector of <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> children. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00242">242</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="afa43836f90c9203c7b2c09647a0707d3" name="afa43836f90c9203c7b2c09647a0707d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa43836f90c9203c7b2c09647a0707d3">&#9670;&#160;</a></span>ConstWeakPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::weak_ptr&lt;const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a>&gt; <a class="el" href="#afa43836f90c9203c7b2c09647a0707d3">sparta::TreeNode::ConstWeakPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weak pointer to a const <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>. Acquire with getWeakPtr. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00270">270</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="ab92c3c0688d1c33036a224f4ce57b715" name="ab92c3c0688d1c33036a224f4ce57b715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92c3c0688d1c33036a224f4ce57b715">&#9670;&#160;</a></span>DelegateVector</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classsparta_1_1TreeNode_1_1delegate.html">delegate</a>&gt; <a class="el" href="#ab92c3c0688d1c33036a224f4ce57b715">sparta::TreeNode::DelegateVector</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector of delegates representing a list of observers to notify. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l03280">3280</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="abb004c7a919bb15eb9113b7ac6dae777" name="abb004c7a919bb15eb9113b7ac6dae777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb004c7a919bb15eb9113b7ac6dae777">&#9670;&#160;</a></span>ExtensionsBase</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using sparta::TreeNode::ExtensionsBase = detail::ExtensionsBase</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l01882">1882</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a7fa01f145455d583b8f16e0f923b7c7c" name="a7fa01f145455d583b8f16e0f923b7c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa01f145455d583b8f16e0f923b7c7c">&#9670;&#160;</a></span>group_idx_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="#a7fa01f145455d583b8f16e0f923b7c7c">sparta::TreeNode::group_idx_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index within a group. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00260">260</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="af5075c9b90f28041b6a7f3f80132c1b3" name="af5075c9b90f28041b6a7f3f80132c1b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5075c9b90f28041b6a7f3f80132c1b3">&#9670;&#160;</a></span>node_uid_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="#af5075c9b90f28041b6a7f3f80132c1b3">sparta::TreeNode::node_uid_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of unique-identifier assigned to every node. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00237">237</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="abdceb31f74d5a8e554defe592af90f54" name="abdceb31f74d5a8e554defe592af90f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdceb31f74d5a8e554defe592af90f54">&#9670;&#160;</a></span>NotificationObserverMap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="classsparta_1_1TreeNode_1_1type__info__container.html">type_info_container</a>, <a class="el" href="#ab92c3c0688d1c33036a224f4ce57b715">DelegateVector</a>&gt; <a class="el" href="#abdceb31f74d5a8e554defe592af90f54">sparta::TreeNode::NotificationObserverMap</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map of delegate vectors containing all observers. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l03285">3285</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a5429faab680829656533d4cd5ff0bc0d" name="a5429faab680829656533d4cd5ff0bc0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5429faab680829656533d4cd5ff0bc0d">&#9670;&#160;</a></span>SharedPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a>&gt; <a class="el" href="#a5429faab680829656533d4cd5ff0bc0d">sparta::TreeNode::SharedPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared pointer to <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>. Acquire with WeakPtr::lock(). </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00275">275</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="abda7e1fd5fa85a6b9b9e0cc413dae2a5" name="abda7e1fd5fa85a6b9b9e0cc413dae2a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda7e1fd5fa85a6b9b9e0cc413dae2a5">&#9670;&#160;</a></span>TagsMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;const std::string*, std::vector&lt;<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a>*&gt; &gt; <a class="el" href="#abda7e1fd5fa85a6b9b9e0cc413dae2a5">sparta::TreeNode::TagsMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map of strings (interned in <a class="el" href="classsparta_1_1StringManager.html" title="Manages string internment for SPARTA. This allows strings to be compared by pointer once interned.">StringManager</a>) tags to TreeNodes. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00280">280</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a91f21b18f9f50f70111730361eff6ddb" name="a91f21b18f9f50f70111730361eff6ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f21b18f9f50f70111730361eff6ddb">&#9670;&#160;</a></span>WeakPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::weak_ptr&lt;<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a>&gt; <a class="el" href="#a91f21b18f9f50f70111730361eff6ddb">sparta::TreeNode::WeakPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weak pointer to a <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>. Acquire with getWeakPtr. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00265">265</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6fdce693f0f3255e5fdb45ac6615cbe6" name="a6fdce693f0f3255e5fdb45ac6615cbe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fdce693f0f3255e5fdb45ac6615cbe6">&#9670;&#160;</a></span>TreeNode() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sparta::TreeNode::TreeNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="section pre"><dt>Precondition</dt><dd>rhp must not be fully finalized </dd>
<dd>
rhp must not have any observers registered directly on it </dd>
<dd>
Avoid move-constructing from TreeNodes with children as the children may fail to be re-added to this new <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> if they attempt to dynamic_cast this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>'s pointer to a subclass of <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>. </dd></dl>

</div>
</div>
<a id="a3026dd9b5648f0614dcc27b97b4b61c7" name="a3026dd9b5648f0614dcc27b97b4b61c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3026dd9b5648f0614dcc27b97b4b61c7">&#9670;&#160;</a></span>TreeNode() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sparta::TreeNode::TreeNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a7fa01f145455d583b8f16e0f923b7c7c">group_idx_type</a></td>          <td class="paramname"><span class="paramname"><em>group_idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>desc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_indexable</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> full constructor. Initializes node and adds it as a child of an existing tree node (if parent is not null). </p>
<dl class="section warning"><dt>Warning</dt><dd>Subclasses should generally not use this constructor (or should pass a null parent instead) because this constructor can invoke addChild, which notifies observers that a child or parent is being added. Observers of these notifications tend to require fully constructed clases because they dynamically cast the <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> pointer to the intended tree type to find out its actual type. Then, it may examine the fields of the <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> subclass which may not yet be fully populated.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> to which this will be added as a child. If this constructor is being invoked by a subclass, parent must be nullptr (or use a constructor with no parent argument). Subclass constructor is then responsible for adding the node. </td></tr>
    <tr><td class="paramname">name</td><td>Name of this node. Name must satisfy validateName. May be NODE_NAME_NONE to indicate anonymous node. A group and group index is required for anonymous nodes. name must not be the same as any alias or name of another child of <em>parent</em>. It is HIGHLY recommended that name end in a number if there are multiple instances of similar objects at the same level in the tree (e.g. core0, core1). Even if only one such object exists at some level in the tree, having a numeric suffix now will ensure it is easy to adapt Python scripts to handle muliple instanecs later. </td></tr>
    <tr><td class="paramname">group</td><td>Group name of this node. Must satisfy validateGroup. May be GROUP_NAME_NONE if a valid node name is given and group_idx == GROUP_IDX_NONE. </td></tr>
    <tr><td class="paramname">group_idx</td><td>Group index within <em>group</em>. Must satisfy validateGroup. Must be GROUP_IDX_NONE unless group != GROUP_NAME_NONE. </td></tr>
    <tr><td class="paramname">desc</td><td>Description of this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>. Must satisfy validateDesc </td></tr>
    <tr><td class="paramname">is_indexable</td><td>Is this node indexable by its parent such that it can be accessed by group and index. Set this to false if children will have colliding group numbers and indexes (e.g. a banked register set). In almost all cases, this should be true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> construction is NOT thread safe</dd></dl>
<h4>Example 1: Using groups to identify a sequence of related elements</h4>
<pre class="fragment">* // given TreeNode* parent with name "parent"
* TreeNode foo2(&amp;parent, "foo2", "foo", 2, "This is a Foo...")
* TreeNode foo3(&amp;parent, "foo3", "foo", 3, "This is a Foo...")
* </pre><p> In a Python shell atop sparta, <em>might</em> allow the following means of accessing foo: </p><pre class="fragment">* &gt;&gt;&gt; parent.foo
* &lt;Group of 2 Nodes&gt;
* &gt;&gt;&gt; parent.foo2 # Node name
* &lt;foo2 node&gt;
* &gt;&gt;&gt; parent.foo3
* &lt;foo3 node&gt;
* &gt;&gt;&gt; parent.foo[2] # Node group[index]
* &lt;foo2 node&gt;
* &gt;&gt;&gt; parent.foo[3]
* &lt;foo3 node&gt;
* &gt;&gt;&gt; for n in parent.foo: print n # Iterate Node group
* &lt;foo2 node&gt;
* &lt;foo3 node&gt;
* \endvarbatim
*
* &lt;h4&gt;Example 2: Using groups for Nodes which have no siblings&lt;/h4&gt;
* Even if you will only have one node having a certain name prefix at
* some point in the sparta tree (e.g. "soc"), it may make sense to make
* it indexable. One day, a multi-soc/board simulation may need to be
* created.
* \verbatim
* // given TreeNode* parent with name "parent"
* TreeNode foo(&amp;parent, "foo", "foo", 0, "This is a Foo...")
* </pre><p> In a Python shell atop sparta, <em>might</em> allow the following means of accessing foo: </p><pre class="fragment">* &gt;&gt;&gt; parent.foo # Name
* &lt;foo node&gt;
* &gt;&gt;&gt; parent.foo[0] # Group
* &lt;foo node&gt;
* &gt;&gt;&gt; for f in parent.foo: print f
* &lt;foo node&gt;
* </pre> 
</div>
</div>
<a id="a80c65ab7c0b7170ef60b279f05fc0cab" name="a80c65ab7c0b7170ef60b279f05fc0cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c65ab7c0b7170ef60b279f05fc0cab">&#9670;&#160;</a></span>TreeNode() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sparta::TreeNode::TreeNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a7fa01f145455d583b8f16e0f923b7c7c">group_idx_type</a></td>          <td class="paramname"><span class="paramname"><em>group_idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>desc</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> constructor with no is_indexable parameter [defaults to true]. </p>
<dl class="section see"><dt>See also</dt><dd>other <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">sparta::TreeNode</a> constructors </dd></dl>

</div>
</div>
<a id="a9eea7ebab08a4ed9aa079ece5b759211" name="a9eea7ebab08a4ed9aa079ece5b759211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eea7ebab08a4ed9aa079ece5b759211">&#9670;&#160;</a></span>TreeNode() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sparta::TreeNode::TreeNode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a7fa01f145455d583b8f16e0f923b7c7c">group_idx_type</a></td>          <td class="paramname"><span class="paramname"><em>group_idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>desc</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> constructor with no parent Node. </p>
<dl class="section see"><dt>See also</dt><dd>other <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">sparta::TreeNode</a> constructors </dd></dl>

</div>
</div>
<a id="a34262fa0ae9db707bda24e1c5728482e" name="a34262fa0ae9db707bda24e1c5728482e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34262fa0ae9db707bda24e1c5728482e">&#9670;&#160;</a></span>TreeNode() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sparta::TreeNode::TreeNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>desc</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> constructor with no group information. </p>
<dl class="section see"><dt>See also</dt><dd>other <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">sparta::TreeNode</a> constructors </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Subclasses should generally not use this constructor (or should pass a null parent instead) because this constructor can invoke addChild, which requires a <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> subclass (at this) to be fully constructed</dd></dl>
<p>group defaults to GROUP_NAME_NONE. group_idx defaults to GROUP_IDX_NONE. </p>

</div>
</div>
<a id="a98d7ec9960d8d6196c39e4d8e3721bd3" name="a98d7ec9960d8d6196c39e4d8e3721bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d7ec9960d8d6196c39e4d8e3721bd3">&#9670;&#160;</a></span>TreeNode() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sparta::TreeNode::TreeNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a7fa01f145455d583b8f16e0f923b7c7c">group_idx_type</a></td>          <td class="paramname"><span class="paramname"><em>group_idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>desc</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> constructor for anonymous node with group information. </p>
<dl class="section see"><dt>See also</dt><dd>other <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">sparta::TreeNode</a> constructors </dd></dl>
<dl class="section note"><dt>Note</dt><dd>group and group_idx must be valid </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Subclasses should generally not use this constructor (or should pass a null parent instead) because this constructor can invoke addChild, which requires a <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> subclass (at this) to be fully constructed</dd></dl>
<p>Name defaults to NODE_NAME_NONE. group and group_idx should be meaningful </p>

</div>
</div>
<a id="ae136cf4e22a254e02ab08d632145ed31" name="ae136cf4e22a254e02ab08d632145ed31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae136cf4e22a254e02ab08d632145ed31">&#9670;&#160;</a></span>TreeNode() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sparta::TreeNode::TreeNode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>desc</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> constructor with no parent node or group information. </p>
<dl class="section see"><dt>See also</dt><dd>other <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">sparta::TreeNode</a> constructors</dd></dl>
<p>group defaults to GROUP_NAME_NONE. group_idx defaults to GROUP_IDX_NONE. </p>

</div>
</div>
<a id="ae6e2a24a1cee8725161eee61a9a8af70" name="ae6e2a24a1cee8725161eee61a9a8af70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e2a24a1cee8725161eee61a9a8af70">&#9670;&#160;</a></span>~TreeNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual sparta::TreeNode::~TreeNode </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual destructor. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a></td><td>if node is attached to a root (via isAttached) and tree is not in TREE_TEARDOWN phase </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a955dd570e1c3f926d2371956535745e0" name="a955dd570e1c3f926d2371956535745e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a955dd570e1c3f926d2371956535745e0">&#9670;&#160;</a></span>activateLink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sparta::TreeNode::activateLink </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>label</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Activate one of the links added with addLink. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>The label of the tree node</td></tr>
  </table>
  </dd>
</dl>
<p>What it means to activate a link can differ from simulator to simulator and each simulator that use the link notion is free to define the semantics of the link and what it means to active a link.</p>
<p>In case this method is not overriden, we assume that it has a resource and will let its resource know about what tree nodes are being shadowed. </p>

</div>
</div>
<a id="a4f2b4d2e10e2e64ecdf35f4d040f1117" name="a4f2b4d2e10e2e64ecdf35f4d040f1117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f2b4d2e10e2e64ecdf35f4d040f1117">&#9670;&#160;</a></span>addAlias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::addAlias </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>alias</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a single alias for this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>Alias to assign to this node. alias is subject to the same constraints as a node name and must satisfy validateName. Additionally, aliases must not be empty strings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Node must not yet have a parent. When adding a node as a child, the parent checks for alias, name, group, and group+idx collisions amongst all its children </dd>
<dd>
No alias with the same name may be present in this node </dd>
<dd>
alias cannot match any name, alias, or group of another child of this node's parent. </dd>
<dd>
Tree cannot be built (Not having a parent should hide this precondition) </dd></dl>

</div>
</div>
<a id="adee6f68fd41da3956ef2201ca9de14ad" name="adee6f68fd41da3956ef2201ca9de14ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adee6f68fd41da3956ef2201ca9de14ad">&#9670;&#160;</a></span>addAliases()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::addAliases </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a991e1785f763d44925f4a53d89a44675">AliasVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds each element of a vector of aliases to this node.. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector of alias strings. Each alias in the vector is subject to the conditions of addAlias </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>See addAlias </dd></dl>

</div>
</div>
<a id="a57ee86186cf09b8dada20df11d635f37" name="a57ee86186cf09b8dada20df11d635f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ee86186cf09b8dada20df11d635f37">&#9670;&#160;</a></span>addChild() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::addChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>child</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AddChild by reference for convenience. </p>
<p>Overloads addChild(TreeNode* child) </p>

</div>
</div>
<a id="a7b6ca285ffd1077f9622662c167315e9" name="a7b6ca285ffd1077f9622662c167315e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b6ca285ffd1077f9622662c167315e9">&#9670;&#160;</a></span>addChild() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::addChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>child</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>inherit_phase</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> to this node as a child. </p>
<dl class="section pre"><dt>Precondition</dt><dd>All subblasses of this instance should be constructed before calling this methods and none should be destructed. This ensures that the onAddingChild_ and onSettingParent_ callback hooks can be invoked with a child having valid RTTI data. See the C++11 standard: 12.7 Construction and destruction [class.cdtor] Paragraph 3. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>borrowed pointer to <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> to add as a child. child must not already be a parent of *this. child cannot already be an immediate child of *this. Child cannot have the same name or alias as another name or alias of a child of *this (group names may be repeated though). Child must not be nullptr. </td></tr>
    <tr><td class="paramname">inherit_phase</td><td>Does the child inherit its phase from the parent This should be true in almost all uses of the framework </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>child is a borrowed reference - child is <em>not</em> copied. child lifetime must exceed that of this instance. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Child must be added to this node and have this node set as its parent. </dd>
<dd>
New child will be added to the end of the list. This is important for finalization because new nodes can be added while nodes are being iterated. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a></td><td>if the child cannot be added for any reason. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not call unless all subblasses of this instance have begun construction. No subclasses have completed destruction. This ensures that the onAddingChild_ and onSettingParent_ callback hooks can be invoked with a child having valid RTTI data. See the C++11 standard: 12.7 Construction and destruction [class.cdtor] Paragraph 3</dd></dl>
<p>Invokes onAddingChild_ before finally attaching the child. This gives subclasses a chance to either reject the node or perform some local actions like caching the child or determining its type.</p>
<p>Invokes setParent_ on the child which handles passing information about the new parent-child relationship to <em>child's</em> subtree. </p>

</div>
</div>
<a id="a1dc907c86ba95d84c6e97f9421cbbc85" name="a1dc907c86ba95d84c6e97f9421cbbc85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc907c86ba95d84c6e97f9421cbbc85">&#9670;&#160;</a></span>addExtension()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Extension , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Extension * sparta::TreeNode::addExtension </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an extension, specifying the ExtensionsBase subclass type. Forward any arguments needed to your subclass extension's constructor. The typical use case for <a class="el" href="#a1dc907c86ba95d84c6e97f9421cbbc85" title="Add an extension, specifying the ExtensionsBase subclass type. Forward any arguments needed to your s...">addExtension()</a> over the other apis is that these extensions are meant to be dynamic-only (on-demand only), bypassing the finalizeTree() checks that all extension parameters have been read. You can call <a class="el" href="#a1dc907c86ba95d84c6e97f9421cbbc85" title="Add an extension, specifying the ExtensionsBase subclass type. Forward any arguments needed to your s...">addExtension()</a> whenever you want. </p>
<dl class="section note"><dt>Note</dt><dd>Instead of subclassing directly from ExtensionsBase, it is more common to subclass ExtensionsParamsOnly. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Throws</td><td>if Extension::NAME is already an extension on this node. Use <a class="el" href="#ac80b64d2c78346e93c5513dda617f547" title="Replace an extension, specifying the ExtensionsBase subclass type. This api is similar to addExtensio...">replaceExtension()</a> instead. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l02045">2045</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1TreeNode_a1dc907c86ba95d84c6e97f9421cbbc85_cgraph.png" border="0" usemap="#aclasssparta_1_1TreeNode_a1dc907c86ba95d84c6e97f9421cbbc85_cgraph" alt=""/></div>
<map name="aclasssparta_1_1TreeNode_a1dc907c86ba95d84c6e97f9421cbbc85_cgraph" id="aclasssparta_1_1TreeNode_a1dc907c86ba95d84c6e97f9421cbbc85_cgraph">
<area shape="rect" title="Add an extension, specifying the ExtensionsBase subclass type. Forward any arguments needed to your s..." alt="" coords="5,5,209,31"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a00b99ce49b9d44c9cc8e7b738601ef4b" title="Check if this tree node has an extension by the given name." alt="" coords="257,5,460,31"/>
<area shape="poly" title=" " alt="" coords="209,16,241,16,241,21,209,21"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a8c99280dc2adae048d57fb001d05de61" title="Get an extension without needing to specify any particular extension name. If no extensions exist,..." alt="" coords="508,5,708,31"/>
<area shape="poly" title=" " alt="" coords="461,16,492,16,492,21,461,21"/>
</map>
</div>

</div>
</div>
<a id="a46abf404b2bc1fff08e6d6bba27bd3ac" name="a46abf404b2bc1fff08e6d6bba27bd3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46abf404b2bc1fff08e6d6bba27bd3ac">&#9670;&#160;</a></span>addExtensionFactory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::addExtensionFactory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>extension_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; ExtensionsBase *()&gt;</td>          <td class="paramname"><span class="paramname"><em>factory</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an extension factory to this tree node by its type (name). </p>
<dl class="section note"><dt>Note</dt><dd>This MUST be called before or during buildTree_() (TREE_BUILDING phase). </dd>
<dd>
<a class="el" href="#a31666fa4b498cd468991f2099e3fbbf7" title="Gets farthest ancestor of this node.">getRoot()</a> MUST be of type <a class="el" href="classsparta_1_1RootTreeNode.html" title="TreeNode which represents the root (&quot;top&quot;) of a device tree.">RootTreeNode</a>. </dd>
<dd>
Extensions are created automatically if provided in &ndash;extension-file, &ndash;arch, &ndash;config-file, or &ndash;node-config-file. </dd>
<dd>
If not provided in one of the above YAML files, getExtension(name) will always return nullptr. </dd></dl>

</div>
</div>
<a id="a413b70f45db0a7182347c109322b3b99" name="a413b70f45db0a7182347c109322b3b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413b70f45db0a7182347c109322b3b99">&#9670;&#160;</a></span>addLink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sparta::TreeNode::addLink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>label</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Link this tree node with another tree node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The tree node to link with </td></tr>
    <tr><td class="paramname">label</td><td>The label of the tree node</td></tr>
  </table>
  </dd>
</dl>
<p>This method is a generic interface for linking a tree node to other tree nodes. Linking is not bi-directinal, linking a tree node A with tree node be by calling this method on A, links A with B but not B with A.</p>
<p>In case this method is not overriden, we assume that it has a resource and will let its resource know about what tree nodes are being shadowed. </p>

<p>Reimplemented in <a class="el" href="classsparta_1_1MirrorNotificationSource.html#aed7510fc42ef3f3b083e3170d62565f3">sparta::MirrorNotificationSource&lt; NotificationDataT &gt;</a>.</p>

</div>
</div>
<a id="ae00f8c73f0a3a25df7bf68a5bc19c524" name="ae00f8c73f0a3a25df7bf68a5bc19c524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae00f8c73f0a3a25df7bf68a5bc19c524">&#9670;&#160;</a></span>addTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::addTag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>tag</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds single tag to this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td><a class="el" href="classsparta_1_1Tag.html" title="Tag(): Simple class to provide nested sequence numbering.">Tag</a> to add to this node. <a class="el" href="classsparta_1_1Tag.html" title="Tag(): Simple class to provide nested sequence numbering.">Tag</a> is subject to the same constraints as a node name and must satisfy validateName. Additionally, tags must not be empty strings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Tags cannot be removed once added </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Tree cannot be in or past TREE_FINALIZED phase </dd>
<dd>
No tag by this name may already be present. Since tag data may come from multiple places in the simulator source code, tags of the same name may have different semantics depending on who added them. This test ensures that one node does not have tags (meta-data) with conflicting semantics. Generally, the client should add each tag only once without checking to see if it already present. This will identify duplicate tags having different semantics </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Adds tag to global_tags_map_. See findChildrenByTag </dd></dl>

</div>
</div>
<a id="ac87c7a582545956ccdcab95b259ec3ae" name="ac87c7a582545956ccdcab95b259ec3ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac87c7a582545956ccdcab95b259ec3ae">&#9670;&#160;</a></span>addTags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::addTags </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds each elements of a vector of tags to this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector of tag strings. Each tag in the vector is subject to the conditions of addTag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>See addTag </dd></dl>

</div>
</div>
<a id="a811cf5ec3c1f09465768fba8bce6788e" name="a811cf5ec3c1f09465768fba8bce6788e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a811cf5ec3c1f09465768fba8bce6788e">&#9670;&#160;</a></span>areParametersLocked_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::TreeNode::areParametersLocked_ </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method informs whether the tree is past the lockdown phase for all LOCKED and HIDDEN parameters. Modifying LOCKED and HIDDEN parameters after this phase is disallowed. Tree can be locked down during TREE_BUILDING phase or TREE_CONFIGURING phase. During TREE_FINALIZING phase, all parameters are locked down as is. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l02952">2952</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="aed70a4d3e810f583e394752685233c69" name="aed70a4d3e810f583e394752685233c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed70a4d3e810f583e394752685233c69">&#9670;&#160;</a></span>bindTreeEarly_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::bindTreeEarly_ </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively invoke TreeNode::onBindTreeEarly_ and Resource::onBindTreeEarly_ (in that order for each node) </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classsparta_1_1RootTreeNode.html#a431fba8d4494832a06e7449ff61b3052" title="Public method for recursively giving all resources and nodes a chance to bind ports locally....">sparta::RootTreeNode::bindTreeEarly</a> </dd></dl>

</div>
</div>
<a id="ae3865c3ca676372326557b644bc1c305" name="ae3865c3ca676372326557b644bc1c305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3865c3ca676372326557b644bc1c305">&#9670;&#160;</a></span>bindTreeLate_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::bindTreeLate_ </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively invoke TreeNode::onBindTreeEarly_ and Resource::onBindTreeLate_ (in that order for each node) </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classsparta_1_1RootTreeNode.html#a61004212c1065745c6a39c7fab351103" title="Public method for recursively giving all resources and nodes a chance to bind ports locally....">sparta::RootTreeNode::bindTreeLate</a> </dd></dl>

</div>
</div>
<a id="a59c939995118db03f0a3fba145eab1aa" name="a59c939995118db03f0a3fba145eab1aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c939995118db03f0a3fba145eab1aa">&#9670;&#160;</a></span>broadcastDeregistrationForNotificationListStringToChildren_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::broadcastDeregistrationForNotificationListStringToChildren_ </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;</td>          <td class="paramname"><span class="paramname"><em>tinfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>obs_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1TreeNode_1_1delegate.html">delegate</a> *</td>          <td class="paramname"><span class="paramname"><em>del</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>private_only</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Symmetric oppostie of broadcastRegistrationForNotificationListStringToChildren_. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l03436">3436</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1TreeNode_a59c939995118db03f0a3fba145eab1aa_cgraph.png" border="0" usemap="#aclasssparta_1_1TreeNode_a59c939995118db03f0a3fba145eab1aa_cgraph" alt=""/></div>
<map name="aclasssparta_1_1TreeNode_a59c939995118db03f0a3fba145eab1aa_cgraph" id="aclasssparta_1_1TreeNode_a59c939995118db03f0a3fba145eab1aa_cgraph">
<area shape="rect" title="Symmetric oppostie of broadcastRegistrationForNotificationListStringToChildren_." alt="" coords="5,41,213,97"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a746152de43052580e24b26d3f890f1a2" title="Recursively notifies children that the notification described has lost one particular observer (del) ..." alt="" coords="272,5,472,61"/>
<area shape="poly" title=" " alt="" coords="213,52,256,46,257,52,213,58"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a4c2e0aceb5596a4f21fc5e1ad34c2ac7" title="Parses a comma&#45;separated list of notification names (or patterns) separated by commas and ignoring wh..." alt="" coords="261,85,484,126"/>
<area shape="poly" title=" " alt="" coords="213,81,245,85,245,90,213,86"/>
</map>
</div>

</div>
</div>
<a id="a746152de43052580e24b26d3f890f1a2" name="a746152de43052580e24b26d3f890f1a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a746152de43052580e24b26d3f890f1a2">&#9670;&#160;</a></span>broadcastDeregistrationForNotificationToChildren_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sparta::TreeNode::broadcastDeregistrationForNotificationToChildren_ </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;</td>          <td class="paramname"><span class="paramname"><em>tinfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const std::string * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>name_ids</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>obs_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1TreeNode_1_1delegate.html">delegate</a> *</td>          <td class="paramname"><span class="paramname"><em>del</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>allow_private</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively notifies children that the notification described has lost one particular observer (<em>del</em>) which was observing at the observation point <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> <em>obs_node</em> with the delegate <em>del</em>. </p>
<p>This is the symmetric opposite of broadcastRegistrationForNotificationToChildren_</p>
<p>Override to use a non-standard child-list. By default, this method simply iterates this node's children and call itself recursively for each </p>

</div>
</div>
<a id="a5b778eda31fa56c9a66bd79bc77b01eb" name="a5b778eda31fa56c9a66bd79bc77b01eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b778eda31fa56c9a66bd79bc77b01eb">&#9670;&#160;</a></span>broadcastRegistrationForNotificationListStringToChildren_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::broadcastRegistrationForNotificationListStringToChildren_ </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;</td>          <td class="paramname"><span class="paramname"><em>tinfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>obs_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1TreeNode_1_1delegate.html">delegate</a> *</td>          <td class="paramname"><span class="paramname"><em>del</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>private_only</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Entry point to broadcastRegistrationForNotificationToChildren_ recursion. Breaks a name string. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l03420">3420</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1TreeNode_a5b778eda31fa56c9a66bd79bc77b01eb_cgraph.png" border="0" usemap="#aclasssparta_1_1TreeNode_a5b778eda31fa56c9a66bd79bc77b01eb_cgraph" alt=""/></div>
<map name="aclasssparta_1_1TreeNode_a5b778eda31fa56c9a66bd79bc77b01eb_cgraph" id="aclasssparta_1_1TreeNode_a5b778eda31fa56c9a66bd79bc77b01eb_cgraph">
<area shape="rect" title="Entry point to broadcastRegistrationForNotificationToChildren_ recursion. Breaks a name string." alt="" coords="5,31,202,87"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a01d32cacde7a58997e485ab87a50e961" title="Recursively notifies children that the notification described is now (or still is) being observed at ..." alt="" coords="250,5,493,46"/>
<area shape="poly" title=" " alt="" coords="202,44,234,40,235,45,202,49"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a4c2e0aceb5596a4f21fc5e1ad34c2ac7" title="Parses a comma&#45;separated list of notification names (or patterns) separated by commas and ignoring wh..." alt="" coords="260,71,483,111"/>
<area shape="poly" title=" " alt="" coords="202,68,245,73,244,79,202,73"/>
</map>
</div>

</div>
</div>
<a id="a01d32cacde7a58997e485ab87a50e961" name="a01d32cacde7a58997e485ab87a50e961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d32cacde7a58997e485ab87a50e961">&#9670;&#160;</a></span>broadcastRegistrationForNotificationToChildren_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sparta::TreeNode::broadcastRegistrationForNotificationToChildren_ </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;</td>          <td class="paramname"><span class="paramname"><em>tinfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const std::string * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>name_ids</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>obs_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1TreeNode_1_1delegate.html">delegate</a> *</td>          <td class="paramname"><span class="paramname"><em>del</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>allow_private</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively notifies children that the notification described is now (or still is) being observed at the observation point <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> <em>obs_node</em> with the newly registered delegate <em>del</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tinfo</td><td>Type info of the notification </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name_ids</td><td>vector of pointers to names or glob-like treenode identifier patterns. that may or may not be interned with <a class="el" href="classsparta_1_1StringManager.html" title="Manages string internment for SPARTA. This allows strings to be compared by pointer once interned.">sparta::StringManager</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">obs_node</td><td>Node at which observer was installed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">del</td><td>Delegate to invoke when the notification posts</td></tr>
  </table>
  </dd>
</dl>
<p>This method allows Notification nodes to keep a map of which TreeNodes are observing observing a notification and what delegates are registered to observe that notification. The delegates can then be invoked directly by notification sources when appropriate notifications are posted.</p>
<p>Override to use a non-standard child-list. By default, this method simply iterates this node's children. </p>

</div>
</div>
<a id="ace577b7bae0092cb2dc2f54b37b24273" name="ace577b7bae0092cb2dc2f54b37b24273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace577b7bae0092cb2dc2f54b37b24273">&#9670;&#160;</a></span>canGenerateNotification() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::TreeNode::canGenerateNotification </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsparta_1_1TreeNode_1_1NotificationInfo.html">NotificationInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>info</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Can this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> generate a notification of the given <a class="el" href="structsparta_1_1TreeNode_1_1NotificationInfo.html" title="Notification type/name information.">NotificationInfo</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Also checks origin to ensure that it points to this node. </dd></dl>

</div>
</div>
<a id="a1acb8b497a9e8d9f3fc5ecae88cf1700" name="a1acb8b497a9e8d9f3fc5ecae88cf1700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1acb8b497a9e8d9f3fc5ecae88cf1700">&#9670;&#160;</a></span>canGenerateNotification() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::TreeNode::canGenerateNotification </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;</td>          <td class="paramname"><span class="paramname"><em>tinfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Can this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> generate a notification of the given type having the given name (does not require interned string - will intern automatically with <a class="el" href="classsparta_1_1StringManager.html" title="Manages string internment for SPARTA. This allows strings to be compared by pointer once interned.">StringManager</a>). </p>
<p>This is a version of the other canGenerateNotification function which does not require name to be a string interned with <a class="el" href="classsparta_1_1StringManager.html" title="Manages string internment for SPARTA. This allows strings to be compared by pointer once interned.">StringManager</a>. Though the other variant is faster, this can be more convenient. </p>

</div>
</div>
<a id="a91bb3b5d18785bd49e3933847eab1011" name="a91bb3b5d18785bd49e3933847eab1011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91bb3b5d18785bd49e3933847eab1011">&#9670;&#160;</a></span>canGenerateNotification() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::TreeNode::canGenerateNotification </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;</td>          <td class="paramname"><span class="paramname"><em>tinfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Can this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> generate a notification of the given type having the given name or pattern. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tinfo</td><td>type_info from typeid on the type of notification being queried. </td></tr>
    <tr><td class="paramname">name</td><td>Pointer to interned name or pattern of notifications to query (from <a class="el" href="classsparta_1_1StringManager.html#ad1e1496d305428f17d58856738b2b033" title="Stores a string in shared space within this manager unless it is already stored.">StringManager::internString</a>). If This value is <a class="el" href="classsparta_1_1StringManager.html#ac8482a5f1d6c13aa1c60459e1bf5f3f1" title="Holds interned empty strings.">StringManager::EMPTY</a>, looks for notifications having any name. glob-like patterns are supported (see matchesGlobLike). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this node can post a notification having the given type T where tinfo=typeid(T) and having a notification name matching the parameter 'name'. If the parameter 'name' is <a class="el" href="classsparta_1_1StringManager.html#ac8482a5f1d6c13aa1c60459e1bf5f3f1" title="Holds interned empty strings.">StringManager::EMPTY</a>, matches on any notification name. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is effectively a const expression - It will invariably return the same result for the same inputs.</dd></dl>
<p>Example </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> bCanGenLogMsg =</div>
<div class="line">  n-&gt;canGenerateNotification(<span class="keyword">typeid</span>(<a class="code hl_struct" href="structsparta_1_1log_1_1Message.html">sparta::log::Message</a>), <a class="code hl_function" href="classsparta_1_1StringManager.html#a00c28199fcaa46cf51ac5ec32a51aade">StringManager::getStringManager</a>().EMPTY);</div>
<div class="line"><span class="keywordtype">bool</span> bCanGenWarningLogMsg =</div>
<div class="line">  n-&gt;canGenerateNotification(<span class="keyword">typeid</span>(<a class="code hl_struct" href="structsparta_1_1log_1_1Message.html">sparta::log::Message</a>), <a class="code hl_variable" href="classsparta_1_1log_1_1categories.html#aa3dbfc8331b45b3904c8813d301af971">sparta::log::categories::WARN</a>);</div>
<div class="ttc" id="aclasssparta_1_1StringManager_html_a00c28199fcaa46cf51ac5ec32a51aade"><div class="ttname"><a href="classsparta_1_1StringManager.html#a00c28199fcaa46cf51ac5ec32a51aade">sparta::StringManager::getStringManager</a></div><div class="ttdeci">static StringManager &amp; getStringManager()</div><div class="ttdoc">Returns the StringManager singleton.</div><div class="ttdef"><b>Definition</b> <a href="StringManager_8hpp_source.html#l00224">StringManager.hpp:224</a></div></div>
<div class="ttc" id="aclasssparta_1_1log_1_1categories_html_aa3dbfc8331b45b3904c8813d301af971"><div class="ttname"><a href="classsparta_1_1log_1_1categories.html#aa3dbfc8331b45b3904c8813d301af971">sparta::log::categories::WARN</a></div><div class="ttdeci">static const std::string *const WARN</div><div class="ttdoc">Indicates a WARNING.</div><div class="ttdef"><b>Definition</b> <a href="CategoryManager_8hpp_source.html#l00022">CategoryManager.hpp:22</a></div></div>
<div class="ttc" id="astructsparta_1_1log_1_1Message_html"><div class="ttname"><a href="structsparta_1_1log_1_1Message.html">sparta::log::Message</a></div><div class="ttdoc">Contains a logging message header and content.</div><div class="ttdef"><b>Definition</b> <a href="Message_8hpp_source.html#l00017">Message.hpp:18</a></div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5ed2ede13a267a23e4794c085be6621d" name="a5ed2ede13a267a23e4794c085be6621d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ed2ede13a267a23e4794c085be6621d">&#9670;&#160;</a></span>canSubtreeGenerateNotification() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::TreeNode::canSubtreeGenerateNotification </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;</td>          <td class="paramname"><span class="paramname"><em>tinfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Can this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> or its descendants (of any distance) generate a notification of the given type having the given name (does not require interned string) </p>
<p>This is a version of the other canGenerateNotification function which does not require name to be a string interned with <a class="el" href="classsparta_1_1StringManager.html" title="Manages string internment for SPARTA. This allows strings to be compared by pointer once interned.">StringManager</a>. Though the other variant is faster, this can be more convenient. </p>

</div>
</div>
<a id="ae324a0d15005548d4c2ed44147d100e3" name="ae324a0d15005548d4c2ed44147d100e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae324a0d15005548d4c2ed44147d100e3">&#9670;&#160;</a></span>canSubtreeGenerateNotification() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::TreeNode::canSubtreeGenerateNotification </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;</td>          <td class="paramname"><span class="paramname"><em>tinfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Can this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> or its descendants (of any distance) generate a notification of the given type having the given name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tinfo</td><td>type_info from typeid on the type of notification being queried. </td></tr>
    <tr><td class="paramname">name</td><td>Pointer to interned name of notifications to query about (from <a class="el" href="classsparta_1_1StringManager.html#ad1e1496d305428f17d58856738b2b033" title="Stores a string in shared space within this manager unless it is already stored.">StringManager::internString</a>). If This value is <a class="el" href="classsparta_1_1StringManager.html#ac8482a5f1d6c13aa1c60459e1bf5f3f1" title="Holds interned empty strings.">StringManager::EMPTY</a>, looks for notifications having any name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this node can post a notification having the given type T where tinfo=typeid(T) and having a notification name matching the parameter 'name'. If the parameter 'name' is <a class="el" href="classsparta_1_1StringManager.html#ac8482a5f1d6c13aa1c60459e1bf5f3f1" title="Holds interned empty strings.">StringManager::EMPTY</a>, matches on any notification name. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This searches the entire subtree and can be slow.</dd></dl>
<p>Uses canGenerateNotification at each node to check. Returns on first match.</p>
<p>Example </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> bCanGenLogMsg =</div>
<div class="line">  n-&gt;canSubtreeGenerateNotification(<span class="keyword">typeid</span>(<a class="code hl_struct" href="structsparta_1_1log_1_1Message.html">sparta::log::Message</a>), <a class="code hl_function" href="classsparta_1_1StringManager.html#a00c28199fcaa46cf51ac5ec32a51aade">StringManager::getStringManager</a>().EMPTY);</div>
<div class="line"><span class="keywordtype">bool</span> bCanGenWarningLogMsg =</div>
<div class="line">  n-&gt;canSubtreeGenerateNotification(<span class="keyword">typeid</span>(<a class="code hl_struct" href="structsparta_1_1log_1_1Message.html">sparta::log::Message</a>), <a class="code hl_variable" href="classsparta_1_1log_1_1categories.html#aa3dbfc8331b45b3904c8813d301af971">sparta::log::categories::WARN</a>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a42372c597a4836b2505a1200c5aaf08f" name="a42372c597a4836b2505a1200c5aaf08f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42372c597a4836b2505a1200c5aaf08f">&#9670;&#160;</a></span>canSubtreeGenerateNotifications()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::TreeNode::canSubtreeGenerateNotifications </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;</td>          <td class="paramname"><span class="paramname"><em>tinfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const std::string * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>names</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if any a subtree can generate any of several notification names which may be patterns. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a42372c597a4836b2505a1200c5aaf08f" title="Checks to see if any a subtree can generate any of several notification names which may be patterns.">canSubtreeGenerateNotifications</a> </dd></dl>

</div>
</div>
<a id="af95a9a2b043fc39a1972871380d09eac" name="af95a9a2b043fc39a1972871380d09eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95a9a2b043fc39a1972871380d09eac">&#9670;&#160;</a></span>createExtension() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ExtensionsBase * sparta::TreeNode::createExtension </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>replace</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an extension on demand without needing to specify any particular extension name. If the arch/config/extension YAML input files have exactly one extension configured for this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>, that extension will be created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">replace</td><td>If true, remove any existing extension of the same name before creating a new one. If false, returns the existing extension if one exists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If 'this' tree node was not given an extension in any of the &ndash;extension-file, &ndash;arch, &ndash;config-file, or &ndash;node-config-file YAML files, then this will always return nullptr. </dd>
<dd>
Does not require a registered extension factory. If no factory exists for the resolved extension name, returns an ExtensionsParamsOnly. Otherwise, returns an extension subclass created by the factory. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>'this' tree node was given more than one extension in the input YAML files, this will always throw an exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1be07418bc8582d96fe2c3fb89ff4d94" name="a1be07418bc8582d96fe2c3fb89ff4d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1be07418bc8582d96fe2c3fb89ff4d94">&#9670;&#160;</a></span>createExtension() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ExtensionsBase * sparta::TreeNode::createExtension </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>extension_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>replace</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd>createExtension(name, replace) </dd></dl>

</div>
</div>
<a id="a5bb4f3d69315bfb965489d00f7be5148" name="a5bb4f3d69315bfb965489d00f7be5148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb4f3d69315bfb965489d00f7be5148">&#9670;&#160;</a></span>createExtension() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ExtensionsBase * sparta::TreeNode::createExtension </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>extension_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>replace</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an extension on demand. This is useful if you want to add an extension to a node that was not specified in any of the &ndash;extension-file, &ndash;arch, &ndash;config-file, or &ndash;node-config-file YAML files. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extension_name</td><td>The name of the extension to create. </td></tr>
    <tr><td class="paramname">replace</td><td>If true, remove any existing extension of the same name before creating a new one. If false, returns the existing extension if one exists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Does not require a registered extension factory. If no factory exists for the given name, returns an ExtensionsParamsOnly. Otherwise, returns an extension subclass created by the factory. </dd></dl>

</div>
</div>
<a id="aacb943215632699fbddc6554dacfbdf7" name="aacb943215632699fbddc6554dacfbdf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb943215632699fbddc6554dacfbdf7">&#9670;&#160;</a></span>createSearchRegexPattern()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string sparta::TreeNode::createSearchRegexPattern </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>pat</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a regex pattern for a node child path containing any number of wildcard characters (not a dot-separated location) which can be used to test against child node names. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pat</td><td>Pattern for searching immediate children (e.g. "core*" or "core0") </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The caller is responsible for parsing a location string into alphanumeric child strings. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2cac07d5f406fa1300d0e283e2a1f498" title="Determines if a given node name has any wildcard characters which will be substituted in createSearch...">hasWildcardCharacters</a> </dd></dl>

</div>
</div>
<a id="a8f4da13fd6f93c76c3df9ded6a20b6b2" name="a8f4da13fd6f93c76c3df9ded6a20b6b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f4da13fd6f93c76c3df9ded6a20b6b2">&#9670;&#160;</a></span>deregisterForNotification() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , typename T , void(T::*)(const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &amp;, const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &amp;, const DataT &amp;) TMethod&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::deregisterForNotification </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes at most one registration made with registerForNotification. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="TreeNode_8hpp.html#a1bb31db8e504f95b76706d7931eaa93e" title="Convenience macro for registering for a notification on a TreeNode.">REGISTER_FOR_NOTIFICATION</a></dd></dl>
<p>Refer to registerForNotification for more information about parameters. To deregister an observer delegate registered through registerForNotification, pass the same arguments. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l03899">3899</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a8f4da13fd6f93c76c3df9ded6a20b6b2" name="a8f4da13fd6f93c76c3df9ded6a20b6b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f4da13fd6f93c76c3df9ded6a20b6b2">&#9670;&#160;</a></span>deregisterForNotification() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , typename T , void(T::*)(const DataT &amp;) TMethod&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::deregisterForNotification </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l03906">3906</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="aac08b48b8d658459cd947170e0b92a0b" name="aac08b48b8d658459cd947170e0b92a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac08b48b8d658459cd947170e0b92a0b">&#9670;&#160;</a></span>dumpDebugContent_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::dumpDebugContent_ </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows resources to write out detailed textual debugging information about the node. This is typically called by a simulator when shutting down due to an exception (or depending on simulator config). However, it could also be called at other times. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Output osteam to which this node should write all of its debug state. Note that this is not necessarily the same ostream for all nodes and resources, so this should not be shared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Simulator can be in any phase </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The entire resource tree is accessible. Nothing has been destructed yet </dd>
<dd>
If you need to print a message </dd>
<dd>
Do not throw here. If simulation state is invalid, that should be detected in validatePostRun_. </dd>
<dd>
The simulator will not continue to run for this device tree at this point. </dd>
<dd>
Conventionally, this method should write to <em>out</em> only. Writing entirely new files from this method is unexpected by the user and violates one of the design principals of this library where the only simulator input and output files and named explicitly by the user. If you must create a new file, please name it clearly. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Must</td><td>not throw! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9dfcfbc1e6b004ff0d80ec3d38cbbd2" name="af9dfcfbc1e6b004ff0d80ec3d38cbbd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9dfcfbc1e6b004ff0d80ec3d38cbbd2">&#9670;&#160;</a></span>dumpLocatedNotificationSources()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT  = ANY_TYPE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::dumpLocatedNotificationSources </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>o</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the relevant NotificationSources from locateNotificationSources and prints them to the output <em>o</em>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataT</td><td>type of notification to search for or <a class="el" href="structsparta_1_1TreeNode_1_1ANY__TYPE.html" title="Type for indicating that ANY notification source type should be included in a search performed by loc...">ANY_TYPE</a>. See locateNotificationSource. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>ostream to write found nodes to. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l03676">3676</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1TreeNode_af9dfcfbc1e6b004ff0d80ec3d38cbbd2_cgraph.png" border="0" usemap="#aclasssparta_1_1TreeNode_af9dfcfbc1e6b004ff0d80ec3d38cbbd2_cgraph" alt=""/></div>
<map name="aclasssparta_1_1TreeNode_af9dfcfbc1e6b004ff0d80ec3d38cbbd2_cgraph" id="aclasssparta_1_1TreeNode_af9dfcfbc1e6b004ff0d80ec3d38cbbd2_cgraph">
<area shape="rect" title="Retrieves the relevant NotificationSources from locateNotificationSources and prints them to the outp..." alt="" coords="5,5,211,46"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#aa6ccf18c0631ba2d1a665567db7618a6" title="Gets all possible notification info from NotificationSources within this node&#39;s subtree." alt="" coords="259,5,420,46"/>
<area shape="poly" title=" " alt="" coords="211,23,243,23,243,28,211,28"/>
<area shape="rect" href="classsparta_1_1StringManager.html#a00c28199fcaa46cf51ac5ec32a51aade" title="Returns the StringManager singleton." alt="" coords="468,5,615,46"/>
<area shape="poly" title=" " alt="" coords="420,23,453,23,453,28,420,28"/>
</map>
</div>

</div>
</div>
<a id="a2ae14d74895ad69d6e8ce3f767342800" name="a2ae14d74895ad69d6e8ce3f767342800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae14d74895ad69d6e8ce3f767342800">&#9670;&#160;</a></span>dumpPossibleNotifications()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::dumpPossibleNotifications </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>o</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps a listing of the notifications which this node can generate to the ostream o. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>ostream to which the notification info list will be dumped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c94c97462083a4d9f1892c72cc14c40" name="a3c94c97462083a4d9f1892c72cc14c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c94c97462083a4d9f1892c72cc14c40">&#9670;&#160;</a></span>dumpPossibleSubtreeNotifications()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::dumpPossibleSubtreeNotifications </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>o</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps a listing of the notifications which this node and its descendants can generate to the ostream o. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>ostream to which the noitification info list will be dumped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2cab43bc4edc2befcfab06e08c4797e" name="ac2cab43bc4edc2befcfab06e08c4797e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2cab43bc4edc2befcfab06e08c4797e">&#9670;&#160;</a></span>enterConfig_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::enterConfig_ </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively enter TREE_CONFIGURING phase. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Cannot</td><td>throw /post res_ of this node contains allocated <a class="el" href="classsparta_1_1Resource.html" title="The is the base class for all types of resources used by the SPARTA framework.">Resource</a> unless there was an exception </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8744a27ae66472ac72860f0fdc9b0149" name="a8744a27ae66472ac72860f0fdc9b0149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8744a27ae66472ac72860f0fdc9b0149">&#9670;&#160;</a></span>enterFinalized_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::enterFinalized_ </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively enter TREE_FINALIZED phase. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a></td><td>if already in TREE_FINALIZED phase or beyond </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Can be called multiple times if tree did not fully finalize. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>All nodes in three are set to TREE_FINALIZED phase </dd></dl>

</div>
</div>
<a id="a774d31f6b6d00ff9d18dbcba38785657" name="a774d31f6b6d00ff9d18dbcba38785657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774d31f6b6d00ff9d18dbcba38785657">&#9670;&#160;</a></span>enterFinalizing_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::enterFinalizing_ </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively enter TREE_FINALIZING phase. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a></td><td>already in TREE_FINALIZING phase or beyond </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>All nodes in tree are set to TREE_FINALIZED phase </dd></dl>

</div>
</div>
<a id="a3f7ae09a1aa188a5570ec00d90a37d21" name="a3f7ae09a1aa188a5570ec00d90a37d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f7ae09a1aa188a5570ec00d90a37d21">&#9670;&#160;</a></span>enterTeardown_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::enterTeardown_ </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively enter TREE_TEARDOWN phase while alerting nodes through onEnteringTeardown_ and alterting Resources through Resource::onStartingTeardown_. Nodes already in TREE_TEARDOWN phase will not be alerted (neither will their associated Resources). All nodes are visited regardless of their parent's phase. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Cannot</td><td>throw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9928daa22b0eba5897a854a266dc6684" name="a9928daa22b0eba5897a854a266dc6684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9928daa22b0eba5897a854a266dc6684">&#9670;&#160;</a></span>finalizeTree_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::finalizeTree_ </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively create resources based on tree configuration. enter_finalize_ should be invoked after this method successfully completes for an entire tree. Finalizes in the order of construction. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if there is an error anywhere in the finalization procedure. No actions are rolled-back, but this method can be called again. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>Any <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> not in TREE_FINALIZING will be moved into TREE_FINALIZING </dd>
<dd>
res_ of this node contains allocated <a class="el" href="classsparta_1_1Resource.html" title="The is the base class for all types of resources used by the SPARTA framework.">Resource</a> unless there was an exception or the node did not try to create a resource. </dd>
<dd>
<a class="el" href="classsparta_1_1Clock.html" title="A representation of simulated time.">Clock</a> is permanently associated with this node and cacheable </dd></dl>

</div>
</div>
<a id="a71fca4d66ac8dee9f524fd3472c4bf8b" name="a71fca4d66ac8dee9f524fd3472c4bf8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71fca4d66ac8dee9f524fd3472c4bf8b">&#9670;&#160;</a></span>findAncestorByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a> * sparta::TreeNode::findAncestorByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find ancestor by name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the ancestor, can include wildcards understood by Sparta </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If found, ancestor's <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>, otherwise nullptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l01153">1153</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1TreeNode_a71fca4d66ac8dee9f524fd3472c4bf8b_cgraph.png" border="0" usemap="#aclasssparta_1_1TreeNode_a71fca4d66ac8dee9f524fd3472c4bf8b_cgraph" alt=""/></div>
<map name="aclasssparta_1_1TreeNode_a71fca4d66ac8dee9f524fd3472c4bf8b_cgraph" id="aclasssparta_1_1TreeNode_a71fca4d66ac8dee9f524fd3472c4bf8b_cgraph">
<area shape="rect" title="Find ancestor by name." alt="" coords="5,47,204,88"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#aa8958d72a1f5aeff2ec36012913ac09c" title="Gets immediate parent of this node if one exists." alt="" coords="252,5,434,31"/>
<area shape="poly" title=" " alt="" coords="204,44,262,32,263,37,205,50"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a31666fa4b498cd468991f2099e3fbbf7" title="Gets farthest ancestor of this node." alt="" coords="257,55,428,80"/>
<area shape="poly" title=" " alt="" coords="204,65,242,65,242,70,204,70"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#af61c4f67a5045b80c62fd331519b969d" title="Determines if the given pattern (which may contain wildcards) can describe this node." alt="" coords="257,104,428,145"/>
<area shape="poly" title=" " alt="" coords="193,86,243,98,242,103,191,91"/>
</map>
</div>

</div>
</div>
<a id="ac4e8b9f4aa2cc56fcba09b88ddf1f626" name="ac4e8b9f4aa2cc56fcba09b88ddf1f626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e8b9f4aa2cc56fcba09b88ddf1f626">&#9670;&#160;</a></span>findAncestorByTag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a> * sparta::TreeNode::findAncestorByTag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>tag</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first ancestor with a particular tag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>the tag we are searching for.</td></tr>
  </table>
  </dd>
</dl>
<p>This method will traverse up the tree until it finds a <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> who's tag matches the searched tag. This does not, by any means, guarantee that the resource is actually available yet.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the treenode with tag or nullptr if not found. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l01202">1202</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1TreeNode_ac4e8b9f4aa2cc56fcba09b88ddf1f626_cgraph.png" border="0" usemap="#aclasssparta_1_1TreeNode_ac4e8b9f4aa2cc56fcba09b88ddf1f626_cgraph" alt=""/></div>
<map name="aclasssparta_1_1TreeNode_ac4e8b9f4aa2cc56fcba09b88ddf1f626_cgraph" id="aclasssparta_1_1TreeNode_ac4e8b9f4aa2cc56fcba09b88ddf1f626_cgraph">
<area shape="rect" title="Find the first ancestor with a particular tag." alt="" coords="5,47,204,88"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#aa8958d72a1f5aeff2ec36012913ac09c" title="Gets immediate parent of this node if one exists." alt="" coords="252,5,434,31"/>
<area shape="poly" title=" " alt="" coords="204,44,262,32,263,37,205,50"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a31666fa4b498cd468991f2099e3fbbf7" title="Gets farthest ancestor of this node." alt="" coords="257,55,428,80"/>
<area shape="poly" title=" " alt="" coords="204,65,242,65,242,70,204,70"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a790acc1b3b08263b8f1941dc33fbb012" title="Does this node have a specific tag (by name)" alt="" coords="258,104,428,130"/>
<area shape="poly" title=" " alt="" coords="205,85,263,98,262,103,204,91"/>
</map>
</div>

</div>
</div>
<a id="ae70953b54ed0fe69a3f13af671b68e53" name="ae70953b54ed0fe69a3f13af671b68e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae70953b54ed0fe69a3f13af671b68e53">&#9670;&#160;</a></span>findAncestorByType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a> * sparta::TreeNode::findAncestorByType </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find ancestor by type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The <a class="el" href="classsparta_1_1Resource.html" title="The is the base class for all types of resources used by the SPARTA framework.">Resource</a> type to check for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If found, ancestor's <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>, otherwise nullptr</dd></dl>
<p>This method will traverse up the tree until it finds a <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> who's resource type matches the given type. This does not, by any means, guarantee that the resource is available for obtaining.</p>
<dl class="section warning"><dt>Warning</dt><dd>If your resource inherits from some base class, passing T=your base class will not find the result. For this case, consider using findAncestorByTag, and add a tag to your base. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l01180">1180</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1TreeNode_ae70953b54ed0fe69a3f13af671b68e53_cgraph.png" border="0" usemap="#aclasssparta_1_1TreeNode_ae70953b54ed0fe69a3f13af671b68e53_cgraph" alt=""/></div>
<map name="aclasssparta_1_1TreeNode_ae70953b54ed0fe69a3f13af671b68e53_cgraph" id="aclasssparta_1_1TreeNode_ae70953b54ed0fe69a3f13af671b68e53_cgraph">
<area shape="rect" title="Find ancestor by type." alt="" coords="5,55,204,96"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#aa8958d72a1f5aeff2ec36012913ac09c" title="Gets immediate parent of this node if one exists." alt="" coords="252,5,434,31"/>
<area shape="poly" title=" " alt="" coords="191,52,271,33,272,38,193,57"/>
<area shape="rect" href="classsparta_1_1ResourceContainer.html#ae244126daf829d0ef231a1f7707a6c3b" title="Gets the typename of the resource that this node will eventually contain." alt="" coords="256,55,430,96"/>
<area shape="poly" title=" " alt="" coords="204,73,241,73,241,78,204,78"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a31666fa4b498cd468991f2099e3fbbf7" title="Gets farthest ancestor of this node." alt="" coords="257,120,428,146"/>
<area shape="poly" title=" " alt="" coords="193,94,272,113,271,118,191,99"/>
</map>
</div>

</div>
</div>
<a id="aedf510819cee4ea78d009b01ea324474" name="aedf510819cee4ea78d009b01ea324474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf510819cee4ea78d009b01ea324474">&#9670;&#160;</a></span>findAncestorResourceByType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * sparta::TreeNode::findAncestorResourceByType </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find an ancestor's resource with a certain type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the resource type you'd like to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if found a pointer to the closest ancestor's resource of type T. nullptr otherwise.</dd></dl>
<p>This method is similar to findAncestorByType but will return the parent's resource instead. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l01225">1225</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1TreeNode_aedf510819cee4ea78d009b01ea324474_cgraph.png" border="0" usemap="#aclasssparta_1_1TreeNode_aedf510819cee4ea78d009b01ea324474_cgraph" alt=""/></div>
<map name="aclasssparta_1_1TreeNode_aedf510819cee4ea78d009b01ea324474_cgraph" id="aclasssparta_1_1TreeNode_aedf510819cee4ea78d009b01ea324474_cgraph">
<area shape="rect" title="Find an ancestor&#39;s resource with a certain type." alt="" coords="5,199,204,240"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#ae70953b54ed0fe69a3f13af671b68e53" title="Find ancestor by type." alt="" coords="252,84,450,125"/>
<area shape="poly" title=" " alt="" coords="149,196,290,130,292,135,151,201"/>
<area shape="rect" href="classsparta_1_1ResourceContainer.html#a8a6dc7a027715d3981f50bc0823bde07" title="Gets the resource contained by this node (if any) as the given type." alt="" coords="264,284,438,325"/>
<area shape="poly" title=" " alt="" coords="166,238,276,276,275,281,165,243"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#aa8958d72a1f5aeff2ec36012913ac09c" title="Gets immediate parent of this node if one exists." alt="" coords="498,5,680,31"/>
<area shape="poly" title=" " alt="" coords="397,82,497,41,521,33,523,38,499,46,399,87"/>
<area shape="rect" href="classsparta_1_1ResourceContainer.html#ae244126daf829d0ef231a1f7707a6c3b" title="Gets the typename of the resource that this node will eventually contain." alt="" coords="502,55,676,96"/>
<area shape="poly" title=" " alt="" coords="450,90,487,85,487,91,451,95"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a31666fa4b498cd468991f2099e3fbbf7" title="Gets farthest ancestor of this node." alt="" coords="504,120,675,146"/>
<area shape="poly" title=" " alt="" coords="451,114,488,118,488,124,450,119"/>
<area shape="rect" href="namespacesparta.html#ac0a2df7a7ca53b2fc0384476286b95ec" title="Demangles a C++ symbol." alt="" coords="530,169,649,195"/>
<area shape="poly" title=" " alt="" coords="377,282,430,243,497,205,515,198,517,203,499,210,433,248,380,286"/>
<area shape="rect" href="classsparta_1_1PhasedObject.html#a2dcca61565924f0a4208c6509f9a42ba" title="Returns the location of this node in device tree which can be used to navigate the device tree in met..." alt="" coords="516,219,662,260"/>
<area shape="poly" title=" " alt="" coords="427,281,501,261,502,266,428,287"/>
<area shape="rect" href="classsparta_1_1ResourceContainer.html#af399ae644f27a3982dd3a2a788ae8d24" title="Gets the rtti type name (demangled) of the resource type held by this container. If there is no resou..." alt="" coords="502,284,676,325"/>
<area shape="poly" title=" " alt="" coords="438,302,487,302,487,308,438,308"/>
<area shape="rect" href="classsparta_1_1PhasedObject.html#ac8edefaf47c41a0be179827e657955d5" title="Is this node (and thus the entire tree above it) &quot;finalized&quot;." alt="" coords="516,350,662,390"/>
<area shape="poly" title=" " alt="" coords="428,323,502,344,501,349,427,328"/>
<area shape="rect" href="classsparta_1_1PhasedObject.html#a5c50c75766fa4096ba77b12c3a53edd1" title="Is this node (and thus the entire tree above it) &quot;finalized&quot;." alt="" coords="516,415,662,456"/>
<area shape="poly" title=" " alt="" coords="380,323,434,361,499,400,513,406,510,411,497,405,431,366,377,328"/>
<area shape="rect" href="classsparta_1_1PhasedObject.html#a8555fc19699141ca78722846bd2e2dc3" title="Is this node (and thus the entire tree above it) in the &quot;teardown&quot; phase." alt="" coords="516,480,662,521"/>
<area shape="poly" title=" " alt="" coords="368,324,421,393,458,431,500,465,508,471,505,475,496,470,454,435,417,396,364,327"/>
</map>
</div>

</div>
</div>
<a id="a34e9cb392ac4901bc21ce583b36d0e01" name="a34e9cb392ac4901bc21ce583b36d0e01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e9cb392ac4901bc21ce583b36d0e01">&#9670;&#160;</a></span>findChildren() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sparta::TreeNode::findChildren </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>results</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Version of findChildren with no replacements vector. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l01430">1430</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="ae707e1cdf8038ea8aeac03ca2620d1e1" name="ae707e1cdf8038ea8aeac03ca2620d1e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae707e1cdf8038ea8aeac03ca2620d1e1">&#9670;&#160;</a></span>findChildren() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sparta::TreeNode::findChildren </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>results</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::string &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>replacements</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds all children starting at this node with a given pattern relative to this node by matching names an aliases. Appends each found child to &lt;results&gt;. </p>
<dl class="section note"><dt>Note</dt><dd>this is not a full recursive search. All children found will be N levels below this node whrere N Is dependent on the number of '.' tokens in the search string. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>Search pattern in a restricted glob format. </td></tr>
    <tr><td class="paramname">results</td><td>All children with identifiers matching the pattern (alias or name) are appended to the back of this vector. Order of results appended is implementation dependent and not guaranteed consistent. All children found from this invocation of findChildren (and any deeper recursion) will be adjacent in &lt;results&gt;. </td></tr>
    <tr><td class="paramname">replacements</td><td>Vector of replacements made on wildcards in path in order to find children. For each result added to <em>results</em>, a vector element is added to <em>replacements</em>. That vector element vector contains as many replacements as there are wildcards in the <em>pattern</em>. To clarify results.size()=replacements.size() and If replacements.size() &gt; 1, replacements[0].size() is the number of wildcards in <em>pattern</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>Appends all children that match pattern to results (does not clear). Order of children appended is not defined or guaranteed to be consistent. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>May return duplicates if any upward traversal is done after multiple downward traversal (e.g. pattern is '<em>..a'). This occurs since each of the N children found with "&lt;/em&gt;" recognizes the upward search pattern '.' (after another '.') and searches the parent for "a". </em></dd>
<dd>
<em> May return duplicates if multiple aliases refer to the same <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>. </em></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><em> The number of children found and appended to results. </em></dd></dl>
<dl class="section note"><dt>Note</dt><dd><em> This is <b> not full path matching </b>. Patterns are extracted between each '.' and the ends of the pattern string. Each of these Extracted patterns is used to search in the current search context and either find the new child/parent to search within OR (if the end of the whole pattern has been reached), to find a node to add to the results output vector </em></dd>
<dd>
<em> This method is not <code>const</code> to allow the caller to modify the found TreeNodes </em></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Does</td><td><em>not throw. May print a warning when a pattern attempts to search up and the current node has no parent. </em></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><em> <a class="el" href="#af61c4f67a5045b80c62fd331519b969d" title="Determines if the given pattern (which may contain wildcards) can describe this node.">locationMatchesPattern</a></em></dd></dl>
<p>The following glob wildcard patterns are supported </p><ul>
<li><em> ? Match 0 or 1 characters </em></li>
<li><em> * Match 0 or more characters</em></li>
</ul>
<p>The following additional patterns are supported </p><ul>
<li><em> + One or more characters</em></li>
</ul>
<p>The following glob patterns are <b>not</b> supported <span style="color:#c00000;"> </p><ul>
<li><em> {} </em></li>
<li><em> [] </em></li>
<li><em> \ (since all names involved in search are alphanumeric and underscore) </em></li>
</ul>
<p>For example: </p><div class="fragment"><div class="line"><span class="comment">// For the following tree:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//       a</span></div>
<div class="line"><span class="comment">//     / | \________</span></div>
<div class="line"><span class="comment">//    /  |   \   \  \</span></div>
<div class="line"><span class="comment">// bee  ca  dee  ee  be</span></div>
<div class="line"><span class="comment">//            \</span></div>
<div class="line"><span class="comment">//             g</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// With pointers to each node (e.g. TreeNode* a):</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">std::vector&lt;sparta::TreeNode*&gt; r;</div>
<div class="line">std::vector&lt;std::vector&lt;std::string&gt;&gt; reps;</div>
<div class="line"> </div>
<div class="line">r.clear();</div>
<div class="line">assert(a-&gt;findChildren(<span class="stringliteral">&quot;bee&quot;</span>, r) == 1);</div>
<div class="line">assert(r[0] == bee);</div>
<div class="line"> </div>
<div class="line">r.clear();</div>
<div class="line">assert(a-&gt;findChildren(<span class="stringliteral">&quot;+ee&quot;</span>, r, reps) == 2);</div>
<div class="line">assert(find(r.begin(), r.end(), dee) != r.end()); <span class="comment">// Order of results not guaranteed</span></div>
<div class="line">assert(find(r.begin(), r.end(), bee) != r.end());</div>
<div class="line">assert(reps.at(0).at(0) == <span class="stringliteral">&quot;b&quot;</span>);</div>
<div class="line">assert(reps.at(1).at(0) == <span class="stringliteral">&quot;d&quot;</span>);</div>
<div class="line"> </div>
<div class="line">r.clear();</div>
<div class="line">assert(a-&gt;findChildren(<span class="stringliteral">&quot;*ee&quot;</span>, r) == 3);</div>
<div class="line">assert(find(r.begin(), r.end(), dee) != r.end()); <span class="comment">// Order of results not guaranteed</span></div>
<div class="line">assert(find(r.begin(), r.end(), bee) != r.end());</div>
<div class="line">assert(find(r.begin(), r.end(), ee) != r.end());</div>
<div class="line"> </div>
<div class="line">r.clear();</div>
<div class="line">assert(a-&gt;findChildren(<span class="stringliteral">&quot;*e+&quot;</span>, r) == 2);</div>
<div class="line">assert(find(r.begin(), r.end(), dee) != r.end()); <span class="comment">// Order of results not guaranteed</span></div>
<div class="line">assert(find(r.begin(), r.end(), bee) != r.end());</div>
<div class="line"> </div>
<div class="line">r.clear();</div>
<div class="line">assert(ca-&gt;findChildren(<span class="stringliteral">&quot;..dee.g&quot;</span>, r) == 1);</div>
<div class="line">assert(r[0] == g);</div>
</div><!-- fragment --><p> </span></p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l01420">1420</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a454fb71960c232bad1413c749c407a3b" name="a454fb71960c232bad1413c749c407a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a454fb71960c232bad1413c749c407a3b">&#9670;&#160;</a></span>findChildrenByTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sparta::TreeNode::findChildrenByTag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>results</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>max_depth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a set of all children having the selected tag which this node or descendants of this node within a distance of the given max_depth. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>Nodes having this tag will be placed into results vector </td></tr>
    <tr><td class="paramname">results</td><td>Vector of to which all results found by this method will be appended. This vector is not cleared </td></tr>
    <tr><td class="paramname">max_depth</td><td>Maximum depth of a ancestor/descendant relationship when filtring children. 0 means that any nodes returned must be the node on which this method is invoked, 1 means that any nodes returned can be this or immediate children, and so on. A max_depth of -1 means that there is no limit on ancestor-descendant distance</td></tr>
  </table>
  </dd>
</dl>
<p>This search works by searching the global tag map for the specified tag and then filtering this list for nodes which are a descendants of the node on which this method is invoked. </p>

</div>
</div>
<a id="a754479f743ac2addfcce2747ef1afb3f" name="a754479f743ac2addfcce2747ef1afb3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754479f743ac2addfcce2747ef1afb3f">&#9670;&#160;</a></span>findDelegate_() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , typename T , void(T::*)(const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &amp;, const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &amp;, const DataT &amp;) TMethod&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DelegateVector::iterator sparta::TreeNode::findDelegate_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab92c3c0688d1c33036a224f4ce57b715">DelegateVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dvec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>target_name</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a delegate associated with the given type T, object pointer, DataT, and TMethod within a DelevateVector. The intent of this function is to help see if a delegate is already registered with a calback by checking all known information associated with that callback against the input arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dvec</td><td>Vector of delegates to search </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>Object which owns the delegate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target_name</td><td>Name or pattern of notification type. that this is used as-is. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator within delegate vector parameter dvec. Will be a valid iterator if no matching delegate is found. Otherwise, will be dvec.end(). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Performs string comparison for delegate target name </dd></dl>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l03340">3340</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a754479f743ac2addfcce2747ef1afb3f" name="a754479f743ac2addfcce2747ef1afb3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754479f743ac2addfcce2747ef1afb3f">&#9670;&#160;</a></span>findDelegate_() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , typename T , void(T::*)(const DataT &amp;) TMethod&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DelegateVector::iterator sparta::TreeNode::findDelegate_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab92c3c0688d1c33036a224f4ce57b715">DelegateVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dvec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>target_name</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l03355">3355</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a244fd94fe20fad6c06500c6474522d1c" name="a244fd94fe20fad6c06500c6474522d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244fd94fe20fad6c06500c6474522d1c">&#9670;&#160;</a></span>findImmediateChildren_() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t sparta::TreeNode::findImmediateChildren_ </td>
          <td>(</td>
          <td class="paramtype">std::regex &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>found</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::string &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>replacements</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allow_private</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const-qualified variant of findImmediateChildren_. </p>

<p>Reimplemented in <a class="el" href="classsparta_1_1VirtualGlobalTreeNode.html#a4095aa74ced7df0995e5b53a09ea4911">sparta::VirtualGlobalTreeNode</a>.</p>

</div>
</div>
<a id="a9ac4c7b95e6ce15d29464218e989ffd5" name="a9ac4c7b95e6ce15d29464218e989ffd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac4c7b95e6ce15d29464218e989ffd5">&#9670;&#160;</a></span>findImmediateChildren_() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t sparta::TreeNode::findImmediateChildren_ </td>
          <td>(</td>
          <td class="paramtype">std::regex &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>found</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::string &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>replacements</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allow_private</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds immediate children with some identity (name or alias) matching a regex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Expression to match with child node identities </td></tr>
    <tr><td class="paramname">found</td><td>All nodes with matching identities are appended to this vector. This vector is not cleared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of children found in this call </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Does not recurse </dd></dl>

<p>Reimplemented in <a class="el" href="classsparta_1_1VirtualGlobalTreeNode.html#aa765b4dc8170856d7e01aa0f5d6df71b">sparta::VirtualGlobalTreeNode</a>.</p>

</div>
</div>
<a id="a8b1b9b2ae0628d9339688665fe1c2111" name="a8b1b9b2ae0628d9339688665fe1c2111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1b9b2ae0628d9339688665fe1c2111">&#9670;&#160;</a></span>getAliases()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#a991e1785f763d44925f4a53d89a44675">AliasVector</a> &amp; sparta::TreeNode::getAliases </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a vector of all aliases of this node. </p>
<dl class="section note"><dt>Note</dt><dd>This is a const vector matching the order and content of the internal alias list </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>const vector of alias strings referring to this node </dd></dl>

</div>
</div>
<a id="ae350a6316e5fc067d71de021b9d76d71" name="ae350a6316e5fc067d71de021b9d76d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae350a6316e5fc067d71de021b9d76d71">&#9670;&#160;</a></span>getAllConfigExtensionNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; std::string &gt; sparta::TreeNode::getAllConfigExtensionNames </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of extension names found for this node in all arch/config/extension files. </p>
<dl class="section note"><dt>Note</dt><dd>If you want a list of extension names for <b>instantiated</b> extensions that exist already on this node, call the method <a class="el" href="#af9e9902e2233c6c0781c53652c0474c4" title="Get a list of extension names for all instantiated extensions on this TreeNode.">getAllInstantiatedExtensionNames()</a>. </dd></dl>

</div>
</div>
<a id="a1d555432f77343119f980c47ac3768dc" name="a1d555432f77343119f980c47ac3768dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d555432f77343119f980c47ac3768dc">&#9670;&#160;</a></span>getAllExtensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, const ExtensionsBase * &gt; sparta::TreeNode::getAllExtensions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a map of extensions for this node. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l02133">2133</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1TreeNode_a1d555432f77343119f980c47ac3768dc_cgraph.png" border="0" usemap="#aclasssparta_1_1TreeNode_a1d555432f77343119f980c47ac3768dc_cgraph" alt=""/></div>
<map name="aclasssparta_1_1TreeNode_a1d555432f77343119f980c47ac3768dc_cgraph" id="aclasssparta_1_1TreeNode_a1d555432f77343119f980c47ac3768dc_cgraph">
<area shape="rect" title="Get a map of extensions for this node." alt="" coords="5,35,165,75"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#af9e9902e2233c6c0781c53652c0474c4" title="Get a list of extension names for all instantiated extensions on this TreeNode." alt="" coords="219,5,406,46"/>
<area shape="poly" title=" " alt="" coords="165,42,203,37,204,42,165,47"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a8c99280dc2adae048d57fb001d05de61" title="Get an extension without needing to specify any particular extension name. If no extensions exist,..." alt="" coords="213,70,413,96"/>
<area shape="poly" title=" " alt="" coords="165,62,197,66,197,71,165,67"/>
</map>
</div>

</div>
</div>
<a id="af9e9902e2233c6c0781c53652c0474c4" name="af9e9902e2233c6c0781c53652c0474c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e9902e2233c6c0781c53652c0474c4">&#9670;&#160;</a></span>getAllInstantiatedExtensionNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; std::string &gt; sparta::TreeNode::getAllInstantiatedExtensionNames </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of extension names for all <b>instantiated</b> extensions on this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>. </p>
<dl class="section note"><dt>Note</dt><dd>If you want a list of extension names found for this node in any arch/config/extension input YAML file, call the method <a class="el" href="#ae350a6316e5fc067d71de021b9d76d71" title="Get a list of extension names found for this node in all arch/config/extension files.">getAllConfigExtensionNames()</a>. </dd></dl>

</div>
</div>
<a id="ad4a5d5c788727dfd1d382872e2711c0e" name="ad4a5d5c788727dfd1d382872e2711c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a5d5c788727dfd1d382872e2711c0e">&#9670;&#160;</a></span>getAs() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename  = typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T sparta::TreeNode::getAs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves this node after casting to type const T. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of child expected </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const T* if this node was castable to const T* using dynamic_cast. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a></td><td>if this node could not be cast to T </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This method performs a dynamic cast (for now) and should not be used in performance-critical code</dd></dl>
<p>Overload of getAs for non-const access with pointer T type. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l01711">1711</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1TreeNode_ad4a5d5c788727dfd1d382872e2711c0e_cgraph.png" border="0" usemap="#aclasssparta_1_1TreeNode_ad4a5d5c788727dfd1d382872e2711c0e_cgraph" alt=""/></div>
<map name="aclasssparta_1_1TreeNode_ad4a5d5c788727dfd1d382872e2711c0e_cgraph" id="aclasssparta_1_1TreeNode_ad4a5d5c788727dfd1d382872e2711c0e_cgraph">
<area shape="rect" title="Retrieves this node after casting to type const T." alt="" coords="5,31,166,56"/>
<area shape="rect" href="namespacesparta.html#ac0a2df7a7ca53b2fc0384476286b95ec" title="Demangles a C++ symbol." alt="" coords="251,5,370,31"/>
<area shape="poly" title=" " alt="" coords="166,32,235,24,236,29,166,37"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a1a6d4aac10bfa5345b587d84170441de" title=" " alt="" coords="214,55,408,80"/>
<area shape="poly" title=" " alt="" coords="166,49,198,53,198,58,166,55"/>
</map>
</div>

</div>
</div>
<a id="aea061c7abb323917f0046feaca92545c" name="aea061c7abb323917f0046feaca92545c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea061c7abb323917f0046feaca92545c">&#9670;&#160;</a></span>getAs() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename  = typename std::enable_if&lt;!std::is_pointer&lt;T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * sparta::TreeNode::getAs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves this node after casting to type const T. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of child expected </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const T* if this node was castable to const T* using dynamic_cast. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a></td><td>if this node could not be cast to T </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This method performs a dynamic cast (for now) and should not be used in performance-critical code</dd></dl>
<p>Overload of getAs for non-const access with non-pointer T type </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l01734">1734</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1TreeNode_aea061c7abb323917f0046feaca92545c_cgraph.png" border="0" usemap="#aclasssparta_1_1TreeNode_aea061c7abb323917f0046feaca92545c_cgraph" alt=""/></div>
<map name="aclasssparta_1_1TreeNode_aea061c7abb323917f0046feaca92545c_cgraph" id="aclasssparta_1_1TreeNode_aea061c7abb323917f0046feaca92545c_cgraph">
<area shape="rect" title="Retrieves this node after casting to type const T." alt="" coords="5,31,166,56"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a164eb7014e7e50a5b4921c139f712056" title="Retrieves this node after casting to type T." alt="" coords="214,31,374,56"/>
<area shape="poly" title=" " alt="" coords="166,41,198,41,198,46,166,46"/>
<area shape="rect" href="namespacesparta.html#ac0a2df7a7ca53b2fc0384476286b95ec" title="Demangles a C++ symbol." alt="" coords="460,5,579,31"/>
<area shape="poly" title=" " alt="" coords="374,32,444,24,444,29,375,37"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a1a6d4aac10bfa5345b587d84170441de" title=" " alt="" coords="422,55,616,80"/>
<area shape="poly" title=" " alt="" coords="375,49,406,53,406,58,374,55"/>
</map>
</div>

</div>
</div>
<a id="a164eb7014e7e50a5b4921c139f712056" name="a164eb7014e7e50a5b4921c139f712056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164eb7014e7e50a5b4921c139f712056">&#9670;&#160;</a></span>getAs() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename  = typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value&gt;::type, class ConstT  = typename ptr_to_const_obj_ptr&lt;T&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstT sparta::TreeNode::getAs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves this node after casting to type T. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of child expected </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T* if this node was castable to T* using dynamic_cast. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a></td><td>if this node could not be cast to T </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This method performs a dynamic cast (for now) and should not be used in performance-critical code</dd></dl>
<p>This could eventually be optimized or used to provide meaningful errors by storing type information in <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l01673">1673</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1TreeNode_a164eb7014e7e50a5b4921c139f712056_cgraph.png" border="0" usemap="#aclasssparta_1_1TreeNode_a164eb7014e7e50a5b4921c139f712056_cgraph" alt=""/></div>
<map name="aclasssparta_1_1TreeNode_a164eb7014e7e50a5b4921c139f712056_cgraph" id="aclasssparta_1_1TreeNode_a164eb7014e7e50a5b4921c139f712056_cgraph">
<area shape="rect" title="Retrieves this node after casting to type T." alt="" coords="5,31,166,56"/>
<area shape="rect" href="namespacesparta.html#ac0a2df7a7ca53b2fc0384476286b95ec" title="Demangles a C++ symbol." alt="" coords="251,5,370,31"/>
<area shape="poly" title=" " alt="" coords="166,32,235,24,236,29,166,37"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a1a6d4aac10bfa5345b587d84170441de" title=" " alt="" coords="214,55,408,80"/>
<area shape="poly" title=" " alt="" coords="166,49,198,53,198,58,166,55"/>
</map>
</div>

</div>
</div>
<a id="ab8976dc0bb4634cc07e51f7f66d64a17" name="ab8976dc0bb4634cc07e51f7f66d64a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8976dc0bb4634cc07e51f7f66d64a17">&#9670;&#160;</a></span>getAs() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename  = typename std::enable_if&lt;!std::is_pointer&lt;T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * sparta::TreeNode::getAs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves this node after casting to type const T. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of child expected </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const T* if this node was castable to const T* using dynamic_cast. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a></td><td>if this node could not be cast to T </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This method performs a dynamic cast (for now) and should not be used in performance-critical code</dd></dl>
<p>Overload of getAs for const access with a pointer T type. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l01696">1696</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1TreeNode_ab8976dc0bb4634cc07e51f7f66d64a17_cgraph.png" border="0" usemap="#aclasssparta_1_1TreeNode_ab8976dc0bb4634cc07e51f7f66d64a17_cgraph" alt=""/></div>
<map name="aclasssparta_1_1TreeNode_ab8976dc0bb4634cc07e51f7f66d64a17_cgraph" id="aclasssparta_1_1TreeNode_ab8976dc0bb4634cc07e51f7f66d64a17_cgraph">
<area shape="rect" title="Retrieves this node after casting to type const T." alt="" coords="5,31,166,56"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a164eb7014e7e50a5b4921c139f712056" title="Retrieves this node after casting to type T." alt="" coords="214,31,374,56"/>
<area shape="poly" title=" " alt="" coords="166,41,198,41,198,46,166,46"/>
<area shape="rect" href="namespacesparta.html#ac0a2df7a7ca53b2fc0384476286b95ec" title="Demangles a C++ symbol." alt="" coords="460,5,579,31"/>
<area shape="poly" title=" " alt="" coords="374,32,444,24,444,29,375,37"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a1a6d4aac10bfa5345b587d84170441de" title=" " alt="" coords="422,55,616,80"/>
<area shape="poly" title=" " alt="" coords="375,49,406,53,406,58,374,55"/>
</map>
</div>

</div>
</div>
<a id="ac598185049018290d5ea6cb674d10473" name="ac598185049018290d5ea6cb674d10473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac598185049018290d5ea6cb674d10473">&#9670;&#160;</a></span>getChild() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * sparta::TreeNode::getChild </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>must_exist</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a child with this dotted path name. </p>
<dl class="section note"><dt>Note</dt><dd>this is not a full recursive search. The child, if found, will be N levels below this node where N Is dependent on the number of '.' tokens in the search string. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>path to child. This may be a single name or a dotted path refering to a node several levels below this node. </td></tr>
    <tr><td class="paramname">must_exist</td><td>If true, requires the child to exist by throwing an exception if it does not. If false, allows the method to return nullptr when no child is found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A valid TreeNode* if child is found by name. If child cannot be found and must_exist==true, throws <a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a>. Otherwise returns nullptr. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>no pattern matching supported in this method </dd>
<dd>
if a name matches on both an alias and a <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> name, the <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> name will take precedence </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a></td><td>if child is not found and must_exist==true</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line">assert(node.getName() == <span class="stringliteral">&quot;root&quot;</span>);</div>
<div class="line">assert(node.getChild(<span class="stringliteral">&quot;a.b.c&quot;</span>).getName() == <span class="stringliteral">&quot;c&quot;</span>);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l01530">1530</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a6e0acc7bdbe1cde5dd450e2a5677316f" name="a6e0acc7bdbe1cde5dd450e2a5677316f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e0acc7bdbe1cde5dd450e2a5677316f">&#9670;&#160;</a></span>getChild() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * sparta::TreeNode::getChild </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>must_exist</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloaded const-qualified. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l01537">1537</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a0f94b930f3b83dc49d0a114b79f725bf" name="a0f94b930f3b83dc49d0a114b79f725bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f94b930f3b83dc49d0a114b79f725bf">&#9670;&#160;</a></span>getChildAs() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename  = typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T sparta::TreeNode::getChildAs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>must_exist</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l01633">1633</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a51613b9aa45cc84a764c07ec34fb0043" name="a51613b9aa45cc84a764c07ec34fb0043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51613b9aa45cc84a764c07ec34fb0043">&#9670;&#160;</a></span>getChildAs() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename  = typename std::enable_if&lt;!std::is_pointer&lt;T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * sparta::TreeNode::getChildAs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>must_exist</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l01654">1654</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="ab18a936bf3a826ff18bd374d2a6b531d" name="ab18a936bf3a826ff18bd374d2a6b531d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab18a936bf3a826ff18bd374d2a6b531d">&#9670;&#160;</a></span>getChildAs() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename  = typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value&gt;::type, class ConstT  = typename ptr_to_const_obj_ptr&lt;T&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ConstT sparta::TreeNode::getChildAs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>must_exist</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a child that is castable to T with the given dotted path. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of child expected </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of child. May be a dotted path indicating multiple levels of device-tree traversal. </td></tr>
    <tr><td class="paramname">must_exist</td><td>If true, Causes an exception to be thrown if no child by this name could be found. If false, a nullptr is returned. Finding a child and failing to cast to T always causes an exception to be thrown </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T* if a child of the correct name is found and it was castable to T* using dynamic_cast. If child cannot be found and must_exist==true, throws <a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a>. Otherwise returns nullptr. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>no pattern matching supported in this method, but dotted paths are acceptable. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a></td><td>if must_exist==true and either the child by the given name (path) could not be found or the found node was not castable to T </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l01605">1605</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1TreeNode_ab18a936bf3a826ff18bd374d2a6b531d_cgraph.png" border="0" usemap="#aclasssparta_1_1TreeNode_ab18a936bf3a826ff18bd374d2a6b531d_cgraph" alt=""/></div>
<map name="aclasssparta_1_1TreeNode_ab18a936bf3a826ff18bd374d2a6b531d_cgraph" id="aclasssparta_1_1TreeNode_ab18a936bf3a826ff18bd374d2a6b531d_cgraph">
<area shape="rect" title="Retrieves a child that is castable to T with the given dotted path." alt="" coords="5,55,195,80"/>
<area shape="rect" href="namespacesparta.html#ac0a2df7a7ca53b2fc0384476286b95ec" title="Demangles a C++ symbol." alt="" coords="280,5,400,31"/>
<area shape="poly" title=" " alt="" coords="166,51,265,31,266,36,167,57"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#ac598185049018290d5ea6cb674d10473" title="Retrieves a child with this dotted path name." alt="" coords="253,55,426,80"/>
<area shape="poly" title=" " alt="" coords="195,65,238,65,238,70,195,70"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a1a6d4aac10bfa5345b587d84170441de" title=" " alt="" coords="243,104,437,130"/>
<area shape="poly" title=" " alt="" coords="167,78,259,98,258,103,166,84"/>
</map>
</div>

</div>
</div>
<a id="a95b665db735ea8bea394d85afd203fc0" name="a95b665db735ea8bea394d85afd203fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95b665db735ea8bea394d85afd203fc0">&#9670;&#160;</a></span>getChildAs() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename  = typename std::enable_if&lt;!std::is_pointer&lt;T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * sparta::TreeNode::getChildAs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>must_exist</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l01627">1627</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a4d156d0d58625322688c5db23d7abcd6" name="a4d156d0d58625322688c5db23d7abcd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d156d0d58625322688c5db23d7abcd6">&#9670;&#160;</a></span>getChildAt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * sparta::TreeNode::getChildAt </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a child at a position in the children vector in the order in which they were added to this node. </p>
<dl class="section warning"><dt>Warning</dt><dd>Do not use this method for iterating child nodes for the purpose of searching. Use getChild* and findChildren* methods instead. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a></td><td>if idx is out of range.</td></tr>
  </table>
  </dd>
</dl>
<p>This method is for iteration-purposes only (so that wrappers may avoid STL). The index used here is NOT a consistent property with any <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> or <a class="el" href="classsparta_1_1Resource.html" title="The is the base class for all types of resources used by the SPARTA framework.">Resource</a>. </p>

</div>
</div>
<a id="a63eb06c6b97cc1d58dde858e4d761550" name="a63eb06c6b97cc1d58dde858e4d761550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63eb06c6b97cc1d58dde858e4d761550">&#9670;&#160;</a></span>getChildren() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#af0a2fea735ac7c0116fd470ddb1b7744">ChildrenVector</a> sparta::TreeNode::getChildren </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a vector of all children of this node in any group in the order in which they were added to this node. </p>
<dl class="section note"><dt>Note</dt><dd>This is a const vector matching the order and content of the internal child list. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not use this method for iterating child nodes for the purpose of searching. Use getChild* and findChildren* methods instead. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>const vector of TreeNode* children</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This will only return the public children. Private children must be accessed via the <a class="el" href="classsparta_1_1TreeNodePrivateAttorney.html">TreeNodePrivateAttorney</a> available to the framework for traversing the entire tree, public and private. </dd></dl>

</div>
</div>
<a id="a71d8ac46557b407b8fb15b70a831cce6" name="a71d8ac46557b407b8fb15b70a831cce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71d8ac46557b407b8fb15b70a831cce6">&#9670;&#160;</a></span>getChildren() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sparta::TreeNode::getChildren </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>results</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignore_builtin_group</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignore_anonymous_nodes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets all children of this node in the order in which they were added to this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">results</td><td>Vector to which all children will be appended. This vector is not result. </td></tr>
    <tr><td class="paramname">ignore_builtin_group</td><td>Ignore any children in group GROUP_NAME_BUILTIN. </td></tr>
    <tr><td class="paramname">ignore_anonymous_nodes</td><td>Ignore any children in group GROUP_NAME_ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of children found</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This will only return the public children. Private children must be accessed via the <a class="el" href="classsparta_1_1TreeNodePrivateAttorney.html">TreeNodePrivateAttorney</a> available to the framework for traversing the entire tree, public and private. </dd></dl>

</div>
</div>
<a id="ae53352d950db4b085566de453e0d2e00" name="ae53352d950db4b085566de453e0d2e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53352d950db4b085566de453e0d2e00">&#9670;&#160;</a></span>getChildrenIdentifiers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sparta::TreeNode::getChildrenIdentifiers </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>idents</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignore_builtin_group</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets all child identifiers, aliases, group names, and group-aliases which can be used to refer to a child of this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idents</td><td>Vector to fill with new identities. Vector is not cleared. </td></tr>
    <tr><td class="paramname">ignore_builtin_group=true</td><td>If true, rejects the builtin group. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of identifiers added to idents </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>idents will be cleared and populated with names, aliases, and group names within this node. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Order of names retrieved should be considered random. Ordering is subject to change between calls due to use of a hash map internally. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Groups cannot currenly be retrieved by getChild. Do not iterate these idents and invoke getChild. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000064">Todo</a></b></dt><dd>Allow groups to be retrieved witih getChild </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method copies many strings. It should not be considered fast. </dd>
<dd>
Anonymous children names will not appear in this list. Their group and aliases will, however.</dd></dl>
<p>This is useful for shell completion when browsing the children of a node. </p>

</div>
</div>
<a id="acea0200191d0c9e5dc04bb558e6fda99" name="acea0200191d0c9e5dc04bb558e6fda99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea0200191d0c9e5dc04bb558e6fda99">&#9670;&#160;</a></span>getChildrenOfType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sparta::TreeNode::getChildrenOfType </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>results</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return all the children matching a particular type using dynamic cast. </p>
<dl class="section warning"><dt>Warning</dt><dd>This will only return the public children. Private children must be accessed via the <a class="el" href="classsparta_1_1TreeNodePrivateAttorney.html">TreeNodePrivateAttorney</a> available to the framework for traversing the entire tree, public and private. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l01135">1135</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1TreeNode_acea0200191d0c9e5dc04bb558e6fda99_cgraph.png" border="0" usemap="#aclasssparta_1_1TreeNode_acea0200191d0c9e5dc04bb558e6fda99_cgraph" alt=""/></div>
<map name="aclasssparta_1_1TreeNode_acea0200191d0c9e5dc04bb558e6fda99_cgraph" id="aclasssparta_1_1TreeNode_acea0200191d0c9e5dc04bb558e6fda99_cgraph">
<area shape="rect" title="return all the children matching a particular type using dynamic cast." alt="" coords="5,5,197,46"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a63eb06c6b97cc1d58dde858e4d761550" title="Gets a vector of all children of this node in any group in the order in which they were added to this..." alt="" coords="245,13,436,38"/>
<area shape="poly" title=" " alt="" coords="197,23,229,23,229,28,197,28"/>
</map>
</div>

</div>
</div>
<a id="ad2ceac50d187c3e2fefab08f590f6f3c" name="ad2ceac50d187c3e2fefab08f590f6f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ceac50d187c3e2fefab08f590f6f3c">&#9670;&#160;</a></span>getClock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsparta_1_1Clock.html">Clock</a> * sparta::TreeNode::getClock </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l02259">2259</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="aec70f36a682dadc1d571fcd723f12cd6" name="aec70f36a682dadc1d571fcd723f12cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec70f36a682dadc1d571fcd723f12cd6">&#9670;&#160;</a></span>getClock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsparta_1_1Clock.html">Clock</a> * sparta::TreeNode::getClock </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Walks up parents (starting with self) until a parent with an associated local clock is found, then returns that clock. </p>
<dl class="section return"><dt>Returns</dt><dd>The clock of the first ancestor (including self) which has a valid clock through getLocalClock. If no ancestor has a clock, returns nullptr </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a883ef289de0f961e1d69a988b50338d8" title="Gets the clock associated directly with this Node. This is useful for configuration and simulator deb...">getLocalClock</a></dd></dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>

<p>Implements <a class="el" href="classsparta_1_1ResourceContainer.html#a07263585cfec6c42a63b9f7e7d8f97d1">sparta::ResourceContainer</a>.</p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l02239">2239</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1TreeNode_aec70f36a682dadc1d571fcd723f12cd6_cgraph.png" border="0" usemap="#aclasssparta_1_1TreeNode_aec70f36a682dadc1d571fcd723f12cd6_cgraph" alt=""/></div>
<map name="aclasssparta_1_1TreeNode_aec70f36a682dadc1d571fcd723f12cd6_cgraph" id="aclasssparta_1_1TreeNode_aec70f36a682dadc1d571fcd723f12cd6_cgraph">
<area shape="rect" title="Walks up parents (starting with self) until a parent with an associated local clock is found,..." alt="" coords="5,70,183,96"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a883ef289de0f961e1d69a988b50338d8" title="Gets the clock associated directly with this Node. This is useful for configuration and simulator deb..." alt="" coords="234,5,410,46"/>
<area shape="poly" title=" " alt="" coords="147,67,223,48,224,53,149,72"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#aa8958d72a1f5aeff2ec36012913ac09c" title="Gets immediate parent of this node if one exists." alt="" coords="231,70,413,96"/>
<area shape="poly" title=" " alt="" coords="183,80,215,80,215,86,183,86"/>
<area shape="rect" href="classsparta_1_1PhasedObject.html#ac8edefaf47c41a0be179827e657955d5" title="Is this node (and thus the entire tree above it) &quot;finalized&quot;." alt="" coords="249,120,394,161"/>
<area shape="poly" title=" " alt="" coords="149,94,235,116,233,121,147,99"/>
</map>
</div>

</div>
</div>
<a id="a8e0703ca8742ef2de67a0d876ccb0c6e" name="a8e0703ca8742ef2de67a0d876ccb0c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e0703ca8742ef2de67a0d876ccb0c6e">&#9670;&#160;</a></span>getDeepestMatchingPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string sparta::TreeNode::getDeepestMatchingPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the deepest whole node location starting from <em>this</em> node that matches some part of <em>path</em> starting at its beginning. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to node relative this <em>this</em> node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dotted node path to the deepest ancestor of <em>this</em> node whose location matches <em>path</em> from the beginning. If the node described by <em>path</em> exists, returns the a path to the node identified by <em>path</em>. Note that the returned string could differ in this case if <em>path</em> contained aliases. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is an expensive operation as it is a recursive search. It should not be called at run-time.</dd></dl>
<p>Ths intent of this is to find out where a path given by a user (e.g. configuration file) diverged from the actual tree for feedback purposes </p>

</div>
</div>
<a id="aa7191a8362fd6e301d2e6f8c37922a87" name="aa7191a8362fd6e301d2e6f8c37922a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7191a8362fd6e301d2e6f8c37922a87">&#9670;&#160;</a></span>getDelegatesRegisteredForNotification()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::getDelegatesRegisteredForNotification </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;</td>          <td class="paramname"><span class="paramname"><em>tinfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsparta_1_1TreeNode_1_1delegate.html">delegate</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dels</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the vector of delegates registered for a notification on this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tinfo</td><td>typeid of the notification to be queried </td></tr>
    <tr><td class="paramname">name</td><td>Name of the notification to be queried (Can be "" to ignore name) </td></tr>
    <tr><td class="paramname">dels</td><td>Vector to which all found delegates matching search parameters will be appended. This vector is not cleared </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e94c653b4d23af19a26ad92b8a17bba" name="a2e94c653b4d23af19a26ad92b8a17bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e94c653b4d23af19a26ad92b8a17bba">&#9670;&#160;</a></span>getDesc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; sparta::TreeNode::getDesc </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the description of this node. </p>
<dl class="section return"><dt>Returns</dt><dd>string description of this node </dd></dl>

</div>
</div>
<a id="aa3290748a9c922f7c9c9dc1f919e0418" name="aa3290748a9c922f7c9c9dc1f919e0418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3290748a9c922f7c9c9dc1f919e0418">&#9670;&#160;</a></span>getDisplayLocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string sparta::TreeNode::getDisplayLocation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the location of this node in the device tree which <em>might</em> not be usable for navigating the device tree (it cannot be used as an argument for getChild/findChildren). </p>
<dl class="section return"><dt>Returns</dt><dd>Location string that is nice for presentation, even if not progamatically useful in the getChild/findChildren methods.</dd></dl>
<p>This differs from getLocation by representing nodes with groups and no names as "group[group_index]" instead of "name". This string cannot currently be used to find children by pattern or name because it refers to a group.</p>
<p>A motifivation for this method is to allow identification of elements in anonymous buffers and queue resources to simulator tools. </p>

</div>
</div>
<a id="a8c99280dc2adae048d57fb001d05de61" name="a8c99280dc2adae048d57fb001d05de61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c99280dc2adae048d57fb001d05de61">&#9670;&#160;</a></span>getExtension() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ExtensionsBase * sparta::TreeNode::getExtension </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an extension without needing to specify any particular extension name. If no extensions exist, returns nullptr. If only one extension exists, returns that extension. If more than one extension exists, throws an exception. </p>
<dl class="section note"><dt>Note</dt><dd>If 'this' tree node was not given an extension in any of the &ndash;extension-file, &ndash;arch, &ndash;config-file, or &ndash;node-config-file YAML files, then this will always return nullptr. If you want to create an extension for this node on demand, call createExtension(name). </dd></dl>

</div>
</div>
<a id="a9d4107352f9e07846b812d794d5a38a5" name="a9d4107352f9e07846b812d794d5a38a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d4107352f9e07846b812d794d5a38a5">&#9670;&#160;</a></span>getExtension() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ExtensionsBase * sparta::TreeNode::getExtension </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an extension without needing to specify any particular extension name. If no extensions exist, returns nullptr. If only one extension exists, returns that extension. If more than one extension exists, throws an exception. </p>
<dl class="section note"><dt>Note</dt><dd>If 'this' tree node was not given an extension in any of the &ndash;extension-file, &ndash;arch, &ndash;config-file, or &ndash;node-config-file YAML files, then this will always return nullptr. If you want to create an extension for this node on demand, call createExtension(name). </dd>
<dd>
Unlike the non-const version, this method will never create the extension automatically under the hood, nor will it cache the extension for performance. </dd></dl>

</div>
</div>
<a id="a5469acef24d1a7d7058ce18cfb76c725" name="a5469acef24d1a7d7058ce18cfb76c725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5469acef24d1a7d7058ce18cfb76c725">&#9670;&#160;</a></span>getExtension() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ExtensionsBase * sparta::TreeNode::getExtension </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>extension_name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an extension object by type string. Returns nullptr if not found (unrecognized). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extension_name</td><td>The name of the extension to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If 'this' tree node was not given an extension in any of the &ndash;extension-file, &ndash;arch, &ndash;config-file, or &ndash;node-config-file YAML files, then this will always return nullptr. If you want to create an extension for this node on demand, call createExtension(name). </dd></dl>

</div>
</div>
<a id="a2433c4a7d26a10420ff908fdfe59ee01" name="a2433c4a7d26a10420ff908fdfe59ee01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2433c4a7d26a10420ff908fdfe59ee01">&#9670;&#160;</a></span>getExtension() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ExtensionsBase * sparta::TreeNode::getExtension </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>extension_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>no_factory_ok</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an extension object by type string. Returns nullptr if not found (unrecognized). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extension_name</td><td>The name of the extension to find </td></tr>
    <tr><td class="paramname">no_factory_ok</td><td>If true, and this tree node was in one of the arch/config/extension YAML input files, and no factory exists for the extension name, return a configured ExtensionsParamsOnly. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If 'this' tree node was not given an extension in any of the &ndash;extension-file, &ndash;arch, &ndash;config-file, or &ndash;node-config-file YAML files, then this will always return nullptr. If you want to create an extension for this node on demand, call createExtension(name). </dd></dl>

</div>
</div>
<a id="acd23bf68d7472b74099c35a5aafe0b9e" name="acd23bf68d7472b74099c35a5aafe0b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd23bf68d7472b74099c35a5aafe0b9e">&#9670;&#160;</a></span>getExtensionAs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * sparta::TreeNode::getExtensionAs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>extension_name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an extension, downcast to the given type. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Throws</td><td>an exception if the extension exists, but the downcast failed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l01926">1926</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1TreeNode_acd23bf68d7472b74099c35a5aafe0b9e_cgraph.png" border="0" usemap="#aclasssparta_1_1TreeNode_acd23bf68d7472b74099c35a5aafe0b9e_cgraph" alt=""/></div>
<map name="aclasssparta_1_1TreeNode_acd23bf68d7472b74099c35a5aafe0b9e_cgraph" id="aclasssparta_1_1TreeNode_acd23bf68d7472b74099c35a5aafe0b9e_cgraph">
<area shape="rect" title="Get an extension, downcast to the given type." alt="" coords="5,5,222,31"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a8c99280dc2adae048d57fb001d05de61" title="Get an extension without needing to specify any particular extension name. If no extensions exist,..." alt="" coords="270,5,470,31"/>
<area shape="poly" title=" " alt="" coords="222,16,254,16,254,21,222,21"/>
</map>
</div>

</div>
</div>
<a id="a1ecd57d84a123959187276ee2404c475" name="a1ecd57d84a123959187276ee2404c475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ecd57d84a123959187276ee2404c475">&#9670;&#160;</a></span>getExtensionAs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * sparta::TreeNode::getExtensionAs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>extension_name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an extension, downcast to the given type. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Throws</td><td>an exception if the extension exists, but the downcast failed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l01948">1948</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1TreeNode_a1ecd57d84a123959187276ee2404c475_cgraph.png" border="0" usemap="#aclasssparta_1_1TreeNode_a1ecd57d84a123959187276ee2404c475_cgraph" alt=""/></div>
<map name="aclasssparta_1_1TreeNode_a1ecd57d84a123959187276ee2404c475_cgraph" id="aclasssparta_1_1TreeNode_a1ecd57d84a123959187276ee2404c475_cgraph">
<area shape="rect" title="Get an extension, downcast to the given type." alt="" coords="5,5,222,31"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a8c99280dc2adae048d57fb001d05de61" title="Get an extension without needing to specify any particular extension name. If no extensions exist,..." alt="" coords="270,5,470,31"/>
<area shape="poly" title=" " alt="" coords="222,16,254,16,254,21,222,21"/>
</map>
</div>

</div>
</div>
<a id="aebcc01a3bfce8b3830e39aba1e63d9f6" name="aebcc01a3bfce8b3830e39aba1e63d9f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebcc01a3bfce8b3830e39aba1e63d9f6">&#9670;&#160;</a></span>getGroup() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; sparta::TreeNode::getGroup </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the group name of this node. </p>
<dl class="section return"><dt>Returns</dt><dd>string group name of this node </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a361467ba0817226281612c6cfdf1671b" title="Group name indicating that a node belongs to no group.">GROUP_NAME_NONE</a> </dd></dl>

</div>
</div>
<a id="a28436401cbe813f5ea99f4c09615fef4" name="a28436401cbe813f5ea99f4c09615fef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28436401cbe813f5ea99f4c09615fef4">&#9670;&#160;</a></span>getGroup() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sparta::TreeNode::getGroup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>results</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets all nodes in a child group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>Name of group to get children from. If GROUP_NAME_NONE, will retrieve only children with group=GROUP_NAME_NONE. </td></tr>
    <tr><td class="paramname">results</td><td>Vector of nodes to which results will be appended. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of nodes found in the group </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000067">Todo</a></b></dt><dd>Optimize lookup by group using mappings</dd></dl>
<p>To get all children regardless of group, use getChildren </p>

</div>
</div>
<a id="aadc69fe186075177c6559e84188982e9" name="aadc69fe186075177c6559e84188982e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc69fe186075177c6559e84188982e9">&#9670;&#160;</a></span>getGroupIdx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7fa01f145455d583b8f16e0f923b7c7c">group_idx_type</a> sparta::TreeNode::getGroupIdx </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the group index of this node. </p>
<dl class="section return"><dt>Returns</dt><dd>string group index of this node </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a0c31b9fc57737636c1b76f7ec7ed0315" title="GroupIndex indicating that a node has no group index because it belongs to no group.">GROUP_IDX_NONE</a> </dd></dl>

</div>
</div>
<a id="a6a8509bfb982375b090e6e2d280bc0dd" name="a6a8509bfb982375b090e6e2d280bc0dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a8509bfb982375b090e6e2d280bc0dd">&#9670;&#160;</a></span>getGroupIndexMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7fa01f145455d583b8f16e0f923b7c7c">group_idx_type</a> sparta::TreeNode::getGroupIndexMax </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>group</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the largest index of a node in the given group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>Name of group to get the index from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Largest group index in the given group, including anonymous nodes. If group is GROUP_NAME_NONE, searches for nodes with that group name (not in a group). If there are no nodes in the chosen group, returns GROUP_NAME_NONE. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000066">Todo</a></b></dt><dd>Optimize this count by storing group mappings </dd></dl>

</div>
</div>
<a id="a6cd50034f379a6e442d479535def905e" name="a6cd50034f379a6e442d479535def905e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd50034f379a6e442d479535def905e">&#9670;&#160;</a></span>getGroupNamePtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string * sparta::TreeNode::getGroupNamePtr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the group name string pointer (interned in <a class="el" href="classsparta_1_1StringManager.html" title="Manages string internment for SPARTA. This allows strings to be compared by pointer once interned.">StringManager</a> singleton) of this node. </p>
<dl class="section return"><dt>Returns</dt><dd>string pointer to group name of this node which can be compared with other strings interned in <a class="el" href="classsparta_1_1StringManager.html" title="Manages string internment for SPARTA. This allows strings to be compared by pointer once interned.">StringManager</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a361467ba0817226281612c6cfdf1671b" title="Group name indicating that a node belongs to no group.">GROUP_NAME_NONE</a> </dd></dl>

</div>
</div>
<a id="ace29f38285cf6318c8c2973e028c1588" name="ace29f38285cf6318c8c2973e028c1588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace29f38285cf6318c8c2973e028c1588">&#9670;&#160;</a></span>getGroupSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sparta::TreeNode::getGroupSize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>group</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of nodes in a group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>Name of group to get children from. If GROUP_NAME_NONE, will retrieve only children with group=GROUP_NAME_NONE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of children in this group, including anonymous nodes. Aliases do not affect this result </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000065">Todo</a></b></dt><dd>Optimize this count by storing group sizes (or group vectors) in <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>.</dd></dl>
<p>To count all children regardless of group, use getNumChildren </p>

</div>
</div>
<a id="aa799fcb616aca8d0e88e7c509bfbbb77" name="aa799fcb616aca8d0e88e7c509bfbbb77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa799fcb616aca8d0e88e7c509bfbbb77">&#9670;&#160;</a></span>getIdentifiers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; const std::string * &gt; sparta::TreeNode::getIdentifiers </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets all the identifiers for this node (excluding groups) </p>
<dl class="section return"><dt>Returns</dt><dd>A vector of string pointers. Elements are guaranteed to be non-null </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>These identifiers are pointers to strings in members and vectors of this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> instance. Altering the name or aliases or group of this Node will invalidate the result vector of this call </dd>
<dd>
The returned vector is re-built each call </dd></dl>

</div>
</div>
<a id="a7081d66107154ff903323fd174795340" name="a7081d66107154ff903323fd174795340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7081d66107154ff903323fd174795340">&#9670;&#160;</a></span>getLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sparta::TreeNode::getLevel </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the level of this node. 0 is root. </p>
<dl class="section warning"><dt>Warning</dt><dd>This can change when the node is connected to a tree. Generally, this should only be queried once the Tree has exited the TREE_FINALIZED phase because level cannot cahnge after finalization. (see isFinalized)</dd></dl>
<p>This is computed based on the number of parents iterated until a node with no parents is reached. </p>

</div>
</div>
<a id="a883ef289de0f961e1d69a988b50338d8" name="a883ef289de0f961e1d69a988b50338d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883ef289de0f961e1d69a988b50338d8">&#9670;&#160;</a></span>getLocalClock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsparta_1_1Clock.html">Clock</a> * sparta::TreeNode::getLocalClock </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the clock associated directly with this Node. This is useful for configuration and simulator debug, but not at run-time. </p>
<dl class="section note"><dt>Note</dt><dd>In general, it is preferable to use getClock to find the closest attached clock in this Node's ancestry. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classsparta_1_1Clock.html" title="A representation of simulated time.">Clock</a> directly attached to this Node (if any). Returning nullptr means no attached clock, however this Node is considered to be within the nearest ancestor's clock. getClock will find nearest ancestor's clock (or local clock, if present)</dd></dl>
<p>By default TreeNodes are not associated (or required to be associated) with a <a class="el" href="classsparta_1_1Clock.html" title="A representation of simulated time.">sparta::Clock</a>. Subclasses may require this, however.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l02289">2289</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="ae1490e10061ce9dd5d53495f65b29f7d" name="ae1490e10061ce9dd5d53495f65b29f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1490e10061ce9dd5d53495f65b29f7d">&#9670;&#160;</a></span>getLocalClock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsparta_1_1Clock.html">Clock</a> * sparta::TreeNode::getLocalClock </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l02296">2296</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a1a6d4aac10bfa5345b587d84170441de" name="a1a6d4aac10bfa5345b587d84170441de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a6d4aac10bfa5345b587d84170441de">&#9670;&#160;</a></span>getLocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string sparta::TreeNode::getLocation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classsparta_1_1PhasedObject.html#a2dcca61565924f0a4208c6509f9a42ba" title="Returns the location of this node in device tree which can be used to navigate the device tree in met...">sparta::PhasedObject::getLocation</a> </dd></dl>

<p>Implements <a class="el" href="classsparta_1_1PhasedObject.html#a2dcca61565924f0a4208c6509f9a42ba">sparta::PhasedObject</a>.</p>

</div>
</div>
<a id="abfa3602a9ab827b1351ef8f518c32576" name="abfa3602a9ab827b1351ef8f518c32576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa3602a9ab827b1351ef8f518c32576">&#9670;&#160;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; sparta::TreeNode::getName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the name of this node. </p>
<dl class="section return"><dt>Returns</dt><dd>string name of this node </dd></dl>

<p>Implements <a class="el" href="classsparta_1_1PhasedObject.html#a5ac4d8d0efe306e61a3804f765cf6278">sparta::PhasedObject</a>.</p>

</div>
</div>
<a id="a7afd83be527cc01da733615ce85726dc" name="a7afd83be527cc01da733615ce85726dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7afd83be527cc01da733615ce85726dc">&#9670;&#160;</a></span>getNamePtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string * sparta::TreeNode::getNamePtr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the name of this node's string pointer which isinterned in <a class="el" href="classsparta_1_1StringManager.html" title="Manages string internment for SPARTA. This allows strings to be compared by pointer once interned.">StringManager</a>) </p>
<dl class="section return"><dt>Returns</dt><dd>String pointer. Guaranteed not to be null </dd></dl>

</div>
</div>
<a id="a1ef80729c2131ffb68b5e62b5002c321" name="a1ef80729c2131ffb68b5e62b5002c321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef80729c2131ffb68b5e62b5002c321">&#9670;&#160;</a></span>getNextName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string sparta::TreeNode::getNextName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the next name between two '.' chars in a string starting at <em>pos</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name string to parse </td></tr>
    <tr><td class="paramname">pos</td><td>Position in name to begin parsing. Will be updated to location of the next '.' found plus 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String between pos and the next '.' found.</dd></dl>
<p>Used for parsing tree paths: </p><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> pos = 4;</div>
<div class="line">assert(<a class="code hl_function" href="#a1ef80729c2131ffb68b5e62b5002c321">getNextName</a>(<span class="stringliteral">&quot;top.a.b.c&quot;</span>, pos) == <span class="charliteral">&#39;a&#39;</span>);</div>
<div class="line">assert(pos == 6);</div>
<div class="ttc" id="aclasssparta_1_1TreeNode_html_a1ef80729c2131ffb68b5e62b5002c321"><div class="ttname"><a href="#a1ef80729c2131ffb68b5e62b5002c321">sparta::TreeNode::getNextName</a></div><div class="ttdeci">static std::string getNextName(const std::string &amp;name, size_t &amp;pos)</div><div class="ttdoc">Gets the next name between two '.' chars in a string starting at pos.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac58ee3afd3ce00f3d8c42cd75a65c097" name="ac58ee3afd3ce00f3d8c42cd75a65c097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac58ee3afd3ce00f3d8c42cd75a65c097">&#9670;&#160;</a></span>getNumChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sparta::TreeNode::getNumChildren </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of children that this node has including those in the sparta builtins group. </p>
<dl class="section return"><dt>Returns</dt><dd>Integer representing number of children in any group.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This will only return the public children. Private children must be accessed via the <a class="el" href="classsparta_1_1TreeNodePrivateAttorney.html">TreeNodePrivateAttorney</a> available to the framework for traversing the entire tree, public and private. </dd></dl>

</div>
</div>
<a id="a319509d49b71536682de2c35856ae24c" name="a319509d49b71536682de2c35856ae24c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319509d49b71536682de2c35856ae24c">&#9670;&#160;</a></span>getNumExtensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t sparta::TreeNode::getNumExtensions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of extensions for this node. </p>
<dl class="section note"><dt>Note</dt><dd>This refers to the number of <b>instantiated</b> extensions on this node. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l02126">2126</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1TreeNode_a319509d49b71536682de2c35856ae24c_cgraph.png" border="0" usemap="#aclasssparta_1_1TreeNode_a319509d49b71536682de2c35856ae24c_cgraph" alt=""/></div>
<map name="aclasssparta_1_1TreeNode_a319509d49b71536682de2c35856ae24c_cgraph" id="aclasssparta_1_1TreeNode_a319509d49b71536682de2c35856ae24c_cgraph">
<area shape="rect" title="Get the number of extensions for this node." alt="" coords="5,5,178,46"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#af9e9902e2233c6c0781c53652c0474c4" title="Get a list of extension names for all instantiated extensions on this TreeNode." alt="" coords="226,5,413,46"/>
<area shape="poly" title=" " alt="" coords="178,23,210,23,210,28,178,28"/>
</map>
</div>

</div>
</div>
<a id="aa8958d72a1f5aeff2ec36012913ac09c" name="aa8958d72a1f5aeff2ec36012913ac09c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8958d72a1f5aeff2ec36012913ac09c">&#9670;&#160;</a></span>getParent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * sparta::TreeNode::getParent </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets immediate parent of this node if one exists. </p>
<dl class="section return"><dt>Returns</dt><dd>parent <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> if there is one. Otherwise returns 0.</dd></dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>

<p>Reimplemented in <a class="el" href="classsparta_1_1GlobalTreeNode.html#adda271ac6faf3fc39bd4285b45dbea8f">sparta::GlobalTreeNode</a>, <a class="el" href="classsparta_1_1RootTreeNode.html#adb246e9be990079ee8557e8458d6a3f3">sparta::RootTreeNode</a>, and <a class="el" href="classsparta_1_1VirtualGlobalTreeNode.html#ad2ea5acc44d417ff95dae98fe75cbff9">sparta::VirtualGlobalTreeNode</a>.</p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00964">964</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="aad888851269c4ccd2009b66b5d6cb111" name="aad888851269c4ccd2009b66b5d6cb111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad888851269c4ccd2009b66b5d6cb111">&#9670;&#160;</a></span>getParent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * sparta::TreeNode::getParent </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00971">971</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a05c4ab072677438d088d7d99c1f585f6" name="a05c4ab072677438d088d7d99c1f585f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05c4ab072677438d088d7d99c1f585f6">&#9670;&#160;</a></span>getParentAs() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename  = typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T sparta::TreeNode::getParentAs </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>must_exist</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l01009">1009</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a51788dafac480f1e80ee6167e2c3da06" name="a51788dafac480f1e80ee6167e2c3da06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51788dafac480f1e80ee6167e2c3da06">&#9670;&#160;</a></span>getParentAs() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename  = typename std::enable_if&lt;!std::is_pointer&lt;T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * sparta::TreeNode::getParentAs </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>must_exist</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l01023">1023</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a3e274bfe8a716d699ad67e74212c87b9" name="a3e274bfe8a716d699ad67e74212c87b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e274bfe8a716d699ad67e74212c87b9">&#9670;&#160;</a></span>getParentAs() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename  = typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T sparta::TreeNode::getParentAs </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>must_exist</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a parent casted to type T* if this node has a parent. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of parent to cast to </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">must_exist</td><td>If true, Causes an exception to be thrown if node has no parent or the parent cannot be dynamically cast to T*. If false, a nullptr is returned when this node has no parent that can be cast to T*. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Parent as a T* if the parent exists and was castable to T* using dynamic_cast. If this node has no parent which can be cast to T*, and must_exist == true, throws. Otherwise, returns nullptr </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a></td><td>if must_exist==true and the parent was null or the parent could not be cast to a T*. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00989">989</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1TreeNode_a3e274bfe8a716d699ad67e74212c87b9_cgraph.png" border="0" usemap="#aclasssparta_1_1TreeNode_a3e274bfe8a716d699ad67e74212c87b9_cgraph" alt=""/></div>
<map name="aclasssparta_1_1TreeNode_a3e274bfe8a716d699ad67e74212c87b9_cgraph" id="aclasssparta_1_1TreeNode_a3e274bfe8a716d699ad67e74212c87b9_cgraph">
<area shape="rect" title="Retrieves a parent casted to type T* if this node has a parent." alt="" coords="5,55,204,80"/>
<area shape="rect" href="namespacesparta.html#ac0a2df7a7ca53b2fc0384476286b95ec" title="Demangles a C++ symbol." alt="" coords="289,5,408,31"/>
<area shape="poly" title=" " alt="" coords="171,51,273,31,274,36,172,57"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a1a6d4aac10bfa5345b587d84170441de" title=" " alt="" coords="252,55,446,80"/>
<area shape="poly" title=" " alt="" coords="204,65,236,65,236,70,204,70"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#aa8958d72a1f5aeff2ec36012913ac09c" title="Gets immediate parent of this node if one exists." alt="" coords="258,104,440,130"/>
<area shape="poly" title=" " alt="" coords="172,78,267,98,266,103,171,84"/>
</map>
</div>

</div>
</div>
<a id="adcfcd5236cbc9208cbcbbbfadd73ec37" name="adcfcd5236cbc9208cbcbbbfadd73ec37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcfcd5236cbc9208cbcbbbfadd73ec37">&#9670;&#160;</a></span>getParentAs() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename  = typename std::enable_if&lt;!std::is_pointer&lt;T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * sparta::TreeNode::getParentAs </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>must_exist</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l01003">1003</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="af31ac794edcf81e88d28157056e91292" name="af31ac794edcf81e88d28157056e91292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31ac794edcf81e88d28157056e91292">&#9670;&#160;</a></span>getPossibleNotifications()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sparta::TreeNode::getPossibleNotifications </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structsparta_1_1TreeNode_1_1NotificationInfo.html">NotificationInfo</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>infos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets information on the possible notifications generated by this node (excludes children). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">infos</td><td>Vector of notification inormation to which this node's information will be added </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of infos appended to the infos vector. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>infos has <a class="el" href="structsparta_1_1TreeNode_1_1NotificationInfo.html" title="Notification type/name information.">NotificationInfo</a> instances appended. Original content remains in place. Vector can only grow. </dd></dl>

</div>
</div>
<a id="a53f97e7a78ab1d0874515d2752381561" name="a53f97e7a78ab1d0874515d2752381561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f97e7a78ab1d0874515d2752381561">&#9670;&#160;</a></span>getPossibleSubtreeNotifications()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sparta::TreeNode::getPossibleSubtreeNotifications </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structsparta_1_1TreeNode_1_1NotificationInfo.html">NotificationInfo</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>infos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets information on the possible notifications generated by this node and all its descendants. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">infos</td><td>Vector of notification information to which this node's information will be added </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of infos appended to the infos vector </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>infos has <a class="el" href="structsparta_1_1TreeNode_1_1NotificationInfo.html" title="Notification type/name information.">NotificationInfo</a> instances appended from this node and all descendants. Vector can only grow. </dd></dl>

</div>
</div>
<a id="a84a42a6710fd8458fb5699c259229e6a" name="a84a42a6710fd8458fb5699c259229e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a42a6710fd8458fb5699c259229e6a">&#9670;&#160;</a></span>getPreviousName_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string sparta::TreeNode::getPreviousName_ </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the previous name between two '.' chars in a string starting at <em>pos</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name string to parse </td></tr>
    <tr><td class="paramname">pos</td><td>Position in name to begin parsing in reverse. Must coincide with a '.' or end of string. Will be updated to location of the next '.' found. Set to npos if the beginning of the string is reached. To start parsing a string from the end, should be set to length of string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String between (excluding) pos and the '.' found earlier in the string.</dd></dl>
<p>Used for parsing tree paths: </p><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> pos = 5;</div>
<div class="line">assert(<a class="code hl_function" href="#a84a42a6710fd8458fb5699c259229e6a">getPreviousName_</a>(<span class="stringliteral">&quot;top.a.b.c&quot;</span>, pos) == <span class="charliteral">&#39;a&#39;</span>);</div>
<div class="line">assert(pos == 3);</div>
<div class="ttc" id="aclasssparta_1_1TreeNode_html_a84a42a6710fd8458fb5699c259229e6a"><div class="ttname"><a href="#a84a42a6710fd8458fb5699c259229e6a">sparta::TreeNode::getPreviousName_</a></div><div class="ttdeci">static std::string getPreviousName_(const std::string &amp;name, size_t &amp;pos)</div><div class="ttdoc">Gets the previous name between two '.' chars in a string starting at pos.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab113915ff2dc4b8ebfee5380eb912994" name="ab113915ff2dc4b8ebfee5380eb912994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab113915ff2dc4b8ebfee5380eb912994">&#9670;&#160;</a></span>getRecursiveNodeCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sparta::TreeNode::getRecursiveNodeCount </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively gets the count of a nodes that are a subclass of a particular type (determined by dynamic_cast). Includes all descendants of this node in the tree, but excludes this node. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l01853">1853</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a31666fa4b498cd468991f2099e3fbbf7" name="a31666fa4b498cd468991f2099e3fbbf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31666fa4b498cd468991f2099e3fbbf7">&#9670;&#160;</a></span>getRoot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * sparta::TreeNode::getRoot </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets farthest ancestor of this node. </p>
<dl class="section return"><dt>Returns</dt><dd>farthest ancestor <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>. May be this if node has no parent. Return value will never be nullptr </dd></dl>
<dl class="section note"><dt>Note</dt><dd>returned <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> may not be an actual <a class="el" href="classsparta_1_1RootTreeNode.html" title="TreeNode which represents the root (&quot;top&quot;) of a device tree.">RootTreeNode</a></dd></dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>

</div>
</div>
<a id="ad7432fe0422eaa5afed7848effbc7d8f" name="ad7432fe0422eaa5afed7848effbc7d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7432fe0422eaa5afed7848effbc7d8f">&#9670;&#160;</a></span>getScopeRoot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * sparta::TreeNode::getScopeRoot </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the root of the scope that this tree node is in. </p>

</div>
</div>
<a id="a817663bb26d61b4970378614ed8a0908" name="a817663bb26d61b4970378614ed8a0908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a817663bb26d61b4970378614ed8a0908">&#9670;&#160;</a></span>getScopeRoot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * sparta::TreeNode::getScopeRoot </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the root of the scope that this tree node is in. </p>

</div>
</div>
<a id="a0074a4a62b20d8b414fe52939feaf9ca" name="a0074a4a62b20d8b414fe52939feaf9ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0074a4a62b20d8b414fe52939feaf9ca">&#9670;&#160;</a></span>getSimulation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1app_1_1Simulation.html">app::Simulation</a> * sparta::TreeNode::getSimulation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the simulation (if any) associated with this tree. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This node should be attached (isAttached) or this will return nullptr </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Function gets <a class="el" href="classsparta_1_1RootTreeNode.html" title="TreeNode which represents the root (&quot;top&quot;) of a device tree.">RootTreeNode</a> of tree and asks it for Simulation pointer (if any) </dd></dl>

</div>
</div>
<a id="a18cf1df166a0430f1ffd56b1f16ce732" name="a18cf1df166a0430f1ffd56b1f16ce732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18cf1df166a0430f1ffd56b1f16ce732">&#9670;&#160;</a></span>getTags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; const std::string * &gt; &amp; sparta::TreeNode::getTags </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the set of tags associated with this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This cannot change after finalization </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>const vector of const string pointers, which will never be null. These tags are stored as pointers into strings held by <a class="el" href="classsparta_1_1StringManager.html" title="Manages string internment for SPARTA. This allows strings to be compared by pointer once interned.">StringManager</a> to save space and often improve comparison speed</dd></dl>
<p>Tags are useful for associating meta-data with a <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> and forming virtual groupings of nodes independent of hierarchy. For example, all nodes (e.g. counters and notification sources) having to do with power-modeling may have "power" tags indicating presence in a virtual "power" group. </p>

</div>
</div>
<a id="a9faa603b824c850070637195f6d4e2a9" name="a9faa603b824c850070637195f6d4e2a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9faa603b824c850070637195f6d4e2a9">&#9670;&#160;</a></span>getVirtualGlobalNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * sparta::TreeNode::getVirtualGlobalNode </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the virtual global node singleton. This node can have no parent and no children. It receives notifications from all nodes in the simulator as if it were the parent of every node in the simulation that has no parent. </p>
<dl class="section note"><dt>Note</dt><dd>Caller must not delete this node.</dd></dl>
<p>This node is typically used to add logging taps that receive messages before the entire device tree hierarchy is defined. This allows warning messages from a newly-constructed node to be sent somewhere, even before that node is part of any device tree. </p>

</div>
</div>
<a id="a9cb544ebd5bc75612acc891758d49ecc" name="a9cb544ebd5bc75612acc891758d49ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb544ebd5bc75612acc891758d49ecc">&#9670;&#160;</a></span>getWeakPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a91f21b18f9f50f70111730361eff6ddb">WeakPtr</a> sparta::TreeNode::getWeakPtr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a weak pointer to this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>. This weak pointer is guaranteed to expire when this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> is destructed unless locked. </p>
<dl class="section return"><dt>Returns</dt><dd>weak_ptr to this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>. Guaranteed not to be expired at this time. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not store the shared_ptr result of a call to sparta::TreeNode::WeakPtr::lock because it will prevent weak references to this shared pointer from expiring when the <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> is actually deleted. Having a shared pointer to this node will NOT prevent its destruction</dd></dl>
<p>Example </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="#a91f21b18f9f50f70111730361eff6ddb">TreeNode::WeakPtr</a> wp = node-&gt;getWeakPtr();</div>
<div class="line">...</div>
<div class="line">if(!wp.expired()){ <span class="comment">// Is weak pointer valid (node not yet deleted)</span></div>
<div class="line">  wp.lock()-&gt;getName(); <span class="comment">// lock converts to shared pointer for use.</span></div>
<div class="line">                        <span class="comment">// Shared pointer is nullptr if p is dead.</span></div>
<div class="line">}</div>
<div class="ttc" id="aclasssparta_1_1TreeNode_html_a91f21b18f9f50f70111730361eff6ddb"><div class="ttname"><a href="#a91f21b18f9f50f70111730361eff6ddb">sparta::TreeNode::WeakPtr</a></div><div class="ttdeci">std::weak_ptr&lt; TreeNode &gt; WeakPtr</div><div class="ttdoc">Weak pointer to a TreeNode. Acquire with getWeakPtr.</div><div class="ttdef"><b>Definition</b> <a href="TreeNode_8hpp_source.html#l00265">TreeNode.hpp:265</a></div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="affdb43d52e9eb2d550b2ab40c4b2722c" name="affdb43d52e9eb2d550b2ab40c4b2722c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affdb43d52e9eb2d550b2ab40c4b2722c">&#9670;&#160;</a></span>hasChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::TreeNode::hasChild </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a child can be found with the given dotted path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Dotted path to child </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>no pattern matching supported in this method. Child-finding behavior is the same as getChild </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if the child can be found, false if not. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac598185049018290d5ea6cb674d10473" title="Retrieves a child with this dotted path name.">getChild</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l01570">1570</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a00b99ce49b9d44c9cc8e7b738601ef4b" name="a00b99ce49b9d44c9cc8e7b738601ef4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b99ce49b9d44c9cc8e7b738601ef4b">&#9670;&#160;</a></span>hasExtension()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::TreeNode::hasExtension </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>extension_name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if this tree node has an extension by the given name. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l02086">2086</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1TreeNode_a00b99ce49b9d44c9cc8e7b738601ef4b_cgraph.png" border="0" usemap="#aclasssparta_1_1TreeNode_a00b99ce49b9d44c9cc8e7b738601ef4b_cgraph" alt=""/></div>
<map name="aclasssparta_1_1TreeNode_a00b99ce49b9d44c9cc8e7b738601ef4b_cgraph" id="aclasssparta_1_1TreeNode_a00b99ce49b9d44c9cc8e7b738601ef4b_cgraph">
<area shape="rect" title="Check if this tree node has an extension by the given name." alt="" coords="5,5,209,31"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a8c99280dc2adae048d57fb001d05de61" title="Get an extension without needing to specify any particular extension name. If no extensions exist,..." alt="" coords="257,5,457,31"/>
<area shape="poly" title=" " alt="" coords="209,16,241,16,241,21,209,21"/>
</map>
</div>

</div>
</div>
<a id="aca5a8c3649144eeeec5acacbba4f2b37" name="aca5a8c3649144eeeec5acacbba4f2b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca5a8c3649144eeeec5acacbba4f2b37">&#9670;&#160;</a></span>hasExtensionOfType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::TreeNode::hasExtensionOfType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>extension_name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if this tree node has an extension by the given name and type. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l02094">2094</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1TreeNode_aca5a8c3649144eeeec5acacbba4f2b37_cgraph.png" border="0" usemap="#aclasssparta_1_1TreeNode_aca5a8c3649144eeeec5acacbba4f2b37_cgraph" alt=""/></div>
<map name="aclasssparta_1_1TreeNode_aca5a8c3649144eeeec5acacbba4f2b37_cgraph" id="aclasssparta_1_1TreeNode_aca5a8c3649144eeeec5acacbba4f2b37_cgraph">
<area shape="rect" title="Check if this tree node has an extension by the given name and type." alt="" coords="5,5,209,46"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a8c99280dc2adae048d57fb001d05de61" title="Get an extension without needing to specify any particular extension name. If no extensions exist,..." alt="" coords="257,13,457,38"/>
<area shape="poly" title=" " alt="" coords="209,23,241,23,241,28,209,28"/>
</map>
</div>

</div>
</div>
<a id="ad8132a8fd4d313c333a49979726a9b0b" name="ad8132a8fd4d313c333a49979726a9b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8132a8fd4d313c333a49979726a9b0b">&#9670;&#160;</a></span>hasImmediateChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::TreeNode::hasImmediateChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the node <em>n</em> is an immediate child of this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Node to test for child-ness of <em>this</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <em>n</em> is an immediate child; false if not. </dd></dl>

</div>
</div>
<a id="a0e7b4d01402471a3021541fb7b6794c1" name="a0e7b4d01402471a3021541fb7b6794c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7b4d01402471a3021541fb7b6794c1">&#9670;&#160;</a></span>hasObserversRegisteredForNotification()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::TreeNode::hasObserversRegisteredForNotification </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;</td>          <td class="paramname"><span class="paramname"><em>tinfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> (not descendants) has any observers for this type of event and name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tinfo</td><td>typeid of the notification to be queried </td></tr>
    <tr><td class="paramname">name</td><td>Name of the notification to be queried (Can be "" to ignore name) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b28db0c7afcacd7ef77c0243ef32364" name="a8b28db0c7afcacd7ef77c0243ef32364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b28db0c7afcacd7ef77c0243ef32364">&#9670;&#160;</a></span>hasTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::TreeNode::hasTag </td>
          <td>(</td>
          <td class="paramtype">const std::string *</td>          <td class="paramname"><span class="paramname"><em>interned_tag_name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does this node have a specific tag (by string pointer interned with <a class="el" href="classsparta_1_1StringManager.html" title="Manages string internment for SPARTA. This allows strings to be compared by pointer once interned.">StringManager</a>). This is faster than the alternate hasTag method because it relies only on pointer comparisons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">interned_tag_name</td><td><a class="el" href="classsparta_1_1Tag.html" title="Tag(): Simple class to provide nested sequence numbering.">Tag</a> pointer. Caller must get this pointer argument from sparta <a class="el" href="classsparta_1_1StringManager.html" title="Manages string internment for SPARTA. This allows strings to be compared by pointer once interned.">StringManager</a> or it may not match </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cac07d5f406fa1300d0e283e2a1f498" name="a2cac07d5f406fa1300d0e283e2a1f498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cac07d5f406fa1300d0e283e2a1f498">&#9670;&#160;</a></span>hasWildcardCharacters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool sparta::TreeNode::hasWildcardCharacters </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a given node name has any wildcard characters which will be substituted in createSearchRegexPattern. </p>
<p>This is useful for identifying which nodes are patterns and which are concrete node names. It is important to keep this in ssync with createSearchRegexPattern </p>

</div>
</div>
<a id="ab50c28d990477787fe2a043555302120" name="ab50c28d990477787fe2a043555302120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50c28d990477787fe2a043555302120">&#9670;&#160;</a></span>identityMatchesPattern_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool sparta::TreeNode::identityMatchesPattern_ </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>ident</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::regex &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>replacements</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs pattern matching on a identity string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ident</td><td>Regex identity. This could be generated from an input glob pattern </td></tr>
    <tr><td class="paramname">expr</td><td>Expression to compare against <em>ident</em> </td></tr>
    <tr><td class="paramname">replacements</td><td>Returns each captured replacement of a in the expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62ec15f8443eb1f90447942deb20d26f" name="a62ec15f8443eb1f90447942deb20d26f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ec15f8443eb1f90447942deb20d26f">&#9670;&#160;</a></span>invokeDelegatesOn_()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::invokeDelegatesOn_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>to_invoke</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataT &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string *</td>          <td class="paramname"><span class="paramname"><em>name_id</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Protected wrapper for invokeDelegates_ which allows a <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> to invoke delegates on another <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> using itself as the origin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_invoke</td><td>TreeNodes whose delegates will be invoked (those which are appropriate for the specified DataT and name_id)</td></tr>
  </table>
  </dd>
</dl>
<p>See invokeDelegates_ for other argument semantics </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l03456">3456</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="aec143fde6eb7584c343c98e62bba1aa4" name="aec143fde6eb7584c343c98e62bba1aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec143fde6eb7584c343c98e62bba1aa4">&#9670;&#160;</a></span>isAnonymous()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::TreeNode::isAnonymous </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is this node anonymous. </p>
<dl class="section return"><dt>Returns</dt><dd>true if node is anonymous </dd></dl>

</div>
</div>
<a id="a5e430f72fd1a922df3c8dbc7be3f7d00" name="a5e430f72fd1a922df3c8dbc7be3f7d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e430f72fd1a922df3c8dbc7be3f7d00">&#9670;&#160;</a></span>isAttached()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sparta::TreeNode::isAttached </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this node part of a device tree with a proper <a class="el" href="classsparta_1_1RootTreeNode.html" title="TreeNode which represents the root (&quot;top&quot;) of a device tree.">RootTreeNode</a> at the root. </p>
<dl class="section return"><dt>Returns</dt><dd>true if node is a child of a <a class="el" href="classsparta_1_1RootTreeNode.html" title="TreeNode which represents the root (&quot;top&quot;) of a device tree.">RootTreeNode</a> regardless of how many tree levels separate them </dd></dl>

<p>Reimplemented in <a class="el" href="classsparta_1_1GlobalTreeNode.html#a9ed26b9674c84728949f73a54b75318e">sparta::GlobalTreeNode</a>, <a class="el" href="classsparta_1_1RootTreeNode.html#a8563862dd80ce7fd07a11b389d9ecb80">sparta::RootTreeNode</a>, and <a class="el" href="classsparta_1_1VirtualGlobalTreeNode.html#a8c15008459f782fd7c9e6aaf018f2a94">sparta::VirtualGlobalTreeNode</a>.</p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00956">956</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a5faf0ebba15c75ea7e421b0b552e2de9" name="a5faf0ebba15c75ea7e421b0b552e2de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5faf0ebba15c75ea7e421b0b552e2de9">&#9670;&#160;</a></span>isBuiltin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::TreeNode::isBuiltin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is this node in the builtins group. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this node is in the GROUP_NAME_BUILTIN group. </dd></dl>

</div>
</div>
<a id="aa8cff588af283f20b1c3dc6f3b52053f" name="aa8cff588af283f20b1c3dc6f3b52053f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8cff588af283f20b1c3dc6f3b52053f">&#9670;&#160;</a></span>isDescendantOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::TreeNode::isDescendantOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>ancestor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>max_depth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this node is a descendant of the specified ancestor node within some number of generations (depth). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ancestor</td><td><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> that will be tested for being a parent this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> </td></tr>
    <tr><td class="paramname">max_depth</td><td>Maximum depth (distance) between ancestor and this node that will allow this test to return true. A more distance ancestor/descendant relationship will cause this method to false. A max depth of 0 implies this node and ancestor must be the same node, a max_depth of 1 means that the ancestor must be an immediate parent or self, 2 means parent of parent or closer, and so on. max_depth of -1 means no limit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7a85c2485062f0e5ba383bb8d94fd3f" name="aa7a85c2485062f0e5ba383bb8d94fd3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a85c2485062f0e5ba383bb8d94fd3f">&#9670;&#160;</a></span>isExpired()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::TreeNode::isExpired </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is this expired (i.e. has it been the rhp of a move constructor) </p>
<dl class="section return"><dt>Returns</dt><dd>true if node is expired </dd></dl>

</div>
</div>
<a id="ad3780c614eaa9c18ba2a162c32c2fa24" name="ad3780c614eaa9c18ba2a162c32c2fa24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3780c614eaa9c18ba2a162c32c2fa24">&#9670;&#160;</a></span>isHidden()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::TreeNode::isHidden </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> supposed to be hidden during tree printouts This value does not have to be respected by anything using <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> and is mainly a UI/printout convenience. </p>
<p>Defaults to false at construction </p>

</div>
</div>
<a id="ae614c29aa798fd41da2dd178a359272f" name="ae614c29aa798fd41da2dd178a359272f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae614c29aa798fd41da2dd178a359272f">&#9670;&#160;</a></span>isNodeConstructed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool sparta::TreeNode::isNodeConstructed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a given node constructed? </p>
<dl class="section note"><dt>Note</dt><dd>This is used for debugging double-frees </dd></dl>

</div>
</div>
<a id="a73b54fb21d8426f14d54c7388f68d2b4" name="a73b54fb21d8426f14d54c7388f68d2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73b54fb21d8426f14d54c7388f68d2b4">&#9670;&#160;</a></span>isScopeRoot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::TreeNode::isScopeRoot </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this tree node is a scope root </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l02223">2223</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="aa6ccf18c0631ba2d1a665567db7618a6" name="aa6ccf18c0631ba2d1a665567db7618a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6ccf18c0631ba2d1a665567db7618a6">&#9670;&#160;</a></span>locateNotificationSources()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT  = ANY_TYPE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sparta::TreeNode::locateNotificationSources </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets all possible notification info from NotificationSources within this node's subtree. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataT</td><td>type of data for which to search. This must be non-const, non-volatile, non-pointer, and non-reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodes</td><td>Result set of nodes to which all found nodes will be appended. This vector is <b>not</b> cleared. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the <a class="el" href="classsparta_1_1NotificationSource.html" title="A TreeNode that generates a specific type of notification which propagates up a tree of TreeNodes (us...">NotificationSource</a> to search for. Specifying "" locates any sourcee matching on DataT.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// Find any nodes that may post the sparta::Register::PostWriteAccess</span></div>
<div class="line"><span class="comment">// type regardless of the notification name.</span></div>
<div class="line">std::vector&lt;sparta::TreeNode*&gt; results;</div>
<div class="line">node-&gt;locateNotificationSources&lt;<a class="code hl_struct" href="structsparta_1_1RegisterBase_1_1PostWriteAccess.html">sparta::Register::PostWriteAccess</a>&gt;(nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Find any nodes that may post any data structure with the notification</span></div>
<div class="line"><span class="comment">// name &quot;post_write&quot;</span></div>
<div class="line">std::vector&lt;sparta::TreeNode*&gt; results;</div>
<div class="line">node-&gt;locateNotificationSources(nodes, <span class="stringliteral">&quot;post_write&quot;</span>);</div>
<div class="line"> </div>
<div class="line">\code</div>
<div class="line"><span class="comment">// Find all notification sources at node or below</span></div>
<div class="line">std::vector&lt;sparta::TreeNode*&gt; results;</div>
<div class="line">node-&gt;locateNotificationSources(nodes);</div>
<div class="ttc" id="astructsparta_1_1RegisterBase_1_1PostWriteAccess_html"><div class="ttname"><a href="structsparta_1_1RegisterBase_1_1PostWriteAccess.html">sparta::RegisterBase::PostWriteAccess</a></div><div class="ttdoc">Structure containing data for a Register post-write notification.</div><div class="ttdef"><b>Definition</b> <a href="Register_8hpp_source.html#l00483">Register.hpp:484</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l03650">3650</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1TreeNode_aa6ccf18c0631ba2d1a665567db7618a6_cgraph.png" border="0" usemap="#aclasssparta_1_1TreeNode_aa6ccf18c0631ba2d1a665567db7618a6_cgraph" alt=""/></div>
<map name="aclasssparta_1_1TreeNode_aa6ccf18c0631ba2d1a665567db7618a6_cgraph" id="aclasssparta_1_1TreeNode_aa6ccf18c0631ba2d1a665567db7618a6_cgraph">
<area shape="rect" title="Gets all possible notification info from NotificationSources within this node&#39;s subtree." alt="" coords="5,5,167,46"/>
<area shape="rect" href="classsparta_1_1StringManager.html#a00c28199fcaa46cf51ac5ec32a51aade" title="Returns the StringManager singleton." alt="" coords="215,5,362,46"/>
<area shape="poly" title=" " alt="" coords="167,23,199,23,199,28,167,28"/>
</map>
</div>

</div>
</div>
<a id="af61c4f67a5045b80c62fd331519b969d" name="af61c4f67a5045b80c62fd331519b969d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61c4f67a5045b80c62fd331519b969d">&#9670;&#160;</a></span>locationMatchesPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::TreeNode::locationMatchesPattern </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>pat_loc</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the given pattern (which may contain wildcards) can describe this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>Pattern to compare this node's location against. This pattern CANNOT have any upward traversal (parent references). </td></tr>
    <tr><td class="paramname">pat_loc</td><td><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> representing the starting point of pattern. This <em>pat_loc</em> node must be AT or ABOVE *this in the tree, otherwise this method will always report false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>A surefire (but slower) way to implement this is to perform findChildren with the inputs and search the result set for *this. It is NOT trivial to write simple downward traversing comparison as one might expect because patterns can go down and then up. All of the paths downward must be tried even if they do not contain *this because a down,down,up,up,down pattern could go into a subtree which does not contain the target *this, but later come back up and then back down to *this. </dd>
<dd>
This is not able to cross virtual parent-child relationships (e.g. in VirtualGlobalNode) </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a></td><td>if <em>pattern</em> contains upward traversal</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// RootTreeNode* r</span></div>
<div class="line"><span class="comment">// Created TreeNode* n</span></div>
<div class="line">assert(n-&gt;getRoot() == r);</div>
<div class="line">assert(n-&gt;getLocation() == <span class="stringliteral">&quot;top.cpu0.regs&quot;</span>);</div>
<div class="line">assert(n-&gt;locationMatchesPattern(<span class="stringliteral">&quot;t?p.cpu*.regs&quot;</span>, r) == <span class="keyword">true</span>);</div>
<div class="line">assert(n-&gt;locationMatchesPattern(<span class="stringliteral">&quot;&quot;</span>, n) == <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aac64404e9cbc67844ce87a0507b73fd8" name="aac64404e9cbc67844ce87a0507b73fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac64404e9cbc67844ce87a0507b73fd8">&#9670;&#160;</a></span>lockdownParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::lockdownParameters </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to put the device tree in lockdown phase. All LOCKED and HIDDEN parameters are frozen after this point. Regular parameters are not affected by this phase. This method requires a Simulation pointer and will assert at compile time if anyone tries to lockdown the tree without the context of a Simulation. </p>
<p>Lockdown the tree node if Simulation is valid </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00429">429</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1TreeNode_aac64404e9cbc67844ce87a0507b73fd8_cgraph.png" border="0" usemap="#aclasssparta_1_1TreeNode_aac64404e9cbc67844ce87a0507b73fd8_cgraph" alt=""/></div>
<map name="aclasssparta_1_1TreeNode_aac64404e9cbc67844ce87a0507b73fd8_cgraph" id="aclasssparta_1_1TreeNode_aac64404e9cbc67844ce87a0507b73fd8_cgraph">
<area shape="rect" title="Method to put the device tree in lockdown phase. All LOCKED and HIDDEN parameters are frozen after th..." alt="" coords="5,55,187,96"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a1a6d4aac10bfa5345b587d84170441de" title=" " alt="" coords="235,5,429,31"/>
<area shape="poly" title=" " alt="" coords="182,52,261,33,262,38,183,57"/>
<area shape="rect" href="classsparta_1_1PhasedObject.html#ade690bdb9df72fd6bad8847fbdf226f1" title="Gets the trees current phase." alt="" coords="259,55,404,96"/>
<area shape="poly" title=" " alt="" coords="187,73,244,73,244,78,187,78"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a31666fa4b498cd468991f2099e3fbbf7" title="Gets farthest ancestor of this node." alt="" coords="246,120,418,146"/>
<area shape="poly" title=" " alt="" coords="183,94,262,113,261,118,182,99"/>
</map>
</div>

</div>
</div>
<a id="aefc0097b5c5a5eda666d42846fc0d655" name="aefc0097b5c5a5eda666d42846fc0d655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc0097b5c5a5eda666d42846fc0d655">&#9670;&#160;</a></span>makeSubtreePrivate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::makeSubtreePrivate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make the entire subtree private. </p>
<p>This will add 1 to privacy_level_ for every node below, this means it should work if B-&gt;C, where C is private on B, and B is added as a private child of A, A.privacy_level_ = 0, B.privacy_level_ = 1, C.privacy_level_ = 2 (C.privacy_level_ was previously == 1).</p>
<p>See documentation for the privacy_level_ variable to really understand what this is doing and why. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l02206">2206</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a83b06f89a9d37325701620637e44f2e2" name="a83b06f89a9d37325701620637e44f2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83b06f89a9d37325701620637e44f2e2">&#9670;&#160;</a></span>matchesGlobLike()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool sparta::TreeNode::matchesGlobLike </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if a glob-like search pattern matches some other string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>Glob-like pattern to search with. This is standard SPARTA tree identifier pattern syntax </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>Other string with which <em>pattern</em> is being compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if pattern matches other, false if not. </dd></dl>

</div>
</div>
<a id="a3ba01f766f0b8212967d2a25ceae475a" name="a3ba01f766f0b8212967d2a25ceae475a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba01f766f0b8212967d2a25ceae475a">&#9670;&#160;</a></span>notificationCategoryMatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool sparta::TreeNode::notificationCategoryMatch </td>
          <td>(</td>
          <td class="paramtype">const std::string *</td>          <td class="paramname"><span class="paramname"><em>query_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string *</td>          <td class="paramname"><span class="paramname"><em>node_id</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two notification categories match where one is an actual category. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">query_id</td><td>pointer to <a class="el" href="classsparta_1_1StringManager.html" title="Manages string internment for SPARTA. This allows strings to be compared by pointer once interned.">StringManager</a> interned string which may be a single category or a glob-like pattern. If <a class="el" href="classsparta_1_1StringManager.html#ac8482a5f1d6c13aa1c60459e1bf5f3f1" title="Holds interned empty strings.">StringManager.EMPTY</a>, matches all patterns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node_id</td><td>concrete category. This is a name, not a pattern. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c2e0aceb5596a4f21fc5e1ad34c2ac7" name="a4c2e0aceb5596a4f21fc5e1ad34c2ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2e0aceb5596a4f21fc5e1ad34c2ac7">&#9670;&#160;</a></span>parseNotificationNameString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; const std::string * &gt; sparta::TreeNode::parseNotificationNameString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>csl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a comma-separated list of notification names (or patterns) separated by commas and ignoring whitespace around commas. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">csl</td><td>Comma-separated list (e.g. "a,b,foo*"). Most common case will be a single name with no commas </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of interned string pointers (through <a class="el" href="classsparta_1_1StringManager.html" title="Manages string internment for SPARTA. This allows strings to be compared by pointer once interned.">sparta::StringManager</a>) </dd></dl>

</div>
</div>
<a id="a859010859da20b3dd6e1d300b12a90d4" name="a859010859da20b3dd6e1d300b12a90d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859010859da20b3dd6e1d300b12a90d4">&#9670;&#160;</a></span>postPropagatingNotification_()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::postPropagatingNotification_ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>origin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataT &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string *</td>          <td class="paramname"><span class="paramname"><em>name_id</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts a notification propagating up the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name_id</td><td>Pointer to interned name in <a class="el" href="classsparta_1_1StringManager.html" title="Manages string internment for SPARTA. This allows strings to be compared by pointer once interned.">StringManager</a>. Compared against delegate name. The pointer is treated like a numeric ID for comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Invokes propagateNotification_ on this node after validating, then invokes propagateNotification_ on the global virtual node. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l03297">3297</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1TreeNode_a859010859da20b3dd6e1d300b12a90d4_cgraph.png" border="0" usemap="#aclasssparta_1_1TreeNode_a859010859da20b3dd6e1d300b12a90d4_cgraph" alt=""/></div>
<map name="aclasssparta_1_1TreeNode_a859010859da20b3dd6e1d300b12a90d4_cgraph" id="aclasssparta_1_1TreeNode_a859010859da20b3dd6e1d300b12a90d4_cgraph">
<area shape="rect" title="Starts a notification propagating up the tree." alt="" coords="5,88,226,129"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a91bb3b5d18785bd49e3933847eab1011" title="Can this TreeNode generate a notification of the given type having the given name or pattern." alt="" coords="274,5,474,46"/>
<area shape="poly" title=" " alt="" coords="181,85,292,49,294,54,182,90"/>
<area shape="rect" href="namespacesparta.html#ac0a2df7a7ca53b2fc0384476286b95ec" title="Demangles a C++ symbol." alt="" coords="314,70,434,96"/>
<area shape="poly" title=" " alt="" coords="226,95,298,88,299,93,226,100"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a1a6d4aac10bfa5345b587d84170441de" title=" " alt="" coords="277,120,471,145"/>
<area shape="poly" title=" " alt="" coords="226,116,261,119,261,125,226,121"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a9faa603b824c850070637195f6d4e2a9" title="Gets the virtual global node singleton. This node can have no parent and no children...." alt="" coords="283,169,464,210"/>
<area shape="poly" title=" " alt="" coords="183,127,293,162,292,167,182,132"/>
</map>
</div>

</div>
</div>
<a id="aa662b6ea451b3f69664881508e048f8a" name="aa662b6ea451b3f69664881508e048f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa662b6ea451b3f69664881508e048f8a">&#9670;&#160;</a></span>recursGetDeepestMatchingPath_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint32_t, std::string &gt; sparta::TreeNode::recursGetDeepestMatchingPath_ </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>name_pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the deepest node path mathing the input <em>path</em>. Implements getDeepestMatchingPath. </p>
<dl class="section return"><dt>Returns</dt><dd>pair containing &lt;match depth, match path&gt; relative to this node </dd></dl>

</div>
</div>
<a id="a6260f885d559f61593a2158545d275fb" name="a6260f885d559f61593a2158545d275fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6260f885d559f61593a2158545d275fb">&#9670;&#160;</a></span>registerForNotification() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , typename T , void(T::*)(const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &amp;, const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &amp;, const DataT &amp;) TMethod&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::registerForNotification </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ensure_possible</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a callback method to listen for all notifications having the specified data type DataT and name (or any name if name is "") occuring on this node or any descendant (subtree). </p>
<dl class="section note"><dt>Note</dt><dd>Some parameters of this method can be automatically filled-in using the REGISTER_FOR_NOTIFICATION macro. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataT</td><td>Type of data object given to the notification callback function registered. This type must be a C++ typename of a type which is copyable, non-const, non-reference, and non-pointer. Useful values for this type can be found by locating <a class="el" href="classsparta_1_1NotificationSource.html" title="A TreeNode that generates a specific type of notification which propagates up a tree of TreeNodes (us...">sparta::NotificationSource</a> nodes throughout the device tree and then by looking at <a class="el" href="classsparta_1_1NotificationSourceBase.html#acd75dadf0a1a94940eb7fb6cdff828a9" title="Gets the demangled name of the C++ notification type which this NotificationSource can emit.">sparta::NotificationSource::getNotificationTypeName</a>. Note that <a class="el" href="structsparta_1_1TreeNode_1_1ANY__TYPE.html" title="Type for indicating that ANY notification source type should be included in a search performed by loc...">ANY_TYPE</a> is not a valid argument for DataT. </td></tr>
    <tr><td class="paramname">T</td><td>Class of object on which callback member function will be invoked. </td></tr>
    <tr><td class="paramname">TMethod</td><td>member function pointer of class <em>T</em> that will be invoked when the specified notification is posted. This member function signature must be: <div class="fragment"><div class="line">ClassName::func(<span class="comment">// TreeNode from which the notification originated</span></div>
<div class="line">                <span class="keyword">const</span> <a class="code hl_class" href="classsparta_1_1TreeNode.html">TreeNode</a>&amp; origin_node,</div>
<div class="line">                <span class="comment">// TreeNode at which the notifications was observed, causing this callback</span></div>
<div class="line">                <span class="keyword">const</span> <a class="code hl_class" href="classsparta_1_1TreeNode.html">TreeNode</a>&amp; observation_node,</div>
<div class="line">                <span class="comment">// Notification event data</span></div>
<div class="line">                <span class="keyword">const</span> datat&amp; data)</div>
<div class="ttc" id="aclasssparta_1_1TreeNode_html"><div class="ttname"><a href="classsparta_1_1TreeNode.html">sparta::TreeNode</a></div><div class="ttdoc">Node in a composite tree representing a sparta Tree item.</div><div class="ttdef"><b>Definition</b> <a href="TreeNode_8hpp_source.html#l00203">TreeNode.hpp:204</a></div></div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of notification being observed. If <em>name</em> is "", all notifications having a data type of <em>DataT</em> will cause this callback to be notified. Locating a notificationSource in the device tree and and using <a class="el" href="classsparta_1_1NotificationSourceBase.html#a476d4d8ae1133d22cbfee796ff0a2c76" title="Returns the notification name string for slow string comparison or printing.">sparta::NotificationSource::getNotificationName</a> can help to determine useful values for <em>name</em>. </td></tr>
    <tr><td class="paramname">ensure_possible</td><td>If true, this method will check that one or more nodes in this node's subtree can generate the notification described by DataT and name. If false, this test is not performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a></td><td>if a ensure_possible=true and a registration is made on a DataT/name combination that cannot be posted by this the node's subtree (since there are no ancestor <a class="el" href="classsparta_1_1NotificationSource.html" title="A TreeNode that generates a specific type of notification which propagates up a tree of TreeNodes (us...">NotificationSource</a> nodes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Cannot re-register with same arguments. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000069">Todo</a></b></dt><dd>Faster attachment of delegates to children. There is notable performance impact today, however. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is potentially slow because all children may be walked to build a notification shortcut list, which is an optimization for the performance-critical notification-posting code </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="TreeNode_8hpp.html#a1bb31db8e504f95b76706d7931eaa93e" title="Convenience macro for registering for a notification on a TreeNode.">REGISTER_FOR_NOTIFICATION</a></dd></dl>
<p>NotificationSources can be located throughout the simulation using the <a class="el" href="#aa6ccf18c0631ba2d1a665567db7618a6" title="Gets all possible notification info from NotificationSources within this node&#39;s subtree.">sparta::TreeNode::locateNotificationSources</a> method.</p>
<p>The methods getPossibleSubtreeNotifications and dumpPossibleSubtreeNotifications can assist in finding <a class="el" href="classsparta_1_1NotificationSource.html" title="A TreeNode that generates a specific type of notification which propagates up a tree of TreeNodes (us...">NotificationSource</a> nodes in the device tree.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyClass {</div>
<div class="line">    <span class="keywordtype">void</span> func(<span class="comment">// TreeNode from which the notification originated</span></div>
<div class="line">              <span class="keyword">const</span> <a class="code hl_class" href="classsparta_1_1TreeNode.html">TreeNode</a>&amp; origin_node,</div>
<div class="line">              <span class="comment">// TreeNode at which the notifications was observed, causing this callback</span></div>
<div class="line">              <span class="keyword">const</span> <a class="code hl_class" href="classsparta_1_1TreeNode.html">TreeNode</a>&amp; observation_node,</div>
<div class="line">              <span class="comment">// Notification event data</span></div>
<div class="line">              <span class="keyword">const</span> datat&amp; data)</div>
<div class="line">    <span class="keywordtype">void</span> func(<span class="keyword">const</span> <a class="code hl_class" href="classsparta_1_1TreeNode.html">TreeNode</a>&amp;, <span class="keyword">const</span> <a class="code hl_class" href="classsparta_1_1TreeNode.html">TreeNode</a>&amp;, <span class="keyword">const</span> SomeData&amp;) {}</div>
<div class="line">}</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">MyClass my_class;</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="comment">// Given NotificationSource&lt;struct SomeData&gt; node;</span></div>
<div class="line">node-&gt;registerForNotification&lt;MyClass, &amp;MyClass::func&gt;(my_class);</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">node-&gt;deregisterForNotification&lt;MyClass, &amp;MyClass::func&gt;(my_class);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l03877">3877</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a6260f885d559f61593a2158545d275fb" name="a6260f885d559f61593a2158545d275fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6260f885d559f61593a2158545d275fb">&#9670;&#160;</a></span>registerForNotification() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , typename T , void(T::*)(const DataT &amp;) TMethod&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::registerForNotification </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ensure_possible</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l03884">3884</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="ad747a7ea6e0fdfb7421fc2bcc4db9e8f" name="ad747a7ea6e0fdfb7421fc2bcc4db9e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad747a7ea6e0fdfb7421fc2bcc4db9e8f">&#9670;&#160;</a></span>removeChildForTeardown_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::removeChildForTeardown_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>child</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>"Removes" the given child by invoking onDestroyingChild_ then removing this child from the children_ list </p>
<dl class="section pre"><dt>Precondition</dt><dd>Must be in teardown phase if this node is attached (isAttached) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>Child to remove from this node. Must actually be a current child of <a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a> is thrown </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>It is not currently safe to continue accessing a tree from which a child was removed. This is a teardown utility for breaking parent-child references which can confuse the notification system during random-order desstruction of the tree. This method DOES NOT allow removal of nodes at runtime because it does not erase all traces of the child. For example, the name map will still exist with dangling pointers. A more thorough removal method is required to actually support removal </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method does not care about phase. Presuably it will only be called from <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> destructors, which will detect any phase problems. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a></td><td>if <em>child</em> is not an actual child of this node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af52ced91b3e4228df74f70678e0e9f7e" name="af52ced91b3e4228df74f70678e0e9f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af52ced91b3e4228df74f70678e0e9f7e">&#9670;&#160;</a></span>removeFromParentForTeardown_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::removeFromParentForTeardown_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Protected Wrapper for <a class="el" href="#aa8958d72a1f5aeff2ec36012913ac09c" title="Gets immediate parent of this node if one exists.">getParent()</a>-&gt;removeChildForTeardown_ which allows subclases of <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> to indirectly invoke removeChildForTeardown_ with themselves as the argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Parent to remove this child from. Must be this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>'s parent. Must not be nullptr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a664c9d3ec69cbbfa5993e9b698e65518" name="a664c9d3ec69cbbfa5993e9b698e65518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a664c9d3ec69cbbfa5993e9b698e65518">&#9670;&#160;</a></span>renderSubtree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string sparta::TreeNode::renderSubtree </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>max_depth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>show_builtins</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>names_only</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>hide_hidden</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*</td>          <td class="paramname"><span class="paramname"><em>leaf_filt_fxn&#160;</em></span>)(const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *)<span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renders the subtree starting at this node as a string containing an indentation-based depth-first representation. </p>
<dl class="section return"><dt>Returns</dt><dd>std::string representing the subtree. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_depth</td><td>Number of levels below this Node to traverse. 0 means this node only. Negative depth means no limit. </td></tr>
    <tr><td class="paramname">show_builtins</td><td>When false, hides all TreeNodes in the GROUP_NAME_BUILTIN group. If true, shows all nodes </td></tr>
    <tr><td class="paramname">names_only</td><td>When true, renders names of nodes. Otherwise, renders string representation of nodes prints only this node. </td></tr>
    <tr><td class="paramname">hide_hidden</td><td>Hides any nodes (and their subtrees) maked as hidden </td></tr>
    <tr><td class="paramname">leaf_filt_fxn</td><td>Filtering function. If nullptr, has no effect. If not nullptr, this function is invoked on each LEAF node encountered to determine whether it should be displayed. If this function returns false, the leaf node is not rendered. If true, the leaf node is rendered. Non-leaf nodes are not subject to filtering, but will be omitted if they contain no leaves (at any depth) which pass the leaf filter function. Note that <em>max_depth</em> prohibits recursion past a certain depth, so nodes may not be shown even if they have ancestor leaves that would be visible (according to the filter) but are below the <em>max_depth</em> threshold. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac80b64d2c78346e93c5513dda617f547" name="ac80b64d2c78346e93c5513dda617f547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac80b64d2c78346e93c5513dda617f547">&#9670;&#160;</a></span>replaceExtension()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Extension , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Extension * sparta::TreeNode::replaceExtension </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace an extension, specifying the ExtensionsBase subclass type. This api is similar to <a class="el" href="#a1dc907c86ba95d84c6e97f9421cbbc85" title="Add an extension, specifying the ExtensionsBase subclass type. Forward any arguments needed to your s...">addExtension()</a> in that you do not have to read these parameters prior to finalizeTree() to avoid "unread unbound parameter" exceptions. </p>
<dl class="section note"><dt>Note</dt><dd>If an extension with the name Extension::NAME already exists, it will be replaced. This api does not throw if there was no existing extension by the same name. </dd>
<dd>
Instead of subclassing directly from ExtensionsBase, it is more common to subclass ExtensionsParamsOnly. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l02071">2071</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1TreeNode_ac80b64d2c78346e93c5513dda617f547_cgraph.png" border="0" usemap="#aclasssparta_1_1TreeNode_ac80b64d2c78346e93c5513dda617f547_cgraph" alt=""/></div>
<map name="aclasssparta_1_1TreeNode_ac80b64d2c78346e93c5513dda617f547_cgraph" id="aclasssparta_1_1TreeNode_ac80b64d2c78346e93c5513dda617f547_cgraph">
<area shape="rect" title="Replace an extension, specifying the ExtensionsBase subclass type. This api is similar to addExtensio..." alt="" coords="5,27,174,68"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a1dc907c86ba95d84c6e97f9421cbbc85" title="Add an extension, specifying the ExtensionsBase subclass type. Forward any arguments needed to your s..." alt="" coords="222,5,425,31"/>
<area shape="poly" title=" " alt="" coords="174,34,206,30,206,36,175,40"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#ac91d6baf74fae76dd391c4e68b04a936" title="Remove an extension by its name. Returns true if successful, false if the extension was not found." alt="" coords="239,55,408,96"/>
<area shape="poly" title=" " alt="" coords="175,55,224,61,223,66,174,60"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a00b99ce49b9d44c9cc8e7b738601ef4b" title="Check if this tree node has an extension by the given name." alt="" coords="473,5,676,31"/>
<area shape="poly" title=" " alt="" coords="425,16,457,16,457,21,425,21"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a8c99280dc2adae048d57fb001d05de61" title="Get an extension without needing to specify any particular extension name. If no extensions exist,..." alt="" coords="724,5,925,31"/>
<area shape="poly" title=" " alt="" coords="677,16,708,16,708,21,677,21"/>
</map>
</div>

</div>
</div>
<a id="aa3077d3b25e965fd6924258b5eb77f61" name="aa3077d3b25e965fd6924258b5eb77f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3077d3b25e965fd6924258b5eb77f61">&#9670;&#160;</a></span>setClock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sparta::TreeNode::setClock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1Clock.html">Clock</a> *</td>          <td class="paramname"><span class="paramname"><em>clk</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a clock to this node. This clock will then be accessed by any descendant which has no assigned clock or an ancestor with an assigned clock between that descendant and this node. getClock returns the <a class="el" href="classsparta_1_1Clock.html" title="A representation of simulated time.">Clock</a> associated with the nearest ancestor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clk</td><td><a class="el" href="classsparta_1_1Clock.html" title="A representation of simulated time.">Clock</a> to assign. Must not be null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Must be in the TREE_BUILDING phase </dd>
<dd>
Can only assign a non-NULL value once </dd></dl>

<p>Reimplemented in <a class="el" href="classsparta_1_1RootTreeNode.html#afc231d9376e7ffd5ea6816e613be22f2">sparta::RootTreeNode</a>.</p>

</div>
</div>
<a id="aeefcb776a4574cd8075f92caaeb4676d" name="aeefcb776a4574cd8075f92caaeb4676d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeefcb776a4574cd8075f92caaeb4676d">&#9670;&#160;</a></span>setExpectedParent_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::setExpectedParent_ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tracks a node as an expected parent without actually adding this node as a child. This is used almost exclusively for printing error messages which include a device-tree location BEFORE actually inserting this node into the device tree since node construction can fail. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Parent <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> that will act as the parent for the purposes of printing device-tree location for this node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Tree cannot already have a parent. It makes no sense to set an expected parent if the node alreay has a parent. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a1a6d4aac10bfa5345b587d84170441de">sparta::TreeNode::getLocation</a> will reflect the location of this node as if it is part of the tree under the specified parent </dd></dl>
<dl class="section note"><dt>Note</dt><dd>the expected parent node does not know about this instance. </dd>
<dd>
An expected parent does not cause this node to behave as if it is part of a tree except when printing a location. </dd>
<dd>
The expected parent will be set to nullptr once an actual parent is set through setParent_.</dd></dl>
<p>Typical usage is to invoke this at the very beginning of the constructor of a <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">sparta::TreeNode</a> subclass. This allows <a class="el" href="#a1a6d4aac10bfa5345b587d84170441de">sparta::TreeNode::getLocation</a> to function as if this node were actually part of a tree. After successful construction, addChild can be used to connect this node to a parent in the device tree. At that time, the expected parent is set back to nullptr.</p>
<p>Using an expected parent for the purposes of printing a device-tree location during construction is much cleaner and simpler than adding a child node to some parent and then trying to remove it if something goes wrong during construction. </p>

</div>
</div>
<a id="a0c72f80e1e5b0847930c4067b22657b1" name="a0c72f80e1e5b0847930c4067b22657b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c72f80e1e5b0847930c4067b22657b1">&#9670;&#160;</a></span>setScopeRoot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::setScopeRoot </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make this tree node the root of a scope </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l02214">2214</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a36c82ded98e4ee01463a9fbd05a56d5f" name="a36c82ded98e4ee01463a9fbd05a56d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c82ded98e4ee01463a9fbd05a56d5f">&#9670;&#160;</a></span>simulationTerminating_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::simulationTerminating_ </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hook to allow simulation resources to clean-up before simulation is ended. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Simulator will be in a state earlier than TREE_TEARDOWN phase </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The entire resource tree is accessible. Nothing has been destructed yet </dd>
<dd>
The simulator will not continue to run for this device tree at this point. </dd>
<dd>
This call may be followed by dumpDebugContent_ depending on the configuration of the simulator and any errors encountered. </dd>
<dd>
This call will be eventually followed by onEnteringTeardown_ unless the application is corrupted or hard-terminated (i.e. std::terminate, exit call, or exception in a destructor when unwinding) </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Any</td><td>exceptions related to post-run state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab76a73f2f862a47e969c212f2ac16d85" name="ab76a73f2f862a47e969c212f2ac16d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab76a73f2f862a47e969c212f2ac16d85">&#9670;&#160;</a></span>stringize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string sparta::TreeNode::stringize </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>pretty</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a string representation of this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pretty</td><td>Print a more verbose, multi-line representaiton (if available). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string representation of this node "&lt;" &lt;location&gt; "&gt;" </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this representation contains some basic information and is not meant for deserialization.</dd></dl>
<p>Subclasses should override this with representations appropriate for their type. </p>

<p>Reimplemented in <a class="el" href="classsparta_1_1Clock.html#a1b49f1865b4c18d606061513563ce88b">sparta::Clock</a>, <a class="el" href="classsparta_1_1Counter.html#a4640d393eceb3aa4395af7df8aeb78f5">sparta::Counter</a>, <a class="el" href="classsparta_1_1CounterBase.html#aea38d992df1eb43e9f64d3635054b5dd">sparta::CounterBase</a>, <a class="el" href="classsparta_1_1CycleCounter.html#a6a4fd092d84176b3bfcdd7fab6b91156">sparta::CycleCounter</a>, <a class="el" href="classsparta_1_1DynamicResourceTreeNode.html#af035ece84b830f0aec3177d389e59b13">sparta::DynamicResourceTreeNode&lt; ResourceT, ParamsT &gt;</a>, <a class="el" href="classsparta_1_1EventSet.html#a53be7c6dab276960edac83101b34c796">sparta::EventSet</a>, <a class="el" href="classsparta_1_1ExportedPort.html#a728917f815699eb92c420994c68affa9">sparta::ExportedPort</a>, <a class="el" href="classsparta_1_1GlobalTreeNode.html#ac8a41934e787cf29238b8909c1544702">sparta::GlobalTreeNode</a>, <a class="el" href="classsparta_1_1log_1_1MessageSource.html#ab1c34c0c670383eec407ab355a0e9ac1">sparta::log::MessageSource</a>, <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIFNode.html#aeb01402b82a446003dc0e81c21f2593f">sparta::memory::BlockingMemoryIFNode</a>, <a class="el" href="classsparta_1_1NotificationSourceBase.html#a9d4a9d5f11abd7a8ce06538b5bd4ae63">sparta::NotificationSourceBase</a>, <a class="el" href="classsparta_1_1ParameterBase.html#a040a45b55cd7cee38a83fe8fa6066be9">sparta::ParameterBase</a>, <a class="el" href="classsparta_1_1ParameterSet.html#af06c5c33eea50428437d086eeb4ef739">sparta::ParameterSet</a>, <a class="el" href="classsparta_1_1Port.html#a45ae02b48cc5c6f9bbc6d916ffa5a885">sparta::Port</a>, <a class="el" href="classsparta_1_1ReadOnlyCounter.html#a892e46ca3e9d510ea6892029685ca28c">sparta::ReadOnlyCounter</a>, <a class="el" href="classsparta_1_1Register.html#a0ff2bf6ee8187bf99f28ebb06e4e6d73">sparta::Register</a>, <a class="el" href="classsparta_1_1RegisterBase_1_1Field.html#aa9cef3767bdce113e7f92e7dc7f652f0">sparta::RegisterBase::Field</a>, <a class="el" href="classsparta_1_1RegisterSet.html#ae4492c3361536faf2d03e8ef2c82747a">sparta::RegisterSet</a>, <a class="el" href="classsparta_1_1ResourceTreeNode.html#ad652f2e78a509d5b6a137bf91b4e745b">sparta::ResourceTreeNode</a>, <a class="el" href="classsparta_1_1RootTreeNode.html#a46b90b8996743a3796368ac1aa8f4227">sparta::RootTreeNode</a>, <a class="el" href="classsparta_1_1StatisticDef.html#a03e26c18ff8d927f70c4688490e8b90b">sparta::StatisticDef</a>, and <a class="el" href="classsparta_1_1StatisticSet.html#ab20c085e6daaa70fe0ba148174dad7c5">sparta::StatisticSet</a>.</p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00722">722</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1TreeNode_ab76a73f2f862a47e969c212f2ac16d85_cgraph.png" border="0" usemap="#aclasssparta_1_1TreeNode_ab76a73f2f862a47e969c212f2ac16d85_cgraph" alt=""/></div>
<map name="aclasssparta_1_1TreeNode_ab76a73f2f862a47e969c212f2ac16d85_cgraph" id="aclasssparta_1_1TreeNode_ab76a73f2f862a47e969c212f2ac16d85_cgraph">
<area shape="rect" title="Create a string representation of this node." alt="" coords="5,31,180,56"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a1a6d4aac10bfa5345b587d84170441de" title=" " alt="" coords="232,5,426,31"/>
<area shape="poly" title=" " alt="" coords="179,32,216,28,217,33,180,37"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#abeb9301d222aa616093a280921f65d4a" title="Render tags to a string in the form: &quot; tags:[tag0, tag1]&quot; If there are any tags. The leading space ma..." alt="" coords="228,55,431,80"/>
<area shape="poly" title=" " alt="" coords="180,50,212,53,212,58,179,55"/>
</map>
</div>

</div>
</div>
<a id="abeb9301d222aa616093a280921f65d4a" name="abeb9301d222aa616093a280921f65d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb9301d222aa616093a280921f65d4a">&#9670;&#160;</a></span>stringizeTags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::stringizeTags </td>
          <td>(</td>
          <td class="paramtype">std::stringstream &amp;</td>          <td class="paramname"><span class="paramname"><em>ss</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Render tags to a string in the form: " tags:[tag0, tag1]" If there are any tags. The leading space makes this a useful sub-utility of stringize because if there are no tags, returns empty string with no leading space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ss</td><td>stringstream to write to </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00742">742</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a7946a8167a01fb800e2bc3eccab14bc2" name="a7946a8167a01fb800e2bc3eccab14bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7946a8167a01fb800e2bc3eccab14bc2">&#9670;&#160;</a></span>validateDesc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::validateDesc </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>desc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validates the given description string for this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>name_ must be assigned for this instance. It will be included in the exception message </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a></td><td>if the string is invalid</td></tr>
  </table>
  </dd>
</dl>
<p>Constraints: </p><ul>
<li>desc must not be empty </li>
</ul>

</div>
</div>
<a id="a7400a57b30c63a2196d1c3f1bbf4466d" name="a7400a57b30c63a2196d1c3f1bbf4466d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7400a57b30c63a2196d1c3f1bbf4466d">&#9670;&#160;</a></span>validateGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::validateGroup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a7fa01f145455d583b8f16e0f923b7c7c">group_idx_type</a></td>          <td class="paramname"><span class="paramname"><em>idx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validates the given group name string and group index for this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>. Does not consider context (e.g. name collisions) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Node name </td></tr>
    <tr><td class="paramname">group</td><td>Group name </td></tr>
    <tr><td class="paramname">idx</td><td>Group index </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a></td><td>if the group name and group index combination is invalid (i.e. already used by another node)</td></tr>
  </table>
  </dd>
</dl>
<p>Constraints: </p><ul>
<li>group must not exactly match any names in sparta::RESERVED_WORDS </li>
<li>group must not begin with a decimal digit </li>
<li>Name must not contain two adjacent underscores </li>
<li>group must contain only alphanumeric characters and underscores (see sparta::ALPHANUM_CHARS). </li>
<li>group cannot end with a decimal digit </li>
<li>index must be <a class="el" href="#a0c31b9fc57737636c1b76f7ec7ed0315" title="GroupIndex indicating that a node has no group index because it belongs to no group.">sparta::TreeNode::GROUP_IDX_NONE</a> if group is <a class="el" href="#a361467ba0817226281612c6cfdf1671b" title="Group name indicating that a node belongs to no group.">sparta::TreeNode::GROUP_NAME_NONE</a> </li>
<li>index must be <a class="el" href="#a0c31b9fc57737636c1b76f7ec7ed0315" title="GroupIndex indicating that a node has no group index because it belongs to no group.">sparta::TreeNode::GROUP_IDX_NONE</a> if group is <a class="el" href="#a2cb0eed181c22d020796770813cff2ff" title="Reserved name for built-in nodes.">sparta::TreeNode::GROUP_NAME_BUILTIN</a>. </li>
<li>index must not be <a class="el" href="#a0c31b9fc57737636c1b76f7ec7ed0315" title="GroupIndex indicating that a node has no group index because it belongs to no group.">sparta::TreeNode::GROUP_IDX_NONE</a> if group is not empty and not <a class="el" href="#a2cb0eed181c22d020796770813cff2ff" title="Reserved name for built-in nodes.">sparta::TreeNode::GROUP_NAME_BUILTIN</a>. </li>
<li>if node name is <a class="el" href="#a2c8d1112f2f15f5709e2fe10077443a5" title="Node name for anonymous node.">sparta::TreeNode::NODE_NAME_NONE</a>, group must not be GROUP_NAME_NONE. </li>
</ul>

</div>
</div>
<a id="ad250972578e11008fb7e3c8258945358" name="ad250972578e11008fb7e3c8258945358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad250972578e11008fb7e3c8258945358">&#9670;&#160;</a></span>validateName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::validateName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>nm</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validates the given name string for this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>. Does not consider context (e.g. name collisions) </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a></td><td>if the name is invalid.</td></tr>
  </table>
  </dd>
</dl>
<p>Constraints: </p><ul>
<li>Name must not exactly match any names in sparta::RESERVED_WORDS </li>
<li>Name must not begin with a decimal digit </li>
<li>Name must not contain two adjacent underscores </li>
<li>Name must contain only alphanumeric characters and underscores (see sparta::ALPHANUM_CHARS). </li>
</ul>

</div>
</div>
<a id="a7234b200ace13c97244698a7370d0971" name="a7234b200ace13c97244698a7370d0971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7234b200ace13c97244698a7370d0971">&#9670;&#160;</a></span>validatePostRun_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::validatePostRun_ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1PostRunValidationInfo.html">PostRunValidationInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>info</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hook to check the state of the simulator post-run and throw exceptions if something is incorrect. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Simulator post-run sanity checking will be enabled. If not enabled, this will never be called </dd>
<dd>
Simulator will be in a state earlier than TREE_TEARDOWN phase </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The entire resource tree is accessible. Nothing has been destructed yet </dd>
<dd>
The simulator will not continue to run for this device tree at this point. </dd>
<dd>
This can be invoked multiple times during a simulation with different info content </dd>
<dd>
This call may be followed by dumpDebugContent_ depending on the configuration of the simulator and any errors encountered. </dd>
<dd>
This call will be eventually followed by onEnteringTeardown_ unless the application is corrupted or hard-terminated (i.e. std::terminate, exit call, or exception in a destructor when unwinding) </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Any</td><td>exceptions related to post-run state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22142bfb1cc678347ae0e371aeb8520a" name="a22142bfb1cc678347ae0e371aeb8520a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22142bfb1cc678347ae0e371aeb8520a">&#9670;&#160;</a></span>validateTree_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::validateTree_ </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterates the finalized tree and validates each node (e.g. ensures statistics can be evaluated) </p>
<dl class="section pre"><dt>Precondition</dt><dd>Tree must be in TREE_FINALIZED phase </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a></td><td>if any node cannot be validated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b0f48ca47859f290f346425fea67443" name="a6b0f48ca47859f290f346425fea67443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0f48ca47859f290f346425fea67443">&#9670;&#160;</a></span>verifyUniqueChildIdentifier_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::TreeNode::verifyUniqueChildIdentifier_ </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>ident</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignore_group_collision</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verifies that the given identifier is unique for all children of this node by comparing against names, groups, and aliases. Throws <a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a> if not unique. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ident</td><td>Identifier of child to check for uniqueness (e.g. a name or alias) </td></tr>
    <tr><td class="paramname">ignore_group_collision</td><td>If true, collisions of keys where the existing value in the names_ map is a Grouping are ignored. (default false: throw exception on collision). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a></td><td>if a ident is not unique. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="aa9f23c76add152bf5c5cd059cf3efaa1" name="aa9f23c76add152bf5c5cd059cf3efaa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9f23c76add152bf5c5cd059cf3efaa1">&#9670;&#160;</a></span>ClockManager</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classsparta_1_1ClockManager.html">ClockManager</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allow <a class="el" href="classsparta_1_1ClockManager.html" title="Manages building a clock tree.">ClockManager</a> to directly change phase on nodes. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00216">216</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a7324f36a680eecafcd1a2d0de19b0d09" name="a7324f36a680eecafcd1a2d0de19b0d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7324f36a680eecafcd1a2d0de19b0d09">&#9670;&#160;</a></span>SpartaStaticInitializer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classsparta_1_1SpartaStaticInitializer.html">SpartaStaticInitializer</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This class is responsible for instantiating the static container held by this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00222">222</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a651be440effba7234b368631d4a346db" name="a651be440effba7234b368631d4a346db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a651be440effba7234b368631d4a346db">&#9670;&#160;</a></span>TreeNodePrivateAttorney</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classsparta_1_1TreeNodePrivateAttorney.html">TreeNodePrivateAttorney</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Friend an attorney pattern that can expose access to getAllChildren_ or other methods that bypass privacy_level_. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00228">228</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="af9491929126414c21425d895196e0cbf" name="af9491929126414c21425d895196e0cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9491929126414c21425d895196e0cbf">&#9670;&#160;</a></span>VirtualGlobalTreeNode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classsparta_1_1VirtualGlobalTreeNode.html">VirtualGlobalTreeNode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allow this class access internals for handling notification observation registration/deregistration broadcasts in a way that does not fit the composite tree pattern. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00211">211</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="adfb91033f1351c5dc6b31c35d4c2ae9a" name="adfb91033f1351c5dc6b31c35d4c2ae9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb91033f1351c5dc6b31c35d4c2ae9a">&#9670;&#160;</a></span>CHILD_FIND_THRESHOLD</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint64_t sparta::TreeNode::CHILD_FIND_THRESHOLD = 100000</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Threshold for number of findChildren calls after finalization before a warning message is printed about framework misuse. </p>
<p>This value should be large enough that a few accesses by tools or lookups for caching pointers to other objects are allowed, but small enough that a findChildren call happening every N cycles of execution in the simulator will be detected during runs that take more than a few minutes. Consider that Parameters are also part of a tree and <a class="el" href="classsparta_1_1ParameterSet.html" title="Generic container of Parameters.">ParameterSet</a> or <a class="el" href="classsparta_1_1RegisterSet.html" title="Holds and can create a set of Register objects having various names and groups.">RegisterSet</a> nodes may be the target of some getChild calls after finalization, but generaly these nodes should be cached in the requesting component.</p>
<dl class="section note"><dt>Note</dt><dd>Reports applied after starting can search the tree, causing many accesses. This constant requires a large value to not print warnings in this situation </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000063">Todo</a></b></dt><dd>getChild/findChildren should know the difference between report-based accesses and model-based accesses so that this can be conditionally incremented </dd></dl>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00391">391</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a8830a6be5d9f6e60e4bff8124d19b289" name="a8830a6be5d9f6e60e4bff8124d19b289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8830a6be5d9f6e60e4bff8124d19b289">&#9670;&#160;</a></span>CHILD_GET_THRESHOLD</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint64_t sparta::TreeNode::CHILD_GET_THRESHOLD = 100000</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Threshold for number of getChild calls after finalization before a warning message is printed about framework misuse. </p>
<p>See CHILD_FIND_THRESHOLD for explanation of threshold value choice </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00399">399</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a2736aba2c285e0c9eb56bd5ad219aac1" name="a2736aba2c285e0c9eb56bd5ad219aac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2736aba2c285e0c9eb56bd5ad219aac1">&#9670;&#160;</a></span>DEBUG_DUMP_SECTION_DIVIDER</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string sparta::TreeNode::DEBUG_DUMP_SECTION_DIVIDER</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String dividing sections in a debug dump file. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00323">323</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a0c31b9fc57737636c1b76f7ec7ed0315" name="a0c31b9fc57737636c1b76f7ec7ed0315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c31b9fc57737636c1b76f7ec7ed0315">&#9670;&#160;</a></span>GROUP_IDX_NONE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#a7fa01f145455d583b8f16e0f923b7c7c">group_idx_type</a> sparta::TreeNode::GROUP_IDX_NONE = (<a class="el" href="#a7fa01f145455d583b8f16e0f923b7c7c">group_idx_type</a>)-1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>GroupIndex indicating that a node has no group index because it belongs to no group. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00302">302</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a2cb0eed181c22d020796770813cff2ff" name="a2cb0eed181c22d020796770813cff2ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb0eed181c22d020796770813cff2ff">&#9670;&#160;</a></span>GROUP_NAME_BUILTIN</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char sparta::TreeNode::GROUP_NAME_BUILTIN[] = &quot;_SPARTA_builtin_group_&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserved name for built-in nodes. </p>
<p>Nodes in this group are exempt from certain restrictions and filtered from printing and searching operations. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00369">369</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a361467ba0817226281612c6cfdf1671b" name="a361467ba0817226281612c6cfdf1671b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a361467ba0817226281612c6cfdf1671b">&#9670;&#160;</a></span>GROUP_NAME_NONE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char sparta::TreeNode::GROUP_NAME_NONE[] = &quot;&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Group name indicating that a node belongs to no group. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00313">313</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a7414db91285d570ee6de31f33f2d318a" name="a7414db91285d570ee6de31f33f2d318a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7414db91285d570ee6de31f33f2d318a">&#9670;&#160;</a></span>LOCATION_NODE_SEPARATOR_ATTACHED</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char sparta::TreeNode::LOCATION_NODE_SEPARATOR_ATTACHED = '.'</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Separator character between node identifiers in a location string when the child is attached to the parent. </p>
<dl class="section warning"><dt>Warning</dt><dd>Do not change these as builtin logic and documentation depends on these constants. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00336">336</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a4a5616cd3a24c63ea04e9a54379a48ea" name="a4a5616cd3a24c63ea04e9a54379a48ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a5616cd3a24c63ea04e9a54379a48ea">&#9670;&#160;</a></span>LOCATION_NODE_SEPARATOR_EXPECTING</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char sparta::TreeNode::LOCATION_NODE_SEPARATOR_EXPECTING = ','</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Separator character between node identifiers in a location string when the child is being attached to the parent but has not been entirely attached (i.g. during construction of the child node) </p>
<dl class="section warning"><dt>Warning</dt><dd>Do not change these as builtin logic and documentation depends on these constants. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00345">345</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a9dcff9c08bb51455a8ee1ad0a065b9ed" name="a9dcff9c08bb51455a8ee1ad0a065b9ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dcff9c08bb51455a8ee1ad0a065b9ed">&#9670;&#160;</a></span>LOCATION_NODE_SEPARATOR_UNATTACHED</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char sparta::TreeNode::LOCATION_NODE_SEPARATOR_UNATTACHED = '~'</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Separator character preceding a node identifiers in a location string when that node has no parent and is not in the process of being attached to one. </p>
<dl class="section warning"><dt>Warning</dt><dd>Do not change these as builtin logic and documentation depends on these constants. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00354">354</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a21d729b6c83cfc71c7cff6a4017ab690" name="a21d729b6c83cfc71c7cff6a4017ab690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d729b6c83cfc71c7cff6a4017ab690">&#9670;&#160;</a></span>MAX_NODE_UID</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#af5075c9b90f28041b6a7f3f80132c1b3">node_uid_type</a> sparta::TreeNode::MAX_NODE_UID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum value of node_uid_ before the framework throws an exception. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00308">308</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a2c8d1112f2f15f5709e2fe10077443a5" name="a2c8d1112f2f15f5709e2fe10077443a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8d1112f2f15f5709e2fe10077443a5">&#9670;&#160;</a></span>NODE_NAME_NONE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char sparta::TreeNode::NODE_NAME_NONE[] = &quot;&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Node name for anonymous node. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00318">318</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a08dafe7762de39f9cf9448d58b238bd6" name="a08dafe7762de39f9cf9448d58b238bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08dafe7762de39f9cf9448d58b238bd6">&#9670;&#160;</a></span>NODE_NAME_VIRTUAL_GLOBAL</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char sparta::TreeNode::NODE_NAME_VIRTUAL_GLOBAL[] = &quot;_SPARTA_virtual_global_&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Node name for the virtual glopbal node. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00328">328</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a0207cd37def4befc0825fa4e2118d861" name="a0207cd37def4befc0825fa4e2118d861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0207cd37def4befc0825fa4e2118d861">&#9670;&#160;</a></span>RENDER_SUBTREE_INDENT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t sparta::TreeNode::RENDER_SUBTREE_INDENT = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Spaces to indent for each tree level in <a class="el" href="#a664c9d3ec69cbbfa5993e9b698e65518" title="Renders the subtree starting at this node as a string containing an indentation-based depth-first rep...">sparta::TreeNode::renderSubtree</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This is cosmetic only </dd></dl>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00361">361</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a462dd7d49771534977161285834213ad" name="a462dd7d49771534977161285834213ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462dd7d49771534977161285834213ad">&#9670;&#160;</a></span>TEARDOWN_ERROR_LIMIT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t sparta::TreeNode::TEARDOWN_ERROR_LIMIT = 5</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of teardown-phase-related messages that can be printed before the rest will be suppressed. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00405">405</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a5fbbbe78bdb65b46ed07ca8de5e4da89" name="a5fbbbe78bdb65b46ed07ca8de5e4da89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fbbbe78bdb65b46ed07ca8de5e4da89">&#9670;&#160;</a></span>TREE_NODE_PATTERN_SUBS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::pair&lt;const char*, std::function&lt;void (std::string&amp;)&gt; &gt; &gt; sparta::TreeNode::TREE_NODE_PATTERN_SUBS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of pattern susbtitutions when creating a search pattern from a <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> name containing wildcards. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00411">411</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/github/workspace/sparta/sparta/simulation/<a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesparta.html">sparta</a></li><li class="navelem"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a></li>
    <li class="footer">Generated on Mon Feb 9 2026 03:27:58 for The Sparta Modeling Framework by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
