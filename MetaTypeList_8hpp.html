<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Sparta Modeling Framework: /github/workspace/sparta/sparta/utils/MetaTypeList.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">The Sparta Modeling Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('MetaTypeList_8hpp.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle"><div class="title">MetaTypeList.hpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Contains the implementation of Metatype_lists, a compile-time list for storing different type structures which can be accessed by using nested type aliases inside. Metatype_lists are extremely useful in Template MetaProgramming.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
</div>
<p><a href="MetaTypeList_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMetaTypeList_1_1type__list.html">MetaTypeList::type_list&lt;... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variadic class template <a class="el" href="classMetaTypeList_1_1type__list.html" title="The variadic class template type_list has no implementation and is empty by itself.">type_list</a> has no implementation and is empty by itself.  <a href="classMetaTypeList_1_1type__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMetaTypeList_1_1create_3_01type__list_3_4_00_01Head_00_01Tail_8_8_8_01_4.html">MetaTypeList::create&lt; type_list&lt;&gt;, Head, Tail... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization where no <a class="el" href="classMetaTypeList_1_1type__list.html" title="The variadic class template type_list has no implementation and is empty by itself.">type_list</a> exist.  <a href="classMetaTypeList_1_1create_3_01type__list_3_4_00_01Head_00_01Tail_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMetaTypeList_1_1create_3_01type__list_3_01Elements_8_8_8_01_4_00_01Head_00_01Tail_8_8_8_01_4.html">MetaTypeList::create&lt; type_list&lt; Elements... &gt;, Head, Tail... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization where <a class="el" href="classMetaTypeList_1_1type__list.html" title="The variadic class template type_list has no implementation and is empty by itself.">type_list</a> exists in the intermediate derivations.  <a href="classMetaTypeList_1_1create_3_01type__list_3_01Elements_8_8_8_01_4_00_01Head_00_01Tail_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMetaTypeList_1_1create_3_01type__list_3_01Elements_8_8_8_01_4_01_4.html">MetaTypeList::create&lt; type_list&lt; Elements... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base case where we have consumed all the paramters in the pack and created the <a class="el" href="classMetaTypeList_1_1type__list.html" title="The variadic class template type_list has no implementation and is empty by itself.">type_list</a>. We just typedef it.  <a href="classMetaTypeList_1_1create_3_01type__list_3_01Elements_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMetaTypeList_1_1frontT_3_01type__list_3_01Head_00_01Tail_8_8_8_01_4_01_4.html">MetaTypeList::frontT&lt; type_list&lt; Head, Tail... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMetaTypeList_1_1frontT.html" title="The class template frontT takes type_list as template param. and typedefs the type of the first templ...">frontT</a> Template Specialization.  <a href="classMetaTypeList_1_1frontT_3_01type__list_3_01Head_00_01Tail_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMetaTypeList_1_1pop__frontT_3_01type__list_3_01Head_00_01Tail_8_8_8_01_4_01_4.html">MetaTypeList::pop_frontT&lt; type_list&lt; Head, Tail... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMetaTypeList_1_1pop__frontT.html" title="The class template pop_frontT takes type_list as template param., extracts out the first type in type...">pop_frontT</a> Template Specialization.  <a href="classMetaTypeList_1_1pop__frontT_3_01type__list_3_01Head_00_01Tail_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMetaTypeList_1_1push__frontT_3_01type__list_3_01Elements_8_8_8_01_4_00_01NewElement_01_4.html">MetaTypeList::push_frontT&lt; type_list&lt; Elements... &gt;, NewElement &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMetaTypeList_1_1push__frontT.html" title="The class template push_frontT takes an existing type_list and a new type, inserts that new type at f...">push_frontT</a> Template Specialization.  <a href="classMetaTypeList_1_1push__frontT_3_01type__list_3_01Elements_8_8_8_01_4_00_01NewElement_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMetaTypeList_1_1push__backT_3_01type__list_3_01Elements_8_8_8_01_4_00_01NewElement_01_4.html">MetaTypeList::push_backT&lt; type_list&lt; Elements... &gt;, NewElement &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMetaTypeList_1_1push__backT.html" title="The class template push_backT takes an existing type_list and a new type, inserts that new type at en...">push_backT</a> Template Specialization.  <a href="classMetaTypeList_1_1push__backT_3_01type__list_3_01Elements_8_8_8_01_4_00_01NewElement_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMetaTypeList_1_1nth__elementT.html">MetaTypeList::nth_elementT&lt; List, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class template gives us the type of Nth element in a <a class="el" href="classMetaTypeList_1_1type__list.html" title="The variadic class template type_list has no implementation and is empty by itself.">type_list</a> by taking advantage of the nested alias template in frontT&lt;T&gt;.  <a href="classMetaTypeList_1_1nth__elementT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMetaTypeList_1_1nth__elementT_3_01List_00_010_01_4.html">MetaTypeList::nth_elementT&lt; List, 0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMetaTypeList_1_1nth__elementT.html" title="This class template gives us the type of Nth element in a type_list by taking advantage of the nested...">nth_elementT</a> Template Specialization.  <a href="classMetaTypeList_1_1nth__elementT_3_01List_00_010_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMetaTypeList_1_1is__empty.html">MetaTypeList::is_empty&lt; typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class Template <a class="el" href="classMetaTypeList_1_1is__empty.html" title="Class Template is_empty Generic case.">is_empty</a> Generic case.  <a href="classMetaTypeList_1_1is__empty.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMetaTypeList_1_1is__empty_3_01type__list_3_4_01_4.html">MetaTypeList::is_empty&lt; type_list&lt;&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class Template <a class="el" href="classMetaTypeList_1_1is__empty.html" title="Class Template is_empty Generic case.">is_empty</a> Specialization.  <a href="classMetaTypeList_1_1is__empty_3_01type__list_3_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMetaTypeList_1_1get__pack__size_3_01type__list_3_01Head_00_01Tail_8_8_8_01_4_01_4.html">MetaTypeList::get_pack_size&lt; type_list&lt; Head, Tail... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unroll Templates till Base case specialization is reached and accumulate.  <a href="classMetaTypeList_1_1get__pack__size_3_01type__list_3_01Head_00_01Tail_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMetaTypeList_1_1get__pack__size_3_01type__list_3_4_01_4.html">MetaTypeList::get_pack_size&lt; type_list&lt;&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base case specialization.  <a href="classMetaTypeList_1_1get__pack__size_3_01type__list_3_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMetaTypeList_1_1is__meta__typelist.html">MetaTypeList::is_meta_typelist&lt;... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic Class Template which takes a type and matches it if that is a <a class="el" href="classMetaTypeList_1_1type__list.html" title="The variadic class template type_list has no implementation and is empty by itself.">type_list</a>. Generic case results to false.  <a href="structMetaTypeList_1_1is__meta__typelist.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMetaTypeList_1_1is__meta__typelist_3_01MetaTypeList_1_1type__list_3_01Args_8_8_8_01_4_01_4.html">MetaTypeList::is_meta_typelist&lt; MetaTypeList::type_list&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template Specialization when the type indeed is a <a class="el" href="classMetaTypeList_1_1type__list.html" title="The variadic class template type_list has no implementation and is empty by itself.">type_list</a>.  <a href="structMetaTypeList_1_1is__meta__typelist_3_01MetaTypeList_1_1type__list_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMetaTypeList_1_1get__index_3_01S_00_01T_00_01type__list_3_01Head_00_01Tail_8_8_8_01_4_00_01e9e5e4740d43bcea1c682581d92b676a.html">MetaTypeList::get_index&lt; S, T, type_list&lt; Head, Tail... &gt;, typename std::enable_if&lt; std::is_same&lt; T, Head &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class Template to return the index of a certain type in a certain typelist. Case when queried type matches front type.  <a href="classMetaTypeList_1_1get__index_3_01S_00_01T_00_01type__list_3_01Head_00_01Tail_8_8_8_01_4_00_01e9e5e4740d43bcea1c682581d92b676a.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMetaTypeList_1_1get__index_3_01S_00_01T_00_01type__list_3_01Head_00_01Tail_8_8_8_01_4_00_01bf9b2ee7d0f482ba78786bed2833ff4d.html">MetaTypeList::get_index&lt; S, T, type_list&lt; Head, Tail... &gt;, typename std::enable_if&lt;!std::is_same&lt; T, Head &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class Template to return the index of a certain type in a certain typelist. Case when queried type does not match front type.  <a href="classMetaTypeList_1_1get__index_3_01S_00_01T_00_01type__list_3_01Head_00_01Tail_8_8_8_01_4_00_01bf9b2ee7d0f482ba78786bed2833ff4d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a20b3270060335e0814519a5b63edfed0" id="r_a20b3270060335e0814519a5b63edfed0"><td class="memTemplParams" colspan="2">template&lt;typename... Elements&gt; </td></tr>
<tr class="memitem:a20b3270060335e0814519a5b63edfed0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a20b3270060335e0814519a5b63edfed0">MetaTypeList::create_t</a> = typename <a class="el" href="classMetaTypeList_1_1create.html">create</a>&lt;<a class="el" href="classMetaTypeList_1_1type__list.html">type_list</a>&lt;Elements...&gt;&gt;::type</td></tr>
<tr class="memdesc:a20b3270060335e0814519a5b63edfed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">create Alias Template.  <br /></td></tr>
<tr class="separator:a20b3270060335e0814519a5b63edfed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af478f3a5f69cebc886c31b1929687b1a" id="r_af478f3a5f69cebc886c31b1929687b1a"><td class="memTemplParams" colspan="2">template&lt;typename List &gt; </td></tr>
<tr class="memitem:af478f3a5f69cebc886c31b1929687b1a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af478f3a5f69cebc886c31b1929687b1a">MetaTypeList::front</a> = typename <a class="el" href="classMetaTypeList_1_1frontT.html">frontT</a>&lt;List&gt;::type</td></tr>
<tr class="memdesc:af478f3a5f69cebc886c31b1929687b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMetaTypeList_1_1frontT.html" title="The class template frontT takes type_list as template param. and typedefs the type of the first templ...">frontT</a> Alias Template.  <br /></td></tr>
<tr class="separator:af478f3a5f69cebc886c31b1929687b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf32d18781bf0dbfc21406448d4c081" id="r_adcf32d18781bf0dbfc21406448d4c081"><td class="memTemplParams" colspan="2">template&lt;typename List &gt; </td></tr>
<tr class="memitem:adcf32d18781bf0dbfc21406448d4c081"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adcf32d18781bf0dbfc21406448d4c081">MetaTypeList::pop_front</a> = typename <a class="el" href="classMetaTypeList_1_1pop__frontT.html">pop_frontT</a>&lt;List&gt;::type</td></tr>
<tr class="memdesc:adcf32d18781bf0dbfc21406448d4c081"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMetaTypeList_1_1pop__frontT.html" title="The class template pop_frontT takes type_list as template param., extracts out the first type in type...">pop_frontT</a> Alias Template.  <br /></td></tr>
<tr class="separator:adcf32d18781bf0dbfc21406448d4c081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8866b5641282ac1f09c984867728fd" id="r_a0d8866b5641282ac1f09c984867728fd"><td class="memTemplParams" colspan="2">template&lt;typename List , typename NewElement &gt; </td></tr>
<tr class="memitem:a0d8866b5641282ac1f09c984867728fd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0d8866b5641282ac1f09c984867728fd">MetaTypeList::push_front</a> = typename <a class="el" href="classMetaTypeList_1_1push__frontT.html">push_frontT</a>&lt;List, NewElement&gt;::type</td></tr>
<tr class="memdesc:a0d8866b5641282ac1f09c984867728fd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMetaTypeList_1_1push__frontT.html" title="The class template push_frontT takes an existing type_list and a new type, inserts that new type at f...">push_frontT</a> Alias Template.  <br /></td></tr>
<tr class="separator:a0d8866b5641282ac1f09c984867728fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0ec3ed65c2b4de676c64148baaa607" id="r_a5c0ec3ed65c2b4de676c64148baaa607"><td class="memTemplParams" colspan="2">template&lt;typename List , typename NewElement &gt; </td></tr>
<tr class="memitem:a5c0ec3ed65c2b4de676c64148baaa607"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5c0ec3ed65c2b4de676c64148baaa607">MetaTypeList::push_back</a> = typename <a class="el" href="classMetaTypeList_1_1push__backT.html">push_backT</a>&lt;List, NewElement&gt;::type</td></tr>
<tr class="memdesc:a5c0ec3ed65c2b4de676c64148baaa607"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMetaTypeList_1_1push__backT.html" title="The class template push_backT takes an existing type_list and a new type, inserts that new type at en...">push_backT</a> Alias Template.  <br /></td></tr>
<tr class="separator:a5c0ec3ed65c2b4de676c64148baaa607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28fb6904b6d37f52a0ac7c20b7dcde07" id="r_a28fb6904b6d37f52a0ac7c20b7dcde07"><td class="memTemplParams" colspan="2">template&lt;typename List , unsigned N&gt; </td></tr>
<tr class="memitem:a28fb6904b6d37f52a0ac7c20b7dcde07"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a28fb6904b6d37f52a0ac7c20b7dcde07">MetaTypeList::nth_element</a> = typename <a class="el" href="classMetaTypeList_1_1nth__elementT.html">nth_elementT</a>&lt;List, N&gt;::type</td></tr>
<tr class="memdesc:a28fb6904b6d37f52a0ac7c20b7dcde07"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMetaTypeList_1_1nth__elementT.html" title="This class template gives us the type of Nth element in a type_list by taking advantage of the nested...">nth_elementT</a> Alias Template.  <br /></td></tr>
<tr class="separator:a28fb6904b6d37f52a0ac7c20b7dcde07"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains the implementation of Metatype_lists, a compile-time list for storing different type structures which can be accessed by using nested type aliases inside. Metatype_lists are extremely useful in Template MetaProgramming. </p>

<p class="definition">Definition in file <a class="el" href="MetaTypeList_8hpp_source.html">MetaTypeList.hpp</a>.</p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a20b3270060335e0814519a5b63edfed0" name="a20b3270060335e0814519a5b63edfed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b3270060335e0814519a5b63edfed0">&#9670;&#160;</a></span>create_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Elements&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a20b3270060335e0814519a5b63edfed0">MetaTypeList::create_t</a> = typename create&lt;type_list&lt;Elements...&gt;&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create Alias Template. </p>

<p class="definition">Definition at line <a class="el" href="MetaTypeList_8hpp_source.html#l00064">64</a> of file <a class="el" href="MetaTypeList_8hpp_source.html">MetaTypeList.hpp</a>.</p>

</div>
</div>
<a id="af478f3a5f69cebc886c31b1929687b1a" name="af478f3a5f69cebc886c31b1929687b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af478f3a5f69cebc886c31b1929687b1a">&#9670;&#160;</a></span>front</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af478f3a5f69cebc886c31b1929687b1a">MetaTypeList::front</a> = typename frontT&lt;List&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>frontT Alias Template. </p>

<p class="definition">Definition at line <a class="el" href="MetaTypeList_8hpp_source.html#l00088">88</a> of file <a class="el" href="MetaTypeList_8hpp_source.html">MetaTypeList.hpp</a>.</p>

</div>
</div>
<a id="a28fb6904b6d37f52a0ac7c20b7dcde07" name="a28fb6904b6d37f52a0ac7c20b7dcde07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28fb6904b6d37f52a0ac7c20b7dcde07">&#9670;&#160;</a></span>nth_element</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List , unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a28fb6904b6d37f52a0ac7c20b7dcde07">MetaTypeList::nth_element</a> = typename nth_elementT&lt;List, N&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>nth_elementT Alias Template. </p>

<p class="definition">Definition at line <a class="el" href="MetaTypeList_8hpp_source.html#l00182">182</a> of file <a class="el" href="MetaTypeList_8hpp_source.html">MetaTypeList.hpp</a>.</p>

</div>
</div>
<a id="adcf32d18781bf0dbfc21406448d4c081" name="adcf32d18781bf0dbfc21406448d4c081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcf32d18781bf0dbfc21406448d4c081">&#9670;&#160;</a></span>pop_front</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#adcf32d18781bf0dbfc21406448d4c081">MetaTypeList::pop_front</a> = typename pop_frontT&lt;List&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pop_frontT Alias Template. </p>

<p class="definition">Definition at line <a class="el" href="MetaTypeList_8hpp_source.html#l00112">112</a> of file <a class="el" href="MetaTypeList_8hpp_source.html">MetaTypeList.hpp</a>.</p>

</div>
</div>
<a id="a5c0ec3ed65c2b4de676c64148baaa607" name="a5c0ec3ed65c2b4de676c64148baaa607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0ec3ed65c2b4de676c64148baaa607">&#9670;&#160;</a></span>push_back</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List , typename NewElement &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a5c0ec3ed65c2b4de676c64148baaa607">MetaTypeList::push_back</a> = typename push_backT&lt;List, NewElement&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>push_backT Alias Template. </p>

<p class="definition">Definition at line <a class="el" href="MetaTypeList_8hpp_source.html#l00162">162</a> of file <a class="el" href="MetaTypeList_8hpp_source.html">MetaTypeList.hpp</a>.</p>

</div>
</div>
<a id="a0d8866b5641282ac1f09c984867728fd" name="a0d8866b5641282ac1f09c984867728fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d8866b5641282ac1f09c984867728fd">&#9670;&#160;</a></span>push_front</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List , typename NewElement &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a0d8866b5641282ac1f09c984867728fd">MetaTypeList::push_front</a> = typename push_frontT&lt;List, NewElement&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>push_frontT Alias Template. </p>

<p class="definition">Definition at line <a class="el" href="MetaTypeList_8hpp_source.html#l00137">137</a> of file <a class="el" href="MetaTypeList_8hpp_source.html">MetaTypeList.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_8b51add0bc6ff831487a715a42aa15b5.html">sparta</a></li><li class="navelem"><a class="el" href="dir_538f46becf9f81566841c79369e25095.html">utils</a></li><li class="navelem"><a class="el" href="MetaTypeList_8hpp.html">MetaTypeList.hpp</a></li>
    <li class="footer">Generated on Fri Aug 22 2025 17:16:11 for The Sparta Modeling Framework by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
