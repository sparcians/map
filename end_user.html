<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Sparta Modeling Framework: Sparta Command Line Interface End-User Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">The Sparta Modeling Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('end_user.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Sparta Command Line Interface End-User Guide</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul>
  <li class="level1">
    <a href="#invocation">1 Simulator Invocation</a>
    <ul>
      <li class="level2">
        <a href="#io_policies">1.1 I/O Policies</a>
      </li>
      <li class="level2">
        <a href="#sparta_cmds">1.2 Sparta Basic Command-Line Options</a>
      </li>
      <li class="level2">
        <a href="#app_cmds">1.3 Application-Specific Commands</a>
      </li>
      <li class="level2">
        <a href="#sparta_advanced_cmds">1.4 Sparta Advanced commands</a>
      </li>
      <li class="level2">
        <a href="#sim_dbg_cmds">1.5 Sparta Simulation Debug commands</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#ctrl_cfg">2 Control and Configuration</a>
    <ul>
      <li class="level2">
        <a href="#ctrl_cfg_parameters">2.1 Parameters</a>
      </li>
      <li class="level2">
        <a href="#ctrl_cfg_architecture">2.2 Selecting Architectures</a>
      </li>
      <li class="level2">
        <a href="#numeric_constants">2.3 Numeric Constants</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#output">3 Simulator Output</a>
    <ul>
      <li class="level2">
        <a href="#auto_summary">3.1 Automatic Summary</a>
      </li>
      <li class="level2">
        <a href="#report_gen">3.2 Report Generation</a>
      </li>
      <li class="level2">
        <a href="#msg_logging">3.3 Message Logging</a>
      </li>
      <li class="level2">
        <a href="#notification_logging">3.4 Notification Logging</a>
      </li>
      <li class="level2">
        <a href="#perf_events">3.5 Performance Events</a>
      </li>
      <li class="level2">
        <a href="#pipeline_collection">3.6 Pipeline Collection</a>
      </li>
      <li class="level2">
        <a href="#debug_dump">3.7 Post-Run Debug dumps</a>
      </li>
      <li class="level2">
        <a href="#backtraces">3.4 Backtraces</a>
      </li>
      <li class="level2">
        <a href="#tree_inspection">3.8 Device Tree Inspection</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#run_with_debugger">4 Running with a debugger</a>
    <ul>
      <li class="level2">
        <a href="#run_with_dbg_gdb">GDB</a>
      </li>
      <li class="level2">
        <a href="#run_with_dbg_other">Other Debuggers</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#data_proc_vis">4 Post-processing and Visualization</a>
    <ul>
      <li class="level2">
        <a href="#argos">4.1 Pipeline viewer (Argos)</a>
      </li>
    </ul>
  </li>
</ul>
</div>
<div class="textblock"><h4><em>For end-users of the Sparta simulator CLI</em></h4>
<p>This page details the usage, configuration, inputs, and outputs of <b>"sparta-based CLI(command line
  interface)"</b>. This term is used to refer to a simulator that uses the <a class="el" href="namespacesparta_1_1app.html" title="Sparta Application framework.">sparta::app</a> framework (<a class="el" href="classsparta_1_1app_1_1CommandLineSimulator.html" title="Command line simulator front-end class with argument parsing Works in conjunction with sparta::app::S...">sparta::app::CommandLineSimulator</a> and <a class="el" href="classsparta_1_1app_1_1Simulation.html" title="Simulator which builds a sparta DeviceTree.">sparta::app::Simulation</a>) to initialize and configure the simulator from the command line. If a simulator application is not using this part of the Sparta framework, very little of this end-user guide is applicable to an application. Some of these features will still be available interally to the simulation framework, but they may be exposed to the end-user in a different manner.</p>
<p>The terms <b>"sparta simulator"</b> and <b>"sparta-instrumented simulator"</b> differ in that they refer only to simulators that expose a sparta tree with instrumentation such as counter, statistics, and notifications. Such simulators may or may not be driven by a sparta CLI.</p>
<p>For the purpose of this page, 'user' means an invidual or script who invokes a simulator through its command line interface or needs to work with Sparta simulator output</p>
<hr  />
 <h1><a class="anchor" id="invocation"></a>
1 Simulator Invocation</h1>
<p>The Sparta command line consists of a number of generic options built into the sparta application framework as well as application-specific commands that pertain to a specific simulator.</p>
<p>In general, the Sparta application framework attempts to provide a large set of generic commands without making any assumptions about the underlying device being simulated. The only assumptions made are that the device operates on one or more clock domains with regular frequencies and that there is some 'tick' (<a class="el" href="classsparta_1_1Scheduler.html#a34dcaf99252d9e9e0511d69d2aa84ff8" title="The current tick the Scheduler is working on or just finished.">sparta::Scheduler::getCurrentTick</a>) unit which can be used as a unit of absolute time in which inputs and outputs can be expressed. The tick is typically 1 picosecond, but may also be the least-common multiple of all these clock periods. All clock periods will be integer multiples of the tick period (in terms of simulated time)</p>
<dl class="section note"><dt>Note</dt><dd>In the future, time-based commands will be specified in terms of a specific clock domain.</dd></dl>
<h2><a class="anchor" id="io_policies"></a>
1.1 I/O Policies</h2>
<dl class="section user"><dt>A. No Hidden I/O</dt><dd>As policy, the Sparta application framework will not read any input files that are not explicitly specified on the command line or indirectly by configuration files specified on the command line. The Sparta application framework generally does not write any output files unless explicitly requested. If any files are automatically written by Sparta, those filenames will always be configurable and disable-able through the command line. For a given simulator, the Sparta application framework's behavior will dependent only on the given command line. There should be no unexpected effects from seemingly unrelated files or environment variables.</dd></dl>
<dl class="section user"><dt></dt><dd><b>NOTE:</b> The only cases of Sparta writing files which were not requested are debug dumps. These files will be written if the simulator exits with an error (and the &ndash;debug-dump policy option allows it). The name of this file is typically. <div class="fragment"><div class="line">error-dump.dbg</div>
</div><!-- fragment --> The --debug-dump-filename option controls this filename.</dd></dl>
<p>Similarly, Sparta will eventually write snapshot pipeout files on error. The pipeout file prefix will be configurable</p>
<dl class="section user"><dt>B. Full Output Control</dt><dd>The user should never be required to guess output filenames. All output files are configurable on the command line or through parameters in configuration files that are specified on the command line. The user may not have full control</dd></dl>
<dl class="section user"><dt>C. Output Error Detection</dt><dd>All output files opened from within Sparta are expected to detect file write errors and throw exceptions on failed writes (e.g. when a disk quota is reached). Similarly, failed heap allocations are expected to throw exceptions, though some objects which suppress these exceptions (e.g. stringstream) may cause such errors to go undetected in the short term.</dd></dl>
<p>Eventually, the simulation may be able to suspend itself from within a failed memory allocation or bad file write.</p>
<dl class="section user"><dt></dt><dd><b style="font-color:$ff0000;">WARNING:</b> Specific simulator applications may violate these policies, but are strongly encouraged not to.</dd></dl>
<h2><a class="anchor" id="sparta_cmds"></a>
1.2 Sparta Basic Command-Line Options</h2>
<p>The most useful of all commands are the help commands. Even if this document is out of date, full (albiet abridged) documentation will be available through the &ndash;help-verbose command line flag. The -h flag shows a limited set of the most common options with very brief descriptions. The get detailed help on all commands, use </p><div class="fragment"><div class="line">simulator --help | less</div>
</div><!-- fragment --><p> or </p><div class="fragment"><div class="line">simulator --help-topic topics</div>
</div><!-- fragment --><p>A number of other built-in commands are listed in later sections.</p>
<dl class="section user"><dt></dt><dd><b>NOTE:</b> In the future, a man-page may be created for the Sparta application framework. A pagination system could be built into the Sparta application framework to make browing the built-in documentation even easier.</dd></dl>
<dl class="section user"><dt></dt><dd><b style="font-color:$ff0000;">WARNING:</b> Some sparta command line options have variable parameters such as --report. The final optional argument, FORMAT, is a string describing a format. If this option immediately preceeds a positional argument (e.g. trace file name) and the user did not specify a FORMAT argument, then the sparta cli will try and consume that positional argument as a FORMAT. If it is a recognized as a valid value of FORMAT, then sparta will interpret it as a format, If not, it will be interpreted as a positional argument. The opposite problem can also occur, where a FORMAT argument is misspelled, causing the cli to interpret it as a positional argument. To avoid this problem, one can ensure that variadic command line options such as --report are not the last named option on the command-line. The be even more explicit, the -- token can be set to indicate the termination of a command-line option argument list. For example, if a positional argument named html (which is also a valid value for FORMAT) is needed on the command line but you don't actually want to specify a FORMAT, use: <div class="fragment"><div class="line">simulator --report top myreport.yaml report.txt -- html</div>
</div><!-- fragment --> This would end up being equivalent to <div class="fragment"><div class="line">simulator --report top myreport.yaml report.txt txt html</div>
</div><!-- fragment --> Here, a report defined by myreport.yaml is written to report.txt with plaintext formatting. An application-specific positional argument named html is also consumed by the whatever simulator application is being run. The sparta CLI does not care about 'html' in this command line. <br  />
 It would probably be a mistake to use the command line: <div class="fragment"><div class="line"><span class="preprocessor"># Poor choice of filename or format</span></div>
<div class="line">simulator --report top myreport.yaml report.txt html</div>
</div><!-- fragment --> The result of this would be saving a report to report.txt as html markup instead of plaintext. See <a class="el" href="#report_gen">3.2 Report Generation</a> for more details on report generation</dd></dl>
<h2><a class="anchor" id="app_cmds"></a>
1.3 Application-Specific Commands</h2>
<p>Simulator command-lines can have any number of application-specific commands. Refer to that simulator's documentation for details.</p>
<p>Examples of some typical simulator-specific commands are instruction-count limits, version-printing, showing additional detailed help pages, and specifying trace files. Positional arguments are <b>always</b> application-specific.</p>
<p>Extending the sparta CLI to add application-specific events is straightforward and requires boost program_options.</p>
<h2><a class="anchor" id="sparta_advanced_cmds"></a>
1.4 Sparta Advanced commands</h2>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo</a></b></dt><dd>Write this section</dd></dl>
<h2><a class="anchor" id="sim_dbg_cmds"></a>
1.5 Sparta Simulation Debug commands</h2>
<p>The sparta CLI provides a few options that help debug the CLI and the Sparta simulation framework.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Usage   </th><th class="markdownTableHeadNone">Behavior    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">--debug-sim   </td><td class="markdownTableBodyNone">Turn on simulator framework debugging    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">--show-options   </td><td class="markdownTableBodyNone">Show all options parsed from the command line    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">--verbose-config   </td><td class="markdownTableBodyNone">Sets all configuration file readers and emitters to verbose mode for easier debugging   </td></tr>
</table>
<hr  />
 <h1><a class="anchor" id="ctrl_cfg"></a>
2 Control and Configuration</h1>
<h2><a class="anchor" id="ctrl_cfg_parameters"></a>
2.1 Parameters</h2>
<p>Sparta simulations are configured using parameters, which can be specified on the command line individually or using YAML configuration files.</p>
<div class="fragment"><div class="line">$simulator -p top.core0.params.foo value</div>
<div class="line">$simulator -c my_conf.yaml</div>
<div class="line">$simulator -n top.core0 my_core_conf.yaml</div>
</div><!-- fragment --><p> <br  />
</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Usage   </th><th class="markdownTableHeadNone">Alternate   </th><th class="markdownTableHeadNone">Behavior    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">-p PATTERN VAL   </td><td class="markdownTableBodyNone">--parameter   </td><td class="markdownTableBodyNone">Specify an individual parameter value. Multiple parameters can be identified using '*' and '?' glob-like wildcards. Example: "\--parameter top.core0.params.foo value"    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">-c FILENAME   </td><td class="markdownTableBodyNone">--config-file   </td><td class="markdownTableBodyNone">Specify a YAML config file to load at the top of the simulator device tree. Example: "--config-file config.yaml" This is effectively the same as --node-config-file top params.yaml    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">-n PATTERN FILENAME   </td><td class="markdownTableBodyNone">--node-config-file   </td><td class="markdownTableBodyNone">Specify a YAML config file to load at aspecific node (or nodes using '*' and '?' glob-like wildcards) in the device tree. Example: "\--node-config-file top.core0 core0_params.yaml"   </td></tr>
</table>
<p>Use of the -p option is straightforward. Using -c and -n require YAML-based sparta parameter configuration files, whose format is described in detail in <a class="el" href="param_format.html">Parameter/Configuration Format (.cfg,.yaml)</a> .</p>
<dl class="section user"><dt>2.1.1 Listing Parameters</dt><dd>Most of the available parameters in the simulation can be seen by using <div class="fragment"><div class="line">$simulator --write-<span class="keyword">final</span>-config FILENAME</div>
</div><!-- fragment --> to write the simulator's full configuration file to a file immediately after the simulation is fully constructed (implying no more changes to configuration) but before it begins running. The output of this feature can be used as an input configuration file. This is currently the recommended way of enumerating the available parameters and generating configuration-file templates. <br  />
 To generate a configuration file with some helpful documentation as in-line comments: <div class="fragment"><div class="line">$simulator --write-<span class="keyword">final</span>-config-verbose FILENAME</div>
</div><!-- fragment --> <br  />
 In both these cases, the output written to ''FILENAME'' can be taken as-is or modified and then used as an input file to a -c or -n command-line argument (see above). <br  />
 This feature is used in several ways. <ul>
<li>To ensure that user-specified parameter value are actually affecting the final configuration </li>
<li>Listing <b>most</b> available parameters </li>
<li>Reproducing a prior run based on its configuration</li>
</ul>
</dd></dl>
<dl class="section user"><dt>2.1.2 Virtual (Unbound) Parameters</dt><dd>Some parameters may not be exposed by simulator in the final-config-file or dumps of the device tree (see --show-tree). In certain cases, a simulator may need to use parameters (for determining topology) which never actually exist as <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">sparta::Parameter</a> in the simulation. These are referred to as virtual or unbound parameters.<br  />
<br  />
 <div style="background-color:#ffc0c0; padding:4px; border:2px dashed #e06060;">Only simulation parameters that exist as <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">sparta::Parameter</a> nodes will be written as part of the final configurations. Today, virtual parameters that are not part of the concrete device tree finalized before running will not be written to a final-config file. Simulator-specific documentation should thoroughly describe any parameter-space not covered by the device tree</div><br  />
 A SpartaException will be thrown at the end of tree finalization if any virtual parameters remain unread. This ensures that all user parameters are consumed by the simulator in some way.</dd></dl>
<h2><a class="anchor" id="ctrl_cfg_architecture"></a>
2.2 Selecting Architectures</h2>
<p>Sparta configuration supports the` concept of architecture configuration baselines. This allows users to load configuration files that override the defaults of chosen parameters hard-coded in the simulator source code. Unlike typical configuration files or command line parameter specifications, selecting an architecture updates both the default and the value of any specified parameter such that it will show up as having a default value the final configuration of the simulator (&ndash;write-final-config) is inspected.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Usage   </th><th class="markdownTableHeadNone">Function    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">--arch ARCH   </td><td class="markdownTableBodyNone">Searches in --arch-search-dir for a configuration file matching the given name "name" or "name.yaml" or "name.yml" or "name/name.yaml" or "name/name.yml"    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">--arch-search-dir DIR   </td><td class="markdownTableBodyNone">Absolute path or relative path (to cwd) dictating where the simulator should look for --arch names to resolve them to actual configuration files   </td></tr>
</table>
<p>The default values for both of these options are simulator specific. The default architecture search dir is listed in the --arch-search-dir command help string.</p>
<p>Afer resolving an --arch name to a config file, that configuration file is listed in the simulator output during simulator setup to show exactly what configuraration files were applied to what parts of the simulated tree and whether they were applyed as architectural baseline configuration or normal configuration.</p>
<h2><a class="anchor" id="numeric_constants"></a>
2.3 Numeric Constants</h2>
<p>Lexical casting of numeric literals in sparta is smart. Values being assigned to integer parameters through command line options or configuration files in the simulator can use prefixes to specify radix and suffixes to specify multipliers.</p>
<p>For example, 10b will be interpreted as 10000000000 (10 billion)</p>
<div class="fragment"><div class="line">$simulator -p top.core0.params.numeric_parameters 10b</div>
</div><!-- fragment --><p>Note that this can be done only on parameters which EXPECT AN INTEGER. This includes any command-line options or configuration files dealing with [u]intXX_t-typed parameters. Only parts of the simulation which expect an integer will use this smart parsing mechanism. This cannot yet be used in statistic expressions because these expressions operate on doubles at all times.</p>
<p>The full set of features includes</p><ol type="1">
<li>Suffixes</li>
<li>SI decimal (power of 10)</li>
<li>k/m/g/t/p/</li>
<li>ISO/IEC 8000 (power of 2):</li>
<li>ki/mi/gi/bi/ti/pi</li>
<li>Case insensitive</li>
<li>Fractional values (if followed by a large enough suffix)</li>
<li>e.g. "0.5b" =&gt; 500m</li>
<li>Fractional value always parsed as decimal</li>
<li>As long as (fraction * suffix) yields a whole number, anything is allowed</li>
<li>OK: 5.123k =&gt; 5123</li>
<li>ERROR: 5.1234k =&gt; 5123.4</li>
<li>Radix Prefixes</li>
<li>0xN..., 0N...</li>
<li>0bN... now supported for binary</li>
<li>Case insensitive</li>
<li>Separators in “, _\t\n” are ignored (note that there is a space in this list)</li>
<li>e.g. "5,000 000" =&gt; 5 million</li>
<li>Not ignored between 2-character prefixes and suffixes</li>
<li>If the number includes spaces and is entered on the command line, ensure that it is handled as a single token by adding quotes</li>
<li>Numbers can be strung together much like they are spoken</li>
<li>e.g. "10b500k" =&gt; 10 billion, five hundred thousand =&gt; 10,000,500,000</li>
<li>Each value encountered is simply added together, so you could do these out of order</li>
<li>Any values after the first cannot have prefixes</li>
<li>Any values after the first are always parsed as decimal</li>
<li>Any negative sign must be at the beginning of the string, affecting the entire number.</li>
<li>This is not an expression, it’s a literal.</li>
</ol>
<p>These suffixes (case insensitive) can be added have the following meanings</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Suffix   </th><th class="markdownTableHeadNone">Multiplier    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">K   </td><td class="markdownTableBodyNone">10^3    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">M   </td><td class="markdownTableBodyNone">10^6    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">G   </td><td class="markdownTableBodyNone">10^9    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">B   </td><td class="markdownTableBodyNone">10^9    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">T   </td><td class="markdownTableBodyNone">10^12    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">P   </td><td class="markdownTableBodyNone">10^15    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Ki   </td><td class="markdownTableBodyNone">2^10    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Mi   </td><td class="markdownTableBodyNone">2^20    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Gi   </td><td class="markdownTableBodyNone">2^30    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Bi   </td><td class="markdownTableBodyNone">2^30    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Ti   </td><td class="markdownTableBodyNone">2^40    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Pi   </td><td class="markdownTableBodyNone">2^50   </td></tr>
</table>
<p>Additional Notes:</p><ol type="1">
<li>For numeric constants with hex prefix, ‘b’ is treated as a digit, not a suffix. Use ‘g’ instead</li>
<li>Fractional values after a decimal point are always parsed in decimal, regardless of prefix on number left of decimal</li>
<li>0x1.1k is parsed as 0x1 + (decimal 0.1 * 1000)</li>
<li>Negative numbers are still supported</li>
<li>Added better detection of overflowing values</li>
<li>Parameter types of uint32_t, for example, will error if they encounter larger values than MAX_UINT32</li>
</ol>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo</a></b></dt><dd>Write this section<ol type="1">
<li>Configuration</li>
<li>Traces</li>
<li>Run Control</li>
<li>Notifications</li>
<li>Inspecting configuration</li>
<li>Showing the tree</li>
<li>Writing configuration</li>
</ol>
</dd></dl>
<hr  />
 <h1><a class="anchor" id="output"></a>
3 Simulator Output</h1>
<p>The sparta CLI supports a number of output mechanisms for any sparta-instrumented simulator.</p>
<h2><a class="anchor" id="auto_summary"></a>
3.1 Automatic Summary</h2>
<p>After a successful run, an automatic summary of all known counters and statistics in the simulation device tree will be written to stdout.</p>
<dl class="section user"><dt></dt><dd><b>NOTE:</b> This is the most obvious output of the simulation, but is by no means the totality of a sparta simulation's output capability.</dd></dl>
<p>By default, this looks something like: </p><pre class="fragment">  top
  top.foo
  top.foo.bar
  stat_x                                             = 0
  stat_y                                             = 12324
  stat_Z                                             = 3.2491
  top.foo.biz
  stat_a                                             = 67</pre><p>If configured to be verbose, the automatic summary looks something like: </p><pre class="fragment">  top
  top.foo
  top.foo.bar
  stat_x                                             = 0       # Number of x's that happend while doing
  # q while in state r or s but not t
  stat_y                                             = 12324   # Time foo.bar did y
  stat_Z                                             = 3.2491  # Value of z. Some of these comments can
  # get really long and may wrap multiple
  # times beacuse someone made them so very
  # very long.
  top.foo.biz
  stat_a                                             = 67      # Short desciption</pre><p>This behavior can be controlled using the &ndash;auto-summary command line option. Valid usages are: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Usage   </th><th class="markdownTableHeadNone">Behavior    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">--auto-summary off   </td><td class="markdownTableBodyNone">Do not write summary    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">--auto-summary on   </td><td class="markdownTableBodyNone">Write summary to stdout    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">--auto-summary normal   </td><td class="markdownTableBodyNone">Write summary to stdout (same as on)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">--auto-summary verbose   </td><td class="markdownTableBodyNone">Write verbose summary to stdout including descriptions   </td></tr>
</table>
<dl class="section user"><dt></dt><dd><b>NOTE:</b> If you want the automatic summary sent to a file instead of stdout, use to the --report-all option, which Sparta's automatic summary uses internally. The automatic summary can be disabled with --auto-summary=off</dd></dl>
<hr  />
<h2><a class="anchor" id="report_gen"></a>
3.2 Report Generation</h2>
<ul>
<li><a class="el" href="report_def_format.html">Report Definition Format (.rrep,.yaml)</a></li>
</ul>
<p>The Sparta Report system is capable of collecting counters and statistics from the simulation device tree and printing their names and values to an output file or stream in any of a variety of formats. This is the principal means of extracting quantitative data from a simulation.</p>
<dl class="section user"><dt></dt><dd><b>NOTE:</b>The automatic summary (<a class="el" href="#auto_summary">3.1 Automatic Summary</a>) generated by default uses this same mechanism internally (though it is not subject to some report-configuration options [e.g. --report-updat-ns] that user-defined reports are).</dd></dl>
<dl class="section user"><dt>3.2.1 Counters and Statistics</dt><dd>A sparta simulation tree will contain two types of objects which can be part of a reports.<ol type="1">
<li>Counters are large interger values, usually monotonically increasing (e.g. number of instructions retired) They are internally represented as uint64_t.</li>
<li>Stiatistcs are expressions refering to counters or other statistics. The simulator has many statistics built in (e.g. average instructions per cycle) which are useful. Users can also define custom reports which contain arbitrary statistics. Since statistics only depend on publicly visible counters, their values could always be computed in post-processing.</li>
</ol>
</dd></dl>
<dl class="section user"><dt></dt><dd>Both counters and statistics objects are always found within a "stats" object in the Sparta device tree.</dd></dl>
<dl class="section user"><dt></dt><dd><b>NOTE:</b> In future versions, reports will be able to contain numeric parameter values as content and statistical expressions will be able to use numeric parameter values (and possibly elements and attributes of contaners) as variables in the expression.</dd></dl>
<dl class="section user"><dt>3.2.2 Report Creation</dt><dd></dd></dl>
<p>Other than the automatic summary, all reports must be explicitly created on the command line. The --report and --report-all options configure a new report or reports. </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Usage   </th><th class="markdownTableHeadNone">Behavior    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">--report PATTERN DEF OUT [FMT]   </td><td class="markdownTableBodyNone">Create one or more reports based on the report definition file DEF at all nodes matching PATTERN and write the end-of-simulation result to OUT using the optionally-specified format FMT. If no format is given, infers it from the file extension. Use --help for more details about this command. See both the --report command details and the "Reports" section of the help output. <em>DEF</em> may be specified as "@" (no quotes necessary) to direct the simulator to autopopulate the report instead of using a definition file.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">--report-all OUT [FMT]   </td><td class="markdownTableBodyNone">Create one or more reports containing all counters and statistics in the simulation and write the end-of-simulation result to OUT using the optionally-specified format FMT. If no format is given, infers it from the file extension. Use --help for more details about this command. See both the --report-all command details and the "Reports" section of the help output   </td></tr>
</table>
<p>Report definition files are a restricted subset of the YAML files with special semantics for YAML dictionaries based on context in the file. See <a class="el" href="report_def_format.html">Report Definition Format (.rrep,.yaml)</a></p>
<p>Often, this is used to place a simple report on the top-level node in the simulation tree </p><pre class="fragment">  simulation --report top myreport.yaml out.txt</pre><p>Node paths in myreport.yaml for the above example would be specified relative to "top".</p>
<p>Often, a global scope is desired so that Sparta scheduler statistics can be used (e.g. ticks) or just to allow fully qualified paths. This can be done using the "_global" keyword.</p>
<pre class="fragment">  simulation --report _global myreport.yaml out.txt</pre><p>Node paths in this report definition would be fully qualified and begin with "top." or "scheduler."</p>
<p>Each report directive can created multiple reports if the PATTERN contains multiple wildcards. For example: </p><pre class="fragment">  simulation --report top.nodeX.* @ out%i.csv csv</pre><p>It is generally a bad idea to direct mutliple reports to the same output file as the result is undefined and the files could be overwritten. If using a wildcard in the <em>PATTERN</em> variable in the --report command, it is usually necessary to use either of the %i (index) or %l (location) variables in the output file name. The following variables are supported (From sparta::app::computeOutputFilename).</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Wildcard   </th><th class="markdownTableHeadNone">Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">%l   </td><td class="markdownTableBodyNone">location (lower case L)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">%i   </td><td class="markdownTableBodyNone">index of substitution for wild-card in <em>PATTERN</em> (0-based). Based on construction order of found nodes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">%p   </td><td class="markdownTableBodyNone">process ID    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">%t   </td><td class="markdownTableBodyNone">timestamp    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">%s   </td><td class="markdownTableBodyNone">simulator name   </td></tr>
</table>
<p>When using a variable in the destination, Sparta will list the instantiations both at the start of simulation and at the end. </p><pre class="fragment">  Running...
  Placing report on node top.nodeX.nodeY for: Report "@" applied at "top.nodeX.*" -&gt; "out0.csv" (format=csv)
  Placing report on node top.nodeX.nodeZ for: Report "@" applied at "top.nodeX.*" -&gt; "out1.csv" (format=csv)

  ... later ...

  [out] Wrote Final Report Report "@" applied at "top.nodeX.*" -&gt; "out%i.csv" (format=csv) (updated 13 times):
  Report instantiated at top.nodeX.nodeY, updated to "out0.csv"
  Report instantiated at top.nodeX.nodeZ, updated to "out1.csv"
  2 reports written</pre><dl class="section user"><dt>3.2.3 Report Periodicity &amp; Warmup</dt><dd></dd></dl>
<p>There are several modifiers to the behavior of the reports created. <b><em>These will eventually be deprecated and replaced with a more robust and flexible control system that can apply to individual reports</em></b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Usage   </th><th class="markdownTableHeadNone">Behavior    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">--report-warmup-count INSTRUCTIONS   </td><td class="markdownTableBodyNone">Does not begin any report (including builtin reports such as the automatic summary) until <em>INSTRUCTIONS</em> instrutions have elapsed based on whatever counter the simulator has identified as having the 'instruction count' semantic. See <a class="el" href="classsparta_1_1app_1_1Simulation.html#a2c1cbf112314f9a69927744a7855e18c" title="Types of semantics attached to certain counters. It is the responsibility of subclasses to implement ...">sparta::app::Simulation::CounterSemantic</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">--report-update-ns NANOSECONDS   </td><td class="markdownTableBodyNone">Periodically update all reports every <em>NANOSECONDS</em> written with formatters that support updating (see --help-topic reporting for information). CSV supports this at the least. This does <b>not</b> affect the automatic summary report. Exclusive to other --report-update-* options.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">--report-update-cycles [CLOCK] CYCLES   </td><td class="markdownTableBodyNone">Periodically update all reports every <em>CYCLES</em> cycles on the clock named <em>CLOCK</em> (optional) written with formatters that support updating (see --help-topic reporting for information). CSV supports this at the least. This does <b>not</b> affect the automatic summary report. Exclusive to other --report-update-* options.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">--report-update-counter COUNTER COUNT   </td><td class="markdownTableBodyNone">Periodically update all reports every <em>COUNT</em> units for a counter located in the tree at path <em>COUNTER</em> (e.g. top.core0.foo.stats.bar) written with formatters that support updating (see --help-topic reporting for information). This option guarantees one update to each applicable report for each multiple of <em>COUNT</em> reached by the counter, even if the counter is incremented as a coarse granularity such that it skips multiple instances of that target count period in a single cycle. The extra updates will show 0-deltas for all counters. CSV supports this at the least. This does <b>not</b> affect the automatic summary report. Exclusive to other --report-update-* options.   </td></tr>
</table>
<p>When using repeating reports, be sure that the report formatter actually supports updating. Some formatters do not.</p>
<p>When the simulator writes its final reports, it will also indicate how many times each user-specified report has been updated. For example: </p><pre class="fragment">  simulation &lt;other arguments&gt; --report-update-ns 1000 --report top.nodeX.nodeY @ out.csv csv</pre><p> May generate: </p><pre class="fragment">  [out] Wrote Final Report Report "@" applied at "top.nodeX.nodeY" -&gt; "out.csv" (format=csv) (updated 14 times):</pre><p>To periodically report based on a counter value such as intruction retierd, the following could be used in a simulator with the appropriate counter. </p><pre class="fragment">  simulation &lt;other arguments&gt; --report-update-counter top.core0.retire.stats.num_insts_retired 1000 --report top.nodeX.nodeY @ out.csv csv</pre><p>When writing a report that is periodically updated, it is useful to create a report definition file that includes a clock cycle counter as the first item in the report definition. Then, the report output will include that clock's value in the first column (in the case of CSV). This looks like: </p><div class="fragment"><div class="line"><span class="preprocessor"># Report definition with a cycle counter as the first stat</span></div>
<div class="line">content:</div>
<div class="line">top.core0:</div>
<div class="line"><span class="stringliteral">&quot;cycles&quot;</span> : <span class="stringliteral">&quot;core0 cycles&quot;</span></div>
<div class="line"><span class="preprocessor"># Additional stats &amp; subreports</span></div>
</div><!-- fragment --><p>After generating a periodic report in the CSV format, try plotting with the Sparta csv report plotter in sparta/tools/plot_csv_report.py</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo</a></b></dt><dd>Complete this section</dd></dl>
<dl class="section user"><dt>3.2.4 Report Output Formatters</dt><dd></dd></dl>
<p>The list of available report output formats are available at <a class="el" href="report_out_format.html">Report Output Formats</a> . Refer to this page for notes and details. Use <b></p><pre>"--help-topic reporting"</pre><p>&lt;/b</p><blockquote class="doxtable">
<p>&zwj;to get information about report formatsinteractively from a Sparta simulator </p>
</blockquote>
<dl class="section user"><dt>3.2.5 Parsing and Extension</dt><dd></dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo</a></b></dt><dd>Complete this section<ol type="1">
<li>Parsing</li>
<li>Formats/extending</li>
</ol>
</dd></dl>
<p></b></p>
<p><b></b></p>
<h2><a class="anchor" id="msg_logging"></a>
<b>3.3 Message Logging</b></h2>
<p><b> For more details about the modeling side of logging, see <a class="el" href="logging.html">Logging</a> in sparta refers to a plaintext logging system for informational and diagnostic messages. Sparta includes a mechanism for generating textual messages that can be configurably directed to various output files in variou formats to generate a textual trace of the state or events inside particular components of a simulation.</b></p>
<p><b></p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Usage   </th><th class="markdownTableHeadNone">Behavior    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">--warn-file FILENAME   </td><td class="markdownTableBodyNone">Specifies which file to which warnings should be directed (independent of --no-warn-stderr)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">--no-warn-stderr   </td><td class="markdownTableBodyNone">If set, prevents logging messages of the "error" category to the stderr stream.(independent of --warn-file)   </td></tr>
</table>
<p></b></p>
<p><b> </p><dl class="section user"><dt>3.3.1 Control</dt><dd></dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Command   </th><th class="markdownTableHeadNone">Functionality    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">-l / --log PATTERN CATEGORY DESTINATION   </td><td class="markdownTableBodyNone">Creates a logging "tap" on the node(s) described by PATTERN. These taps observe log messages emitted at or below these nodes in the Sparta tree when the messages' categories match CATEGORY. If CATEGORY is "", all message categories match. ALl log output received through this tap is routed to DESTINATION, which is formatted based on the file extension. See the <b>Logging Formats</b> below.   </td></tr>
</table>
<p></b></p>
<p><b> </p><dl class="section user"><dt>3.3.2 Logging Formats</dt><dd></dd></dl>
<p>The <em>DESTINTION</em> field of the --log option directs the log messages from that log tap to a specific destination. These destinations are formatted based on their file extension (for now). Using 1 or 2 as a destination file directs the log output to stdout or stderr respectively.</b></p>
<p><b></p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Format   </th><th class="markdownTableHeadNone">File Extension   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Basic (stdout)   </td><td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">Contains message origin, category, and content    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Basic (stderr)   </td><td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">Contains message origin, category, and content    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Basic (file)   </td><td class="markdownTableBodyNone">*.log.basic   </td><td class="markdownTableBodyNone">Contains message origin, category, and content    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Verbose (file)   </td><td class="markdownTableBodyNone">*.log.verbose   </td><td class="markdownTableBodyNone">Contains all message meta-data    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Raw (file)   </td><td class="markdownTableBodyNone">*.log.raw   </td><td class="markdownTableBodyNone">Contains no message meta-data    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Default (file)   </td><td class="markdownTableBodyNone">(any other )   </td><td class="markdownTableBodyNone">Contains most message meta-data excluding thread and message sequence number   </td></tr>
</table>
<p></b></p>
<p><b> Except <b>raw</b> output, each logger output places its content on a single line, beginning with a an opening '{', followed by some fileds describing the log messages, usualy including a timestamp, origin, and category, followed by a closing '}' and then the log message itself. This generally makes these log messages easily parsable.</b></p>
<p><b> All current logging formats can be seen near the end of the help text generated by --help or by the --help-logging command.</b></p>
<p><b> </p><dl class="section user"><dt>3.3.3 Parsing Output</dt><dd></dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo</a></b></dt><dd>Write this section</dd></dl>
<p></b></p>
<p><b></b></p>
<h2><a class="anchor" id="notification_logging"></a>
<b>3.4 Notification Logging</b></h2>
<p><b></b></p>
<p><b> </p><dl class="section user"><dt></dt><dd>This feature is not yet implemented</dd></dl>
<p></b></p>
<h2><a class="anchor" id="perf_events"></a>
<b>3.5 Performance Events</b></h2>
<p><b></b></p>
<p><b> </p><dl class="section user"><dt></dt><dd>This feature is not yet implemented</dd></dl>
<p></b></p>
<h2><a class="anchor" id="pipeline_collection"></a>
<b>3.6 Pipeline Collection</b></h2>
<p><b></b></p>
<p><b> Pipeline collection captures a per-cycle trace of 'transactions' flowing through specially instrumented stations (e.g. buffer elements, queues, etc.) throughout the simulator when enabled. This data can be visualized in the Argos (<a class="el" href="#argos">4.1 Pipeline viewer (Argos)</a>) viewer with customizable layouts to display and navigate pipeline snapshots and time-based pipeline crawls.</b></p>
<p><b> This data is written to a set of files having a common, user-specified prefix. Support for collection requires participation on the part of each model.</b></p>
<p><b> These files include a clock listing, a map of device tree locations to indices, a transaction data binary, a time-index, and a simulation info file</b></p>
<p><b> </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo</a></b></dt><dd>Write this section</dd></dl>
<p></b></p>
<p><b> See also pipeout_format</b></p>
<p><b> </p><dl class="section user"><dt>3.6.1 Collection Control</dt><dd></dd></dl>
<p>Often, pipeline collection introduces too much performance and disk-space overhead to leave on for a multi-million cycle simulation. It becomes necessary to selectively enable collection after a certain amount of progress has been made in the simulation. Pipeline collection (and log taps) can be controlled with the --debug-on family of options. </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Usage   </th><th class="markdownTableHeadNone">Behavior    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">--debug-on [clock] CYCLE   </td><td class="markdownTableBodyNone">Defers pipeline collection and user-specified logging until cyclye=CYCLE on optional clock=path.to.clock.name    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">--debug-on-icount ICOUNT   </td><td class="markdownTableBodyNone">Defers pipeline collection and user-specified logging until the instruction count has reached ICOUNT. Each simualtor defines its own instruction counter through app::Simulation::findSemanticCounter   </td></tr>
</table>
<p></b></p>
<p><b> </p><dl class="section user"><dt></dt><dd><b>WARNING:</b> This also currently controls all user-specified logging taps (-l,--log) as well.</dd></dl>
<dl class="section user"><dt></dt><dd><b>WARNING:</b> This command will soon be removed and replaced with separate, fine-grained controls for the time period if pipeline collection, reports, and logging taps. This new control will also support triggering based on counters</dd></dl>
<dl class="section user"><dt></dt><dd><b>NOTE:</b> The simulation may also generate a 1-tick instantaneous pipeline file if an exception occurs while running. This may or may not be the same file specified on the command line with -z. If a pipeline dump is created, the debug dump (<a class="el" href="#debug_dump">3.7 Post-Run Debug dumps</a>) will contain the name of the pipeline file.</dd></dl>
<p></b></p>
<h2><a class="anchor" id="debug_dump"></a>
<b>3.7 Post-Run Debug dumps</b></h2>
<p><b> When the Sparta application framework encounters an exception during running or post-run validation, it attempts to dump the debug state. This behavior can be controlled to always dump or never dump using the &ndash;debug-dump command line option. Valid usages are </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Usage   </th><th class="markdownTableHeadNone">Behavior    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">--debug-dump always   </td><td class="markdownTableBodyNone">Always dump    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">--debug-dump never   </td><td class="markdownTableBodyNone">Never dump    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">--debug-dump error   </td><td class="markdownTableBodyNone">(default) Dump on run exception or post-run validation exception   </td></tr>
</table>
<p></b></p>
<p><b> During this dump, the simulator will write information about itself, about the Sparta Scheduler, the exception, the device tree, the backtrace of the exception (if exception is a SpartaException) and then every known resource will be asked to write its debug state to a file. During this procedure all exceptions are suppressed and a note about any suppressed exceptions will be found in the dump.</b></p>
<p><b> When a debug dump occurs, the simulator will write a message such as: </p><pre class="fragment">  [out] Debug state written to "error-dump.dbg"</pre><p></b></p>
<p><b> If a post-run debug dump occurs, the output file used for this dump can be explicitly controlled with the --debug-dump-filenamet argument. </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Usage   </th><th class="markdownTableHeadNone">Behavior    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">--debug-dump-filename FILENAME   </td><td class="markdownTableBodyNone">Save to FILENAME. If "", auto-generates filename    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">(omitted)   </td><td class="markdownTableBodyNone">Auto-generate timestamped filename   </td></tr>
</table>
<p></b></p>
<p><b> </p><dl class="section user"><dt></dt><dd><b>NOTE:</b> Only exceptions are handled by this mechanism. Signals to not currently cause debug dumps.</dd></dl>
<dl class="section user"><dt></dt><dd><b>NOTE:</b> Support for debug dumps during other phases of the simulator (e.g. initialation, teardown) may be added later</dd></dl>
<p>The debug dump file contains a section for each resource in the simulation that writes any debug data to the output stream when given the chance. The file structure will look something like this </p><div class="fragment"><div class="line">================================================================================</div>
<div class="line">Device tree:</div>
<div class="line">================================================================================</div>
<div class="line">_Sparta_global_node_ : &lt;_Sparta_global_node_&gt; {builtin}</div>
<div class="line">+-top : &lt;top (root)&gt;</div>
<div class="line">| +-foo : &lt;top.foo&gt;</div>
<div class="line">| | +-fiz : &lt;top.foo.fiz&gt;</div>
<div class="line">| | +-buz : &lt;top.foo.buz&gt;</div>
<div class="line">&lt;etc...&gt;</div>
<div class="line"> </div>
<div class="line">top.foo.fiz</div>
<div class="line">==============================================</div>
<div class="line">debug info...</div>
<div class="line">debug info...</div>
<div class="line">debug info...</div>
<div class="line">==============================================</div>
<div class="line"> </div>
<div class="line">top.foo.buz</div>
<div class="line">==============================================</div>
<div class="line">debug info...</div>
<div class="line">debug info...</div>
<div class="line">debug info...</div>
<div class="line">==============================================</div>
</div><!-- fragment --><p></b></p>
<p><b> This output contains some ANSI color escape sequences that can look strange if viewed as plaintext. To see the colors represented by these sequences, either </p><div class="fragment"><div class="line">cat dumpfile</div>
</div><!-- fragment --><p> or </p><div class="fragment"><div class="line">less -R dumpfile</div>
</div><!-- fragment --><p></b></p>
<p><b> </p><dl class="section user"><dt></dt><dd><b>NOTE:</b> The format of this file is subject to change. It is not meant to be parsed.</dd></dl>
<dl class="section user"><dt></dt><dd><b>NOTE:</b> In future versions the Sparta CLI may respond to SIGTERM, SIGSTOP/SIGCONT, and SIGQUIT may be handled</dd></dl>
<p></b></p>
<h2><a class="anchor" id="backtraces"></a>
<b>3.4 Backtraces</b></h2>
<p><b> When the Sparta application framework encounters a fatal signal in the following list</p><ul>
<li>SIGSEGV</li>
<li>SIGFPE</li>
<li>SIGILL</li>
<li>SIGABRT</li>
<li>SIGBUS</li>
</ul>
<p></b></p>
<p><b> The simulator will attempt to print a bactrace to stderr and exit with EXIT_FAILURE (from cstdlib). No debug dump is currently written for these signals. Backtraces are also written to the error-dump.dbg (see <a class="el" href="#debug_dump">3.7 Post-Run Debug dumps</a>) file when exiting the simulation due to an unhandled Exception. Other signals may eventually be handled similarly.</b></p>
<p><b></b></p>
<h2><a class="anchor" id="tree_inspection"></a>
<b>3.8 Device Tree Inspection</b></h2>
<p><b> The device tree constructed by the simulator is visible in its entirity to a user who requests it. These are highly verbose options, but give a clear picture of the content of the simulator. When specifying parameters or creating manual report definitions, this is one way to view the structure of the simulator.</b></p>
<p><b></p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Usage   </th><th class="markdownTableHeadNone">Behavior    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">--show-tree   </td><td class="markdownTableBodyNone">Show the entire simulation device tree between each phase of simulator startup and continues as usual    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">--show-parameters   </td><td class="markdownTableBodyNone">Show all parameters in the device tree after configuration is complete and continues as usual    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">--show-ports   </td><td class="markdownTableBodyNone">Show all ports in the device tree after the tree is fully bound and continues as usual    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">--show-counters   </td><td class="markdownTableBodyNone">Show all counters and statistics in the device tree after the tree is fully bound and continues as usual    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">--show-notifications   </td><td class="markdownTableBodyNone">Show all notification sources in the device tree after the tree is fully bound and continues as usual    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">--show-loggers   </td><td class="markdownTableBodyNone">Show all log message sources in the device tree after the tree is fully bound and continues as usual    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">--show-dag   </td><td class="markdownTableBodyNone">Show the Event DAG (directed acyclic graph) and continues as usual    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">&#160;   </td><td class="markdownTableBodyNone">&#160;    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">--help-tree   </td><td class="markdownTableBodyNone">Same as --show-tree --no-run    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">--help-parameters   </td><td class="markdownTableBodyNone">Same as --show-parameters --no-run    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">--help-ports   </td><td class="markdownTableBodyNone">Same as --show-ports --no-run    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">--help-counters   </td><td class="markdownTableBodyNone">Same as --show-counters --no-run    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">--help-notifications   </td><td class="markdownTableBodyNone">Same as --show-notifications --no-run    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">--help-loggers   </td><td class="markdownTableBodyNone">Same as --show-loggers --no-run    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">&#160;   </td><td class="markdownTableBodyNone">&#160;    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">--help-topic verbose   </td><td class="markdownTableBodyNone">Shows verbose help then exits    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">--help-topic brief   </td><td class="markdownTableBodyNone">Shows brief help then exits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">--help-topic logging   </td><td class="markdownTableBodyNone">Shows help topic on logging then exits    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">--help-topic reporting   </td><td class="markdownTableBodyNone">Shows help topic on logging then exits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">--help-topic topics   </td><td class="markdownTableBodyNone">Shows all help topics    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">--help-topic pipeout   </td><td class="markdownTableBodyNone">Shows all help topics    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">--help-topic parameter   </td><td class="markdownTableBodyNone">Shows all help topics   </td></tr>
</table>
<p></b></p>
<p><b> </p><dl class="section user"><dt></dt><dd><b>NOTE:</b> In future versions these options will support the printing of a specific subtree instead of the entire device tree.</dd></dl>
<hr  />
<p> </b></p>
<h1><a class="anchor" id="run_with_debugger"></a>
<b>4 Running with a debugger</b></h1>
<p><b> </b></p>
<h2><a class="anchor" id="run_with_dbg_gdb"></a>
<b>GDB</b></h2>
<p><b> GDB 4.7 is capable of debugging the sparta infrastructure and handles the GNU ISO C++11 standard library.</b></p>
<p><b> The Sparta simulation framework catches and rethrows exceptions internally in order to provide debug dumps, perform proper cleanup, and potentially preserve state for user inspection once an interactive shell is built for sparta simulators. GDB breaks on uncaught exceptions by default, which is not helpful for sparta. It is more effective to break on Exception throws as seen below.</b></p>
<p><b> </p><pre class="fragment">  gdb --args simulator
  ...
  (gdb) catch throw
  (gdb) run</pre><p></b></p>
<p><b> Alternatively, one can set a breakpoint on the <a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">sparta::SpartaException</a> constructor to stop execution at a point very close to an exception being thrown.</b></p>
<p><b> </p><pre class="fragment">  (gdb) break 'sparta::SpartaException::SpartaException()'</pre><p></b></p>
<p><b> This default construtor for SpartaException is always invoked (through delegation) regardless of how the exception is constructed, so it will reliably be hit for every SpartaException (or subclass) that is <b>constructed</b>.</b></p>
<p><b> Be sure to use other run-time debugging tools available, such as <a class="el" href="#msg_logging">3.3 Message Logging</a>, <a class="el" href="#pipeline_collection">3.6 Pipeline Collection</a>, <a class="el" href="#debug_dump">3.7 Post-Run Debug dumps</a>, and <a class="el" href="#backtraces">3.4 Backtraces</a>.</b></p>
<p><b></b></p>
<h2><a class="anchor" id="run_with_dbg_other"></a>
<b>Other Debuggers</b></h2>
<p><b> Other debuggers such as Totalview have been used to debug sparta-based simulators. However, C++11 STL support in this debugger is limited and types like std::shared_ptr from the GNU ISO standard library can cause crashes in this debugger</b></p>
<p><b></p><hr  />
<p> </b></p>
<h1><a class="anchor" id="data_proc_vis"></a>
<b>4 Post-processing and Visualization</b></h1>
<p><b> </b></p>
<h2><a class="anchor" id="argos"></a>
<b>4.1 Pipeline viewer (Argos)</b></h2>
<p><b></b></p>
<p><b> Argos visualizes pipeline data generated from a simulator if that simulator supports sparta pipeline collection. See pipeline for instructions on using pipeline collection.</b></p>
<p><b> Argos is a free-form visualization tool for showing pipeline snapshots and crawls in custom layouts. Development is ongoing.</b></p>
<p><b> Future editions of Argos will aim to provide more dashboard-like functionality with the ability to show counters, statistics, and histograms from the simulation in addition to pipeline state. </b></p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Aug 22 2025 17:16:11 for The Sparta Modeling Framework by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
