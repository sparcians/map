<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Sparta Modeling Framework: sparta::memory::CachedMemory&lt; MemoryWriteType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">The Sparta Modeling Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classsparta_1_1memory_1_1CachedMemory.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsparta_1_1memory_1_1CachedMemory-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">sparta::memory::CachedMemory&lt; MemoryWriteType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Memory that can be used as a cache for core models.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="CachedMemory_8hpp_source.html">CachedMemory.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sparta::memory::CachedMemory&lt; MemoryWriteType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1memory_1_1CachedMemory__inherit__graph.png" border="0" usemap="#asparta_1_1memory_1_1CachedMemory_3_01MemoryWriteType_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="asparta_1_1memory_1_1CachedMemory_3_01MemoryWriteType_01_4_inherit__map" id="asparta_1_1memory_1_1CachedMemory_3_01MemoryWriteType_01_4_inherit__map">
<area shape="rect" title="Memory that can be used as a cache for core models." alt="" coords="8,168,213,208"/>
<area shape="rect" href="classsparta_1_1memory_1_1BlockingMemoryIF.html" title="Pure&#45;virtual memory interface which represents a simple, immediately accessible (blocking) address&#45;sp..." alt="" coords="28,79,193,120"/>
<area shape="poly" title=" " alt="" coords="113,135,113,167,108,167,108,135"/>
<area shape="rect" href="classsparta_1_1memory_1_1DebugMemoryIF.html" title="Memory interface which represents a simple, immediately accessible (blocking) address&#45;space with supp..." alt="" coords="5,5,216,31"/>
<area shape="poly" title=" " alt="" coords="113,46,113,79,108,79,108,46"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for sparta::memory::CachedMemory&lt; MemoryWriteType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1memory_1_1CachedMemory__coll__graph.png" border="0" usemap="#asparta_1_1memory_1_1CachedMemory_3_01MemoryWriteType_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="asparta_1_1memory_1_1CachedMemory_3_01MemoryWriteType_01_4_coll__map" id="asparta_1_1memory_1_1CachedMemory_3_01MemoryWriteType_01_4_coll__map">
<area shape="rect" title="Memory that can be used as a cache for core models." alt="" coords="8,259,213,300"/>
<area shape="rect" href="classsparta_1_1memory_1_1BlockingMemoryIF.html" title="Pure&#45;virtual memory interface which represents a simple, immediately accessible (blocking) address&#45;sp..." alt="" coords="28,169,193,210"/>
<area shape="poly" title=" " alt="" coords="113,225,113,259,108,259,108,225"/>
<area shape="rect" href="classsparta_1_1memory_1_1DebugMemoryIF.html" title="Memory interface which represents a simple, immediately accessible (blocking) address&#45;space with supp..." alt="" coords="5,94,216,120"/>
<area shape="poly" title=" " alt="" coords="113,135,113,169,108,169,108,135"/>
<area shape="rect" href="classsparta_1_1memory_1_1TranslationIF.html" title="Blocking translation interface with 1:1 translation unless subclassed." alt="" coords="15,5,206,31"/>
<area shape="poly" title=" " alt="" coords="113,47,113,94,108,94,108,47"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4c7ea86e8c127375cb5a0edcdc13a6cf" id="r_a4c7ea86e8c127375cb5a0edcdc13a6cf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c7ea86e8c127375cb5a0edcdc13a6cf">CachedMemory</a> (const std::string &amp;name, uint64_t write_id, uint32_t outstanding_writes_watermark, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> block_size, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> total_size, <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html">sparta::memory::BlockingMemoryIF</a> *downstream_memory)</td></tr>
<tr class="memdesc:a4c7ea86e8c127375cb5a0edcdc13a6cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classsparta_1_1memory_1_1CachedMemory.html" title="Memory that can be used as a cache for core models.">CachedMemory</a> object.  <br /></td></tr>
<tr class="separator:a4c7ea86e8c127375cb5a0edcdc13a6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c640bb786b1f4d68b4f470cd85e4b97" id="r_a3c640bb786b1f4d68b4f470cd85e4b97"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c640bb786b1f4d68b4f470cd85e4b97">getWriteID</a> () const</td></tr>
<tr class="memdesc:a3c640bb786b1f4d68b4f470cd85e4b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the write ID for this cache.  <br /></td></tr>
<tr class="separator:a3c640bb786b1f4d68b4f470cd85e4b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4fda8242919792b497822c022013bc1" id="r_af4fda8242919792b497822c022013bc1"><td class="memItemLeft" align="right" valign="top">const std::map&lt; uint64_t, MemoryWriteType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4fda8242919792b497822c022013bc1">getOutstandingWrites</a> () const</td></tr>
<tr class="memdesc:af4fda8242919792b497822c022013bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all outstanding writes.  <br /></td></tr>
<tr class="separator:af4fda8242919792b497822c022013bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2d41625d2b4de4f65b0e05e2b04a0d" id="r_a1d2d41625d2b4de4f65b0e05e2b04a0d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; MemoryWriteType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d2d41625d2b4de4f65b0e05e2b04a0d">getOutstandingWritesForAddr</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> paddr) const</td></tr>
<tr class="memdesc:a1d2d41625d2b4de4f65b0e05e2b04a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given address, find outstanding writes that are not merged/committed.  <br /></td></tr>
<tr class="separator:a1d2d41625d2b4de4f65b0e05e2b04a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94ea7e7ad811157b87af0dc83d88385" id="r_aa94ea7e7ad811157b87af0dc83d88385"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa94ea7e7ad811157b87af0dc83d88385">getNumOutstandingWrites</a> () const</td></tr>
<tr class="memdesc:aa94ea7e7ad811157b87af0dc83d88385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of uncomitted writes.  <br /></td></tr>
<tr class="separator:aa94ea7e7ad811157b87af0dc83d88385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48ca2227e3ec73ca282bc036a01c698" id="r_aa48ca2227e3ec73ca282bc036a01c698"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa48ca2227e3ec73ca282bc036a01c698">commitWrite</a> (const MemoryWriteType &amp;write_to_commit)</td></tr>
<tr class="memdesc:aa48ca2227e3ec73ca282bc036a01c698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit the write that matches the given MemoryWriteType.  <br /></td></tr>
<tr class="separator:aa48ca2227e3ec73ca282bc036a01c698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e2c897917a86b6774a54159d9eb41f" id="r_ae4e2c897917a86b6774a54159d9eb41f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4e2c897917a86b6774a54159d9eb41f">mergeWrite</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> paddr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size, const uint8_t *buf)</td></tr>
<tr class="memdesc:ae4e2c897917a86b6774a54159d9eb41f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge an incoming write from system memory.  <br /></td></tr>
<tr class="separator:ae4e2c897917a86b6774a54159d9eb41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a301b501c6aff43748a6ae97ee8e0c8" id="r_a7a301b501c6aff43748a6ae97ee8e0c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a301b501c6aff43748a6ae97ee8e0c8">dropWrite</a> (const MemoryWriteType &amp;write_to_drop)</td></tr>
<tr class="memdesc:a7a301b501c6aff43748a6ae97ee8e0c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the outstanding write that matches the given MemoryWriteType.  <br /></td></tr>
<tr class="separator:a7a301b501c6aff43748a6ae97ee8e0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028b114e26c84b4e90849dca6a2b5cfa" id="r_a028b114e26c84b4e90849dca6a2b5cfa"><td class="memItemLeft" align="right" valign="top">const MemoryWriteType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a028b114e26c84b4e90849dca6a2b5cfa">getLastOutstandingWrite</a> () const</td></tr>
<tr class="memdesc:a028b114e26c84b4e90849dca6a2b5cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the latest outstanding store access.  <br /></td></tr>
<tr class="separator:a028b114e26c84b4e90849dca6a2b5cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html">sparta::memory::BlockingMemoryIF</a></td></tr>
<tr class="memitem:a27d1b36cb9fc030de5880fcad11a551e inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF" id="r_a27d1b36cb9fc030de5880fcad11a551e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html#a27d1b36cb9fc030de5880fcad11a551e">stringize</a> (bool pretty=false) const</td></tr>
<tr class="memdesc:a27d1b36cb9fc030de5880fcad11a551e inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render description of this <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html" title="Pure-virtual memory interface which represents a simple, immediately accessible (blocking) address-sp...">BlockingMemoryIF</a> as a string.  <br /></td></tr>
<tr class="separator:a27d1b36cb9fc030de5880fcad11a551e inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8c5d968f26baac8aee245f69e629e2 inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF" id="r_a9a8c5d968f26baac8aee245f69e629e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html#a9a8c5d968f26baac8aee245f69e629e2">BlockingMemoryIF</a> (const std::string &amp;desc, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> block_size, const <a class="el" href="structsparta_1_1memory_1_1DebugMemoryIF_1_1AccessWindow.html">DebugMemoryIF::AccessWindow</a> &amp;window, <a class="el" href="classsparta_1_1memory_1_1TranslationIF.html">TranslationIF</a> *transif=nullptr)</td></tr>
<tr class="memdesc:a9a8c5d968f26baac8aee245f69e629e2 inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a blocking memory interface.  <br /></td></tr>
<tr class="separator:a9a8c5d968f26baac8aee245f69e629e2 inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4101acaca8b05c104178ed095d1a80 inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF" id="r_a5b4101acaca8b05c104178ed095d1a80"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html#a5b4101acaca8b05c104178ed095d1a80">tryRead</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size, uint8_t *buf, const void *in_supplement=nullptr, void *out_supplement=nullptr)</td></tr>
<tr class="memdesc:a5b4101acaca8b05c104178ed095d1a80 inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read memory of size <em>size</em> at address <em>addr</em>.  <br /></td></tr>
<tr class="separator:a5b4101acaca8b05c104178ed095d1a80 inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc22520a86cc03110b62033f325e45c0 inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF" id="r_acc22520a86cc03110b62033f325e45c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html#acc22520a86cc03110b62033f325e45c0">read</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size, uint8_t *buf, const void *in_supplement=nullptr, void *out_supplement=nullptr)</td></tr>
<tr class="memdesc:acc22520a86cc03110b62033f325e45c0 inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to read memory.  <br /></td></tr>
<tr class="separator:acc22520a86cc03110b62033f325e45c0 inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85336d877e0227b567f05f901c0e782 inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF" id="r_ae85336d877e0227b567f05f901c0e782"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html#ae85336d877e0227b567f05f901c0e782">tryWrite</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size, const uint8_t *buf, const void *in_supplement=nullptr, void *out_supplement=nullptr)</td></tr>
<tr class="memdesc:ae85336d877e0227b567f05f901c0e782 inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to write memory of size <em>size</em> at address <em>addr</em>.  <br /></td></tr>
<tr class="separator:ae85336d877e0227b567f05f901c0e782 inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabcf3f10b82cd9130538164358074d7 inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF" id="r_afabcf3f10b82cd9130538164358074d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html#afabcf3f10b82cd9130538164358074d7">write</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size, const uint8_t *buf, const void *in_supplement=nullptr, void *out_supplement=nullptr)</td></tr>
<tr class="memdesc:afabcf3f10b82cd9130538164358074d7 inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to write memory.  <br /></td></tr>
<tr class="separator:afabcf3f10b82cd9130538164358074d7 inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab879c2cb4b5a6e0e0a16516235d024e1 inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF" id="r_ab879c2cb4b5a6e0e0a16516235d024e1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classsparta_1_1memory_1_1DMIBlockingMemoryIF.html">DMIBlockingMemoryIF</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html#ab879c2cb4b5a6e0e0a16516235d024e1">getDMI</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size)</td></tr>
<tr class="memdesc:ab879c2cb4b5a6e0e0a16516235d024e1 inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a DMI blocking interface to access the given address/size.  <br /></td></tr>
<tr class="separator:ab879c2cb4b5a6e0e0a16516235d024e1 inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e02e6da4f120023cf4728b2b6b7f7cb inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF" id="r_a6e02e6da4f120023cf4728b2b6b7f7cb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html#a6e02e6da4f120023cf4728b2b6b7f7cb">invalidateAllDMI</a> ()</td></tr>
<tr class="memdesc:a6e02e6da4f120023cf4728b2b6b7f7cb inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate all DMI's.  <br /></td></tr>
<tr class="separator:a6e02e6da4f120023cf4728b2b6b7f7cb inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classsparta_1_1memory_1_1DebugMemoryIF')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html">sparta::memory::DebugMemoryIF</a></td></tr>
<tr class="memitem:ae47924af1683c0df0d0521b661c051a6 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_ae47924af1683c0df0d0521b661c051a6"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>DebugMemoryIF</b> ()=delete</td></tr>
<tr class="memdesc:ae47924af1683c0df0d0521b661c051a6 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constuctor. <br /></td></tr>
<tr class="separator:ae47924af1683c0df0d0521b661c051a6 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216bb8e3ff6974157a2a792408bc4314 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a216bb8e3ff6974157a2a792408bc4314"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a216bb8e3ff6974157a2a792408bc4314">DebugMemoryIF</a> (const std::string &amp;desc, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> block_size, const <a class="el" href="structsparta_1_1memory_1_1DebugMemoryIF_1_1AccessWindow.html">AccessWindow</a> &amp;window, <a class="el" href="classsparta_1_1memory_1_1TranslationIF.html">TranslationIF</a> *transif=nullptr)</td></tr>
<tr class="memdesc:a216bb8e3ff6974157a2a792408bc4314 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a DebugMemoryInterface.  <br /></td></tr>
<tr class="separator:a216bb8e3ff6974157a2a792408bc4314 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc718c72432a36e9271ca56511f911c inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a0bc718c72432a36e9271ca56511f911c"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a0bc718c72432a36e9271ca56511f911c">~DebugMemoryIF</a> ()</td></tr>
<tr class="memdesc:a0bc718c72432a36e9271ca56511f911c inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virutal destructor.  <br /></td></tr>
<tr class="separator:a0bc718c72432a36e9271ca56511f911c inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff89438e6b7853ae0ea0fd43372dc2f inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a2ff89438e6b7853ae0ea0fd43372dc2f"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classsparta_1_1memory_1_1TranslationIF.html">TranslationIF</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a2ff89438e6b7853ae0ea0fd43372dc2f">getTranslationIF</a> ()</td></tr>
<tr class="memdesc:a2ff89438e6b7853ae0ea0fd43372dc2f inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the translation interface associated with this Debug memory interface (if any).  <br /></td></tr>
<tr class="separator:a2ff89438e6b7853ae0ea0fd43372dc2f inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff33a34afa19cb71943d7f12102d2b2 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a2ff33a34afa19cb71943d7f12102d2b2"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a2ff33a34afa19cb71943d7f12102d2b2">getDescription</a> ()</td></tr>
<tr class="memdesc:a2ff33a34afa19cb71943d7f12102d2b2 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the description specified at construction.  <br /></td></tr>
<tr class="separator:a2ff33a34afa19cb71943d7f12102d2b2 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec5c7bd3d39673eacfea9c54341d768 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_afec5c7bd3d39673eacfea9c54341d768"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#afec5c7bd3d39673eacfea9c54341d768">getBlockSize</a> () const</td></tr>
<tr class="memdesc:afec5c7bd3d39673eacfea9c54341d768 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the block size of memory represented by this interface. Read and write accesses must not span block boundaries (where addr % block_size == 0).  <br /></td></tr>
<tr class="separator:afec5c7bd3d39673eacfea9c54341d768 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88eaaf49740910933179b3b489e10c41 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a88eaaf49740910933179b3b489e10c41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a88eaaf49740910933179b3b489e10c41">getRange</a> () const</td></tr>
<tr class="memdesc:a88eaaf49740910933179b3b489e10c41 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total span of this interface's valid address range.  <br /></td></tr>
<tr class="separator:a88eaaf49740910933179b3b489e10c41 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813c0abcfcf0f1da307c0fe66eaead12 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a813c0abcfcf0f1da307c0fe66eaead12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a813c0abcfcf0f1da307c0fe66eaead12">getLowEnd</a> () const</td></tr>
<tr class="memdesc:a813c0abcfcf0f1da307c0fe66eaead12 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the lowest address accessible.  <br /></td></tr>
<tr class="separator:a813c0abcfcf0f1da307c0fe66eaead12 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619defc758b28691ce97c4e37f8d232d inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a619defc758b28691ce97c4e37f8d232d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a619defc758b28691ce97c4e37f8d232d">getHighEnd</a> () const</td></tr>
<tr class="memdesc:a619defc758b28691ce97c4e37f8d232d inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the highest address accessible + 1.  <br /></td></tr>
<tr class="separator:a619defc758b28691ce97c4e37f8d232d inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bafb07c039aab8148305aefc68c578 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a60bafb07c039aab8148305aefc68c578"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a60bafb07c039aab8148305aefc68c578">getAccessibleSize</a> () const</td></tr>
<tr class="memdesc:a60bafb07c039aab8148305aefc68c578 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total accessible size of this interface's valid addresses within the total size (getRange) excluding holes between access windows.  <br /></td></tr>
<tr class="separator:a60bafb07c039aab8148305aefc68c578 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c3357ec5fd3e290636854b46b7719d inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_ad5c3357ec5fd3e290636854b46b7719d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structsparta_1_1memory_1_1DebugMemoryIF_1_1AccessWindow.html">AccessWindow</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#ad5c3357ec5fd3e290636854b46b7719d">getWindows</a> () const</td></tr>
<tr class="memdesc:ad5c3357ec5fd3e290636854b46b7719d inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the vector of windows representing this interface.  <br /></td></tr>
<tr class="separator:ad5c3357ec5fd3e290636854b46b7719d inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1237a04a9fdfb296be4dc712fddbd0e inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_ab1237a04a9fdfb296be4dc712fddbd0e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#ab1237a04a9fdfb296be4dc712fddbd0e">isAddressInWindows</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr) const noexcept</td></tr>
<tr class="memdesc:ab1237a04a9fdfb296be4dc712fddbd0e inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given address is in an access window defined for this interface.  <br /></td></tr>
<tr class="separator:ab1237a04a9fdfb296be4dc712fddbd0e inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35fa48697f197f9357be0d6c5fae0c6 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_ae35fa48697f197f9357be0d6c5fae0c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#ae35fa48697f197f9357be0d6c5fae0c6">verifyInAccessWindows</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size) const</td></tr>
<tr class="memdesc:ae35fa48697f197f9357be0d6c5fae0c6 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies that the range [addr, addr+size) is within the access windows for this interface.  <br /></td></tr>
<tr class="separator:ae35fa48697f197f9357be0d6c5fae0c6 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56bff166f0c2e250be9450a8a152becc inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a56bff166f0c2e250be9450a8a152becc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a56bff166f0c2e250be9450a8a152becc">isInAccessWindows</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size) const</td></tr>
<tr class="memdesc:a56bff166f0c2e250be9450a8a152becc inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the range [addr, addr+size) is within the access windows for this interface.  <br /></td></tr>
<tr class="separator:a56bff166f0c2e250be9450a8a152becc inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb92bd2905d208cab60935b46dcd67a9 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_acb92bd2905d208cab60935b46dcd67a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#acb92bd2905d208cab60935b46dcd67a9">verifyNoBlockSpan</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size) const</td></tr>
<tr class="memdesc:acb92bd2905d208cab60935b46dcd67a9 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies that the given address does not span block boundaries defined for this interface.  <br /></td></tr>
<tr class="separator:acb92bd2905d208cab60935b46dcd67a9 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4efd1a8b860fd5224a78b4f17f06853d inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a4efd1a8b860fd5224a78b4f17f06853d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a4efd1a8b860fd5224a78b4f17f06853d">doesAccessSpan</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size) const noexcept</td></tr>
<tr class="memdesc:a4efd1a8b860fd5224a78b4f17f06853d inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given address spans block boundaries defined for this interface. Accesses which span blocks are illegal for read/write accesses, but allowed for peak/poke debug accesses.  <br /></td></tr>
<tr class="separator:a4efd1a8b860fd5224a78b4f17f06853d inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d460c6428bfcb6d1e37b3b908f17eef inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a1d460c6428bfcb6d1e37b3b908f17eef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a1d460c6428bfcb6d1e37b3b908f17eef">tryPeek</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size, uint8_t *buf) const</td></tr>
<tr class="memdesc:a1d460c6428bfcb6d1e37b3b908f17eef inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to 'peek' memory without having any side effects, size-limitations, alignment constraints except that all bytes peeked are inside an access window for this interface.  <br /></td></tr>
<tr class="separator:a1d460c6428bfcb6d1e37b3b908f17eef inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af806a7b9bf291eb5e1ae1311e70398f2 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_af806a7b9bf291eb5e1ae1311e70398f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#af806a7b9bf291eb5e1ae1311e70398f2">peek</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size, uint8_t *buf) const</td></tr>
<tr class="memdesc:af806a7b9bf291eb5e1ae1311e70398f2 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper on tryPeek which throws a <a class="el" href="classsparta_1_1memory_1_1MemoryAccessError.html" title="Indicates that there was an issue accessing a SPARTA memory object or interface.">MemoryAccessError</a> if the peek is not legal.  <br /></td></tr>
<tr class="separator:af806a7b9bf291eb5e1ae1311e70398f2 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca95f6e332e2c05d78fa5c08ff73965 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_afca95f6e332e2c05d78fa5c08ff73965"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#afca95f6e332e2c05d78fa5c08ff73965">tryPoke</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size, const uint8_t *buf)</td></tr>
<tr class="memdesc:afca95f6e332e2c05d78fa5c08ff73965 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to 'poke' memory without having any side effects other than changing the bytes within the range [ <em>addr</em> , <em>addr</em> + <em>size</em> ). Poke has no size-limitations or alignment constraints except that all bytes peeked are inside an access window for this interface.  <br /></td></tr>
<tr class="separator:afca95f6e332e2c05d78fa5c08ff73965 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5d6378acc3c8737db0f6416b8082df inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_abb5d6378acc3c8737db0f6416b8082df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#abb5d6378acc3c8737db0f6416b8082df">poke</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size, const uint8_t *buf)</td></tr>
<tr class="memdesc:abb5d6378acc3c8737db0f6416b8082df inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper on tryPoke which throws a <a class="el" href="classsparta_1_1memory_1_1MemoryAccessError.html" title="Indicates that there was an issue accessing a SPARTA memory object or interface.">MemoryAccessError</a> if the poke is not legal.  <br /></td></tr>
<tr class="separator:abb5d6378acc3c8737db0f6416b8082df inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classsparta_1_1memory_1_1BlockingMemoryIF"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classsparta_1_1memory_1_1BlockingMemoryIF')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html">sparta::memory::BlockingMemoryIF</a></td></tr>
<tr class="inherit_header pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html">sparta::memory::DebugMemoryIF</a></td></tr>
<tr class="memitem:a65c02153d3a5600ccd331c8888aa99b5 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a65c02153d3a5600ccd331c8888aa99b5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a65c02153d3a5600ccd331c8888aa99b5">block_size_</a></td></tr>
<tr class="memdesc:a65c02153d3a5600ccd331c8888aa99b5 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of a block accessed through this interface.  <br /></td></tr>
<tr class="separator:a65c02153d3a5600ccd331c8888aa99b5 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3017884c6a75c3c142c996bc621e68 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a7a3017884c6a75c3c142c996bc621e68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a7a3017884c6a75c3c142c996bc621e68">block_mask_</a></td></tr>
<tr class="memdesc:a7a3017884c6a75c3c142c996bc621e68 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask applied to an address to get only bits representing the block ID.  <br /></td></tr>
<tr class="separator:a7a3017884c6a75c3c142c996bc621e68 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ca96578aee4568ca9f7f65d97f8622 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF" id="r_ac8ca96578aee4568ca9f7f65d97f8622"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#ac8ca96578aee4568ca9f7f65d97f8622">block_idx_lsb_</a></td></tr>
<tr class="memdesc:ac8ca96578aee4568ca9f7f65d97f8622 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">rshift applied to an address to get the block ID  <br /></td></tr>
<tr class="separator:ac8ca96578aee4568ca9f7f65d97f8622 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3ebb4e5d6568ef4cf7ed73c4b3efb5 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF" id="r_aed3ebb4e5d6568ef4cf7ed73c4b3efb5"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structsparta_1_1memory_1_1DebugMemoryIF_1_1AccessWindow.html">AccessWindow</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#aed3ebb4e5d6568ef4cf7ed73c4b3efb5">acc_windows_</a></td></tr>
<tr class="memdesc:aed3ebb4e5d6568ef4cf7ed73c4b3efb5 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of access windows representing this memory.  <br /></td></tr>
<tr class="separator:aed3ebb4e5d6568ef4cf7ed73c4b3efb5 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76ed77db27ed4a7c3c08d75a965faf6 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF" id="r_aa76ed77db27ed4a7c3c08d75a965faf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1memory_1_1TranslationIF.html">TranslationIF</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#aa76ed77db27ed4a7c3c08d75a965faf6">trans_</a></td></tr>
<tr class="memdesc:aa76ed77db27ed4a7c3c08d75a965faf6 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1memory_1_1Translation.html" title="An older class used to help in encapsulate read/virtual addresses.">Translation</a> interface created for this interface. Externally owned.  <br /></td></tr>
<tr class="separator:aa76ed77db27ed4a7c3c08d75a965faf6 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2182d932a817fceab277b60492a5203 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF" id="r_ad2182d932a817fceab277b60492a5203"><td class="memItemLeft" align="right" valign="top">const std::string *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#ad2182d932a817fceab277b60492a5203">desc_ptr_</a></td></tr>
<tr class="memdesc:ad2182d932a817fceab277b60492a5203 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description pointer.  <br /></td></tr>
<tr class="separator:ad2182d932a817fceab277b60492a5203 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c0a329c864f37b5021277ce4349dc0 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a64c0a329c864f37b5021277ce4349dc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a64c0a329c864f37b5021277ce4349dc0">total_range_</a></td></tr>
<tr class="memdesc:a64c0a329c864f37b5021277ce4349dc0 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range of addresses from highest accessible to lowest.  <br /></td></tr>
<tr class="separator:a64c0a329c864f37b5021277ce4349dc0 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece4fca05034cac697a447f391027fbf inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF" id="r_aece4fca05034cac697a447f391027fbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#aece4fca05034cac697a447f391027fbf">low_end_</a></td></tr>
<tr class="memdesc:aece4fca05034cac697a447f391027fbf inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowest accessible address.  <br /></td></tr>
<tr class="separator:aece4fca05034cac697a447f391027fbf inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11cbfa9ae6babb7e56cdc56366a3ae33 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a11cbfa9ae6babb7e56cdc56366a3ae33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a11cbfa9ae6babb7e56cdc56366a3ae33">high_end_</a></td></tr>
<tr class="memdesc:a11cbfa9ae6babb7e56cdc56366a3ae33 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Highest accessible address + 1.  <br /></td></tr>
<tr class="separator:a11cbfa9ae6babb7e56cdc56366a3ae33 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616fca295fada16fa14ec939588265be inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a616fca295fada16fa14ec939588265be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a616fca295fada16fa14ec939588265be">accessible_size_</a></td></tr>
<tr class="memdesc:a616fca295fada16fa14ec939588265be inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes accessible through this interface.  <br /></td></tr>
<tr class="separator:a616fca295fada16fa14ec939588265be inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class MemoryWriteType = StoreData&gt;<br />
class sparta::memory::CachedMemory&lt; MemoryWriteType &gt;</div><p>Memory that can be used as a cache for core models. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MemoryWriteType</td><td>Type supplied by the modeler to track the outstanding writes</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="classsparta_1_1memory_1_1CachedMemory.html" title="Memory that can be used as a cache for core models.">CachedMemory</a> is used by a functional/performance model to "cache" outstanding writes and provide those values back to the core when asked. It is implemented as full memory model, with its memory always representing the latest stored value that is not committed.</p>
<p>When the write is committed by a functional model (like in a cosimulation environment), the data is pushed downstream.</p>
<p>If the memory is <em>not</em> to be pushed out (flushing for example), the modeler can "drop" that memory update and <a class="el" href="classsparta_1_1memory_1_1CachedMemory.html" title="Memory that can be used as a cache for core models.">CachedMemory</a> will restore the previous value.</p>
<p>Use case: data-driven performance modeling where there are speculative stores (storing to a local store commit buffer) and there are dependent loads on that data. If the store is no longer speculative, the store is officially committed. If it's flushed, old data can be restored and downstream memory (main memory/IO devices, etc) will never see the data.</p>
<p>System memory is responsible for updating other <a class="el" href="classsparta_1_1memory_1_1CachedMemory.html" title="Memory that can be used as a cache for core models.">CachedMemory</a> instances in the case of multicore.</p>
<p>Since this class acts like a cache off of a core (example), a few rules apply:</p>
<ol type="1">
<li>Reads will always be from this block of memory and must be aligned. If the read is not in this cache, downstream memory will be peeked, but the result will not be cached.</li>
<li>Writes will always cache. If the data were not in the cache initially, downsteam memory will be peeked and loaded before merging the write data.</li>
<li>Peeking will always be a read on the cache memory. If the block is not in the cache, peeking will be forwarded to downstream memory</li>
<li>Poking will always write to the cache as well as downsteam memory. If the data is not in the cache, it will be loaded into the cache before being written </li>
</ol>

<p class="definition">Definition at line <a class="el" href="CachedMemory_8hpp_source.html#l00164">164</a> of file <a class="el" href="CachedMemory_8hpp_source.html">CachedMemory.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4c7ea86e8c127375cb5a0edcdc13a6cf" name="a4c7ea86e8c127375cb5a0edcdc13a6cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7ea86e8c127375cb5a0edcdc13a6cf">&#9670;&#160;</a></span>CachedMemory()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemoryWriteType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1memory_1_1CachedMemory.html">sparta::memory::CachedMemory</a>&lt; MemoryWriteType &gt;::CachedMemory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>write_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>outstanding_writes_watermark</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>block_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>total_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html">sparta::memory::BlockingMemoryIF</a> *</td>          <td class="paramname"><span class="paramname"><em>downstream_memory</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classsparta_1_1memory_1_1CachedMemory.html" title="Memory that can be used as a cache for core models.">CachedMemory</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td><a class="el" href="classsparta_1_1memory_1_1CachedMemory.html" title="Memory that can be used as a cache for core models.">CachedMemory</a> name </td></tr>
    <tr><td class="paramname">write_id</td><td>The ID this <a class="el" href="classsparta_1_1memory_1_1CachedMemory.html" title="Memory that can be used as a cache for core models.">CachedMemory</a> to uniquify memory writes </td></tr>
    <tr><td class="paramname">outstanding_writes_watermark</td><td>Watermark for assertion if uncomitted writes get too large </td></tr>
    <tr><td class="paramname">block_size</td><td>Block size of the cache. (See sparta::MemoryObject::MemoryObject) </td></tr>
    <tr><td class="paramname">total_size</td><td>Total size of the cache block (See sparta::MemoryObject::MemoryObject) </td></tr>
    <tr><td class="paramname">downstream_memory</td><td>The coherency point past this <a class="el" href="classsparta_1_1memory_1_1CachedMemory.html" title="Memory that can be used as a cache for core models.">CachedMemory</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="CachedMemory_8hpp_source.html#l00280">280</a> of file <a class="el" href="CachedMemory_8hpp_source.html">CachedMemory.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa48ca2227e3ec73ca282bc036a01c698" name="aa48ca2227e3ec73ca282bc036a01c698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa48ca2227e3ec73ca282bc036a01c698">&#9670;&#160;</a></span>commitWrite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemoryWriteType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsparta_1_1memory_1_1CachedMemory.html">sparta::memory::CachedMemory</a>&lt; MemoryWriteType &gt;::commitWrite </td>
          <td>(</td>
          <td class="paramtype">const MemoryWriteType &amp;</td>          <td class="paramname"><span class="paramname"><em>write_to_commit</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Commit the write that matches the given MemoryWriteType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">write_to_commit</td><td>The MemoryAccessWrite to commit</td></tr>
  </table>
  </dd>
</dl>
<p>There must be an exact match in the cache for that address/size combination for the outstanding write to be removed </p>

<p class="definition">Definition at line <a class="el" href="CachedMemory_8hpp_source.html#l00394">394</a> of file <a class="el" href="CachedMemory_8hpp_source.html">CachedMemory.hpp</a>.</p>

</div>
</div>
<a id="a7a301b501c6aff43748a6ae97ee8e0c8" name="a7a301b501c6aff43748a6ae97ee8e0c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a301b501c6aff43748a6ae97ee8e0c8">&#9670;&#160;</a></span>dropWrite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemoryWriteType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsparta_1_1memory_1_1CachedMemory.html">sparta::memory::CachedMemory</a>&lt; MemoryWriteType &gt;::dropWrite </td>
          <td>(</td>
          <td class="paramtype">const MemoryWriteType &amp;</td>          <td class="paramname"><span class="paramname"><em>write_to_drop</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop the outstanding write that matches the given MemoryWriteType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">write_to_drop</td><td>The MemoryAccessWrite to drop </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a></td><td>if no commit with the given exists </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="CachedMemory_8hpp_source.html#l00421">421</a> of file <a class="el" href="CachedMemory_8hpp_source.html">CachedMemory.hpp</a>.</p>

</div>
</div>
<a id="a028b114e26c84b4e90849dca6a2b5cfa" name="a028b114e26c84b4e90849dca6a2b5cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028b114e26c84b4e90849dca6a2b5cfa">&#9670;&#160;</a></span>getLastOutstandingWrite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemoryWriteType  = StoreData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MemoryWriteType &amp; <a class="el" href="classsparta_1_1memory_1_1CachedMemory.html">sparta::memory::CachedMemory</a>&lt; MemoryWriteType &gt;::getLastOutstandingWrite </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the latest outstanding store access. </p>
<dl class="section return"><dt>Returns</dt><dd>The latest/newest write access created </dd></dl>

<p class="definition">Definition at line <a class="el" href="CachedMemory_8hpp_source.html#l00249">249</a> of file <a class="el" href="CachedMemory_8hpp_source.html">CachedMemory.hpp</a>.</p>

</div>
</div>
<a id="aa94ea7e7ad811157b87af0dc83d88385" name="aa94ea7e7ad811157b87af0dc83d88385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa94ea7e7ad811157b87af0dc83d88385">&#9670;&#160;</a></span>getNumOutstandingWrites()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemoryWriteType  = StoreData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classsparta_1_1memory_1_1CachedMemory.html">sparta::memory::CachedMemory</a>&lt; MemoryWriteType &gt;::getNumOutstandingWrites </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of uncomitted writes. </p>

<p class="definition">Definition at line <a class="el" href="CachedMemory_8hpp_source.html#l00214">214</a> of file <a class="el" href="CachedMemory_8hpp_source.html">CachedMemory.hpp</a>.</p>

</div>
</div>
<a id="af4fda8242919792b497822c022013bc1" name="af4fda8242919792b497822c022013bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4fda8242919792b497822c022013bc1">&#9670;&#160;</a></span>getOutstandingWrites()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemoryWriteType  = StoreData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; uint64_t, MemoryWriteType &gt; &amp; <a class="el" href="classsparta_1_1memory_1_1CachedMemory.html">sparta::memory::CachedMemory</a>&lt; MemoryWriteType &gt;::getOutstandingWrites </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all outstanding writes. </p>
<dl class="section return"><dt>Returns</dt><dd>vector of outstanding memory access writes based on the user type </dd></dl>

<p class="definition">Definition at line <a class="el" href="CachedMemory_8hpp_source.html#l00194">194</a> of file <a class="el" href="CachedMemory_8hpp_source.html">CachedMemory.hpp</a>.</p>

</div>
</div>
<a id="a1d2d41625d2b4de4f65b0e05e2b04a0d" name="a1d2d41625d2b4de4f65b0e05e2b04a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d2d41625d2b4de4f65b0e05e2b04a0d">&#9670;&#160;</a></span>getOutstandingWritesForAddr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemoryWriteType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; MemoryWriteType &gt; <a class="el" href="classsparta_1_1memory_1_1CachedMemory.html">sparta::memory::CachedMemory</a>&lt; MemoryWriteType &gt;::getOutstandingWritesForAddr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>paddr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given address, find outstanding writes that are not merged/committed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">paddr</td><td>Physical address to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of outstanding memory writes that match</dd></dl>
<p>This function will return all MemAccessWrites that it finds that partially (at least/most 1 byte) or completely contains the given paddr.</p>
<p>The first element of the vector is the oldest outstanding write </p>

<p class="definition">Definition at line <a class="el" href="CachedMemory_8hpp_source.html#l00381">381</a> of file <a class="el" href="CachedMemory_8hpp_source.html">CachedMemory.hpp</a>.</p>

</div>
</div>
<a id="a3c640bb786b1f4d68b4f470cd85e4b97" name="a3c640bb786b1f4d68b4f470cd85e4b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c640bb786b1f4d68b4f470cd85e4b97">&#9670;&#160;</a></span>getWriteID()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemoryWriteType  = StoreData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classsparta_1_1memory_1_1CachedMemory.html">sparta::memory::CachedMemory</a>&lt; MemoryWriteType &gt;::getWriteID </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the write ID for this cache. </p>
<dl class="section return"><dt>Returns</dt><dd>The write ID given at construction </dd></dl>

<p class="definition">Definition at line <a class="el" href="CachedMemory_8hpp_source.html#l00188">188</a> of file <a class="el" href="CachedMemory_8hpp_source.html">CachedMemory.hpp</a>.</p>

</div>
</div>
<a id="ae4e2c897917a86b6774a54159d9eb41f" name="ae4e2c897917a86b6774a54159d9eb41f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e2c897917a86b6774a54159d9eb41f">&#9670;&#160;</a></span>mergeWrite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MemoryWriteType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsparta_1_1memory_1_1CachedMemory.html">sparta::memory::CachedMemory</a>&lt; MemoryWriteType &gt;::mergeWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>paddr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge an incoming write from system memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">paddr</td><td>Write's address </td></tr>
    <tr><td class="paramname">size</td><td>Write's size (in bytes) </td></tr>
    <tr><td class="paramname">buf</td><td>Data to store</td></tr>
  </table>
  </dd>
</dl>
<p>This function will merge the given data into this cache only writing those bytes that do not collide wtih stores that have not been committed. </p>

<p class="definition">Definition at line <a class="el" href="CachedMemory_8hpp_source.html#l00461">461</a> of file <a class="el" href="CachedMemory_8hpp_source.html">CachedMemory.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/github/workspace/sparta/sparta/memory/<a class="el" href="CachedMemory_8hpp_source.html">CachedMemory.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesparta.html">sparta</a></li><li class="navelem"><a class="el" href="namespacesparta_1_1memory.html">memory</a></li><li class="navelem"><a class="el" href="classsparta_1_1memory_1_1CachedMemory.html">CachedMemory</a></li>
    <li class="footer">Generated on Fri Aug 22 2025 17:16:16 for The Sparta Modeling Framework by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
