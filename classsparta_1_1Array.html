<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Sparta Modeling Framework: sparta::Array&lt; DataT, ArrayT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">The Sparta Modeling Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classsparta_1_1Array.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsparta_1_1Array-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">sparta::Array&lt; DataT, ArrayT &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a> is essentially a fixed size vector, maintains a concept of validity of its indexes, and provides access via stl iteration and general get methods.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Array_8hpp_source.html">Array.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsparta_1_1Array_1_1ArrayIterator.html">ArrayIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator struct for this array.  <a href="structsparta_1_1Array_1_1ArrayIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1bb281eb6ea67b75689245df3f312217" id="r_a1bb281eb6ea67b75689245df3f312217"><td class="memItemLeft" align="right" valign="top">typedef DataT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1bb281eb6ea67b75689245df3f312217">value_type</a></td></tr>
<tr class="memdesc:a1bb281eb6ea67b75689245df3f312217"><td class="mdescLeft">&#160;</td><td class="mdescRight">The data type, STL style.  <br /></td></tr>
<tr class="separator:a1bb281eb6ea67b75689245df3f312217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546060e6fa2adb6becdede9562261d1b" id="r_a546060e6fa2adb6becdede9562261d1b"><td class="memItemLeft" align="right" valign="top">typedef DataT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a546060e6fa2adb6becdede9562261d1b">DataType</a></td></tr>
<tr class="memdesc:a546060e6fa2adb6becdede9562261d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected typedef for the data that will be stored in this structure.  <br /></td></tr>
<tr class="separator:a546060e6fa2adb6becdede9562261d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515ba51f9b4063f374e1bfaa4bc8df3e" id="r_a515ba51f9b4063f374e1bfaa4bc8df3e"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a515ba51f9b4063f374e1bfaa4bc8df3e">size_type</a></td></tr>
<tr class="memdesc:a515ba51f9b4063f374e1bfaa4bc8df3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for size_type.  <br /></td></tr>
<tr class="separator:a515ba51f9b4063f374e1bfaa4bc8df3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9638faa1db280f6dca4e95bf585ec83a" id="r_a9638faa1db280f6dca4e95bf585ec83a"><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9638faa1db280f6dca4e95bf585ec83a">AgedList</a></td></tr>
<tr class="memdesc:a9638faa1db280f6dca4e95bf585ec83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a list of indexes in age order.  <br /></td></tr>
<tr class="separator:a9638faa1db280f6dca4e95bf585ec83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda1560686f6087d7eeca8b8c7ebb161" id="r_acda1560686f6087d7eeca8b8c7ebb161"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsparta_1_1Array_1_1ArrayIterator.html">ArrayIterator</a>&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acda1560686f6087d7eeca8b8c7ebb161">iterator</a></td></tr>
<tr class="memdesc:acda1560686f6087d7eeca8b8c7ebb161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for regular iterator.  <br /></td></tr>
<tr class="separator:acda1560686f6087d7eeca8b8c7ebb161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f98b24cb76df10e17b0cc1e92b59df2" id="r_a4f98b24cb76df10e17b0cc1e92b59df2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsparta_1_1Array_1_1ArrayIterator.html">ArrayIterator</a>&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f98b24cb76df10e17b0cc1e92b59df2">const_iterator</a></td></tr>
<tr class="memdesc:a4f98b24cb76df10e17b0cc1e92b59df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for constant iterator.  <br /></td></tr>
<tr class="separator:a4f98b24cb76df10e17b0cc1e92b59df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acc3b48ca8f281222590b94db05ff0116" id="r_acc3b48ca8f281222590b94db05ff0116"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#acda1560686f6087d7eeca8b8c7ebb161">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc3b48ca8f281222590b94db05ff0116">getCircularIterator</a> (uint32_t idx=0)</td></tr>
<tr class="memdesc:acc3b48ca8f281222590b94db05ff0116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator that is circular on the <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a> (has no <a class="el" href="#a109717b550dd8e2e6556f624511934b8" title="STL-like end operation.">end()</a>)  <br /></td></tr>
<tr class="separator:acc3b48ca8f281222590b94db05ff0116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab94d543d1def48f666f176e364b5a1f" id="r_aab94d543d1def48f666f176e364b5a1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#acda1560686f6087d7eeca8b8c7ebb161">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab94d543d1def48f666f176e364b5a1f">getUnitializedIterator</a> ()</td></tr>
<tr class="memdesc:aab94d543d1def48f666f176e364b5a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a method to get an uninitialized iterator.  <br /></td></tr>
<tr class="separator:aab94d543d1def48f666f176e364b5a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907a7790d84849692fd3b90bf4f41a59" id="r_a907a7790d84849692fd3b90bf4f41a59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#acda1560686f6087d7eeca8b8c7ebb161">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a907a7790d84849692fd3b90bf4f41a59">begin</a> ()</td></tr>
<tr class="memdesc:a907a7790d84849692fd3b90bf4f41a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like begin operation, starts at index 0 (ignores valid bit).  <br /></td></tr>
<tr class="separator:a907a7790d84849692fd3b90bf4f41a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14979dea733c40c2233453652d1dd77" id="r_ac14979dea733c40c2233453652d1dd77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a4f98b24cb76df10e17b0cc1e92b59df2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac14979dea733c40c2233453652d1dd77">begin</a> () const</td></tr>
<tr class="memdesc:ac14979dea733c40c2233453652d1dd77"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like begin operation, const, starts at index 0 (ignores valid bit).  <br /></td></tr>
<tr class="separator:ac14979dea733c40c2233453652d1dd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109717b550dd8e2e6556f624511934b8" id="r_a109717b550dd8e2e6556f624511934b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#acda1560686f6087d7eeca8b8c7ebb161">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a109717b550dd8e2e6556f624511934b8">end</a> ()</td></tr>
<tr class="memdesc:a109717b550dd8e2e6556f624511934b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like end operation.  <br /></td></tr>
<tr class="separator:a109717b550dd8e2e6556f624511934b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46951fc8d770a8d48c961fba80d376c" id="r_ae46951fc8d770a8d48c961fba80d376c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a4f98b24cb76df10e17b0cc1e92b59df2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae46951fc8d770a8d48c961fba80d376c">end</a> () const</td></tr>
<tr class="memdesc:ae46951fc8d770a8d48c961fba80d376c"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like end operation, const.  <br /></td></tr>
<tr class="separator:ae46951fc8d770a8d48c961fba80d376c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1ec52fc43356ee602b064087efa012" id="r_a1b1ec52fc43356ee602b064087efa012"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#acda1560686f6087d7eeca8b8c7ebb161">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b1ec52fc43356ee602b064087efa012">abegin</a> ()</td></tr>
<tr class="memdesc:a1b1ec52fc43356ee602b064087efa012"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like begin operation, starts at the oldest valid index.  <br /></td></tr>
<tr class="separator:a1b1ec52fc43356ee602b064087efa012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cbe7b4bc9837392562aecc1bedf0a54" id="r_a8cbe7b4bc9837392562aecc1bedf0a54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a4f98b24cb76df10e17b0cc1e92b59df2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cbe7b4bc9837392562aecc1bedf0a54">abegin</a> () const</td></tr>
<tr class="memdesc:a8cbe7b4bc9837392562aecc1bedf0a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like begin operation, const, starts at the oldest valid index.  <br /></td></tr>
<tr class="separator:a8cbe7b4bc9837392562aecc1bedf0a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed7f95597f8b7488b2607eb5b686cdd" id="r_a6ed7f95597f8b7488b2607eb5b686cdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#acda1560686f6087d7eeca8b8c7ebb161">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ed7f95597f8b7488b2607eb5b686cdd">aend</a> ()</td></tr>
<tr class="memdesc:a6ed7f95597f8b7488b2607eb5b686cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like end operation.  <br /></td></tr>
<tr class="separator:a6ed7f95597f8b7488b2607eb5b686cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7500ddfee429ad4c31e8b97d76c6b14a" id="r_a7500ddfee429ad4c31e8b97d76c6b14a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a4f98b24cb76df10e17b0cc1e92b59df2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7500ddfee429ad4c31e8b97d76c6b14a">aend</a> () const</td></tr>
<tr class="memdesc:a7500ddfee429ad4c31e8b97d76c6b14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like end operation, const.  <br /></td></tr>
<tr class="separator:a7500ddfee429ad4c31e8b97d76c6b14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539dcd630e9aae1d235b5ff14e995387" id="r_a539dcd630e9aae1d235b5ff14e995387"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a539dcd630e9aae1d235b5ff14e995387">Array</a> (const std::string &amp;name, uint32_t num_entries, const <a class="el" href="classsparta_1_1Clock.html">Clock</a> *clk, <a class="el" href="classsparta_1_1StatisticSet.html">StatisticSet</a> *statset=nullptr, <a class="el" href="classsparta_1_1InstrumentationNode.html#a507d5eba99bdae4b0fefe7ab69050965">InstrumentationNode::visibility_t</a> stat_vis_general=<a class="el" href="classsparta_1_1InstrumentationNode.html#a9e4e4feeb259d54e2fafb15325e3fd8b">InstrumentationNode::AUTO_VISIBILITY</a>, <a class="el" href="classsparta_1_1InstrumentationNode.html#a507d5eba99bdae4b0fefe7ab69050965">InstrumentationNode::visibility_t</a> stat_vis_detailed=<a class="el" href="classsparta_1_1InstrumentationNode.html#a855b6ecdd93e412052ae264032002ce1a01a69b1a50e88559f40efc68ba7e5224">InstrumentationNode::VIS_HIDDEN</a>, <a class="el" href="classsparta_1_1InstrumentationNode.html#a507d5eba99bdae4b0fefe7ab69050965">InstrumentationNode::visibility_t</a> stat_vis_max=<a class="el" href="classsparta_1_1InstrumentationNode.html#a9e4e4feeb259d54e2fafb15325e3fd8b">InstrumentationNode::AUTO_VISIBILITY</a>, <a class="el" href="classsparta_1_1InstrumentationNode.html#a507d5eba99bdae4b0fefe7ab69050965">InstrumentationNode::visibility_t</a> stat_vis_avg=<a class="el" href="classsparta_1_1InstrumentationNode.html#a9e4e4feeb259d54e2fafb15325e3fd8b">InstrumentationNode::AUTO_VISIBILITY</a>)</td></tr>
<tr class="memdesc:a539dcd630e9aae1d235b5ff14e995387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an array.  <br /></td></tr>
<tr class="separator:a539dcd630e9aae1d235b5ff14e995387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90601a0bc2ddfaa11d58903b7c8e774" id="r_ad90601a0bc2ddfaa11d58903b7c8e774"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad90601a0bc2ddfaa11d58903b7c8e774">~Array</a> ()</td></tr>
<tr class="memdesc:ad90601a0bc2ddfaa11d58903b7c8e774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <br /></td></tr>
<tr class="separator:ad90601a0bc2ddfaa11d58903b7c8e774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34378974bf1f8a986556b71e2b074d57" id="r_a34378974bf1f8a986556b71e2b074d57"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34378974bf1f8a986556b71e2b074d57">getName</a> () const</td></tr>
<tr class="memdesc:a34378974bf1f8a986556b71e2b074d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of this resource.  <br /></td></tr>
<tr class="separator:a34378974bf1f8a986556b71e2b074d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b47047a46bca0f7375c680465fd2192" id="r_a6b47047a46bca0f7375c680465fd2192"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b47047a46bca0f7375c680465fd2192">isValid</a> (const uint32_t idx) const</td></tr>
<tr class="memdesc:a6b47047a46bca0f7375c680465fd2192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether an index is currently valid.  <br /></td></tr>
<tr class="separator:a6b47047a46bca0f7375c680465fd2192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d854e215f22fbe70407ab87a5bc11c" id="r_a75d854e215f22fbe70407ab87a5bc11c"><td class="memItemLeft" align="right" valign="top">const DataT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75d854e215f22fbe70407ab87a5bc11c">read</a> (const uint32_t idx) const</td></tr>
<tr class="memdesc:a75d854e215f22fbe70407ab87a5bc11c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read (only) the data at an index.  <br /></td></tr>
<tr class="separator:a75d854e215f22fbe70407ab87a5bc11c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0dceb28fe2dd2cd96e51869f5bbee3" id="r_a4e0dceb28fe2dd2cd96e51869f5bbee3"><td class="memItemLeft" align="right" valign="top">DataT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e0dceb28fe2dd2cd96e51869f5bbee3">access</a> (const uint32_t idx)</td></tr>
<tr class="memdesc:a4e0dceb28fe2dd2cd96e51869f5bbee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access (writeable) the data at a position.  <br /></td></tr>
<tr class="separator:a4e0dceb28fe2dd2cd96e51869f5bbee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef7ce44f6458ea2061d9776678178dc" id="r_a6ef7ce44f6458ea2061d9776678178dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a4f98b24cb76df10e17b0cc1e92b59df2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ef7ce44f6458ea2061d9776678178dc">getOldestIndex</a> (const uint32_t nth=0) const</td></tr>
<tr class="memdesc:a6ef7ce44f6458ea2061d9776678178dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the oldest index in the array.  <br /></td></tr>
<tr class="separator:a6ef7ce44f6458ea2061d9776678178dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63bf00d9c60726b2939338c0c885094e" id="r_a63bf00d9c60726b2939338c0c885094e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a4f98b24cb76df10e17b0cc1e92b59df2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63bf00d9c60726b2939338c0c885094e">getYoungestIndex</a> (const uint32_t nth=0) const</td></tr>
<tr class="memdesc:a63bf00d9c60726b2939338c0c885094e"><td class="mdescLeft">&#160;</td><td class="mdescRight">provide access the youngest index in the array.  <br /></td></tr>
<tr class="separator:a63bf00d9c60726b2939338c0c885094e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b458c2ca7766f2f6414241bcf4505fe" id="r_a2b458c2ca7766f2f6414241bcf4505fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b458c2ca7766f2f6414241bcf4505fe">getNextOldestIndex</a> (uint32_t &amp;prev_idx) const</td></tr>
<tr class="memdesc:a2b458c2ca7766f2f6414241bcf4505fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the input argument to the index containing the location of the next oldest item after input argument. If the input argument is the youngest index, we return false.  <br /></td></tr>
<tr class="separator:a2b458c2ca7766f2f6414241bcf4505fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703a278a381ba1c2bd0b14efa4d598cf" id="r_a703a278a381ba1c2bd0b14efa4d598cf"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a703a278a381ba1c2bd0b14efa4d598cf">getAge</a> (const uint32_t idx) const</td></tr>
<tr class="memdesc:a703a278a381ba1c2bd0b14efa4d598cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide the age information of the given entry index.  <br /></td></tr>
<tr class="separator:a703a278a381ba1c2bd0b14efa4d598cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0dd0962d692683c1f4f0ef3df9278f" id="r_a3c0dd0962d692683c1f4f0ef3df9278f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a9638faa1db280f6dca4e95bf585ec83a">AgedList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c0dd0962d692683c1f4f0ef3df9278f">getAgedList</a> () const</td></tr>
<tr class="memdesc:a3c0dd0962d692683c1f4f0ef3df9278f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide access to our aged_list_ internals.  <br /></td></tr>
<tr class="separator:a3c0dd0962d692683c1f4f0ef3df9278f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04bb4a1d42dec14d026afe15c65eef35" id="r_a04bb4a1d42dec14d026afe15c65eef35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a515ba51f9b4063f374e1bfaa4bc8df3e">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04bb4a1d42dec14d026afe15c65eef35">capacity</a> () const</td></tr>
<tr class="memdesc:a04bb4a1d42dec14d026afe15c65eef35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum number of elements this <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a> can hold.  <br /></td></tr>
<tr class="separator:a04bb4a1d42dec14d026afe15c65eef35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58ce73335e9712a099f78571664fb22" id="r_ad58ce73335e9712a099f78571664fb22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a515ba51f9b4063f374e1bfaa4bc8df3e">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad58ce73335e9712a099f78571664fb22">numValid</a> () const</td></tr>
<tr class="memdesc:ad58ce73335e9712a099f78571664fb22"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of valid entries contained.  <br /></td></tr>
<tr class="separator:ad58ce73335e9712a099f78571664fb22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039224bc8e092407594aff700851e8b4" id="r_a039224bc8e092407594aff700851e8b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a515ba51f9b4063f374e1bfaa4bc8df3e">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a039224bc8e092407594aff700851e8b4">size</a> () const</td></tr>
<tr class="separator:a039224bc8e092407594aff700851e8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e5a2ba4cb4744cffa13dd76745e138" id="r_a48e5a2ba4cb4744cffa13dd76745e138"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a515ba51f9b4063f374e1bfaa4bc8df3e">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48e5a2ba4cb4744cffa13dd76745e138">numFree</a> () const</td></tr>
<tr class="memdesc:a48e5a2ba4cb4744cffa13dd76745e138"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of free entries.  <br /></td></tr>
<tr class="separator:a48e5a2ba4cb4744cffa13dd76745e138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb0ab0790272625843677fc769654ff" id="r_aedb0ab0790272625843677fc769654ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedb0ab0790272625843677fc769654ff">erase</a> (const <a class="el" href="#acda1560686f6087d7eeca8b8c7ebb161">iterator</a> &amp;iter)</td></tr>
<tr class="memdesc:aedb0ab0790272625843677fc769654ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate data at an iterator position.  <br /></td></tr>
<tr class="separator:aedb0ab0790272625843677fc769654ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02bc7a8692af50863c6bbb276a2609d6" id="r_a02bc7a8692af50863c6bbb276a2609d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02bc7a8692af50863c6bbb276a2609d6">erase</a> (const uint32_t &amp;idx)</td></tr>
<tr class="memdesc:a02bc7a8692af50863c6bbb276a2609d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate the entry at a certain index.  <br /></td></tr>
<tr class="separator:a02bc7a8692af50863c6bbb276a2609d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0797e3e64c1819e7ef7c48d665f8f8" id="r_aef0797e3e64c1819e7ef7c48d665f8f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef0797e3e64c1819e7ef7c48d665f8f8">clear</a> ()</td></tr>
<tr class="memdesc:aef0797e3e64c1819e7ef7c48d665f8f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the array of all data.  <br /></td></tr>
<tr class="separator:aef0797e3e64c1819e7ef7c48d665f8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469f43e31ed089cede106dd07254ffa9" id="r_a469f43e31ed089cede106dd07254ffa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a469f43e31ed089cede106dd07254ffa9">write</a> (const uint32_t idx, const DataT &amp;dat)</td></tr>
<tr class="memdesc:a469f43e31ed089cede106dd07254ffa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to the array.  <br /></td></tr>
<tr class="separator:a469f43e31ed089cede106dd07254ffa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1b7e23f0d8cb0a251652942448106f" id="r_afe1b7e23f0d8cb0a251652942448106f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe1b7e23f0d8cb0a251652942448106f">write</a> (const uint32_t idx, DataT &amp;&amp;dat)</td></tr>
<tr class="memdesc:afe1b7e23f0d8cb0a251652942448106f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to the array.  <br /></td></tr>
<tr class="separator:afe1b7e23f0d8cb0a251652942448106f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0831489c25514d68eb4be986ae6b2f3b" id="r_a0831489c25514d68eb4be986ae6b2f3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0831489c25514d68eb4be986ae6b2f3b">write</a> (const <a class="el" href="#acda1560686f6087d7eeca8b8c7ebb161">iterator</a> &amp;iter, const DataT &amp;dat)</td></tr>
<tr class="memdesc:a0831489c25514d68eb4be986ae6b2f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data at an iterator position.  <br /></td></tr>
<tr class="separator:a0831489c25514d68eb4be986ae6b2f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7bcdfa954a2c815a31ec40469e570b" id="r_a9b7bcdfa954a2c815a31ec40469e570b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b7bcdfa954a2c815a31ec40469e570b">write</a> (const <a class="el" href="#acda1560686f6087d7eeca8b8c7ebb161">iterator</a> &amp;iter, DataT &amp;&amp;dat)</td></tr>
<tr class="memdesc:a9b7bcdfa954a2c815a31ec40469e570b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data at an iterator position.  <br /></td></tr>
<tr class="separator:a9b7bcdfa954a2c815a31ec40469e570b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7be5afcb2c23c312f3420639bf9ff28" id="r_ab7be5afcb2c23c312f3420639bf9ff28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7be5afcb2c23c312f3420639bf9ff28">isYounger</a> (uint32_t lhs, uint32_t rhs)</td></tr>
<tr class="memdesc:ab7be5afcb2c23c312f3420639bf9ff28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if an index was written (using <a class="el" href="#a469f43e31ed089cede106dd07254ffa9" title="Write data to the array.">write()</a>) to the <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a> after another index.  <br /></td></tr>
<tr class="separator:ab7be5afcb2c23c312f3420639bf9ff28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fae013527896550d8a4ae1b1d621c1" id="r_ad2fae013527896550d8a4ae1b1d621c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2fae013527896550d8a4ae1b1d621c1">isOlder</a> (uint32_t lhs, uint32_t rhs)</td></tr>
<tr class="memdesc:ad2fae013527896550d8a4ae1b1d621c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if an index was written (using <a class="el" href="#a469f43e31ed089cede106dd07254ffa9" title="Write data to the array.">write()</a>) to the <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a> before another index.  <br /></td></tr>
<tr class="separator:ad2fae013527896550d8a4ae1b1d621c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa046c91cf846523a2c1fba7765246ca" id="r_aaa046c91cf846523a2c1fba7765246ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa046c91cf846523a2c1fba7765246ca">enableCollection</a> (<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *parent)</td></tr>
<tr class="memdesc:aaa046c91cf846523a2c1fba7765246ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up a auto-collector for this <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a>.  <br /></td></tr>
<tr class="separator:aaa046c91cf846523a2c1fba7765246ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class DataT, <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt;<br />
class sparta::Array&lt; DataT, ArrayT &gt;</div><p><a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a> is essentially a fixed size vector, maintains a concept of validity of its indexes, and provides access via stl iteration and general get methods. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataT</td><td>the data type stored in the <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a>. </td></tr>
    <tr><td class="paramname">ArrayT</td><td>the type of array <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3a97be62eb080a8b5fcc3f3f06a80a6cc7">ArrayType::AGED</a> vs <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3a1e23852820b9154316c7c06e2b7ba051">ArrayType::NORMAL</a></td></tr>
  </table>
  </dd>
</dl>
<p>The <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a> class maintains a list of elements, constrained to the number of entries, allowing a user to add/remove entries from the middle, beginning, or end without collapsing. If the template parameter <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3a97be62eb080a8b5fcc3f3f06a80a6cc7">ArrayType::AGED</a> is provided (default), the array will keep track of the age of the internal components.</p>
<p>The methods <a class="el" href="#a907a7790d84849692fd3b90bf4f41a59" title="STL-like begin operation, starts at index 0 (ignores valid bit).">begin()</a> and <a class="el" href="#a109717b550dd8e2e6556f624511934b8" title="STL-like end operation.">end()</a> will return iterators to the array, with <a class="el" href="#a907a7790d84849692fd3b90bf4f41a59" title="STL-like begin operation, starts at index 0 (ignores valid bit).">begin()</a> always returning an iterator pointing to index 0 and <a class="el" href="#a109717b550dd8e2e6556f624511934b8" title="STL-like end operation.">end()</a> pointing beyond it. The iterator <b>might</b> <b>not</b> be pointing to valid data, so a call to <a class="el" href="#a6b47047a46bca0f7375c680465fd2192" title="Determine whether an index is currently valid.">isValid()</a> on the iterator is required before dereferencing.</p>
<p>To iterator over the aged list, use the methods <a class="el" href="#a1b1ec52fc43356ee602b064087efa012" title="STL-like begin operation, starts at the oldest valid index.">abegin()</a> and <a class="el" href="#a6ed7f95597f8b7488b2607eb5b686cdd" title="STL-like end operation.">aend()</a>. </p>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00057">57</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9638faa1db280f6dca4e95bf585ec83a" name="a9638faa1db280f6dca4e95bf585ec83a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9638faa1db280f6dca4e95bf585ec83a">&#9670;&#160;</a></span>AgedList</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;uint32_t&gt; <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::AgedList</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a list of indexes in age order. </p>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00096">96</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="a4f98b24cb76df10e17b0cc1e92b59df2" name="a4f98b24cb76df10e17b0cc1e92b59df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f98b24cb76df10e17b0cc1e92b59df2">&#9670;&#160;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsparta_1_1Array_1_1ArrayIterator.html">ArrayIterator</a>&lt;true&gt; <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for constant iterator. </p>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00379">379</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="a546060e6fa2adb6becdede9562261d1b" name="a546060e6fa2adb6becdede9562261d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546060e6fa2adb6becdede9562261d1b">&#9670;&#160;</a></span>DataType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DataT <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::DataType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expected typedef for the data that will be stored in this structure. </p>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00090">90</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="acda1560686f6087d7eeca8b8c7ebb161" name="acda1560686f6087d7eeca8b8c7ebb161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda1560686f6087d7eeca8b8c7ebb161">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsparta_1_1Array_1_1ArrayIterator.html">ArrayIterator</a>&lt;false&gt; <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for regular iterator. </p>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00376">376</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="a515ba51f9b4063f374e1bfaa4bc8df3e" name="a515ba51f9b4063f374e1bfaa4bc8df3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515ba51f9b4063f374e1bfaa4bc8df3e">&#9670;&#160;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::size_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for size_type. </p>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00093">93</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="a1bb281eb6ea67b75689245df3f312217" name="a1bb281eb6ea67b75689245df3f312217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb281eb6ea67b75689245df3f312217">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DataT <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The data type, STL style. </p>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00087">87</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a539dcd630e9aae1d235b5ff14e995387" name="a539dcd630e9aae1d235b5ff14e995387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a539dcd630e9aae1d235b5ff14e995387">&#9670;&#160;</a></span>Array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::Array </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>num_entries</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1Clock.html">Clock</a> *</td>          <td class="paramname"><span class="paramname"><em>clk</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1StatisticSet.html">StatisticSet</a> *</td>          <td class="paramname"><span class="paramname"><em>statset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1InstrumentationNode.html#a507d5eba99bdae4b0fefe7ab69050965">InstrumentationNode::visibility_t</a></td>          <td class="paramname"><span class="paramname"><em>stat_vis_general</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classsparta_1_1InstrumentationNode.html#a9e4e4feeb259d54e2fafb15325e3fd8b">InstrumentationNode::AUTO_VISIBILITY</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1InstrumentationNode.html#a507d5eba99bdae4b0fefe7ab69050965">InstrumentationNode::visibility_t</a></td>          <td class="paramname"><span class="paramname"><em>stat_vis_detailed</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classsparta_1_1InstrumentationNode.html#a855b6ecdd93e412052ae264032002ce1a01a69b1a50e88559f40efc68ba7e5224">InstrumentationNode::VIS_HIDDEN</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1InstrumentationNode.html#a507d5eba99bdae4b0fefe7ab69050965">InstrumentationNode::visibility_t</a></td>          <td class="paramname"><span class="paramname"><em>stat_vis_max</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classsparta_1_1InstrumentationNode.html#a9e4e4feeb259d54e2fafb15325e3fd8b">InstrumentationNode::AUTO_VISIBILITY</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1InstrumentationNode.html#a507d5eba99bdae4b0fefe7ab69050965">InstrumentationNode::visibility_t</a></td>          <td class="paramname"><span class="paramname"><em>stat_vis_avg</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classsparta_1_1InstrumentationNode.html#a9e4e4feeb259d54e2fafb15325e3fd8b">InstrumentationNode::AUTO_VISIBILITY</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the buffer </td></tr>
    <tr><td class="paramname">num_entries</td><td>The number of entries this buffer can hold </td></tr>
    <tr><td class="paramname">clk</td><td>The clock this buffer belongs to </td></tr>
    <tr><td class="paramname">statset</td><td>Pointer to the counter set to register utilization counts; default nullptr. This works for timed and untimed.</td></tr>
    <tr><td class="paramname">stat_vis_general</td><td>Sets the visibility of the stat counters for the 0th and last index of the utilization counts, so the empty and full counts.</td></tr>
    <tr><td class="paramname">stat_vis_detailed</td><td>Sets the visibility of the stat counts between 0 and the last index. i.e. more detailed than the general stats, default VIS_HIDDEN</td></tr>
    <tr><td class="paramname">stat_vis_max</td><td>Sets the visibility for a stat that contains the maximum utilization for this buffer. The default is AUTO_VISIBILITY.</td></tr>
    <tr><td class="paramname">stat_vis_avg</td><td>Sets the visibility for a stat that contains the weighted utilization average for this buffer. The default is AUTO_VISIBILITY.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>By default the stat_vis_* options are set to VIS_SPARTA_DEFAULT, for this structure AUTO_VISIBILITY resolves to CONTAINER_DEFAULT_VISIBILITY which at the time of writing this comment is set to VIS_HIDDEN. If you rely on the stats from this container you should explicitly set the visibility. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l01020">1020</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="ad90601a0bc2ddfaa11d58903b7c8e774" name="ad90601a0bc2ddfaa11d58903b7c8e774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90601a0bc2ddfaa11d58903b7c8e774">&#9670;&#160;</a></span>~Array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::~<a class="el" href="classsparta_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual destructor. </p>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00526">526</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Array_ad90601a0bc2ddfaa11d58903b7c8e774_cgraph.png" border="0" usemap="#aclasssparta_1_1Array_ad90601a0bc2ddfaa11d58903b7c8e774_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Array_ad90601a0bc2ddfaa11d58903b7c8e774_cgraph" id="aclasssparta_1_1Array_ad90601a0bc2ddfaa11d58903b7c8e774_cgraph">
<area shape="rect" title="Virtual destructor." alt="" coords="5,5,142,31"/>
<area shape="rect" href="classsparta_1_1Array.html#aef0797e3e64c1819e7ef7c48d665f8f8" title="Clear the array of all data." alt="" coords="190,5,317,31"/>
<area shape="poly" title=" " alt="" coords="142,16,174,16,174,21,142,21"/>
</map>
</div>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1b1ec52fc43356ee602b064087efa012" name="a1b1ec52fc43356ee602b064087efa012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1ec52fc43356ee602b064087efa012">&#9670;&#160;</a></span>abegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acda1560686f6087d7eeca8b8c7ebb161">iterator</a> <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::abegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STL-like begin operation, starts at the oldest valid index. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the oldest entry in the array </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00441">441</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Array_a1b1ec52fc43356ee602b064087efa012_cgraph.png" border="0" usemap="#aclasssparta_1_1Array_a1b1ec52fc43356ee602b064087efa012_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Array_a1b1ec52fc43356ee602b064087efa012_cgraph" id="aclasssparta_1_1Array_a1b1ec52fc43356ee602b064087efa012_cgraph">
<area shape="rect" title="STL&#45;like begin operation, starts at the oldest valid index." alt="" coords="5,42,143,68"/>
<area shape="rect" href="classsparta_1_1Array.html#a6ef7ce44f6458ea2061d9776678178dc" title="Return the oldest index in the array." alt="" coords="191,5,346,46"/>
<area shape="poly" title=" " alt="" coords="143,42,175,37,176,42,143,47"/>
<area shape="rect" href="classsparta_1_1Array.html#ad58ce73335e9712a099f78571664fb22" title="The number of valid entries contained." alt="" coords="192,70,345,96"/>
<area shape="poly" title=" " alt="" coords="143,62,177,67,176,72,143,68"/>
<area shape="rect" href="classsparta_1_1Array.html#a6b47047a46bca0f7375c680465fd2192" title="Determine whether an index is currently valid." alt="" coords="394,13,532,38"/>
<area shape="poly" title=" " alt="" coords="346,23,379,23,379,28,346,28"/>
</map>
</div>

</div>
</div>
<a id="a8cbe7b4bc9837392562aecc1bedf0a54" name="a8cbe7b4bc9837392562aecc1bedf0a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cbe7b4bc9837392562aecc1bedf0a54">&#9670;&#160;</a></span>abegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a4f98b24cb76df10e17b0cc1e92b59df2">const_iterator</a> <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::abegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STL-like begin operation, const, starts at the oldest valid index. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the oldest entry in the array </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00454">454</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Array_a8cbe7b4bc9837392562aecc1bedf0a54_cgraph.png" border="0" usemap="#aclasssparta_1_1Array_a8cbe7b4bc9837392562aecc1bedf0a54_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Array_a8cbe7b4bc9837392562aecc1bedf0a54_cgraph" id="aclasssparta_1_1Array_a8cbe7b4bc9837392562aecc1bedf0a54_cgraph">
<area shape="rect" title="STL&#45;like begin operation, const, starts at the oldest valid index." alt="" coords="5,42,143,68"/>
<area shape="rect" href="classsparta_1_1Array.html#a6ef7ce44f6458ea2061d9776678178dc" title="Return the oldest index in the array." alt="" coords="191,5,346,46"/>
<area shape="poly" title=" " alt="" coords="143,42,175,37,176,42,143,47"/>
<area shape="rect" href="classsparta_1_1Array.html#ad58ce73335e9712a099f78571664fb22" title="The number of valid entries contained." alt="" coords="192,70,345,96"/>
<area shape="poly" title=" " alt="" coords="143,62,177,67,176,72,143,68"/>
<area shape="rect" href="classsparta_1_1Array.html#a6b47047a46bca0f7375c680465fd2192" title="Determine whether an index is currently valid." alt="" coords="394,13,532,38"/>
<area shape="poly" title=" " alt="" coords="346,23,379,23,379,28,346,28"/>
</map>
</div>

</div>
</div>
<a id="a4e0dceb28fe2dd2cd96e51869f5bbee3" name="a4e0dceb28fe2dd2cd96e51869f5bbee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e0dceb28fe2dd2cd96e51869f5bbee3">&#9670;&#160;</a></span>access()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DataT &amp; <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::access </td>
          <td>(</td>
          <td class="paramtype">const uint32_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access (writeable) the data at a position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index to access. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00560">560</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Array_a4e0dceb28fe2dd2cd96e51869f5bbee3_cgraph.png" border="0" usemap="#aclasssparta_1_1Array_a4e0dceb28fe2dd2cd96e51869f5bbee3_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Array_a4e0dceb28fe2dd2cd96e51869f5bbee3_cgraph" id="aclasssparta_1_1Array_a4e0dceb28fe2dd2cd96e51869f5bbee3_cgraph">
<area shape="rect" title="Access (writeable) the data at a position." alt="" coords="5,5,147,31"/>
<area shape="rect" href="classsparta_1_1Array.html#a6b47047a46bca0f7375c680465fd2192" title="Determine whether an index is currently valid." alt="" coords="195,5,333,31"/>
<area shape="poly" title=" " alt="" coords="147,16,179,16,179,21,147,21"/>
</map>
</div>

</div>
</div>
<a id="a6ed7f95597f8b7488b2607eb5b686cdd" name="a6ed7f95597f8b7488b2607eb5b686cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed7f95597f8b7488b2607eb5b686cdd">&#9670;&#160;</a></span>aend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acda1560686f6087d7eeca8b8c7ebb161">iterator</a> <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::aend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STL-like end operation. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element past the youngest entry </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00466">466</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="a7500ddfee429ad4c31e8b97d76c6b14a" name="a7500ddfee429ad4c31e8b97d76c6b14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7500ddfee429ad4c31e8b97d76c6b14a">&#9670;&#160;</a></span>aend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a4f98b24cb76df10e17b0cc1e92b59df2">const_iterator</a> <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::aend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STL-like end operation, const. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the element one past the youngest entry </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00475">475</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="a907a7790d84849692fd3b90bf4f41a59" name="a907a7790d84849692fd3b90bf4f41a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a907a7790d84849692fd3b90bf4f41a59">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acda1560686f6087d7eeca8b8c7ebb161">iterator</a> <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STL-like begin operation, starts at index 0 (ignores valid bit). </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the beginning of the <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00405">405</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="ac14979dea733c40c2233453652d1dd77" name="ac14979dea733c40c2233453652d1dd77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14979dea733c40c2233453652d1dd77">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a4f98b24cb76df10e17b0cc1e92b59df2">const_iterator</a> <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STL-like begin operation, const, starts at index 0 (ignores valid bit). </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the beginning of the <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00414">414</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="a04bb4a1d42dec14d026afe15c65eef35" name="a04bb4a1d42dec14d026afe15c65eef35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04bb4a1d42dec14d026afe15c65eef35">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a515ba51f9b4063f374e1bfaa4bc8df3e">size_type</a> <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum number of elements this <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a> can hold. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of positions this array was constructed with </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00680">680</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="aef0797e3e64c1819e7ef7c48d665f8f8" name="aef0797e3e64c1819e7ef7c48d665f8f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef0797e3e64c1819e7ef7c48d665f8f8">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the array of all data. </p>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00748">748</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="aaa046c91cf846523a2c1fba7765246ca" name="aaa046c91cf846523a2c1fba7765246ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa046c91cf846523a2c1fba7765246ca">&#9670;&#160;</a></span>enableCollection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::enableCollection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set up a auto-collector for this <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the parent tree node under which to create the collection </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00848">848</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Array_aaa046c91cf846523a2c1fba7765246ca_cgraph.png" border="0" usemap="#aclasssparta_1_1Array_aaa046c91cf846523a2c1fba7765246ca_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Array_aaa046c91cf846523a2c1fba7765246ca_cgraph" id="aclasssparta_1_1Array_aaa046c91cf846523a2c1fba7765246ca_cgraph">
<area shape="rect" title="Set up a auto&#45;collector for this Array." alt="" coords="5,5,200,31"/>
<area shape="rect" href="classsparta_1_1Array.html#a04bb4a1d42dec14d026afe15c65eef35" title="Return the maximum number of elements this Array can hold." alt="" coords="248,5,395,31"/>
<area shape="poly" title=" " alt="" coords="200,16,233,16,233,21,200,21"/>
</map>
</div>

</div>
</div>
<a id="a109717b550dd8e2e6556f624511934b8" name="a109717b550dd8e2e6556f624511934b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109717b550dd8e2e6556f624511934b8">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acda1560686f6087d7eeca8b8c7ebb161">iterator</a> <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STL-like end operation. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the end of the <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a>, past the last element </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00423">423</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="ae46951fc8d770a8d48c961fba80d376c" name="ae46951fc8d770a8d48c961fba80d376c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46951fc8d770a8d48c961fba80d376c">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a4f98b24cb76df10e17b0cc1e92b59df2">const_iterator</a> <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STL-like end operation, const. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the end of the <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a>, past the last element </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00432">432</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="aedb0ab0790272625843677fc769654ff" name="aedb0ab0790272625843677fc769654ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb0ab0790272625843677fc769654ff">&#9670;&#160;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#acda1560686f6087d7eeca8b8c7ebb161">iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invalidate data at an iterator position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>An iterator used to invalidate &ndash; must be valid </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00710">710</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Array_aedb0ab0790272625843677fc769654ff_cgraph.png" border="0" usemap="#aclasssparta_1_1Array_aedb0ab0790272625843677fc769654ff_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Array_aedb0ab0790272625843677fc769654ff_cgraph" id="aclasssparta_1_1Array_aedb0ab0790272625843677fc769654ff_cgraph">
<area shape="rect" title="Invalidate data at an iterator position." alt="" coords="5,46,137,72"/>
<area shape="poly" title=" " alt="" coords="38,47,31,38,35,28,49,22,71,20,95,22,108,29,105,34,94,27,71,25,50,27,39,32,36,37,42,44"/>
<area shape="rect" href="structsparta_1_1Array_1_1ArrayIterator.html#ac3725d0fc1cd5bba92898d9f45936d8a" title="What index does our iterator currently represent." alt="" coords="185,5,355,46"/>
<area shape="poly" title=" " alt="" coords="137,45,169,40,170,45,138,51"/>
<area shape="rect" href="structsparta_1_1Array_1_1ArrayIterator.html#a559cd56f34e40b70c7fc55e98b4dc53f" title="Determine whether this array entry pointed to by this iterator is valid." alt="" coords="185,71,355,111"/>
<area shape="poly" title=" " alt="" coords="138,67,170,72,169,77,137,72"/>
<area shape="rect" href="namespacesparta.html#a57bc9340188818892abcbd141b40fa50" title="Ensures that a pointer is not null." alt="" coords="403,13,507,38"/>
<area shape="poly" title=" " alt="" coords="356,23,387,23,387,28,356,28"/>
<area shape="rect" href="namespacesparta.html#ac0a2df7a7ca53b2fc0384476286b95ec" title="Demangles a C++ symbol." alt="" coords="555,13,675,38"/>
<area shape="poly" title=" " alt="" coords="508,23,540,23,540,28,508,28"/>
</map>
</div>

</div>
</div>
<a id="a02bc7a8692af50863c6bbb276a2609d6" name="a02bc7a8692af50863c6bbb276a2609d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02bc7a8692af50863c6bbb276a2609d6">&#9670;&#160;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const uint32_t &amp;</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invalidate the entry at a certain index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index to invalidate. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00719">719</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Array_a02bc7a8692af50863c6bbb276a2609d6_cgraph.png" border="0" usemap="#aclasssparta_1_1Array_a02bc7a8692af50863c6bbb276a2609d6_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Array_a02bc7a8692af50863c6bbb276a2609d6_cgraph" id="aclasssparta_1_1Array_a02bc7a8692af50863c6bbb276a2609d6_cgraph">
<area shape="rect" title="Invalidate the entry at a certain index." alt="" coords="5,5,137,31"/>
<area shape="rect" href="classsparta_1_1Array.html#a6b47047a46bca0f7375c680465fd2192" title="Determine whether an index is currently valid." alt="" coords="185,5,323,31"/>
<area shape="poly" title=" " alt="" coords="137,16,169,16,169,21,137,21"/>
</map>
</div>

</div>
</div>
<a id="a703a278a381ba1c2bd0b14efa4d598cf" name="a703a278a381ba1c2bd0b14efa4d598cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a703a278a381ba1c2bd0b14efa4d598cf">&#9670;&#160;</a></span>getAge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::getAge </td>
          <td>(</td>
          <td class="paramtype">const uint32_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide the age information of the given entry index. </p>
<dl class="section return"><dt>Returns</dt><dd>The age of the index. The less, the older. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00659">659</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Array_a703a278a381ba1c2bd0b14efa4d598cf_cgraph.png" border="0" usemap="#aclasssparta_1_1Array_a703a278a381ba1c2bd0b14efa4d598cf_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Array_a703a278a381ba1c2bd0b14efa4d598cf_cgraph" id="aclasssparta_1_1Array_a703a278a381ba1c2bd0b14efa4d598cf_cgraph">
<area shape="rect" title="Provide the age information of the given entry index." alt="" coords="5,5,146,31"/>
<area shape="rect" href="classsparta_1_1Array.html#a6b47047a46bca0f7375c680465fd2192" title="Determine whether an index is currently valid." alt="" coords="194,5,332,31"/>
<area shape="poly" title=" " alt="" coords="146,16,178,16,178,21,146,21"/>
</map>
</div>

</div>
</div>
<a id="a3c0dd0962d692683c1f4f0ef3df9278f" name="a3c0dd0962d692683c1f4f0ef3df9278f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0dd0962d692683c1f4f0ef3df9278f">&#9670;&#160;</a></span>getAgedList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#a9638faa1db280f6dca4e95bf585ec83a">AgedList</a> &amp; <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::getAgedList </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide access to our aged_list_ internals. </p>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00669">669</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="acc3b48ca8f281222590b94db05ff0116" name="acc3b48ca8f281222590b94db05ff0116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3b48ca8f281222590b94db05ff0116">&#9670;&#160;</a></span>getCircularIterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acda1560686f6087d7eeca8b8c7ebb161">iterator</a> <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::getCircularIterator </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator that is circular on the <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a> (has no <a class="el" href="#a109717b550dd8e2e6556f624511934b8" title="STL-like end operation.">end()</a>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Where to start from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator type that a ++ will never == <a class="el" href="#a109717b550dd8e2e6556f624511934b8" title="STL-like end operation.">end()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00386">386</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="a34378974bf1f8a986556b71e2b074d57" name="a34378974bf1f8a986556b71e2b074d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34378974bf1f8a986556b71e2b074d57">&#9670;&#160;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::getName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name of this resource. </p>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00533">533</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="a2b458c2ca7766f2f6414241bcf4505fe" name="a2b458c2ca7766f2f6414241bcf4505fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b458c2ca7766f2f6414241bcf4505fe">&#9670;&#160;</a></span>getNextOldestIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::getNextOldestIndex </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;</td>          <td class="paramname"><span class="paramname"><em>prev_idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the input argument to the index containing the location of the next oldest item after input argument. If the input argument is the youngest index, we return false. </p>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00645">645</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="a6ef7ce44f6458ea2061d9776678178dc" name="a6ef7ce44f6458ea2061d9776678178dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ef7ce44f6458ea2061d9776678178dc">&#9670;&#160;</a></span>getOldestIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a4f98b24cb76df10e17b0cc1e92b59df2">const_iterator</a> <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::getOldestIndex </td>
          <td>(</td>
          <td class="paramtype">const uint32_t</td>          <td class="paramname"><span class="paramname"><em>nth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the oldest index in the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nth</td><td>Is the nth oldest entry you are looking for. nth=0 is the oldest entry, nth = 1 is the second oldest, etc.. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the nth oldest entry. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this method may be expensive for larger nth values. Low values should be very quick.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is only accessible if the template parameter FullArrayType == AGED </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00578">578</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Array_a6ef7ce44f6458ea2061d9776678178dc_cgraph.png" border="0" usemap="#aclasssparta_1_1Array_a6ef7ce44f6458ea2061d9776678178dc_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Array_a6ef7ce44f6458ea2061d9776678178dc_cgraph" id="aclasssparta_1_1Array_a6ef7ce44f6458ea2061d9776678178dc_cgraph">
<area shape="rect" title="Return the oldest index in the array." alt="" coords="5,5,161,46"/>
<area shape="rect" href="classsparta_1_1Array.html#a6b47047a46bca0f7375c680465fd2192" title="Determine whether an index is currently valid." alt="" coords="209,13,347,38"/>
<area shape="poly" title=" " alt="" coords="161,23,193,23,193,28,161,28"/>
</map>
</div>

</div>
</div>
<a id="aab94d543d1def48f666f176e364b5a1f" name="aab94d543d1def48f666f176e364b5a1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab94d543d1def48f666f176e364b5a1f">&#9670;&#160;</a></span>getUnitializedIterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acda1560686f6087d7eeca8b8c7ebb161">iterator</a> <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::getUnitializedIterator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide a method to get an uninitialized iterator. </p>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00395">395</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="a63bf00d9c60726b2939338c0c885094e" name="a63bf00d9c60726b2939338c0c885094e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63bf00d9c60726b2939338c0c885094e">&#9670;&#160;</a></span>getYoungestIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a4f98b24cb76df10e17b0cc1e92b59df2">const_iterator</a> <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::getYoungestIndex </td>
          <td>(</td>
          <td class="paramtype">const uint32_t</td>          <td class="paramname"><span class="paramname"><em>nth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>provide access the youngest index in the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nth</td><td>Is the nth youngest entry to be found. nth=0 is the youngest, nth=1 is the second youngest, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the nth youngest index. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this method may get expensive for larger nth values.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is only accessible if the template parameter FullArrayType == AGED. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00616">616</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Array_a63bf00d9c60726b2939338c0c885094e_cgraph.png" border="0" usemap="#aclasssparta_1_1Array_a63bf00d9c60726b2939338c0c885094e_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Array_a63bf00d9c60726b2939338c0c885094e_cgraph" id="aclasssparta_1_1Array_a63bf00d9c60726b2939338c0c885094e_cgraph">
<area shape="rect" title="provide access the youngest index in the array." alt="" coords="5,5,178,46"/>
<area shape="rect" href="classsparta_1_1Array.html#a6b47047a46bca0f7375c680465fd2192" title="Determine whether an index is currently valid." alt="" coords="226,13,364,38"/>
<area shape="poly" title=" " alt="" coords="178,23,210,23,210,28,178,28"/>
</map>
</div>

</div>
</div>
<a id="ad2fae013527896550d8a4ae1b1d621c1" name="ad2fae013527896550d8a4ae1b1d621c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2fae013527896550d8a4ae1b1d621c1">&#9670;&#160;</a></span>isOlder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::isOlder </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if an index was written (using <a class="el" href="#a469f43e31ed089cede106dd07254ffa9" title="Write data to the array.">write()</a>) to the <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a> before another index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>an index to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>an index to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if lhs was written at less recently than rhs was written at. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00836">836</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="a6b47047a46bca0f7375c680465fd2192" name="a6b47047a46bca0f7375c680465fd2192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b47047a46bca0f7375c680465fd2192">&#9670;&#160;</a></span>isValid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::isValid </td>
          <td>(</td>
          <td class="paramtype">const uint32_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether an index is currently valid. </p>
<dl class="section return"><dt>Returns</dt><dd>true if valid. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00541">541</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="ab7be5afcb2c23c312f3420639bf9ff28" name="ab7be5afcb2c23c312f3420639bf9ff28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7be5afcb2c23c312f3420639bf9ff28">&#9670;&#160;</a></span>isYounger()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::isYounger </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if an index was written (using <a class="el" href="#a469f43e31ed089cede106dd07254ffa9" title="Write data to the array.">write()</a>) to the <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a> after another index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>an index to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>an index to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if lhs was written more recently than rhs to the array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00821">821</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="a48e5a2ba4cb4744cffa13dd76745e138" name="a48e5a2ba4cb4744cffa13dd76745e138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48e5a2ba4cb4744cffa13dd76745e138">&#9670;&#160;</a></span>numFree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a515ba51f9b4063f374e1bfaa4bc8df3e">size_type</a> <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::numFree </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of free entries. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of free spaces in the array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00701">701</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="ad58ce73335e9712a099f78571664fb22" name="ad58ce73335e9712a099f78571664fb22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad58ce73335e9712a099f78571664fb22">&#9670;&#160;</a></span>numValid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a515ba51f9b4063f374e1bfaa4bc8df3e">size_type</a> <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::numValid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of valid entries contained. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of valid elements in the array </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00688">688</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="a75d854e215f22fbe70407ab87a5bc11c" name="a75d854e215f22fbe70407ab87a5bc11c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d854e215f22fbe70407ab87a5bc11c">&#9670;&#160;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DataT &amp; <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::read </td>
          <td>(</td>
          <td class="paramtype">const uint32_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read (only) the data at an index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the index to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the data. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00550">550</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Array_a75d854e215f22fbe70407ab87a5bc11c_cgraph.png" border="0" usemap="#aclasssparta_1_1Array_a75d854e215f22fbe70407ab87a5bc11c_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Array_a75d854e215f22fbe70407ab87a5bc11c_cgraph" id="aclasssparta_1_1Array_a75d854e215f22fbe70407ab87a5bc11c_cgraph">
<area shape="rect" title="Read (only) the data at an index." alt="" coords="5,5,130,31"/>
<area shape="rect" href="classsparta_1_1Array.html#a6b47047a46bca0f7375c680465fd2192" title="Determine whether an index is currently valid." alt="" coords="178,5,316,31"/>
<area shape="poly" title=" " alt="" coords="130,16,162,16,162,21,130,21"/>
</map>
</div>

</div>
</div>
<a id="a039224bc8e092407594aff700851e8b4" name="a039224bc8e092407594aff700851e8b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a039224bc8e092407594aff700851e8b4">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a515ba51f9b4063f374e1bfaa4bc8df3e">size_type</a> <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="#ad58ce73335e9712a099f78571664fb22" title="The number of valid entries contained.">numValid()</a> &ndash; function for stl compatibility. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00693">693</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Array_a039224bc8e092407594aff700851e8b4_cgraph.png" border="0" usemap="#aclasssparta_1_1Array_a039224bc8e092407594aff700851e8b4_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Array_a039224bc8e092407594aff700851e8b4_cgraph" id="aclasssparta_1_1Array_a039224bc8e092407594aff700851e8b4_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,128,31"/>
<area shape="rect" href="classsparta_1_1Array.html#ad58ce73335e9712a099f78571664fb22" title="The number of valid entries contained." alt="" coords="176,5,329,31"/>
<area shape="poly" title=" " alt="" coords="128,16,160,16,160,21,128,21"/>
</map>
</div>

</div>
</div>
<a id="a0831489c25514d68eb4be986ae6b2f3b" name="a0831489c25514d68eb4be986ae6b2f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0831489c25514d68eb4be986ae6b2f3b">&#9670;&#160;</a></span>write() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#acda1560686f6087d7eeca8b8c7ebb161">iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>iter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataT &amp;</td>          <td class="paramname"><span class="paramname"><em>dat</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data at an iterator position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The iterator pointing to the data </td></tr>
    <tr><td class="paramname">dat</td><td>The data to write at the iterator location</td></tr>
  </table>
  </dd>
</dl>
<p>This will write to the location at <em>iter</em>, whether the iterator is valid or not. </p>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00796">796</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Array_a0831489c25514d68eb4be986ae6b2f3b_cgraph.png" border="0" usemap="#aclasssparta_1_1Array_a0831489c25514d68eb4be986ae6b2f3b_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Array_a0831489c25514d68eb4be986ae6b2f3b_cgraph" id="aclasssparta_1_1Array_a0831489c25514d68eb4be986ae6b2f3b_cgraph">
<area shape="rect" title="Write data at an iterator position." alt="" coords="5,42,133,68"/>
<area shape="rect" href="structsparta_1_1Array_1_1ArrayIterator.html#ac3725d0fc1cd5bba92898d9f45936d8a" title="What index does our iterator currently represent." alt="" coords="181,5,351,46"/>
<area shape="poly" title=" " alt="" coords="132,43,165,38,166,43,133,48"/>
<area shape="rect" href="classsparta_1_1Array.html#a469f43e31ed089cede106dd07254ffa9" title="Write data to the array." alt="" coords="202,70,330,96"/>
<area shape="poly" title=" " alt="" coords="133,61,187,69,187,74,132,67"/>
<area shape="rect" href="namespacesparta.html#a57bc9340188818892abcbd141b40fa50" title="Ensures that a pointer is not null." alt="" coords="399,13,503,38"/>
<area shape="poly" title=" " alt="" coords="352,23,383,23,383,28,352,28"/>
<area shape="rect" href="namespacesparta.html#ac0a2df7a7ca53b2fc0384476286b95ec" title="Demangles a C++ symbol." alt="" coords="551,13,671,38"/>
<area shape="poly" title=" " alt="" coords="504,23,536,23,536,28,504,28"/>
</map>
</div>

</div>
</div>
<a id="a9b7bcdfa954a2c815a31ec40469e570b" name="a9b7bcdfa954a2c815a31ec40469e570b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7bcdfa954a2c815a31ec40469e570b">&#9670;&#160;</a></span>write() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#acda1560686f6087d7eeca8b8c7ebb161">iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>iter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataT &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>dat</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data at an iterator position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The iterator pointing to the data </td></tr>
    <tr><td class="paramname">dat</td><td>The data to write at the iterator location</td></tr>
  </table>
  </dd>
</dl>
<p>This will write to the location at <em>iter</em>, whether the iterator is valid or not. </p>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00809">809</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Array_a9b7bcdfa954a2c815a31ec40469e570b_cgraph.png" border="0" usemap="#aclasssparta_1_1Array_a9b7bcdfa954a2c815a31ec40469e570b_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Array_a9b7bcdfa954a2c815a31ec40469e570b_cgraph" id="aclasssparta_1_1Array_a9b7bcdfa954a2c815a31ec40469e570b_cgraph">
<area shape="rect" title="Write data at an iterator position." alt="" coords="5,42,133,68"/>
<area shape="rect" href="structsparta_1_1Array_1_1ArrayIterator.html#ac3725d0fc1cd5bba92898d9f45936d8a" title="What index does our iterator currently represent." alt="" coords="181,5,351,46"/>
<area shape="poly" title=" " alt="" coords="132,43,165,38,166,43,133,48"/>
<area shape="rect" href="classsparta_1_1Array.html#a469f43e31ed089cede106dd07254ffa9" title="Write data to the array." alt="" coords="202,70,330,96"/>
<area shape="poly" title=" " alt="" coords="133,61,187,69,187,74,132,67"/>
<area shape="rect" href="namespacesparta.html#a57bc9340188818892abcbd141b40fa50" title="Ensures that a pointer is not null." alt="" coords="399,13,503,38"/>
<area shape="poly" title=" " alt="" coords="352,23,383,23,383,28,352,28"/>
<area shape="rect" href="namespacesparta.html#ac0a2df7a7ca53b2fc0384476286b95ec" title="Demangles a C++ symbol." alt="" coords="551,13,671,38"/>
<area shape="poly" title=" " alt="" coords="504,23,536,23,536,28,504,28"/>
</map>
</div>

</div>
</div>
<a id="a469f43e31ed089cede106dd07254ffa9" name="a469f43e31ed089cede106dd07254ffa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a469f43e31ed089cede106dd07254ffa9">&#9670;&#160;</a></span>write() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::write </td>
          <td>(</td>
          <td class="paramtype">const uint32_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataT &amp;</td>          <td class="paramname"><span class="paramname"><em>dat</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data to the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index to write at </td></tr>
    <tr><td class="paramname">dat</td><td>The data to write at that index.</td></tr>
  </table>
  </dd>
</dl>
<p>This will write to the location at <em>idx</em>, whether the position is valid or not. </p>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00770">770</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="afe1b7e23f0d8cb0a251652942448106f" name="afe1b7e23f0d8cb0a251652942448106f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe1b7e23f0d8cb0a251652942448106f">&#9670;&#160;</a></span>write() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT , <a class="el" href="namespacesparta.html#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> ArrayT = ArrayType::AGED&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsparta_1_1Array.html">sparta::Array</a>&lt; DataT, ArrayT &gt;::write </td>
          <td>(</td>
          <td class="paramtype">const uint32_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataT &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>dat</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data to the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index to write at </td></tr>
    <tr><td class="paramname">dat</td><td>The data to write at that index.</td></tr>
  </table>
  </dd>
</dl>
<p>This will write to the location at <em>idx</em>, whether the position is valid or not. </p>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00783">783</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/github/workspace/sparta/sparta/resources/<a class="el" href="Array_8hpp_source.html">Array.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesparta.html">sparta</a></li><li class="navelem"><a class="el" href="classsparta_1_1Array.html">Array</a></li>
    <li class="footer">Generated on Mon Feb 9 2026 03:27:55 for The Sparta Modeling Framework by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
