<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Sparta Modeling Framework: sparta::Buffer&lt; DataT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">The Sparta Modeling Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classsparta_1_1Buffer.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsparta_1_1Buffer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">sparta::Buffer&lt; DataT &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collapse.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aaa13a09b664fbf036778a741dcb230f8" id="r_aaa13a09b664fbf036778a741dcb230f8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classsparta_1_1Buffer.html">Buffer</a>&lt; DataT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa13a09b664fbf036778a741dcb230f8">BufferType</a></td></tr>
<tr class="separator:aaa13a09b664fbf036778a741dcb230f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027e59bd7563bb34eee934059bbd515e" id="r_a027e59bd7563bb34eee934059bbd515e"><td class="memItemLeft" align="right" valign="top">typedef DataT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a027e59bd7563bb34eee934059bbd515e">value_type</a></td></tr>
<tr class="separator:a027e59bd7563bb34eee934059bbd515e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe6b7897ac5ca01ef690685bd993d3a" id="r_afbe6b7897ac5ca01ef690685bd993d3a"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbe6b7897ac5ca01ef690685bd993d3a">size_type</a></td></tr>
<tr class="separator:afbe6b7897ac5ca01ef690685bd993d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985ee08a3a91cbe74c785cfd44febda1" id="r_a985ee08a3a91cbe74c785cfd44febda1"><td class="memItemLeft" align="right" valign="top">typedef BufferIterator&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a985ee08a3a91cbe74c785cfd44febda1">iterator</a></td></tr>
<tr class="memdesc:a985ee08a3a91cbe74c785cfd44febda1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for regular iterator.  <br /></td></tr>
<tr class="separator:a985ee08a3a91cbe74c785cfd44febda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df32139913eb6022e949defb82d5c06" id="r_a5df32139913eb6022e949defb82d5c06"><td class="memItemLeft" align="right" valign="top">typedef BufferIterator&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5df32139913eb6022e949defb82d5c06">const_iterator</a></td></tr>
<tr class="memdesc:a5df32139913eb6022e949defb82d5c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for constant iterator.  <br /></td></tr>
<tr class="separator:a5df32139913eb6022e949defb82d5c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f12bfc92bc79cbd91767c78c303fe38" id="r_a1f12bfc92bc79cbd91767c78c303fe38"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator&lt; <a class="el" href="#a5df32139913eb6022e949defb82d5c06">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f12bfc92bc79cbd91767c78c303fe38">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a1f12bfc92bc79cbd91767c78c303fe38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for regular reverse iterator.  <br /></td></tr>
<tr class="separator:a1f12bfc92bc79cbd91767c78c303fe38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177989df95f185f27a2d49b6c199b4d9" id="r_a177989df95f185f27a2d49b6c199b4d9"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator&lt; <a class="el" href="#a985ee08a3a91cbe74c785cfd44febda1">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a177989df95f185f27a2d49b6c199b4d9">reverse_iterator</a></td></tr>
<tr class="memdesc:a177989df95f185f27a2d49b6c199b4d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for constant reverse iterator.  <br /></td></tr>
<tr class="separator:a177989df95f185f27a2d49b6c199b4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a47efeeffbe8c5a66c49d0989bcbfd8f9" id="r_a47efeeffbe8c5a66c49d0989bcbfd8f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47efeeffbe8c5a66c49d0989bcbfd8f9">Buffer</a> (const std::string &amp;name, const uint32_t num_entries, const <a class="el" href="classsparta_1_1Clock.html">Clock</a> *clk, <a class="el" href="classsparta_1_1StatisticSet.html">StatisticSet</a> *statset=nullptr, <a class="el" href="classsparta_1_1InstrumentationNode.html#a507d5eba99bdae4b0fefe7ab69050965">InstrumentationNode::visibility_t</a> stat_vis_general=<a class="el" href="classsparta_1_1InstrumentationNode.html#a9e4e4feeb259d54e2fafb15325e3fd8b">InstrumentationNode::AUTO_VISIBILITY</a>, <a class="el" href="classsparta_1_1InstrumentationNode.html#a507d5eba99bdae4b0fefe7ab69050965">InstrumentationNode::visibility_t</a> stat_vis_detailed=<a class="el" href="classsparta_1_1InstrumentationNode.html#a855b6ecdd93e412052ae264032002ce1a01a69b1a50e88559f40efc68ba7e5224">InstrumentationNode::VIS_HIDDEN</a>, <a class="el" href="classsparta_1_1InstrumentationNode.html#a507d5eba99bdae4b0fefe7ab69050965">InstrumentationNode::visibility_t</a> stat_vis_max=<a class="el" href="classsparta_1_1InstrumentationNode.html#a9e4e4feeb259d54e2fafb15325e3fd8b">InstrumentationNode::AUTO_VISIBILITY</a>, <a class="el" href="classsparta_1_1InstrumentationNode.html#a507d5eba99bdae4b0fefe7ab69050965">InstrumentationNode::visibility_t</a> stat_vis_avg=<a class="el" href="classsparta_1_1InstrumentationNode.html#a9e4e4feeb259d54e2fafb15325e3fd8b">InstrumentationNode::AUTO_VISIBILITY</a>)</td></tr>
<tr class="memdesc:a47efeeffbe8c5a66c49d0989bcbfd8f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a buffer.  <br /></td></tr>
<tr class="separator:a47efeeffbe8c5a66c49d0989bcbfd8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8bfe121c9f394b46571258c6242d487" id="r_ad8bfe121c9f394b46571258c6242d487"><td class="memItemLeft" align="right" valign="top"><a id="ad8bfe121c9f394b46571258c6242d487" name="ad8bfe121c9f394b46571258c6242d487"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Buffer</b> (const <a class="el" href="classsparta_1_1Buffer.html">Buffer</a>&lt; value_type &gt; &amp;)=delete</td></tr>
<tr class="memdesc:ad8bfe121c9f394b46571258c6242d487"><td class="mdescLeft">&#160;</td><td class="mdescRight">No copies allowed for <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a>. <br /></td></tr>
<tr class="separator:ad8bfe121c9f394b46571258c6242d487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b13d791067765bae857d60b4482b6b9" id="r_a8b13d791067765bae857d60b4482b6b9"><td class="memItemLeft" align="right" valign="top"><a id="a8b13d791067765bae857d60b4482b6b9" name="a8b13d791067765bae857d60b4482b6b9"></a>
<a class="el" href="classsparta_1_1Buffer.html">Buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classsparta_1_1Buffer.html">Buffer</a>&lt; value_type &gt; &amp;)=delete</td></tr>
<tr class="memdesc:a8b13d791067765bae857d60b4482b6b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">No copies allowed for <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a>. <br /></td></tr>
<tr class="separator:a8b13d791067765bae857d60b4482b6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f5f8ed23228487b671d710830e02d6" id="r_a29f5f8ed23228487b671d710830e02d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29f5f8ed23228487b671d710830e02d6">Buffer</a> (<a class="el" href="classsparta_1_1Buffer.html">Buffer</a>&lt; value_type &gt; &amp;&amp;)</td></tr>
<tr class="memdesc:a29f5f8ed23228487b671d710830e02d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move Constructor to allow moves.  <br /></td></tr>
<tr class="separator:a29f5f8ed23228487b671d710830e02d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1b37dfc53764fba6c172ad930c6fb0" id="r_afa1b37dfc53764fba6c172ad930c6fb0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa1b37dfc53764fba6c172ad930c6fb0">~Buffer</a> ()</td></tr>
<tr class="memdesc:afa1b37dfc53764fba6c172ad930c6fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear (and destruct the <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a>'s contents)  <br /></td></tr>
<tr class="separator:afa1b37dfc53764fba6c172ad930c6fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d76633c1dddbb573fe7992a11ff9b4" id="r_a22d76633c1dddbb573fe7992a11ff9b4"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22d76633c1dddbb573fe7992a11ff9b4">getName</a> () const</td></tr>
<tr class="memdesc:a22d76633c1dddbb573fe7992a11ff9b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of this resource.  <br /></td></tr>
<tr class="separator:a22d76633c1dddbb573fe7992a11ff9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4acbe31cd8041c3cf7818886a67d825" id="r_ab4acbe31cd8041c3cf7818886a67d825"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4acbe31cd8041c3cf7818886a67d825">isValid</a> (uint32_t idx) const</td></tr>
<tr class="memdesc:ab4acbe31cd8041c3cf7818886a67d825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if data at the index is valid.  <br /></td></tr>
<tr class="separator:ab4acbe31cd8041c3cf7818886a67d825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905154d88dbaaa223d154ee1c2c859a2" id="r_a905154d88dbaaa223d154ee1c2c859a2"><td class="memItemLeft" align="right" valign="top">const value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a905154d88dbaaa223d154ee1c2c859a2">read</a> (uint32_t idx) const</td></tr>
<tr class="memdesc:a905154d88dbaaa223d154ee1c2c859a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and return the data at the given index, const reference.  <br /></td></tr>
<tr class="separator:a905154d88dbaaa223d154ee1c2c859a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3292252569d5410fb0b0652d85343778" id="r_a3292252569d5410fb0b0652d85343778"><td class="memItemLeft" align="right" valign="top">const value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3292252569d5410fb0b0652d85343778">read</a> (const <a class="el" href="#a5df32139913eb6022e949defb82d5c06">const_iterator</a> &amp;entry) const</td></tr>
<tr class="memdesc:a3292252569d5410fb0b0652d85343778"><td class="mdescLeft">&#160;</td><td class="mdescRight">read the entry at the BufferIterator's location  <br /></td></tr>
<tr class="separator:a3292252569d5410fb0b0652d85343778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc05fa6659a18d18e756ba8314ba689" id="r_a9bc05fa6659a18d18e756ba8314ba689"><td class="memItemLeft" align="right" valign="top">const value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bc05fa6659a18d18e756ba8314ba689">read</a> (const <a class="el" href="#a1f12bfc92bc79cbd91767c78c303fe38">const_reverse_iterator</a> &amp;entry) const</td></tr>
<tr class="memdesc:a9bc05fa6659a18d18e756ba8314ba689"><td class="mdescLeft">&#160;</td><td class="mdescRight">read the entry at the BufferIterator's location  <br /></td></tr>
<tr class="separator:a9bc05fa6659a18d18e756ba8314ba689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb32977c84a0835581b18c027d19199f" id="r_adb32977c84a0835581b18c027d19199f"><td class="memItemLeft" align="right" valign="top">value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb32977c84a0835581b18c027d19199f">access</a> (uint32_t idx)</td></tr>
<tr class="memdesc:adb32977c84a0835581b18c027d19199f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and return the data at the given index, reference.  <br /></td></tr>
<tr class="separator:adb32977c84a0835581b18c027d19199f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab050bc94a2f2c8210ed351b6fbac694" id="r_aab050bc94a2f2c8210ed351b6fbac694"><td class="memItemLeft" align="right" valign="top">value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab050bc94a2f2c8210ed351b6fbac694">access</a> (const <a class="el" href="#a5df32139913eb6022e949defb82d5c06">const_iterator</a> &amp;entry)</td></tr>
<tr class="memdesc:aab050bc94a2f2c8210ed351b6fbac694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and return the data at the given BufferIterator's location, reference.  <br /></td></tr>
<tr class="separator:aab050bc94a2f2c8210ed351b6fbac694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bce381b99d905e2ed2b8f63cf4fbe6c" id="r_a7bce381b99d905e2ed2b8f63cf4fbe6c"><td class="memItemLeft" align="right" valign="top">value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bce381b99d905e2ed2b8f63cf4fbe6c">access</a> (const <a class="el" href="#a1f12bfc92bc79cbd91767c78c303fe38">const_reverse_iterator</a> &amp;entry)</td></tr>
<tr class="memdesc:a7bce381b99d905e2ed2b8f63cf4fbe6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and return the data at the given BufferIterator's location, reference.  <br /></td></tr>
<tr class="separator:a7bce381b99d905e2ed2b8f63cf4fbe6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac24ffe104db5ccc42f83ddabd1c1b3a" id="r_aac24ffe104db5ccc42f83ddabd1c1b3a"><td class="memItemLeft" align="right" valign="top">value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac24ffe104db5ccc42f83ddabd1c1b3a">accessBack</a> ()</td></tr>
<tr class="memdesc:aac24ffe104db5ccc42f83ddabd1c1b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and return the data at the bottom of the <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a>.  <br /></td></tr>
<tr class="separator:aac24ffe104db5ccc42f83ddabd1c1b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb1899d768f143c8df9e24a5a44f287" id="r_abfb1899d768f143c8df9e24a5a44f287"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfb1899d768f143c8df9e24a5a44f287">capacity</a> () const</td></tr>
<tr class="memdesc:abfb1899d768f143c8df9e24a5a44f287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the fixed size of this buffer.  <br /></td></tr>
<tr class="separator:abfb1899d768f143c8df9e24a5a44f287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e8b8181aae8c9427385d0d1015a579" id="r_a58e8b8181aae8c9427385d0d1015a579"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58e8b8181aae8c9427385d0d1015a579">size</a> () const</td></tr>
<tr class="memdesc:a58e8b8181aae8c9427385d0d1015a579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of valid entries.  <br /></td></tr>
<tr class="separator:a58e8b8181aae8c9427385d0d1015a579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a42bbf90ee44b4930588e0ddb4d6e19" id="r_a1a42bbf90ee44b4930588e0ddb4d6e19"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a42bbf90ee44b4930588e0ddb4d6e19">numFree</a> () const</td></tr>
<tr class="memdesc:a1a42bbf90ee44b4930588e0ddb4d6e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of free entries.  <br /></td></tr>
<tr class="separator:a1a42bbf90ee44b4930588e0ddb4d6e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c4eabdfc563b338adce22fc0eed88c" id="r_a67c4eabdfc563b338adce22fc0eed88c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a985ee08a3a91cbe74c785cfd44febda1">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67c4eabdfc563b338adce22fc0eed88c">push_back</a> (const value_type &amp;dat)</td></tr>
<tr class="memdesc:a67c4eabdfc563b338adce22fc0eed88c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append data to the end of <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a>, and return a BufferIterator.  <br /></td></tr>
<tr class="separator:a67c4eabdfc563b338adce22fc0eed88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5505984db6b80574965b5d9333be3f" id="r_a7f5505984db6b80574965b5d9333be3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a985ee08a3a91cbe74c785cfd44febda1">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f5505984db6b80574965b5d9333be3f">push_back</a> (value_type &amp;&amp;dat)</td></tr>
<tr class="memdesc:a7f5505984db6b80574965b5d9333be3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append data to the end of <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a>, and return a BufferIterator.  <br /></td></tr>
<tr class="separator:a7f5505984db6b80574965b5d9333be3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a066c7ac12d45ad7fa62721c26aed5efd" id="r_a066c7ac12d45ad7fa62721c26aed5efd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a985ee08a3a91cbe74c785cfd44febda1">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a066c7ac12d45ad7fa62721c26aed5efd">insert</a> (uint32_t idx, const value_type &amp;dat)</td></tr>
<tr class="memdesc:a066c7ac12d45ad7fa62721c26aed5efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the item BEFORE the given index.  <br /></td></tr>
<tr class="separator:a066c7ac12d45ad7fa62721c26aed5efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2e0d4362318c1e133857dabad1cbcb" id="r_abf2e0d4362318c1e133857dabad1cbcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a985ee08a3a91cbe74c785cfd44febda1">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf2e0d4362318c1e133857dabad1cbcb">insert</a> (uint32_t idx, value_type &amp;&amp;dat)</td></tr>
<tr class="memdesc:abf2e0d4362318c1e133857dabad1cbcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the item BEFORE the given index.  <br /></td></tr>
<tr class="separator:abf2e0d4362318c1e133857dabad1cbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959768b33f68ffc78882b3d32789301f" id="r_a959768b33f68ffc78882b3d32789301f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a985ee08a3a91cbe74c785cfd44febda1">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a959768b33f68ffc78882b3d32789301f">insert</a> (const <a class="el" href="#a5df32139913eb6022e949defb82d5c06">const_iterator</a> &amp;entry, const value_type &amp;dat)</td></tr>
<tr class="memdesc:a959768b33f68ffc78882b3d32789301f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do an insert before a BufferIterator see insert method above.  <br /></td></tr>
<tr class="separator:a959768b33f68ffc78882b3d32789301f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37742f1e5b1223195faf08e5ede0f6c9" id="r_a37742f1e5b1223195faf08e5ede0f6c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a985ee08a3a91cbe74c785cfd44febda1">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37742f1e5b1223195faf08e5ede0f6c9">insert</a> (const <a class="el" href="#a5df32139913eb6022e949defb82d5c06">const_iterator</a> &amp;entry, value_type &amp;&amp;dat)</td></tr>
<tr class="memdesc:a37742f1e5b1223195faf08e5ede0f6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do an insert before a BufferIterator see insert method above.  <br /></td></tr>
<tr class="separator:a37742f1e5b1223195faf08e5ede0f6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad961e89882e617f8bf254466968ec5f4" id="r_ad961e89882e617f8bf254466968ec5f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a985ee08a3a91cbe74c785cfd44febda1">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad961e89882e617f8bf254466968ec5f4">insert</a> (const <a class="el" href="#a1f12bfc92bc79cbd91767c78c303fe38">const_reverse_iterator</a> &amp;entry, const value_type &amp;dat)</td></tr>
<tr class="memdesc:ad961e89882e617f8bf254466968ec5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do an insert before a BufferIterator see insert method above.  <br /></td></tr>
<tr class="separator:ad961e89882e617f8bf254466968ec5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9facdc43c765aafac1bfdcb0a7513149" id="r_a9facdc43c765aafac1bfdcb0a7513149"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a985ee08a3a91cbe74c785cfd44febda1">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9facdc43c765aafac1bfdcb0a7513149">insert</a> (const <a class="el" href="#a1f12bfc92bc79cbd91767c78c303fe38">const_reverse_iterator</a> &amp;entry, value_type &amp;&amp;dat)</td></tr>
<tr class="memdesc:a9facdc43c765aafac1bfdcb0a7513149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do an insert before a BufferIterator see insert method above.  <br /></td></tr>
<tr class="separator:a9facdc43c765aafac1bfdcb0a7513149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55071d909463f8fe74495ebfdacde810" id="r_a55071d909463f8fe74495ebfdacde810"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55071d909463f8fe74495ebfdacde810">erase</a> (uint32_t idx)</td></tr>
<tr class="memdesc:a55071d909463f8fe74495ebfdacde810"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase a position in the <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a> immediately.  <br /></td></tr>
<tr class="separator:a55071d909463f8fe74495ebfdacde810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39cac9a92b318226be305b4218613b5" id="r_aa39cac9a92b318226be305b4218613b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a985ee08a3a91cbe74c785cfd44febda1">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa39cac9a92b318226be305b4218613b5">erase</a> (const <a class="el" href="#a5df32139913eb6022e949defb82d5c06">const_iterator</a> &amp;entry)</td></tr>
<tr class="memdesc:aa39cac9a92b318226be305b4218613b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the index at which the entry exists in the <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a>.  <br /></td></tr>
<tr class="separator:aa39cac9a92b318226be305b4218613b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2603b1fdcf9fc00d2112528b53cf90b" id="r_ad2603b1fdcf9fc00d2112528b53cf90b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a177989df95f185f27a2d49b6c199b4d9">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2603b1fdcf9fc00d2112528b53cf90b">erase</a> (const <a class="el" href="#a1f12bfc92bc79cbd91767c78c303fe38">const_reverse_iterator</a> &amp;entry)</td></tr>
<tr class="memdesc:ad2603b1fdcf9fc00d2112528b53cf90b"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase the index at which the entry exists in the <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a>.  <br /></td></tr>
<tr class="separator:ad2603b1fdcf9fc00d2112528b53cf90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181331e7a93759f7bac294ed16dc4d2e" id="r_a181331e7a93759f7bac294ed16dc4d2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a181331e7a93759f7bac294ed16dc4d2e">clear</a> ()</td></tr>
<tr class="memdesc:a181331e7a93759f7bac294ed16dc4d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty the contents of the <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a>.  <br /></td></tr>
<tr class="separator:a181331e7a93759f7bac294ed16dc4d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3ce6c6cc99f191934b30881de18b4f" id="r_a5c3ce6c6cc99f191934b30881de18b4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c3ce6c6cc99f191934b30881de18b4f">empty</a> () const</td></tr>
<tr class="memdesc:a5c3ce6c6cc99f191934b30881de18b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if the buffer is empty.  <br /></td></tr>
<tr class="separator:a5c3ce6c6cc99f191934b30881de18b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace76a7b21e07822cfca79fd53b39dbde" id="r_ace76a7b21e07822cfca79fd53b39dbde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace76a7b21e07822cfca79fd53b39dbde">enableCollection</a> (<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *parent)</td></tr>
<tr class="memdesc:ace76a7b21e07822cfca79fd53b39dbde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request that this queue begin collecting its contents for pipeline collection.  <br /></td></tr>
<tr class="separator:ace76a7b21e07822cfca79fd53b39dbde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d89a4542f3f1ada339f82d26d5c51c" id="r_a78d89a4542f3f1ada339f82d26d5c51c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a985ee08a3a91cbe74c785cfd44febda1">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78d89a4542f3f1ada339f82d26d5c51c">begin</a> ()</td></tr>
<tr class="memdesc:a78d89a4542f3f1ada339f82d26d5c51c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the iterator pointing to the beginning of <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a>.  <br /></td></tr>
<tr class="separator:a78d89a4542f3f1ada339f82d26d5c51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af957d9119fd0009a62271ec686e7b3c6" id="r_af957d9119fd0009a62271ec686e7b3c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a985ee08a3a91cbe74c785cfd44febda1">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af957d9119fd0009a62271ec686e7b3c6">end</a> ()</td></tr>
<tr class="memdesc:af957d9119fd0009a62271ec686e7b3c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator referring to past-the-end element in the <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a> container.  <br /></td></tr>
<tr class="separator:af957d9119fd0009a62271ec686e7b3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6226a43da26babb69530e2bf824cd68c" id="r_a6226a43da26babb69530e2bf824cd68c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a5df32139913eb6022e949defb82d5c06">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6226a43da26babb69530e2bf824cd68c">begin</a> () const</td></tr>
<tr class="memdesc:a6226a43da26babb69530e2bf824cd68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the const_iterator pointing to the begin of <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a>.  <br /></td></tr>
<tr class="separator:a6226a43da26babb69530e2bf824cd68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d6ef45332459d9cdb0be128b2a8d70" id="r_a81d6ef45332459d9cdb0be128b2a8d70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a5df32139913eb6022e949defb82d5c06">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81d6ef45332459d9cdb0be128b2a8d70">end</a> () const</td></tr>
<tr class="memdesc:a81d6ef45332459d9cdb0be128b2a8d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_iterator referring to past-the-end element in the <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a> container.  <br /></td></tr>
<tr class="separator:a81d6ef45332459d9cdb0be128b2a8d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e79ec1c29adfcbac8944f3b8de9ca53" id="r_a9e79ec1c29adfcbac8944f3b8de9ca53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a177989df95f185f27a2d49b6c199b4d9">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e79ec1c29adfcbac8944f3b8de9ca53">rbegin</a> ()</td></tr>
<tr class="memdesc:a9e79ec1c29adfcbac8944f3b8de9ca53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the iterator pointing to the pass-the-end element of <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a>.  <br /></td></tr>
<tr class="separator:a9e79ec1c29adfcbac8944f3b8de9ca53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a685b46fb7c11c9a2ac42217df6d263cd" id="r_a685b46fb7c11c9a2ac42217df6d263cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a177989df95f185f27a2d49b6c199b4d9">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a685b46fb7c11c9a2ac42217df6d263cd">rend</a> ()</td></tr>
<tr class="memdesc:a685b46fb7c11c9a2ac42217df6d263cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an reverse iterator referring to starting element in the <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a> container.  <br /></td></tr>
<tr class="separator:a685b46fb7c11c9a2ac42217df6d263cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1757b7271c1a70f883e15692db9e466" id="r_af1757b7271c1a70f883e15692db9e466"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a1f12bfc92bc79cbd91767c78c303fe38">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1757b7271c1a70f883e15692db9e466">rbegin</a> () const</td></tr>
<tr class="memdesc:af1757b7271c1a70f883e15692db9e466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the const_reverse_iterator pointing to the pass-the-end of <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a>.  <br /></td></tr>
<tr class="separator:af1757b7271c1a70f883e15692db9e466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420ec8c60431fd8bdcaa809ef9d1f3b6" id="r_a420ec8c60431fd8bdcaa809ef9d1f3b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a1f12bfc92bc79cbd91767c78c303fe38">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a420ec8c60431fd8bdcaa809ef9d1f3b6">rend</a> () const</td></tr>
<tr class="memdesc:a420ec8c60431fd8bdcaa809ef9d1f3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_reverse_iterator referring to start element in the <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a> container.  <br /></td></tr>
<tr class="separator:a420ec8c60431fd8bdcaa809ef9d1f3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789bf078f54f2e28df280786d21c16d1" id="r_a789bf078f54f2e28df280786d21c16d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a789bf078f54f2e28df280786d21c16d1">makeInfinite</a> (const uint32_t resize_delta=1)</td></tr>
<tr class="memdesc:a789bf078f54f2e28df280786d21c16d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a> grow beyond its capacity. The buffer grows by adding new entries in its internal vectors. The number of new entries it adds defaults to the value 1, each time it resizes itself.  <br /></td></tr>
<tr class="separator:a789bf078f54f2e28df280786d21c16d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class DataT&gt;<br />
class sparta::Buffer&lt; DataT &gt;</div><p>A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collapse. </p>
<p>The <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a> allows a user to append data to the end, beginning, or middle of the buffer, and erase anywhere. The <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a> will collapse on empty entries unlike the <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">sparta::Array</a>.</p>
<p>The <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a> acks like a standard container via public push_back, insert, and erase methods. The BufferIterator can be used as an index into the <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a>, and maintains knowledge internally of its location in the <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a>, as well whether or not it still represents a valid entry.</p>
<dl class="section warning"><dt>Warning</dt><dd>Once an entry has been appended with appendEntry method, the index with that data can only be erased via the erase(BufferIterator&amp;), and not the <a class="el" href="#a55071d909463f8fe74495ebfdacde810" title="erase a position in the Buffer immediately.">erase(uint32_t)</a>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classsparta_1_1Buffer.html">Buffer&lt;uint32_t&gt;</a> buffer;</div>
<div class="line"><a class="code hl_typedef" href="#a985ee08a3a91cbe74c785cfd44febda1">Buffer&lt;uint32_t&gt;::iterator</a> entry = buffer.<a class="code hl_function" href="#a67c4eabdfc563b338adce22fc0eed88c">push_back</a>(3);</div>
<div class="line"><a class="code hl_typedef" href="#a985ee08a3a91cbe74c785cfd44febda1">Buffer&lt;uint32_t&gt;::iterator</a> entry2 = buffer.<a class="code hl_function" href="#a67c4eabdfc563b338adce22fc0eed88c">push_back</a>(5);</div>
<div class="line">buffer.<a class="code hl_function" href="#a67c4eabdfc563b338adce22fc0eed88c">push_back</a>(1);</div>
<div class="line"> </div>
<div class="line">assert(buffer.<a class="code hl_function" href="#a905154d88dbaaa223d154ee1c2c859a2">read</a>(2) == 1);</div>
<div class="line"> </div>
<div class="line">buffer.<a class="code hl_function" href="#a55071d909463f8fe74495ebfdacde810">erase</a>(1);</div>
<div class="line">buffer.<a class="code hl_function" href="#a55071d909463f8fe74495ebfdacde810">erase</a>(entry2); <span class="comment">// THROWS an exception since the location that entry2 represented.</span></div>
<div class="line"><span class="comment">// was erased.</span></div>
<div class="line"> </div>
<div class="line">Buffer&lt;uint32_t&gt;::BufferIterator e_copy(entry);</div>
<div class="line">buffer.<a class="code hl_function" href="#a55071d909463f8fe74495ebfdacde810">erase</a>(e_copy);</div>
<div class="line"><span class="comment">// THROWS expection b/c the data represented by e_copy and entry</span></div>
<div class="line"><span class="comment">// are invalid after the line above</span></div>
<div class="line">buffer.<a class="code hl_function" href="#a55071d909463f8fe74495ebfdacde810">erase</a>(entry);</div>
<div class="ttc" id="aclasssparta_1_1Buffer_html"><div class="ttname"><a href="classsparta_1_1Buffer.html">sparta::Buffer</a></div><div class="ttdoc">A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...</div><div class="ttdef"><b>Definition</b> <a href="Buffer_8hpp_source.html#l00073">Buffer.hpp:74</a></div></div>
<div class="ttc" id="aclasssparta_1_1Buffer_html_a55071d909463f8fe74495ebfdacde810"><div class="ttname"><a href="#a55071d909463f8fe74495ebfdacde810">sparta::Buffer::erase</a></div><div class="ttdeci">void erase(uint32_t idx)</div><div class="ttdoc">erase a position in the Buffer immediately.</div><div class="ttdef"><b>Definition</b> <a href="Buffer_8hpp_source.html#l00624">Buffer.hpp:624</a></div></div>
<div class="ttc" id="aclasssparta_1_1Buffer_html_a67c4eabdfc563b338adce22fc0eed88c"><div class="ttname"><a href="#a67c4eabdfc563b338adce22fc0eed88c">sparta::Buffer::push_back</a></div><div class="ttdeci">iterator push_back(const value_type &amp;dat)</div><div class="ttdoc">Append data to the end of Buffer, and return a BufferIterator.</div><div class="ttdef"><b>Definition</b> <a href="Buffer_8hpp_source.html#l00521">Buffer.hpp:521</a></div></div>
<div class="ttc" id="aclasssparta_1_1Buffer_html_a905154d88dbaaa223d154ee1c2c859a2"><div class="ttname"><a href="#a905154d88dbaaa223d154ee1c2c859a2">sparta::Buffer::read</a></div><div class="ttdeci">const value_type &amp; read(uint32_t idx) const</div><div class="ttdoc">Read and return the data at the given index, const reference.</div><div class="ttdef"><b>Definition</b> <a href="Buffer_8hpp_source.html#l00426">Buffer.hpp:426</a></div></div>
<div class="ttc" id="aclasssparta_1_1Buffer_html_a985ee08a3a91cbe74c785cfd44febda1"><div class="ttname"><a href="#a985ee08a3a91cbe74c785cfd44febda1">sparta::Buffer::iterator</a></div><div class="ttdeci">BufferIterator&lt; false &gt; iterator</div><div class="ttdoc">Typedef for regular iterator.</div><div class="ttdef"><b>Definition</b> <a href="Buffer_8hpp_source.html#l00335">Buffer.hpp:335</a></div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataT</td><td>The data type contained in the <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00073">73</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aaa13a09b664fbf036778a741dcb230f8" name="aaa13a09b664fbf036778a741dcb230f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa13a09b664fbf036778a741dcb230f8">&#9670;&#160;</a></span>BufferType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Buffer.html">Buffer</a>&lt;DataT&gt; <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::BufferType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00079">79</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>

</div>
</div>
<a id="a5df32139913eb6022e949defb82d5c06" name="a5df32139913eb6022e949defb82d5c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df32139913eb6022e949defb82d5c06">&#9670;&#160;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">BufferIterator&lt;true&gt; <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for constant iterator. </p>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00338">338</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>

</div>
</div>
<a id="a1f12bfc92bc79cbd91767c78c303fe38" name="a1f12bfc92bc79cbd91767c78c303fe38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f12bfc92bc79cbd91767c78c303fe38">&#9670;&#160;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::reverse_iterator&lt;<a class="el" href="#a5df32139913eb6022e949defb82d5c06">const_iterator</a>&gt; <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::const_reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for regular reverse iterator. </p>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00341">341</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>

</div>
</div>
<a id="a985ee08a3a91cbe74c785cfd44febda1" name="a985ee08a3a91cbe74c785cfd44febda1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a985ee08a3a91cbe74c785cfd44febda1">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">BufferIterator&lt;false&gt; <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for regular iterator. </p>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00335">335</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>

</div>
</div>
<a id="a177989df95f185f27a2d49b6c199b4d9" name="a177989df95f185f27a2d49b6c199b4d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a177989df95f185f27a2d49b6c199b4d9">&#9670;&#160;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::reverse_iterator&lt;<a class="el" href="#a985ee08a3a91cbe74c785cfd44febda1">iterator</a>&gt; <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for constant reverse iterator. </p>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00344">344</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>

</div>
</div>
<a id="afbe6b7897ac5ca01ef690685bd993d3a" name="afbe6b7897ac5ca01ef690685bd993d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe6b7897ac5ca01ef690685bd993d3a">&#9670;&#160;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::size_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00085">85</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>

</div>
</div>
<a id="a027e59bd7563bb34eee934059bbd515e" name="a027e59bd7563bb34eee934059bbd515e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a027e59bd7563bb34eee934059bbd515e">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DataT <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00082">82</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a47efeeffbe8c5a66c49d0989bcbfd8f9" name="a47efeeffbe8c5a66c49d0989bcbfd8f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47efeeffbe8c5a66c49d0989bcbfd8f9">&#9670;&#160;</a></span>Buffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::Buffer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t</td>          <td class="paramname"><span class="paramname"><em>num_entries</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1Clock.html">Clock</a> *</td>          <td class="paramname"><span class="paramname"><em>clk</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1StatisticSet.html">StatisticSet</a> *</td>          <td class="paramname"><span class="paramname"><em>statset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1InstrumentationNode.html#a507d5eba99bdae4b0fefe7ab69050965">InstrumentationNode::visibility_t</a></td>          <td class="paramname"><span class="paramname"><em>stat_vis_general</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classsparta_1_1InstrumentationNode.html#a9e4e4feeb259d54e2fafb15325e3fd8b">InstrumentationNode::AUTO_VISIBILITY</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1InstrumentationNode.html#a507d5eba99bdae4b0fefe7ab69050965">InstrumentationNode::visibility_t</a></td>          <td class="paramname"><span class="paramname"><em>stat_vis_detailed</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classsparta_1_1InstrumentationNode.html#a855b6ecdd93e412052ae264032002ce1a01a69b1a50e88559f40efc68ba7e5224">InstrumentationNode::VIS_HIDDEN</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1InstrumentationNode.html#a507d5eba99bdae4b0fefe7ab69050965">InstrumentationNode::visibility_t</a></td>          <td class="paramname"><span class="paramname"><em>stat_vis_max</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classsparta_1_1InstrumentationNode.html#a9e4e4feeb259d54e2fafb15325e3fd8b">InstrumentationNode::AUTO_VISIBILITY</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1InstrumentationNode.html#a507d5eba99bdae4b0fefe7ab69050965">InstrumentationNode::visibility_t</a></td>          <td class="paramname"><span class="paramname"><em>stat_vis_avg</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classsparta_1_1InstrumentationNode.html#a9e4e4feeb259d54e2fafb15325e3fd8b">InstrumentationNode::AUTO_VISIBILITY</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the buffer </td></tr>
    <tr><td class="paramname">num_entries</td><td>The number of entries this buffer can hold </td></tr>
    <tr><td class="paramname">clk</td><td>The clock this <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a> is associated; used for internal counters</td></tr>
    <tr><td class="paramname">statset</td><td>Pointer to the counter set to register utilization counts; default nullptr. This works for timed and untimed.</td></tr>
    <tr><td class="paramname">stat_vis_general</td><td>Sets the visibility of the stat counters for the 0th and last index of the utilization counts, so the empty and full counts.</td></tr>
    <tr><td class="paramname">stat_vis_detailed</td><td>Sets the visibility of the stat counts between 0 and the last index. i.e. more detailed than the general stats, default VIS_HIDDEN</td></tr>
    <tr><td class="paramname">stat_vis_max</td><td>Sets the visibility for a stat that contains the maximum utilization for this buffer. The default is AUTO_VISIBILITY.</td></tr>
    <tr><td class="paramname">stat_vis_avg</td><td>Sets the visibility for a stat that contains the weighted utilization average for this buffer. The default is AUTO_VISIBILITY.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>By default the stat_vis_* options are set to VIS_SPARTA_DEFAULT, for this structure VIS_SPARTA_DEFAULT resolves to SPARTA_CONTAINER_DEFAULT which at the time of writing this comment is set to VIS_HIDDEN. If you rely on the stats from this container you should explicity set the visibility. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l01041">1041</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Buffer_a47efeeffbe8c5a66c49d0989bcbfd8f9_cgraph.png" border="0" usemap="#aclasssparta_1_1Buffer_a47efeeffbe8c5a66c49d0989bcbfd8f9_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Buffer_a47efeeffbe8c5a66c49d0989bcbfd8f9_cgraph" id="aclasssparta_1_1Buffer_a47efeeffbe8c5a66c49d0989bcbfd8f9_cgraph">
<area shape="rect" title="Construct a buffer." alt="" coords="5,5,143,31"/>
<area shape="rect" href="classsparta_1_1Buffer.html#a181331e7a93759f7bac294ed16dc4d2e" title="Empty the contents of the Buffer." alt="" coords="191,5,322,31"/>
<area shape="poly" title=" " alt="" coords="143,16,176,16,176,21,143,21"/>
</map>
</div>

</div>
</div>
<a id="a29f5f8ed23228487b671d710830e02d6" name="a29f5f8ed23228487b671d710830e02d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f5f8ed23228487b671d710830e02d6">&#9670;&#160;</a></span>Buffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::Buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Buffer.html">Buffer</a>&lt; value_type &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rval</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move Constructor to allow moves. </p>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l01076">1076</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>

</div>
</div>
<a id="afa1b37dfc53764fba6c172ad930c6fb0" name="afa1b37dfc53764fba6c172ad930c6fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1b37dfc53764fba6c172ad930c6fb0">&#9670;&#160;</a></span>~Buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::~<a class="el" href="classsparta_1_1Buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear (and destruct the <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a>'s contents) </p>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00402">402</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Buffer_afa1b37dfc53764fba6c172ad930c6fb0_cgraph.png" border="0" usemap="#aclasssparta_1_1Buffer_afa1b37dfc53764fba6c172ad930c6fb0_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Buffer_afa1b37dfc53764fba6c172ad930c6fb0_cgraph" id="aclasssparta_1_1Buffer_afa1b37dfc53764fba6c172ad930c6fb0_cgraph">
<area shape="rect" title="Clear (and destruct the Buffer&#39;s contents)" alt="" coords="5,5,150,31"/>
<area shape="rect" href="classsparta_1_1Buffer.html#a181331e7a93759f7bac294ed16dc4d2e" title="Empty the contents of the Buffer." alt="" coords="198,5,329,31"/>
<area shape="poly" title=" " alt="" coords="150,16,182,16,182,21,150,21"/>
</map>
</div>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aab050bc94a2f2c8210ed351b6fbac694" name="aab050bc94a2f2c8210ed351b6fbac694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab050bc94a2f2c8210ed351b6fbac694">&#9670;&#160;</a></span>access() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_type &amp; <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::access </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a5df32139913eb6022e949defb82d5c06">const_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>entry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read and return the data at the given BufferIterator's location, reference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>the BufferIterator to read from. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00464">464</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Buffer_aab050bc94a2f2c8210ed351b6fbac694_cgraph.png" border="0" usemap="#aclasssparta_1_1Buffer_aab050bc94a2f2c8210ed351b6fbac694_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Buffer_aab050bc94a2f2c8210ed351b6fbac694_cgraph" id="aclasssparta_1_1Buffer_aab050bc94a2f2c8210ed351b6fbac694_cgraph">
<area shape="rect" title="Read and return the data at the given BufferIterator&#39;s location, reference." alt="" coords="5,5,151,31"/>
<area shape="rect" href="classsparta_1_1Buffer.html#adb32977c84a0835581b18c027d19199f" title="Read and return the data at the given index, reference." alt="" coords="199,5,344,31"/>
<area shape="poly" title=" " alt="" coords="151,16,183,16,183,21,151,21"/>
<area shape="rect" href="classsparta_1_1Buffer.html#ab4acbe31cd8041c3cf7818886a67d825" title="Determine if data at the index is valid." alt="" coords="392,5,534,31"/>
<area shape="poly" title=" " alt="" coords="344,16,376,16,376,21,344,21"/>
<area shape="rect" href="classsparta_1_1Buffer.html#a58e8b8181aae8c9427385d0d1015a579" title="Return the number of valid entries." alt="" coords="582,5,709,31"/>
<area shape="poly" title=" " alt="" coords="535,16,567,16,567,21,535,21"/>
</map>
</div>

</div>
</div>
<a id="a7bce381b99d905e2ed2b8f63cf4fbe6c" name="a7bce381b99d905e2ed2b8f63cf4fbe6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bce381b99d905e2ed2b8f63cf4fbe6c">&#9670;&#160;</a></span>access() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_type &amp; <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::access </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a1f12bfc92bc79cbd91767c78c303fe38">const_reverse_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>entry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read and return the data at the given BufferIterator's location, reference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>the BufferIterator to read from. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00472">472</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Buffer_a7bce381b99d905e2ed2b8f63cf4fbe6c_cgraph.png" border="0" usemap="#aclasssparta_1_1Buffer_a7bce381b99d905e2ed2b8f63cf4fbe6c_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Buffer_a7bce381b99d905e2ed2b8f63cf4fbe6c_cgraph" id="aclasssparta_1_1Buffer_a7bce381b99d905e2ed2b8f63cf4fbe6c_cgraph">
<area shape="rect" title="Read and return the data at the given BufferIterator&#39;s location, reference." alt="" coords="5,5,151,31"/>
<area shape="rect" href="classsparta_1_1Buffer.html#adb32977c84a0835581b18c027d19199f" title="Read and return the data at the given index, reference." alt="" coords="199,5,344,31"/>
<area shape="poly" title=" " alt="" coords="151,16,183,16,183,21,151,21"/>
<area shape="rect" href="classsparta_1_1Buffer.html#ab4acbe31cd8041c3cf7818886a67d825" title="Determine if data at the index is valid." alt="" coords="392,5,534,31"/>
<area shape="poly" title=" " alt="" coords="344,16,376,16,376,21,344,21"/>
<area shape="rect" href="classsparta_1_1Buffer.html#a58e8b8181aae8c9427385d0d1015a579" title="Return the number of valid entries." alt="" coords="582,5,709,31"/>
<area shape="poly" title=" " alt="" coords="535,16,567,16,567,21,535,21"/>
</map>
</div>

</div>
</div>
<a id="adb32977c84a0835581b18c027d19199f" name="adb32977c84a0835581b18c027d19199f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb32977c84a0835581b18c027d19199f">&#9670;&#160;</a></span>access() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_type &amp; <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::access </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read and return the data at the given index, reference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data to return at the given index (reference) logarithmic time complexity on average </dd></dl>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00455">455</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Buffer_adb32977c84a0835581b18c027d19199f_cgraph.png" border="0" usemap="#aclasssparta_1_1Buffer_adb32977c84a0835581b18c027d19199f_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Buffer_adb32977c84a0835581b18c027d19199f_cgraph" id="aclasssparta_1_1Buffer_adb32977c84a0835581b18c027d19199f_cgraph">
<area shape="rect" title="Read and return the data at the given index, reference." alt="" coords="5,5,151,31"/>
<area shape="rect" href="classsparta_1_1Buffer.html#ab4acbe31cd8041c3cf7818886a67d825" title="Determine if data at the index is valid." alt="" coords="199,5,341,31"/>
<area shape="poly" title=" " alt="" coords="151,16,183,16,183,21,151,21"/>
<area shape="rect" href="classsparta_1_1Buffer.html#a58e8b8181aae8c9427385d0d1015a579" title="Return the number of valid entries." alt="" coords="389,5,515,31"/>
<area shape="poly" title=" " alt="" coords="342,16,373,16,373,21,342,21"/>
</map>
</div>

</div>
</div>
<a id="aac24ffe104db5ccc42f83ddabd1c1b3a" name="aac24ffe104db5ccc42f83ddabd1c1b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac24ffe104db5ccc42f83ddabd1c1b3a">&#9670;&#160;</a></span>accessBack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_type &amp; <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::accessBack </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read and return the data at the bottom of the <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The data to return at the given index (reference) logarithmic time complexity on average </dd></dl>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00481">481</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Buffer_aac24ffe104db5ccc42f83ddabd1c1b3a_cgraph.png" border="0" usemap="#aclasssparta_1_1Buffer_aac24ffe104db5ccc42f83ddabd1c1b3a_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Buffer_aac24ffe104db5ccc42f83ddabd1c1b3a_cgraph" id="aclasssparta_1_1Buffer_aac24ffe104db5ccc42f83ddabd1c1b3a_cgraph">
<area shape="rect" title="Read and return the data at the bottom of the Buffer." alt="" coords="5,5,181,31"/>
<area shape="rect" href="classsparta_1_1Buffer.html#ab4acbe31cd8041c3cf7818886a67d825" title="Determine if data at the index is valid." alt="" coords="229,5,371,31"/>
<area shape="poly" title=" " alt="" coords="181,16,213,16,213,21,181,21"/>
<area shape="rect" href="classsparta_1_1Buffer.html#a58e8b8181aae8c9427385d0d1015a579" title="Return the number of valid entries." alt="" coords="419,5,545,31"/>
<area shape="poly" title=" " alt="" coords="372,16,403,16,403,21,372,21"/>
</map>
</div>

</div>
</div>
<a id="a78d89a4542f3f1ada339f82d26d5c51c" name="a78d89a4542f3f1ada339f82d26d5c51c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78d89a4542f3f1ada339f82d26d5c51c">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a985ee08a3a91cbe74c785cfd44febda1">iterator</a> <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the iterator pointing to the beginning of <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to first element in buffer </dd></dl>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00744">744</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>

</div>
</div>
<a id="a6226a43da26babb69530e2bf824cd68c" name="a6226a43da26babb69530e2bf824cd68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6226a43da26babb69530e2bf824cd68c">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a5df32139913eb6022e949defb82d5c06">const_iterator</a> <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the const_iterator pointing to the begin of <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>const_iterator pointing to first element in buffer </dd></dl>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00762">762</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>

</div>
</div>
<a id="abfb1899d768f143c8df9e24a5a44f287" name="abfb1899d768f143c8df9e24a5a44f287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb1899d768f143c8df9e24a5a44f287">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the fixed size of this buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of this buffer </dd></dl>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00490">490</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>

</div>
</div>
<a id="a181331e7a93759f7bac294ed16dc4d2e" name="a181331e7a93759f7bac294ed16dc4d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a181331e7a93759f7bac294ed16dc4d2e">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty the contents of the <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a>. </p>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00694">694</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>

</div>
</div>
<a id="a5c3ce6c6cc99f191934b30881de18b4f" name="a5c3ce6c6cc99f191934b30881de18b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c3ce6c6cc99f191934b30881de18b4f">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query if the buffer is empty. </p>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00720">720</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>

</div>
</div>
<a id="ace76a7b21e07822cfca79fd53b39dbde" name="ace76a7b21e07822cfca79fd53b39dbde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace76a7b21e07822cfca79fd53b39dbde">&#9670;&#160;</a></span>enableCollection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::enableCollection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request that this queue begin collecting its contents for pipeline collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>A pointer to the parent treenode for which to add Collectable objects under. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This only sets the <a class="el" href="classsparta_1_1Queue.html" title="A data structure that allows appending at the back and invalidating from the front.">Queue</a> up for collection. collection must be started with an instatiation of the PipelineCollector </dd></dl>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00734">734</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>

</div>
</div>
<a id="af957d9119fd0009a62271ec686e7b3c6" name="af957d9119fd0009a62271ec686e7b3c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af957d9119fd0009a62271ec686e7b3c6">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a985ee08a3a91cbe74c785cfd44febda1">iterator</a> <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator referring to past-the-end element in the <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a> container. </p>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00756">756</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>

</div>
</div>
<a id="a81d6ef45332459d9cdb0be128b2a8d70" name="a81d6ef45332459d9cdb0be128b2a8d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81d6ef45332459d9cdb0be128b2a8d70">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a5df32139913eb6022e949defb82d5c06">const_iterator</a> <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_iterator referring to past-the-end element in the <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a> container. </p>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00773">773</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>

</div>
</div>
<a id="aa39cac9a92b318226be305b4218613b5" name="aa39cac9a92b318226be305b4218613b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa39cac9a92b318226be305b4218613b5">&#9670;&#160;</a></span>erase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a985ee08a3a91cbe74c785cfd44febda1">iterator</a> <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a5df32139913eb6022e949defb82d5c06">const_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>entry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the index at which the entry exists in the <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>a reference to the entry to be erased. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00672">672</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Buffer_aa39cac9a92b318226be305b4218613b5_cgraph.png" border="0" usemap="#aclasssparta_1_1Buffer_aa39cac9a92b318226be305b4218613b5_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Buffer_aa39cac9a92b318226be305b4218613b5_cgraph" id="aclasssparta_1_1Buffer_aa39cac9a92b318226be305b4218613b5_cgraph">
<area shape="rect" title="erase the index at which the entry exists in the Buffer." alt="" coords="5,5,141,31"/>
<area shape="rect" href="classsparta_1_1Buffer.html#a55071d909463f8fe74495ebfdacde810" title="erase a position in the Buffer immediately." alt="" coords="189,5,324,31"/>
<area shape="poly" title=" " alt="" coords="141,16,173,16,173,21,141,21"/>
<area shape="rect" href="classsparta_1_1Buffer.html#a58e8b8181aae8c9427385d0d1015a579" title="Return the number of valid entries." alt="" coords="372,5,498,31"/>
<area shape="poly" title=" " alt="" coords="324,16,357,16,357,21,324,21"/>
</map>
</div>

</div>
</div>
<a id="ad2603b1fdcf9fc00d2112528b53cf90b" name="ad2603b1fdcf9fc00d2112528b53cf90b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2603b1fdcf9fc00d2112528b53cf90b">&#9670;&#160;</a></span>erase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a177989df95f185f27a2d49b6c199b4d9">reverse_iterator</a> <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a1f12bfc92bc79cbd91767c78c303fe38">const_reverse_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>entry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase the index at which the entry exists in the <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>a reference to the entry to be erased. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00685">685</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Buffer_ad2603b1fdcf9fc00d2112528b53cf90b_cgraph.png" border="0" usemap="#aclasssparta_1_1Buffer_ad2603b1fdcf9fc00d2112528b53cf90b_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Buffer_ad2603b1fdcf9fc00d2112528b53cf90b_cgraph" id="aclasssparta_1_1Buffer_ad2603b1fdcf9fc00d2112528b53cf90b_cgraph">
<area shape="rect" title="erase the index at which the entry exists in the Buffer." alt="" coords="5,5,141,31"/>
<area shape="rect" href="classsparta_1_1Buffer.html#a55071d909463f8fe74495ebfdacde810" title="erase a position in the Buffer immediately." alt="" coords="189,5,324,31"/>
<area shape="poly" title=" " alt="" coords="141,16,173,16,173,21,141,21"/>
<area shape="rect" href="classsparta_1_1Buffer.html#a58e8b8181aae8c9427385d0d1015a579" title="Return the number of valid entries." alt="" coords="372,5,498,31"/>
<area shape="poly" title=" " alt="" coords="324,16,357,16,357,21,324,21"/>
</map>
</div>

</div>
</div>
<a id="a55071d909463f8fe74495ebfdacde810" name="a55071d909463f8fe74495ebfdacde810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55071d909463f8fe74495ebfdacde810">&#9670;&#160;</a></span>erase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>erase a position in the <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a> immediately. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the index to be erased.</td></tr>
  </table>
  </dd>
</dl>
<p>In a un-TimedBuffer, invalidations immediately changes the indexes in the buffer using this function. Therefore, it's recommended that erases are performed using a BufferIterator.</p>
<dl class="section warning"><dt>Warning</dt><dd>This method will throw an exception if the index can be represented by an existing BufferIterator. If a BufferIterator has been created, the erase(BufferIterator&amp;) should be used. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00624">624</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Buffer_a55071d909463f8fe74495ebfdacde810_cgraph.png" border="0" usemap="#aclasssparta_1_1Buffer_a55071d909463f8fe74495ebfdacde810_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Buffer_a55071d909463f8fe74495ebfdacde810_cgraph" id="aclasssparta_1_1Buffer_a55071d909463f8fe74495ebfdacde810_cgraph">
<area shape="rect" title="erase a position in the Buffer immediately." alt="" coords="5,5,141,31"/>
<area shape="rect" href="classsparta_1_1Buffer.html#a58e8b8181aae8c9427385d0d1015a579" title="Return the number of valid entries." alt="" coords="189,5,315,31"/>
<area shape="poly" title=" " alt="" coords="141,16,173,16,173,21,141,21"/>
</map>
</div>

</div>
</div>
<a id="a22d76633c1dddbb573fe7992a11ff9b4" name="a22d76633c1dddbb573fe7992a11ff9b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d76633c1dddbb573fe7992a11ff9b4">&#9670;&#160;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::getName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name of this resource. </p>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00407">407</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>

</div>
</div>
<a id="a959768b33f68ffc78882b3d32789301f" name="a959768b33f68ffc78882b3d32789301f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a959768b33f68ffc78882b3d32789301f">&#9670;&#160;</a></span>insert() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a985ee08a3a91cbe74c785cfd44febda1">iterator</a> <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a5df32139913eb6022e949defb82d5c06">const_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>entry</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;</td>          <td class="paramname"><span class="paramname"><em>dat</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do an insert before a BufferIterator see insert method above. </p>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00587">587</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Buffer_a959768b33f68ffc78882b3d32789301f_cgraph.png" border="0" usemap="#aclasssparta_1_1Buffer_a959768b33f68ffc78882b3d32789301f_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Buffer_a959768b33f68ffc78882b3d32789301f_cgraph" id="aclasssparta_1_1Buffer_a959768b33f68ffc78882b3d32789301f_cgraph">
<area shape="rect" title="Do an insert before a BufferIterator see insert method above." alt="" coords="5,5,141,31"/>
<area shape="rect" href="classsparta_1_1Buffer.html#a066c7ac12d45ad7fa62721c26aed5efd" title="Insert the item BEFORE the given index." alt="" coords="189,5,324,31"/>
<area shape="poly" title=" " alt="" coords="141,16,173,16,173,21,141,21"/>
</map>
</div>

</div>
</div>
<a id="a37742f1e5b1223195faf08e5ede0f6c9" name="a37742f1e5b1223195faf08e5ede0f6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37742f1e5b1223195faf08e5ede0f6c9">&#9670;&#160;</a></span>insert() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a985ee08a3a91cbe74c785cfd44febda1">iterator</a> <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a5df32139913eb6022e949defb82d5c06">const_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>entry</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>dat</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do an insert before a BufferIterator see insert method above. </p>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00593">593</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Buffer_a37742f1e5b1223195faf08e5ede0f6c9_cgraph.png" border="0" usemap="#aclasssparta_1_1Buffer_a37742f1e5b1223195faf08e5ede0f6c9_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Buffer_a37742f1e5b1223195faf08e5ede0f6c9_cgraph" id="aclasssparta_1_1Buffer_a37742f1e5b1223195faf08e5ede0f6c9_cgraph">
<area shape="rect" title="Do an insert before a BufferIterator see insert method above." alt="" coords="5,5,141,31"/>
<area shape="rect" href="classsparta_1_1Buffer.html#a066c7ac12d45ad7fa62721c26aed5efd" title="Insert the item BEFORE the given index." alt="" coords="189,5,324,31"/>
<area shape="poly" title=" " alt="" coords="141,16,173,16,173,21,141,21"/>
</map>
</div>

</div>
</div>
<a id="ad961e89882e617f8bf254466968ec5f4" name="ad961e89882e617f8bf254466968ec5f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad961e89882e617f8bf254466968ec5f4">&#9670;&#160;</a></span>insert() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a985ee08a3a91cbe74c785cfd44febda1">iterator</a> <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a1f12bfc92bc79cbd91767c78c303fe38">const_reverse_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>entry</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;</td>          <td class="paramname"><span class="paramname"><em>dat</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do an insert before a BufferIterator see insert method above. </p>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00599">599</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Buffer_ad961e89882e617f8bf254466968ec5f4_cgraph.png" border="0" usemap="#aclasssparta_1_1Buffer_ad961e89882e617f8bf254466968ec5f4_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Buffer_ad961e89882e617f8bf254466968ec5f4_cgraph" id="aclasssparta_1_1Buffer_ad961e89882e617f8bf254466968ec5f4_cgraph">
<area shape="rect" title="Do an insert before a BufferIterator see insert method above." alt="" coords="5,5,141,31"/>
<area shape="rect" href="classsparta_1_1Buffer.html#a066c7ac12d45ad7fa62721c26aed5efd" title="Insert the item BEFORE the given index." alt="" coords="189,5,324,31"/>
<area shape="poly" title=" " alt="" coords="141,16,173,16,173,21,141,21"/>
</map>
</div>

</div>
</div>
<a id="a9facdc43c765aafac1bfdcb0a7513149" name="a9facdc43c765aafac1bfdcb0a7513149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9facdc43c765aafac1bfdcb0a7513149">&#9670;&#160;</a></span>insert() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a985ee08a3a91cbe74c785cfd44febda1">iterator</a> <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a1f12bfc92bc79cbd91767c78c303fe38">const_reverse_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>entry</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>dat</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do an insert before a BufferIterator see insert method above. </p>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00605">605</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Buffer_a9facdc43c765aafac1bfdcb0a7513149_cgraph.png" border="0" usemap="#aclasssparta_1_1Buffer_a9facdc43c765aafac1bfdcb0a7513149_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Buffer_a9facdc43c765aafac1bfdcb0a7513149_cgraph" id="aclasssparta_1_1Buffer_a9facdc43c765aafac1bfdcb0a7513149_cgraph">
<area shape="rect" title="Do an insert before a BufferIterator see insert method above." alt="" coords="5,5,141,31"/>
<area shape="rect" href="classsparta_1_1Buffer.html#a066c7ac12d45ad7fa62721c26aed5efd" title="Insert the item BEFORE the given index." alt="" coords="189,5,324,31"/>
<area shape="poly" title=" " alt="" coords="141,16,173,16,173,21,141,21"/>
</map>
</div>

</div>
</div>
<a id="a066c7ac12d45ad7fa62721c26aed5efd" name="a066c7ac12d45ad7fa62721c26aed5efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a066c7ac12d45ad7fa62721c26aed5efd">&#9670;&#160;</a></span>insert() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a985ee08a3a91cbe74c785cfd44febda1">iterator</a> <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;</td>          <td class="paramname"><span class="paramname"><em>dat</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert the item BEFORE the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index to insert the new item before </td></tr>
    <tr><td class="paramname">dat</td><td>The data to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A BufferIterator for the new location.</dd></dl>
<p>As an example, if the buffer contains: </p><div class="fragment"><div class="line">[a, b, c]</div>
</div><!-- fragment --><p>an insert(1, w) becomes</p>
<div class="fragment"><div class="line">[a, w, b, c]</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00558">558</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>

</div>
</div>
<a id="abf2e0d4362318c1e133857dabad1cbcb" name="abf2e0d4362318c1e133857dabad1cbcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf2e0d4362318c1e133857dabad1cbcb">&#9670;&#160;</a></span>insert() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a985ee08a3a91cbe74c785cfd44febda1">iterator</a> <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>dat</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert the item BEFORE the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index to insert the new item before </td></tr>
    <tr><td class="paramname">dat</td><td>The data to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A BufferIterator for the new location.</dd></dl>
<p>As an example, if the buffer contains: </p><div class="fragment"><div class="line">[a, b, c]</div>
</div><!-- fragment --><p>an insert(1, w) becomes</p>
<div class="fragment"><div class="line">[a, w, b, c]</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00581">581</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>

</div>
</div>
<a id="ab4acbe31cd8041c3cf7818886a67d825" name="ab4acbe31cd8041c3cf7818886a67d825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4acbe31cd8041c3cf7818886a67d825">&#9670;&#160;</a></span>isValid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::isValid </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if data at the index is valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index to determine validity </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid; false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00417">417</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Buffer_ab4acbe31cd8041c3cf7818886a67d825_cgraph.png" border="0" usemap="#aclasssparta_1_1Buffer_ab4acbe31cd8041c3cf7818886a67d825_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Buffer_ab4acbe31cd8041c3cf7818886a67d825_cgraph" id="aclasssparta_1_1Buffer_ab4acbe31cd8041c3cf7818886a67d825_cgraph">
<area shape="rect" title="Determine if data at the index is valid." alt="" coords="5,5,148,31"/>
<area shape="rect" href="classsparta_1_1Buffer.html#a58e8b8181aae8c9427385d0d1015a579" title="Return the number of valid entries." alt="" coords="196,5,322,31"/>
<area shape="poly" title=" " alt="" coords="148,16,180,16,180,21,148,21"/>
</map>
</div>

</div>
</div>
<a id="a789bf078f54f2e28df280786d21c16d1" name="a789bf078f54f2e28df280786d21c16d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a789bf078f54f2e28df280786d21c16d1">&#9670;&#160;</a></span>makeInfinite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::makeInfinite </td>
          <td>(</td>
          <td class="paramtype">const uint32_t</td>          <td class="paramname"><span class="paramname"><em>resize_delta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes the <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a> grow beyond its capacity. The buffer grows by adding new entries in its internal vectors. The number of new entries it adds defaults to the value 1, each time it resizes itself. </p>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00809">809</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>

</div>
</div>
<a id="a1a42bbf90ee44b4930588e0ddb4d6e19" name="a1a42bbf90ee44b4930588e0ddb4d6e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a42bbf90ee44b4930588e0ddb4d6e19">&#9670;&#160;</a></span>numFree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::numFree </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of free entries. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of free entries</dd></dl>
<p>Does not take into account the number of erased entries <em>this</em> cycle </p>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00508">508</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Buffer_a1a42bbf90ee44b4930588e0ddb4d6e19_cgraph.png" border="0" usemap="#aclasssparta_1_1Buffer_a1a42bbf90ee44b4930588e0ddb4d6e19_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Buffer_a1a42bbf90ee44b4930588e0ddb4d6e19_cgraph" id="aclasssparta_1_1Buffer_a1a42bbf90ee44b4930588e0ddb4d6e19_cgraph">
<area shape="rect" title="Return the number of free entries." alt="" coords="5,31,160,56"/>
<area shape="rect" href="classsparta_1_1Buffer.html#abfb1899d768f143c8df9e24a5a44f287" title="Return the fixed size of this buffer." alt="" coords="208,5,359,31"/>
<area shape="poly" title=" " alt="" coords="160,31,192,27,192,32,160,36"/>
<area shape="rect" href="classsparta_1_1Buffer.html#a58e8b8181aae8c9427385d0d1015a579" title="Return the number of valid entries." alt="" coords="220,55,346,80"/>
<area shape="poly" title=" " alt="" coords="160,50,205,56,205,61,160,55"/>
</map>
</div>

</div>
</div>
<a id="a67c4eabdfc563b338adce22fc0eed88c" name="a67c4eabdfc563b338adce22fc0eed88c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c4eabdfc563b338adce22fc0eed88c">&#9670;&#160;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a985ee08a3a91cbe74c785cfd44febda1">iterator</a> <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;</td>          <td class="paramname"><span class="paramname"><em>dat</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append data to the end of <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a>, and return a BufferIterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dat</td><td>Data to be pushed back into the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a BufferIterator created to represent the object appended.</dd></dl>
<p>Append data to the end of <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a>, and return a BufferIterator for the location appeneded. Untimed Buffers will have the data become valid immediately. </p>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00521">521</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>

</div>
</div>
<a id="a7f5505984db6b80574965b5d9333be3f" name="a7f5505984db6b80574965b5d9333be3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f5505984db6b80574965b5d9333be3f">&#9670;&#160;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a985ee08a3a91cbe74c785cfd44febda1">iterator</a> <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">value_type &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>dat</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append data to the end of <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a>, and return a BufferIterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dat</td><td>Data to be pushed back into the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a BufferIterator created to represent the object appended.</dd></dl>
<p>Append data to the end of <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a>, and return a BufferIterator for the location appeneded. Untimed Buffers will have the data become valid immediately. </p>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00535">535</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>

</div>
</div>
<a id="a9e79ec1c29adfcbac8944f3b8de9ca53" name="a9e79ec1c29adfcbac8944f3b8de9ca53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e79ec1c29adfcbac8944f3b8de9ca53">&#9670;&#160;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a177989df95f185f27a2d49b6c199b4d9">reverse_iterator</a> <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the iterator pointing to the pass-the-end element of <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Revese iterator pointing to last element in buffer </dd></dl>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00779">779</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>

</div>
</div>
<a id="af1757b7271c1a70f883e15692db9e466" name="af1757b7271c1a70f883e15692db9e466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1757b7271c1a70f883e15692db9e466">&#9670;&#160;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a1f12bfc92bc79cbd91767c78c303fe38">const_reverse_iterator</a> <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the const_reverse_iterator pointing to the pass-the-end of <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>const_reverse_iterator pointing to first element in buffer </dd></dl>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00793">793</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>

</div>
</div>
<a id="a3292252569d5410fb0b0652d85343778" name="a3292252569d5410fb0b0652d85343778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3292252569d5410fb0b0652d85343778">&#9670;&#160;</a></span>read() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_type &amp; <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::read </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a5df32139913eb6022e949defb82d5c06">const_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>entry</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>read the entry at the BufferIterator's location </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>the BufferIterator to read from. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00435">435</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Buffer_a3292252569d5410fb0b0652d85343778_cgraph.png" border="0" usemap="#aclasssparta_1_1Buffer_a3292252569d5410fb0b0652d85343778_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Buffer_a3292252569d5410fb0b0652d85343778_cgraph" id="aclasssparta_1_1Buffer_a3292252569d5410fb0b0652d85343778_cgraph">
<area shape="rect" title="read the entry at the BufferIterator&#39;s location" alt="" coords="5,5,134,31"/>
<area shape="rect" href="classsparta_1_1Buffer.html#a905154d88dbaaa223d154ee1c2c859a2" title="Read and return the data at the given index, const reference." alt="" coords="182,5,310,31"/>
<area shape="poly" title=" " alt="" coords="134,16,166,16,166,21,134,21"/>
<area shape="rect" href="classsparta_1_1Buffer.html#ab4acbe31cd8041c3cf7818886a67d825" title="Determine if data at the index is valid." alt="" coords="358,5,500,31"/>
<area shape="poly" title=" " alt="" coords="310,16,342,16,342,21,310,21"/>
<area shape="rect" href="classsparta_1_1Buffer.html#a58e8b8181aae8c9427385d0d1015a579" title="Return the number of valid entries." alt="" coords="548,5,675,31"/>
<area shape="poly" title=" " alt="" coords="501,16,533,16,533,21,501,21"/>
</map>
</div>

</div>
</div>
<a id="a9bc05fa6659a18d18e756ba8314ba689" name="a9bc05fa6659a18d18e756ba8314ba689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc05fa6659a18d18e756ba8314ba689">&#9670;&#160;</a></span>read() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_type &amp; <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::read </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a1f12bfc92bc79cbd91767c78c303fe38">const_reverse_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>entry</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>read the entry at the BufferIterator's location </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>the BufferIterator to read from. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00444">444</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Buffer_a9bc05fa6659a18d18e756ba8314ba689_cgraph.png" border="0" usemap="#aclasssparta_1_1Buffer_a9bc05fa6659a18d18e756ba8314ba689_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Buffer_a9bc05fa6659a18d18e756ba8314ba689_cgraph" id="aclasssparta_1_1Buffer_a9bc05fa6659a18d18e756ba8314ba689_cgraph">
<area shape="rect" title="read the entry at the BufferIterator&#39;s location" alt="" coords="5,5,134,31"/>
<area shape="rect" href="classsparta_1_1Buffer.html#a905154d88dbaaa223d154ee1c2c859a2" title="Read and return the data at the given index, const reference." alt="" coords="182,5,310,31"/>
<area shape="poly" title=" " alt="" coords="134,16,166,16,166,21,134,21"/>
<area shape="rect" href="classsparta_1_1Buffer.html#ab4acbe31cd8041c3cf7818886a67d825" title="Determine if data at the index is valid." alt="" coords="358,5,500,31"/>
<area shape="poly" title=" " alt="" coords="310,16,342,16,342,21,310,21"/>
<area shape="rect" href="classsparta_1_1Buffer.html#a58e8b8181aae8c9427385d0d1015a579" title="Return the number of valid entries." alt="" coords="548,5,675,31"/>
<area shape="poly" title=" " alt="" coords="501,16,533,16,533,21,501,21"/>
</map>
</div>

</div>
</div>
<a id="a905154d88dbaaa223d154ee1c2c859a2" name="a905154d88dbaaa223d154ee1c2c859a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a905154d88dbaaa223d154ee1c2c859a2">&#9670;&#160;</a></span>read() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_type &amp; <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::read </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read and return the data at the given index, const reference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data to return at the given index (const reference) </dd></dl>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00426">426</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Buffer_a905154d88dbaaa223d154ee1c2c859a2_cgraph.png" border="0" usemap="#aclasssparta_1_1Buffer_a905154d88dbaaa223d154ee1c2c859a2_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Buffer_a905154d88dbaaa223d154ee1c2c859a2_cgraph" id="aclasssparta_1_1Buffer_a905154d88dbaaa223d154ee1c2c859a2_cgraph">
<area shape="rect" title="Read and return the data at the given index, const reference." alt="" coords="5,5,134,31"/>
<area shape="rect" href="classsparta_1_1Buffer.html#ab4acbe31cd8041c3cf7818886a67d825" title="Determine if data at the index is valid." alt="" coords="182,5,324,31"/>
<area shape="poly" title=" " alt="" coords="134,16,166,16,166,21,134,21"/>
<area shape="rect" href="classsparta_1_1Buffer.html#a58e8b8181aae8c9427385d0d1015a579" title="Return the number of valid entries." alt="" coords="372,5,498,31"/>
<area shape="poly" title=" " alt="" coords="325,16,356,16,356,21,325,21"/>
</map>
</div>

</div>
</div>
<a id="a685b46fb7c11c9a2ac42217df6d263cd" name="a685b46fb7c11c9a2ac42217df6d263cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a685b46fb7c11c9a2ac42217df6d263cd">&#9670;&#160;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a177989df95f185f27a2d49b6c199b4d9">reverse_iterator</a> <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::rend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an reverse iterator referring to starting element in the <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a> container. </p>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00787">787</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>

</div>
</div>
<a id="a420ec8c60431fd8bdcaa809ef9d1f3b6" name="a420ec8c60431fd8bdcaa809ef9d1f3b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420ec8c60431fd8bdcaa809ef9d1f3b6">&#9670;&#160;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a1f12bfc92bc79cbd91767c78c303fe38">const_reverse_iterator</a> <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::rend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_reverse_iterator referring to start element in the <a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a> container. </p>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00801">801</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>

</div>
</div>
<a id="a58e8b8181aae8c9427385d0d1015a579" name="a58e8b8181aae8c9427385d0d1015a579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58e8b8181aae8c9427385d0d1015a579">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classsparta_1_1Buffer.html">sparta::Buffer</a>&lt; DataT &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of valid entries. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of valid entries. Does not subtract entries erased <em>this</em> cycle </dd></dl>

<p class="definition">Definition at line <a class="el" href="Buffer_8hpp_source.html#l00498">498</a> of file <a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/github/workspace/sparta/sparta/resources/<a class="el" href="Buffer_8hpp_source.html">Buffer.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesparta.html">sparta</a></li><li class="navelem"><a class="el" href="classsparta_1_1Buffer.html">Buffer</a></li>
    <li class="footer">Generated on Mon Feb 9 2026 03:27:55 for The Sparta Modeling Framework by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
