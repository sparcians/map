<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Sparta Modeling Framework: sparta::Parameter&lt; ValueType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">The Sparta Modeling Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classsparta_1_1Parameter.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classsparta_1_1Parameter-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">sparta::Parameter&lt; ValueType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> instance, templated to contain only a specific type.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sparta::Parameter&lt; ValueType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Parameter__inherit__graph.png" border="0" usemap="#asparta_1_1Parameter_3_01ValueType_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="asparta_1_1Parameter_3_01ValueType_01_4_inherit__map" id="asparta_1_1Parameter_3_01ValueType_01_4_inherit__map">
<area shape="rect" title="Parameter instance, templated to contain only a specific type." alt="" coords="125,300,256,341"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html" title="Non&#45;templated base class for generic parameter access and iteration." alt="" coords="114,226,267,252"/>
<area shape="poly" title=" " alt="" coords="193,267,193,300,188,300,188,267"/>
<area shape="rect" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item." alt="" coords="130,153,251,178"/>
<area shape="poly" title=" " alt="" coords="193,194,193,226,188,226,188,194"/>
<area shape="rect" href="classsparta_1_1ResourceContainer.html" title="PhasedObject which can hold 0 or 1 Resource pointers to an associatedresource. Contains logic for set..." alt="" coords="5,79,179,105"/>
<area shape="poly" title=" " alt="" coords="123,112,176,150,173,154,119,116"/>
<area shape="rect" href="classsparta_1_1PhasedObject.html" title="Object having a specific phase in the sparta construction paradigm." alt="" coords="19,5,165,31"/>
<area shape="poly" title=" " alt="" coords="95,46,95,79,89,79,89,46"/>
<area shape="rect" href="classsparta_1_1ArchDataContainer.html" title="Container class for any number of ArchData pointers owned externally." alt="" coords="203,79,376,105"/>
<area shape="poly" title=" " alt="" coords="262,116,209,154,206,150,259,112"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for sparta::Parameter&lt; ValueType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Parameter__coll__graph.png" border="0" usemap="#asparta_1_1Parameter_3_01ValueType_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="asparta_1_1Parameter_3_01ValueType_01_4_coll__map" id="asparta_1_1Parameter_3_01ValueType_01_4_coll__map">
<area shape="rect" title="Parameter instance, templated to contain only a specific type." alt="" coords="125,300,256,341"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html" title="Non&#45;templated base class for generic parameter access and iteration." alt="" coords="114,226,267,252"/>
<area shape="poly" title=" " alt="" coords="193,267,193,300,188,300,188,267"/>
<area shape="rect" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item." alt="" coords="130,153,251,178"/>
<area shape="poly" title=" " alt="" coords="193,194,193,226,188,226,188,194"/>
<area shape="rect" href="classsparta_1_1ResourceContainer.html" title="PhasedObject which can hold 0 or 1 Resource pointers to an associatedresource. Contains logic for set..." alt="" coords="5,79,179,105"/>
<area shape="poly" title=" " alt="" coords="123,112,176,150,173,154,119,116"/>
<area shape="rect" href="classsparta_1_1PhasedObject.html" title="Object having a specific phase in the sparta construction paradigm." alt="" coords="19,5,165,31"/>
<area shape="poly" title=" " alt="" coords="95,46,95,79,89,79,89,46"/>
<area shape="rect" href="classsparta_1_1ArchDataContainer.html" title="Container class for any number of ArchData pointers owned externally." alt="" coords="203,79,376,105"/>
<area shape="poly" title=" " alt="" coords="262,116,209,154,206,150,259,112"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a42c937893d3974e6143c5dd88d86d1c7" id="r_a42c937893d3974e6143c5dd88d86d1c7"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42c937893d3974e6143c5dd88d86d1c7">ParameterAttribute</a> : std::uint8_t { <br />
&#160;&#160;<b>DEFAULT</b> = 0
, <b>__FIRST</b> = DEFAULT
, <b>LOCKED</b> = 1
, <b>HIDDEN</b> = 2
, <br />
&#160;&#160;<b>__LAST</b>
<br />
 }</td></tr>
<tr class="memdesc:a42c937893d3974e6143c5dd88d86d1c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">ParameterAttribute enum class which describes special attributes of this parameter.  <a href="#a42c937893d3974e6143c5dd88d86d1c7">More...</a><br /></td></tr>
<tr class="separator:a42c937893d3974e6143c5dd88d86d1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75bb728b6180aa7caad038ef7ad5d7f" id="r_ad75bb728b6180aa7caad038ef7ad5d7f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad75bb728b6180aa7caad038ef7ad5d7f">type</a> = ValueType</td></tr>
<tr class="memdesc:ad75bb728b6180aa7caad038ef7ad5d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type held by this parameter. This cannot change at run-time.  <br /></td></tr>
<tr class="separator:ad75bb728b6180aa7caad038ef7ad5d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6a9f537344e21a846ebea4e217787e" id="r_a7f6a9f537344e21a846ebea4e217787e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f6a9f537344e21a846ebea4e217787e">value_type</a> = ValueType</td></tr>
<tr class="separator:a7f6a9f537344e21a846ebea4e217787e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classsparta_1_1ParameterBase"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_types_classsparta_1_1ParameterBase')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classsparta_1_1ParameterBase.html">sparta::ParameterBase</a></td></tr>
<tr class="memitem:af4e84978d016d9540c19af0918dba0fa inherit pub_types_classsparta_1_1ParameterBase" id="r_af4e84978d016d9540c19af0918dba0fa"><td class="memItemLeft" align="right" valign="top">typedef class <a class="el" href="classsparta_1_1ParameterBase_1_1ParameterValueIterator.html">sparta::ParameterBase::ParameterValueIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html#af4e84978d016d9540c19af0918dba0fa">const_iterator</a></td></tr>
<tr class="memdesc:af4e84978d016d9540c19af0918dba0fa inherit pub_types_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic value iterator for a SINGLE parameter which represents values ONLY as std::string.  <br /></td></tr>
<tr class="separator:af4e84978d016d9540c19af0918dba0fa inherit pub_types_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classsparta_1_1TreeNode"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_types_classsparta_1_1TreeNode')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a></td></tr>
<tr class="memitem:af5075c9b90f28041b6a7f3f80132c1b3 inherit pub_types_classsparta_1_1TreeNode" id="r_af5075c9b90f28041b6a7f3f80132c1b3"><td class="memItemLeft" align="right" valign="top">typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#af5075c9b90f28041b6a7f3f80132c1b3">node_uid_type</a></td></tr>
<tr class="memdesc:af5075c9b90f28041b6a7f3f80132c1b3 inherit pub_types_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of unique-identifier assigned to every node.  <br /></td></tr>
<tr class="separator:af5075c9b90f28041b6a7f3f80132c1b3 inherit pub_types_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a2fea735ac7c0116fd470ddb1b7744 inherit pub_types_classsparta_1_1TreeNode" id="r_af0a2fea735ac7c0116fd470ddb1b7744"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#af0a2fea735ac7c0116fd470ddb1b7744">ChildrenVector</a></td></tr>
<tr class="memdesc:af0a2fea735ac7c0116fd470ddb1b7744 inherit pub_types_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> children.  <br /></td></tr>
<tr class="separator:af0a2fea735ac7c0116fd470ddb1b7744 inherit pub_types_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991e1785f763d44925f4a53d89a44675 inherit pub_types_classsparta_1_1TreeNode" id="r_a991e1785f763d44925f4a53d89a44675"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a991e1785f763d44925f4a53d89a44675">AliasVector</a></td></tr>
<tr class="memdesc:a991e1785f763d44925f4a53d89a44675 inherit pub_types_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of aliases (other names for this node)  <br /></td></tr>
<tr class="separator:a991e1785f763d44925f4a53d89a44675 inherit pub_types_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa15383cc601098b76d0ef08eff4200 inherit pub_types_classsparta_1_1TreeNode" id="r_a8fa15383cc601098b76d0ef08eff4200"><td class="memItemLeft" align="right" valign="top">typedef std::multimap&lt; std::string, <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a8fa15383cc601098b76d0ef08eff4200">ChildNameMapping</a></td></tr>
<tr class="memdesc:a8fa15383cc601098b76d0ef08eff4200 inherit pub_types_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapping of names, aliases, and groups to individual child nodes within one node. This must be in a deterministic order, so an ordered container (e.g. std::map) is required. A sorted contained is probably desirable, but not required.  <br /></td></tr>
<tr class="separator:a8fa15383cc601098b76d0ef08eff4200 inherit pub_types_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa01f145455d583b8f16e0f923b7c7c inherit pub_types_classsparta_1_1TreeNode" id="r_a7fa01f145455d583b8f16e0f923b7c7c"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a7fa01f145455d583b8f16e0f923b7c7c">group_idx_type</a></td></tr>
<tr class="memdesc:a7fa01f145455d583b8f16e0f923b7c7c inherit pub_types_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index within a group.  <br /></td></tr>
<tr class="separator:a7fa01f145455d583b8f16e0f923b7c7c inherit pub_types_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f21b18f9f50f70111730361eff6ddb inherit pub_types_classsparta_1_1TreeNode" id="r_a91f21b18f9f50f70111730361eff6ddb"><td class="memItemLeft" align="right" valign="top">typedef std::weak_ptr&lt; <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a91f21b18f9f50f70111730361eff6ddb">WeakPtr</a></td></tr>
<tr class="memdesc:a91f21b18f9f50f70111730361eff6ddb inherit pub_types_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weak pointer to a <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>. Acquire with getWeakPtr.  <br /></td></tr>
<tr class="separator:a91f21b18f9f50f70111730361eff6ddb inherit pub_types_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa43836f90c9203c7b2c09647a0707d3 inherit pub_types_classsparta_1_1TreeNode" id="r_afa43836f90c9203c7b2c09647a0707d3"><td class="memItemLeft" align="right" valign="top">typedef std::weak_ptr&lt; const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#afa43836f90c9203c7b2c09647a0707d3">ConstWeakPtr</a></td></tr>
<tr class="memdesc:afa43836f90c9203c7b2c09647a0707d3 inherit pub_types_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weak pointer to a const <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>. Acquire with getWeakPtr.  <br /></td></tr>
<tr class="separator:afa43836f90c9203c7b2c09647a0707d3 inherit pub_types_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5429faab680829656533d4cd5ff0bc0d inherit pub_types_classsparta_1_1TreeNode" id="r_a5429faab680829656533d4cd5ff0bc0d"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a5429faab680829656533d4cd5ff0bc0d">SharedPtr</a></td></tr>
<tr class="memdesc:a5429faab680829656533d4cd5ff0bc0d inherit pub_types_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer to <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>. Acquire with WeakPtr::lock().  <br /></td></tr>
<tr class="separator:a5429faab680829656533d4cd5ff0bc0d inherit pub_types_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda7e1fd5fa85a6b9b9e0cc413dae2a5 inherit pub_types_classsparta_1_1TreeNode" id="r_abda7e1fd5fa85a6b9b9e0cc413dae2a5"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; const std::string *, std::vector&lt; <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#abda7e1fd5fa85a6b9b9e0cc413dae2a5">TagsMap</a></td></tr>
<tr class="memdesc:abda7e1fd5fa85a6b9b9e0cc413dae2a5 inherit pub_types_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of strings (interned in <a class="el" href="classsparta_1_1StringManager.html" title="Manages string internment for SPARTA. This allows strings to be compared by pointer once interned.">StringManager</a>) tags to TreeNodes.  <br /></td></tr>
<tr class="separator:abda7e1fd5fa85a6b9b9e0cc413dae2a5 inherit pub_types_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb004c7a919bb15eb9113b7ac6dae777 inherit pub_types_classsparta_1_1TreeNode" id="r_abb004c7a919bb15eb9113b7ac6dae777"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#abb004c7a919bb15eb9113b7ac6dae777">ExtensionsBase</a> = detail::ExtensionsBase</td></tr>
<tr class="separator:abb004c7a919bb15eb9113b7ac6dae777 inherit pub_types_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classsparta_1_1PhasedObject"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_types_classsparta_1_1PhasedObject')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classsparta_1_1PhasedObject.html">sparta::PhasedObject</a></td></tr>
<tr class="memitem:afe9c78396c961fd96f0975867197b366 inherit pub_types_classsparta_1_1PhasedObject" id="r_afe9c78396c961fd96f0975867197b366"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1PhasedObject.html#afe9c78396c961fd96f0975867197b366">TreePhase</a> { <br />
&#160;&#160;<a class="el" href="classsparta_1_1PhasedObject.html#afe9c78396c961fd96f0975867197b366abd4d809ed80d002633d62a28b233d397">TREE_BUILDING</a> = 0
, <a class="el" href="classsparta_1_1PhasedObject.html#afe9c78396c961fd96f0975867197b366a4ad63ff1aeafd781623e5b9dd8e95dc1">TREE_CONFIGURING</a> = 1
, <a class="el" href="classsparta_1_1PhasedObject.html#afe9c78396c961fd96f0975867197b366a2f07c28e39e7339f7f0cf444aaee3f36">TREE_FINALIZING</a> = 2
, <a class="el" href="classsparta_1_1PhasedObject.html#afe9c78396c961fd96f0975867197b366ad3c0a8e691ca35c690e5055d2c888789">TREE_FINALIZED</a> = 3
, <br />
&#160;&#160;<a class="el" href="classsparta_1_1PhasedObject.html#afe9c78396c961fd96f0975867197b366a7ddcaa6221e3b5dbbe9c359203ff8ec7">TREE_TEARDOWN</a> = 4
<br />
 }</td></tr>
<tr class="memdesc:afe9c78396c961fd96f0975867197b366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current phase of tree construction (applies to node and entire tree).  <a href="classsparta_1_1PhasedObject.html#afe9c78396c961fd96f0975867197b366">More...</a><br /></td></tr>
<tr class="separator:afe9c78396c961fd96f0975867197b366 inherit pub_types_classsparta_1_1PhasedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aad0e025d41c2a0e8041edcfeaf36d339" id="r_aad0e025d41c2a0e8041edcfeaf36d339"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad0e025d41c2a0e8041edcfeaf36d339">Parameter</a> (const std::string &amp;name, const ValueType &amp;def, const std::string &amp;doc, bool isvolatile=false)</td></tr>
<tr class="memdesc:aad0e025d41c2a0e8041edcfeaf36d339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a parameter.  <br /></td></tr>
<tr class="separator:aad0e025d41c2a0e8041edcfeaf36d339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef156e555746ae268ab4b36ef8281b2" id="r_abef156e555746ae268ab4b36ef8281b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abef156e555746ae268ab4b36ef8281b2">Parameter</a> (const std::string &amp;name, const ValueType &amp;def, const std::string &amp;doc, <a class="el" href="classsparta_1_1ParameterSet.html">ParameterSet</a> *ps, bool isvolatile=false)</td></tr>
<tr class="memdesc:abef156e555746ae268ab4b36ef8281b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor used by the PARAMETER macro.  <br /></td></tr>
<tr class="separator:abef156e555746ae268ab4b36ef8281b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a9771a031bcb3812059bd4e432b72b" id="r_ac2a9771a031bcb3812059bd4e432b72b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2a9771a031bcb3812059bd4e432b72b">Parameter</a> (const std::string &amp;name, const ValueType &amp;def, const std::string &amp;doc, const <a class="el" href="#a42c937893d3974e6143c5dd88d86d1c7">ParameterAttribute</a> &amp;attr, <a class="el" href="classsparta_1_1ParameterSet.html">ParameterSet</a> *ps, bool isvolatile=false)</td></tr>
<tr class="separator:ac2a9771a031bcb3812059bd4e432b72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a1bf15e9cf031b34dfc0d653727b7a" id="r_ac8a1bf15e9cf031b34dfc0d653727b7a"><td class="memItemLeft" align="right" valign="top"><a id="ac8a1bf15e9cf031b34dfc0d653727b7a" name="ac8a1bf15e9cf031b34dfc0d653727b7a"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~Parameter</b> ()=default</td></tr>
<tr class="memdesc:ac8a1bf15e9cf031b34dfc0d653727b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:ac8a1bf15e9cf031b34dfc0d653727b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2434a8379e8dfa6efc3302b659a018f0" id="r_a2434a8379e8dfa6efc3302b659a018f0"><td class="memTemplParams" colspan="2">template&lt;class T , bool(T::*)(ValueType &amp;, const <a class="el" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a> *) TMethod&gt; </td></tr>
<tr class="memitem:a2434a8379e8dfa6efc3302b659a018f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2434a8379e8dfa6efc3302b659a018f0">addDependentValidationCallback</a> (T *obj, const std::string &amp;name)</td></tr>
<tr class="memdesc:a2434a8379e8dfa6efc3302b659a018f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds dependency callback to a class member function.  <br /></td></tr>
<tr class="separator:a2434a8379e8dfa6efc3302b659a018f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1ec52a744453cfb389342e905567af" id="r_aed1ec52a744453cfb389342e905567af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed1ec52a744453cfb389342e905567af">addDependentValidationCallback</a> (bool(*method)(ValueType &amp;, const <a class="el" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a> *), const std::string &amp;name)</td></tr>
<tr class="memdesc:aed1ec52a744453cfb389342e905567af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds dependency callback via a global function or lambda.  <br /></td></tr>
<tr class="separator:aed1ec52a744453cfb389342e905567af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b33ce993b9abe4e81ce42eb97857eff" id="r_a8b33ce993b9abe4e81ce42eb97857eff"><td class="memItemLeft" align="right" valign="top">virtual const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b33ce993b9abe4e81ce42eb97857eff">getTypeName</a> () const override final</td></tr>
<tr class="memdesc:a8b33ce993b9abe4e81ce42eb97857eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the human-readable name of this parameter's type.  <br /></td></tr>
<tr class="separator:a8b33ce993b9abe4e81ce42eb97857eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13216927d662fcb5de9a36ce2179dd76" id="r_a13216927d662fcb5de9a36ce2179dd76"><td class="memItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13216927d662fcb5de9a36ce2179dd76">getDefault</a> () const</td></tr>
<tr class="memdesc:a13216927d662fcb5de9a36ce2179dd76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the default value.  <br /></td></tr>
<tr class="separator:a13216927d662fcb5de9a36ce2179dd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756acb6cf2ac52b0bfdbc20e5b30afda" id="r_a756acb6cf2ac52b0bfdbc20e5b30afda"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a756acb6cf2ac52b0bfdbc20e5b30afda">getDefaultAsString</a> () const override final</td></tr>
<tr class="memdesc:a756acb6cf2ac52b0bfdbc20e5b30afda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the default value as a string, even if type is a vector.  <br /></td></tr>
<tr class="separator:a756acb6cf2ac52b0bfdbc20e5b30afda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb696e84552242fd4280958d49623994" id="r_acb696e84552242fd4280958d49623994"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb696e84552242fd4280958d49623994">getValueAsString</a> () const override final</td></tr>
<tr class="memdesc:acb696e84552242fd4280958d49623994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns value as a string, even if type is a vector.  <br /></td></tr>
<tr class="separator:acb696e84552242fd4280958d49623994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37be5fa8bb230e79e14533226f0b021e" id="r_a37be5fa8bb230e79e14533226f0b021e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37be5fa8bb230e79e14533226f0b021e">getValueAsStringAt</a> (size_t idx, bool peek=false) const override final</td></tr>
<tr class="memdesc:a37be5fa8bb230e79e14533226f0b021e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Treats this parameter as a vector and gets the value as a string at a specific index. If parameter is not a vector, it is treated as a 1-element vector.  <br /></td></tr>
<tr class="separator:a37be5fa8bb230e79e14533226f0b021e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4ee1dcd6a654426b11908083647238" id="r_aaa4ee1dcd6a654426b11908083647238"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa4ee1dcd6a654426b11908083647238">getItemValueFromString</a> (const std::vector&lt; uint32_t &gt; &amp;indices, bool peek=false) const override final</td></tr>
<tr class="memdesc:aaa4ee1dcd6a654426b11908083647238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override from <a class="el" href="classsparta_1_1ParameterBase.html" title="Non-templated base class for generic parameter access and iteration.">ParameterBase</a>.  <br /></td></tr>
<tr class="separator:aaa4ee1dcd6a654426b11908083647238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc86aeeee15bb10ce2fc5633116b0ef" id="r_a2dc86aeeee15bb10ce2fc5633116b0ef"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2dc86aeeee15bb10ce2fc5633116b0ef">getVectorSizeAt</a> (const std::vector&lt; uint32_t &gt; &amp;indices, bool peek=false) const override final</td></tr>
<tr class="memdesc:a2dc86aeeee15bb10ce2fc5633116b0ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of a nested vector within the parameter located by indices.  <br /></td></tr>
<tr class="separator:a2dc86aeeee15bb10ce2fc5633116b0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cdfa7fa59064b6fd0d3b95e3b2a1013" id="r_a2cdfa7fa59064b6fd0d3b95e3b2a1013"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cdfa7fa59064b6fd0d3b95e3b2a1013">operator const ValueType &amp;</a> () const</td></tr>
<tr class="memdesc:a2cdfa7fa59064b6fd0d3b95e3b2a1013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a the value currently held by this <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a>.  <br /></td></tr>
<tr class="separator:a2cdfa7fa59064b6fd0d3b95e3b2a1013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa69ab01de249a2f932ff61014f7f3bb" id="r_aaa69ab01de249a2f932ff61014f7f3bb"><td class="memItemLeft" align="right" valign="top">const ValueType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa69ab01de249a2f932ff61014f7f3bb">operator()</a> () const</td></tr>
<tr class="memdesc:aaa69ab01de249a2f932ff61014f7f3bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value currently held by this <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a>.  <br /></td></tr>
<tr class="separator:aaa69ab01de249a2f932ff61014f7f3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa038c634ce8cc174ab250c94e7422772" id="r_aa038c634ce8cc174ab250c94e7422772"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa038c634ce8cc174ab250c94e7422772">ignore</a> () const</td></tr>
<tr class="memdesc:aa038c634ce8cc174ab250c94e7422772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks this parameter as ignored.  <br /></td></tr>
<tr class="separator:aa038c634ce8cc174ab250c94e7422772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeece5f57cd4bab7adb5c5ef51545b73" id="r_abeece5f57cd4bab7adb5c5ef51545b73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abeece5f57cd4bab7adb5c5ef51545b73">unread</a> () const</td></tr>
<tr class="memdesc:abeece5f57cd4bab7adb5c5ef51545b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark this parameter as unread and unignored.  <br /></td></tr>
<tr class="separator:abeece5f57cd4bab7adb5c5ef51545b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4002f93df7129d4a1b9007fc626e2462" id="r_a4002f93df7129d4a1b9007fc626e2462"><td class="memItemLeft" align="right" valign="top">const ValueType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4002f93df7129d4a1b9007fc626e2462">getValue</a> () const</td></tr>
<tr class="memdesc:a4002f93df7129d4a1b9007fc626e2462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current value of this <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a>.  <br /></td></tr>
<tr class="separator:a4002f93df7129d4a1b9007fc626e2462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98993f7c2db4f9639a8f18dee402c0a0" id="r_a98993f7c2db4f9639a8f18dee402c0a0"><td class="memItemLeft" align="right" valign="top">const ValueType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98993f7c2db4f9639a8f18dee402c0a0">peekValue</a> () const</td></tr>
<tr class="memdesc:a98993f7c2db4f9639a8f18dee402c0a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current value of this <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> without incrementing the read count. This should be used when validating parameters in a <a class="el" href="classsparta_1_1Resource.html" title="The is the base class for all types of resources used by the SPARTA framework.">Resource</a> Constructor.  <br /></td></tr>
<tr class="separator:a98993f7c2db4f9639a8f18dee402c0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab538e978a97d98c7092d428514ac9c52" id="r_ab538e978a97d98c7092d428514ac9c52"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab538e978a97d98c7092d428514ac9c52">getDoubleValue</a> () const override final</td></tr>
<tr class="memdesc:ab538e978a97d98c7092d428514ac9c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast value to double if possible. Throw if not.  <br /></td></tr>
<tr class="separator:ab538e978a97d98c7092d428514ac9c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87eae331f49a25fa566a427dbd30b03" id="r_ab87eae331f49a25fa566a427dbd30b03"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab87eae331f49a25fa566a427dbd30b03">getNumValues</a> (bool peek=false) const override final</td></tr>
<tr class="memdesc:ab87eae331f49a25fa566a427dbd30b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of values in this <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a>.  <br /></td></tr>
<tr class="separator:ab87eae331f49a25fa566a427dbd30b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94522f8ab3cd8b3eb642066559f1e2ad" id="r_a94522f8ab3cd8b3eb642066559f1e2ad"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94522f8ab3cd8b3eb642066559f1e2ad">isVector</a> () const override final</td></tr>
<tr class="memdesc:a94522f8ab3cd8b3eb642066559f1e2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this parameter a vector?  <br /></td></tr>
<tr class="separator:a94522f8ab3cd8b3eb642066559f1e2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8242e8a62a61455cd2414d34908e4287" id="r_a8242e8a62a61455cd2414d34908e4287"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8242e8a62a61455cd2414d34908e4287">getDimensionality</a> () const override final</td></tr>
<tr class="memdesc:a8242e8a62a61455cd2414d34908e4287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the number of dimensions of this <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a>. A scalar has 0 dimensions. A parameter of type vector&lt;uint32_t&gt; would have a dimensionality of 1. vector&lt;vector&lt;uint32_t&gt;&gt; would have a dimensionality of 2.  <br /></td></tr>
<tr class="separator:a8242e8a62a61455cd2414d34908e4287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9823b9579def8710f640e149bd6797a2" id="r_a9823b9579def8710f640e149bd6797a2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classsparta_1_1ParameterBase.html#af4e84978d016d9540c19af0918dba0fa">ParameterBase::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9823b9579def8710f640e149bd6797a2">begin</a> () const override final</td></tr>
<tr class="memdesc:a9823b9579def8710f640e149bd6797a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get begin iterator.  <br /></td></tr>
<tr class="separator:a9823b9579def8710f640e149bd6797a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5f572605d3105b096bc97c37a08379" id="r_a6f5f572605d3105b096bc97c37a08379"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classsparta_1_1ParameterBase.html#af4e84978d016d9540c19af0918dba0fa">ParameterBase::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f5f572605d3105b096bc97c37a08379">end</a> () const override final</td></tr>
<tr class="memdesc:a6f5f572605d3105b096bc97c37a08379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get begin iterator.  <br /></td></tr>
<tr class="separator:a6f5f572605d3105b096bc97c37a08379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9c08be5bee629ffed4dc7ca0e8fb72" id="r_aec9c08be5bee629ffed4dc7ca0e8fb72"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aec9c08be5bee629ffed4dc7ca0e8fb72"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aec9c08be5bee629ffed4dc7ca0e8fb72">operator==</a> (const <a class="el" href="classsparta_1_1Parameter.html">Parameter</a>&lt; T &gt; &amp;rhp) const</td></tr>
<tr class="memdesc:aec9c08be5bee629ffed4dc7ca0e8fb72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> objects by value.  <br /></td></tr>
<tr class="separator:aec9c08be5bee629ffed4dc7ca0e8fb72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ac7466386653f4a480018187145328" id="r_ad5ac7466386653f4a480018187145328"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad5ac7466386653f4a480018187145328"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad5ac7466386653f4a480018187145328">operator!=</a> (const <a class="el" href="classsparta_1_1Parameter.html">Parameter</a>&lt; T &gt; &amp;rhp) const</td></tr>
<tr class="memdesc:ad5ac7466386653f4a480018187145328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> objects by value.  <br /></td></tr>
<tr class="separator:ad5ac7466386653f4a480018187145328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af49bc4b97ea2eeca7a52a59f88a95ceb" id="r_af49bc4b97ea2eeca7a52a59f88a95ceb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af49bc4b97ea2eeca7a52a59f88a95ceb">operator&gt;</a> (const <a class="el" href="classsparta_1_1Parameter.html">Parameter</a>&lt; <a class="el" href="#ad75bb728b6180aa7caad038ef7ad5d7f">type</a> &gt; &amp;rhp) const</td></tr>
<tr class="memdesc:af49bc4b97ea2eeca7a52a59f88a95ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> objects by value.  <br /></td></tr>
<tr class="separator:af49bc4b97ea2eeca7a52a59f88a95ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cd56b4806dd0c99f4c21c0f2608bd1" id="r_ac0cd56b4806dd0c99f4c21c0f2608bd1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac0cd56b4806dd0c99f4c21c0f2608bd1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac0cd56b4806dd0c99f4c21c0f2608bd1">operator&gt;=</a> (const <a class="el" href="classsparta_1_1Parameter.html">Parameter</a>&lt; T &gt; &amp;rhp) const</td></tr>
<tr class="memdesc:ac0cd56b4806dd0c99f4c21c0f2608bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> objects by value.  <br /></td></tr>
<tr class="separator:ac0cd56b4806dd0c99f4c21c0f2608bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf90330443b0d393ce1c35b4e432bc59" id="r_acf90330443b0d393ce1c35b4e432bc59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf90330443b0d393ce1c35b4e432bc59">operator&lt;</a> (const <a class="el" href="classsparta_1_1Parameter.html">Parameter</a>&lt; <a class="el" href="#ad75bb728b6180aa7caad038ef7ad5d7f">type</a> &gt; &amp;rhp) const</td></tr>
<tr class="memdesc:acf90330443b0d393ce1c35b4e432bc59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> objects by value.  <br /></td></tr>
<tr class="separator:acf90330443b0d393ce1c35b4e432bc59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c74a2913e9738e3854fcb72d8fb7a63" id="r_a8c74a2913e9738e3854fcb72d8fb7a63"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c74a2913e9738e3854fcb72d8fb7a63">operator&lt;=</a> (const <a class="el" href="classsparta_1_1Parameter.html">Parameter</a>&lt; <a class="el" href="#ad75bb728b6180aa7caad038ef7ad5d7f">type</a> &gt; &amp;rhp) const</td></tr>
<tr class="memdesc:a8c74a2913e9738e3854fcb72d8fb7a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> objects by value.  <br /></td></tr>
<tr class="separator:a8c74a2913e9738e3854fcb72d8fb7a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14647c23e7dacee88576fbfa57d40cea" id="r_a14647c23e7dacee88576fbfa57d40cea"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a14647c23e7dacee88576fbfa57d40cea"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_base_of&lt; <a class="el" href="classsparta_1_1ParameterBase.html">ParameterBase</a>, T &gt;::value, bool &gt;<a class="el" href="#ad75bb728b6180aa7caad038ef7ad5d7f">::type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a14647c23e7dacee88576fbfa57d40cea">operator==</a> (const T rhp) const</td></tr>
<tr class="memdesc:a14647c23e7dacee88576fbfa57d40cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments read count.  <br /></td></tr>
<tr class="separator:a14647c23e7dacee88576fbfa57d40cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917f7a286151ba1d0852feffe79ee39a" id="r_a917f7a286151ba1d0852feffe79ee39a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a917f7a286151ba1d0852feffe79ee39a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_base_of&lt; <a class="el" href="classsparta_1_1ParameterBase.html">ParameterBase</a>, T &gt;::value, bool &gt;<a class="el" href="#ad75bb728b6180aa7caad038ef7ad5d7f">::type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a917f7a286151ba1d0852feffe79ee39a">operator!=</a> (const T rhp) const</td></tr>
<tr class="memdesc:a917f7a286151ba1d0852feffe79ee39a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments read count.  <br /></td></tr>
<tr class="separator:a917f7a286151ba1d0852feffe79ee39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c2f60e9c069f511048a38035110bf4" id="r_af9c2f60e9c069f511048a38035110bf4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af9c2f60e9c069f511048a38035110bf4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_base_of&lt; <a class="el" href="classsparta_1_1ParameterBase.html">ParameterBase</a>, T &gt;::value, bool &gt;<a class="el" href="#ad75bb728b6180aa7caad038ef7ad5d7f">::type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af9c2f60e9c069f511048a38035110bf4">operator&gt;</a> (const T rhp) const</td></tr>
<tr class="memdesc:af9c2f60e9c069f511048a38035110bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments read count.  <br /></td></tr>
<tr class="separator:af9c2f60e9c069f511048a38035110bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d464b0fd543f8743959616fe65d0c78" id="r_a9d464b0fd543f8743959616fe65d0c78"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9d464b0fd543f8743959616fe65d0c78"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_base_of&lt; <a class="el" href="classsparta_1_1ParameterBase.html">ParameterBase</a>, T &gt;::value, bool &gt;<a class="el" href="#ad75bb728b6180aa7caad038ef7ad5d7f">::type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9d464b0fd543f8743959616fe65d0c78">operator&gt;=</a> (const T rhp) const</td></tr>
<tr class="memdesc:a9d464b0fd543f8743959616fe65d0c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments read count.  <br /></td></tr>
<tr class="separator:a9d464b0fd543f8743959616fe65d0c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730bc68591e8ac73b2251035ef7f631c" id="r_a730bc68591e8ac73b2251035ef7f631c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a730bc68591e8ac73b2251035ef7f631c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_base_of&lt; <a class="el" href="classsparta_1_1ParameterBase.html">ParameterBase</a>, T &gt;::value, bool &gt;<a class="el" href="#ad75bb728b6180aa7caad038ef7ad5d7f">::type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a730bc68591e8ac73b2251035ef7f631c">operator&lt;</a> (const T rhp) const</td></tr>
<tr class="memdesc:a730bc68591e8ac73b2251035ef7f631c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments read count.  <br /></td></tr>
<tr class="separator:a730bc68591e8ac73b2251035ef7f631c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3565f68b825e7fafea55f9c47ed1db77" id="r_a3565f68b825e7fafea55f9c47ed1db77"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3565f68b825e7fafea55f9c47ed1db77"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_base_of&lt; <a class="el" href="classsparta_1_1ParameterBase.html">ParameterBase</a>, T &gt;::value, bool &gt;<a class="el" href="#ad75bb728b6180aa7caad038ef7ad5d7f">::type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3565f68b825e7fafea55f9c47ed1db77">operator&lt;=</a> (const T rhp) const</td></tr>
<tr class="memdesc:a3565f68b825e7fafea55f9c47ed1db77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments read count.  <br /></td></tr>
<tr class="separator:a3565f68b825e7fafea55f9c47ed1db77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a58d898f4d773903dc6ecb6260a797" id="r_a05a58d898f4d773903dc6ecb6260a797"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05a58d898f4d773903dc6ecb6260a797">operator=</a> (const <a class="el" href="classsparta_1_1Parameter.html">Parameter</a> &amp;p)=delete</td></tr>
<tr class="memdesc:a05a58d898f4d773903dc6ecb6260a797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment - deleted explicitly.  <br /></td></tr>
<tr class="separator:a05a58d898f4d773903dc6ecb6260a797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f23570d658ad7780ce5a88472ab7efb" id="r_a1f23570d658ad7780ce5a88472ab7efb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f23570d658ad7780ce5a88472ab7efb">operator=</a> (const ValueType &amp;v)</td></tr>
<tr class="memdesc:a1f23570d658ad7780ce5a88472ab7efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the specified value to this parameter.  <br /></td></tr>
<tr class="separator:a1f23570d658ad7780ce5a88472ab7efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f846e287e35a8bd50b0678f7070e95" id="r_a88f846e287e35a8bd50b0678f7070e95"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88f846e287e35a8bd50b0678f7070e95">isDefaultOverridden</a> () const override final</td></tr>
<tr class="memdesc:a88f846e287e35a8bd50b0678f7070e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has the default value (NOT the current value) for parameter been overridden in any way (including partially changed).  <br /></td></tr>
<tr class="separator:a88f846e287e35a8bd50b0678f7070e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf07b72e853b048e7be152b94d6d64f" id="r_adaf07b72e853b048e7be152b94d6d64f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adaf07b72e853b048e7be152b94d6d64f">overrideDefaultFromString</a> (const std::string &amp;str) override final</td></tr>
<tr class="memdesc:adaf07b72e853b048e7be152b94d6d64f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default value of this non-vector parameter for architecture baseline configuration purposes.  <br /></td></tr>
<tr class="separator:adaf07b72e853b048e7be152b94d6d64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf575259cd01e2f21e2839409ecfb11c" id="r_abf575259cd01e2f21e2839409ecfb11c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf575259cd01e2f21e2839409ecfb11c">overrideDefaultFromStringVector</a> (const std::vector&lt; std::string &gt; &amp;vec) override final</td></tr>
<tr class="memdesc:abf575259cd01e2f21e2839409ecfb11c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default value of this vector parameter for architecture baseline configuration purposes.  <br /></td></tr>
<tr class="separator:abf575259cd01e2f21e2839409ecfb11c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d414f91f18e584169d18cc55a9aa209" id="r_a2d414f91f18e584169d18cc55a9aa209"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d414f91f18e584169d18cc55a9aa209">overrideDefaultItemValueFromString</a> (const std::vector&lt; uint32_t &gt; &amp;indices, const std::string &amp;str) override final</td></tr>
<tr class="memdesc:a2d414f91f18e584169d18cc55a9aa209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partially override the default default value in some element at an n-dimensional array specified.  <br /></td></tr>
<tr class="separator:a2d414f91f18e584169d18cc55a9aa209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109e4b60b180e8baa424a096b4933f23" id="r_a109e4b60b180e8baa424a096b4933f23"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a109e4b60b180e8baa424a096b4933f23">overrideDefaultResizeVectorsFromString</a> (const std::vector&lt; uint32_t &gt; &amp;indices) override final</td></tr>
<tr class="memdesc:a109e4b60b180e8baa424a096b4933f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override the default value by clearing the possibly-nested vector (if this parameter is a vector). The nested vector contens can then be set by overrideDefaultItemValueFromString.  <br /></td></tr>
<tr class="separator:a109e4b60b180e8baa424a096b4933f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67dc16f6b1fd26003673070dc5c2950" id="r_ac67dc16f6b1fd26003673070dc5c2950"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac67dc16f6b1fd26003673070dc5c2950">overrideDefaultClearVectorValue</a> () override final</td></tr>
<tr class="memdesc:ac67dc16f6b1fd26003673070dc5c2950"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the parameter is a vector type, clears the default value so that it becomes an empty vector (regardless of dimensionality)  <br /></td></tr>
<tr class="separator:ac67dc16f6b1fd26003673070dc5c2950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b8a21f76fdfa4e5a2d2d97c2aab8eb" id="r_a21b8a21f76fdfa4e5a2d2d97c2aab8eb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21b8a21f76fdfa4e5a2d2d97c2aab8eb">restoreValueFromDefaultImpl_</a> () override final</td></tr>
<tr class="memdesc:a21b8a21f76fdfa4e5a2d2d97c2aab8eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements restoreValueFromDefault.  <br /></td></tr>
<tr class="separator:a21b8a21f76fdfa4e5a2d2d97c2aab8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65810457dc3f37939bc3c51fcf6af90" id="r_aa65810457dc3f37939bc3c51fcf6af90"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa65810457dc3f37939bc3c51fcf6af90">equals</a> (const <a class="el" href="classsparta_1_1ParameterBase.html">ParameterBase</a> &amp;other) override final</td></tr>
<tr class="memdesc:aa65810457dc3f37939bc3c51fcf6af90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the value of this equals <code>other</code>.  <br /></td></tr>
<tr class="separator:aa65810457dc3f37939bc3c51fcf6af90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614aef390723e61cd91e11d66f9b88e8" id="r_a614aef390723e61cd91e11d66f9b88e8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a614aef390723e61cd91e11d66f9b88e8">resizeVectorsFromString</a> (const std::vector&lt; uint32_t &gt; &amp;indices) override final</td></tr>
<tr class="memdesc:a614aef390723e61cd91e11d66f9b88e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to resize a vector nested within this parameter to contain the vector indicated by indices.  <br /></td></tr>
<tr class="separator:a614aef390723e61cd91e11d66f9b88e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96220dce75014ed76dc0a2339731ab2e" id="r_a96220dce75014ed76dc0a2339731ab2e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96220dce75014ed76dc0a2339731ab2e">clearVectorValue</a> () override final</td></tr>
<tr class="memdesc:a96220dce75014ed76dc0a2339731ab2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the parameter is a vector type, clears the value so that it becomes an empty vector (regardless of dimensionality)  <br /></td></tr>
<tr class="separator:a96220dce75014ed76dc0a2339731ab2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27173c5407e013cb0a8631d34e5a66f" id="r_ac27173c5407e013cb0a8631d34e5a66f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Printing_8hpp.html#afabfc368950e958421c5eba711aadee5">sparta::utils::DisplayBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac27173c5407e013cb0a8631d34e5a66f">setNumericDisplayBase</a> (<a class="el" href="Printing_8hpp.html#afabfc368950e958421c5eba711aadee5">sparta::utils::DisplayBase</a> base)</td></tr>
<tr class="memdesc:ac27173c5407e013cb0a8631d34e5a66f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the numeric base for displaying the value of this parameter.  <br /></td></tr>
<tr class="separator:ac27173c5407e013cb0a8631d34e5a66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037e5e41f14b3de6daf736357d78dd6c" id="r_a037e5e41f14b3de6daf736357d78dd6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Printing_8hpp.html#afabfc368950e958421c5eba711aadee5">sparta::utils::DisplayBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a037e5e41f14b3de6daf736357d78dd6c">getNumericDisplayBase</a> () const</td></tr>
<tr class="memdesc:a037e5e41f14b3de6daf736357d78dd6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the numeric base for displaying the value of this parameter.  <br /></td></tr>
<tr class="separator:a037e5e41f14b3de6daf736357d78dd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59973ad0c3690f62beadc6554d0991c" id="r_ae59973ad0c3690f62beadc6554d0991c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae59973ad0c3690f62beadc6554d0991c">validateIndependently</a> (std::string &amp;err_names) const override</td></tr>
<tr class="memdesc:ae59973ad0c3690f62beadc6554d0991c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs validation independently of all other Parameters.  <br /></td></tr>
<tr class="separator:ae59973ad0c3690f62beadc6554d0991c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42bf97905838535b6cd8528caad5a923" id="r_a42bf97905838535b6cd8528caad5a923"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42bf97905838535b6cd8528caad5a923">validateDependencies</a> (const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *node, std::string &amp;err_names) const override</td></tr>
<tr class="memdesc:a42bf97905838535b6cd8528caad5a923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes all validation callbacks for a particular node in the device tree and returns true if none of them fail.  <br /></td></tr>
<tr class="separator:a42bf97905838535b6cd8528caad5a923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa873586c6dd7c8fee0afb157135a46e4" id="r_aa873586c6dd7c8fee0afb157135a46e4"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:aa873586c6dd7c8fee0afb157135a46e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Parameter.html">Parameter</a>&lt; ValueType &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa873586c6dd7c8fee0afb157135a46e4">operator&lt;&lt;</a> (U e)</td></tr>
<tr class="memdesc:aa873586c6dd7c8fee0afb157135a46e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for constructing vectors.  <br /></td></tr>
<tr class="separator:aa873586c6dd7c8fee0afb157135a46e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2744386e81aea13c257e4c2ae7b279d0" id="r_a2744386e81aea13c257e4c2ae7b279d0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2744386e81aea13c257e4c2ae7b279d0">isVisibilityAllowed</a> () const override</td></tr>
<tr class="memdesc:a2744386e81aea13c257e4c2ae7b279d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if this parameter is safe to be displayed via prints, dumps. A parameter should not be displayed if it is HIDDEN and the subtree containing this parameter is already locked.  <br /></td></tr>
<tr class="separator:a2744386e81aea13c257e4c2ae7b279d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsparta_1_1ParameterBase"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classsparta_1_1ParameterBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsparta_1_1ParameterBase.html">sparta::ParameterBase</a></td></tr>
<tr class="memitem:a9fe793772a1fadb6966cde1e10d578b2 inherit pub_methods_classsparta_1_1ParameterBase" id="r_a9fe793772a1fadb6966cde1e10d578b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html#a9fe793772a1fadb6966cde1e10d578b2">ParameterBase</a> (const std::string &amp;name, const std::string &amp;desc)</td></tr>
<tr class="memdesc:a9fe793772a1fadb6966cde1e10d578b2 inherit pub_methods_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:a9fe793772a1fadb6966cde1e10d578b2 inherit pub_methods_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fcf20674bbec9daea8bfafa9ebfba99 inherit pub_methods_classsparta_1_1ParameterBase" id="r_a7fcf20674bbec9daea8bfafa9ebfba99"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html#a7fcf20674bbec9daea8bfafa9ebfba99">~ParameterBase</a> ()</td></tr>
<tr class="memdesc:a7fcf20674bbec9daea8bfafa9ebfba99 inherit pub_methods_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a7fcf20674bbec9daea8bfafa9ebfba99 inherit pub_methods_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9571624685f3aa0c2a0a124038dc1040 inherit pub_methods_classsparta_1_1ParameterBase" id="r_a9571624685f3aa0c2a0a124038dc1040"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html#a9571624685f3aa0c2a0a124038dc1040">setIsVolatile</a> ()</td></tr>
<tr class="memdesc:a9571624685f3aa0c2a0a124038dc1040 inherit pub_methods_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set volatile flag (allows write after read)  <br /></td></tr>
<tr class="separator:a9571624685f3aa0c2a0a124038dc1040 inherit pub_methods_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d42e4b8c58c2970f4f1e28e76448b12 inherit pub_methods_classsparta_1_1ParameterBase" id="r_a2d42e4b8c58c2970f4f1e28e76448b12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html#a2d42e4b8c58c2970f4f1e28e76448b12">isVolatile</a> () const</td></tr>
<tr class="memdesc:a2d42e4b8c58c2970f4f1e28e76448b12 inherit pub_methods_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this a volatile parmaeter?  <br /></td></tr>
<tr class="separator:a2d42e4b8c58c2970f4f1e28e76448b12 inherit pub_methods_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae297438f7452736fc86dc6df8a477925 inherit pub_methods_classsparta_1_1ParameterBase" id="r_ae297438f7452736fc86dc6df8a477925"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html#ae297438f7452736fc86dc6df8a477925">isDefault</a> () const</td></tr>
<tr class="memdesc:ae297438f7452736fc86dc6df8a477925 inherit pub_methods_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this parameter's current value the default value.  <br /></td></tr>
<tr class="separator:ae297438f7452736fc86dc6df8a477925 inherit pub_methods_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4614279cea617d802d0d39a1f507cb inherit pub_methods_classsparta_1_1ParameterBase" id="r_a3b4614279cea617d802d0d39a1f507cb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html#a3b4614279cea617d802d0d39a1f507cb">peekItemValueFromString</a> (const std::vector&lt; uint32_t &gt; &amp;indices) const</td></tr>
<tr class="memdesc:a3b4614279cea617d802d0d39a1f507cb inherit pub_methods_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for getItemValueFromString with peek=true.  <br /></td></tr>
<tr class="separator:a3b4614279cea617d802d0d39a1f507cb inherit pub_methods_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a875067bbb85de2f450c3735a46299a inherit pub_methods_classsparta_1_1ParameterBase" id="r_a3a875067bbb85de2f450c3735a46299a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3a875067bbb85de2f450c3735a46299a inherit pub_methods_classsparta_1_1ParameterBase"><td class="memTemplItemLeft" align="right" valign="top">const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html#a3a875067bbb85de2f450c3735a46299a">getValueAs</a> () const</td></tr>
<tr class="memdesc:a3a875067bbb85de2f450c3735a46299a inherit pub_methods_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value of this <a class="el" href="classsparta_1_1ParameterBase.html" title="Non-templated base class for generic parameter access and iteration.">ParameterBase</a> as a templated type T if this parameter actually contains a value of type T.  <br /></td></tr>
<tr class="separator:a3a875067bbb85de2f450c3735a46299a inherit pub_methods_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42eaa99e6bb72ad12302733b3d65a1d inherit pub_methods_classsparta_1_1ParameterBase" id="r_ac42eaa99e6bb72ad12302733b3d65a1d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html#ac42eaa99e6bb72ad12302733b3d65a1d">peekVectorSizeAt</a> (const std::vector&lt; uint32_t &gt; &amp;indices) const</td></tr>
<tr class="memdesc:ac42eaa99e6bb72ad12302733b3d65a1d inherit pub_methods_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper of getVectorSizeAt with peek=true.  <br /></td></tr>
<tr class="separator:ac42eaa99e6bb72ad12302733b3d65a1d inherit pub_methods_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ec4af1889545c1a9f79e51e979ad4c inherit pub_methods_classsparta_1_1ParameterBase" id="r_a57ec4af1889545c1a9f79e51e979ad4c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html#a57ec4af1889545c1a9f79e51e979ad4c">peekNumValues</a> () const</td></tr>
<tr class="memdesc:a57ec4af1889545c1a9f79e51e979ad4c inherit pub_methods_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for getNumValues with peek=true.  <br /></td></tr>
<tr class="separator:a57ec4af1889545c1a9f79e51e979ad4c inherit pub_methods_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c0a157203a29b9389bd82c750f6d16 inherit pub_methods_classsparta_1_1ParameterBase" id="r_a03c0a157203a29b9389bd82c750f6d16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html#a03c0a157203a29b9389bd82c750f6d16">restoreValueFromDefault</a> ()</td></tr>
<tr class="memdesc:a03c0a157203a29b9389bd82c750f6d16 inherit pub_methods_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to restore the devalue value of this parameter.  <br /></td></tr>
<tr class="separator:a03c0a157203a29b9389bd82c750f6d16 inherit pub_methods_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441d92cb73f3aa2df048a41da14b072f inherit pub_methods_classsparta_1_1ParameterBase" id="r_a441d92cb73f3aa2df048a41da14b072f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html#a441d92cb73f3aa2df048a41da14b072f">setValueFromString</a> (const std::string &amp;str, bool poke=false)</td></tr>
<tr class="memdesc:a441d92cb73f3aa2df048a41da14b072f inherit pub_methods_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to assign a value to this non-vector <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> from a string.  <br /></td></tr>
<tr class="separator:a441d92cb73f3aa2df048a41da14b072f inherit pub_methods_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7812509e7fc7d19b401f61dc6115562 inherit pub_methods_classsparta_1_1ParameterBase" id="r_ab7812509e7fc7d19b401f61dc6115562"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html#ab7812509e7fc7d19b401f61dc6115562">setValueFromStringVector</a> (const std::vector&lt; std::string &gt; &amp;str, bool poke=false)</td></tr>
<tr class="memdesc:ab7812509e7fc7d19b401f61dc6115562 inherit pub_methods_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to assign a value to this vector <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> from a string.  <br /></td></tr>
<tr class="separator:ab7812509e7fc7d19b401f61dc6115562 inherit pub_methods_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66bcea40c1fbf54fefea0bcb26e0b0cd inherit pub_methods_classsparta_1_1ParameterBase" id="r_a66bcea40c1fbf54fefea0bcb26e0b0cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html#a66bcea40c1fbf54fefea0bcb26e0b0cd">setItemValueFromString</a> (const std::vector&lt; uint32_t &gt; &amp;indices, const std::string &amp;str)</td></tr>
<tr class="memdesc:a66bcea40c1fbf54fefea0bcb26e0b0cd inherit pub_methods_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to assign a value to this nested vector <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> from a string at a position within the vector indicated by indices.  <br /></td></tr>
<tr class="separator:a66bcea40c1fbf54fefea0bcb26e0b0cd inherit pub_methods_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040a45b55cd7cee38a83fe8fa6066be9 inherit pub_methods_classsparta_1_1ParameterBase" id="r_a040a45b55cd7cee38a83fe8fa6066be9"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html#a040a45b55cd7cee38a83fe8fa6066be9">stringize</a> (bool pretty=false) const override</td></tr>
<tr class="memdesc:a040a45b55cd7cee38a83fe8fa6066be9 inherit pub_methods_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render description of this parameter as a string.  <br /></td></tr>
<tr class="separator:a040a45b55cd7cee38a83fe8fa6066be9 inherit pub_methods_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6153ee8fe686a5ac716322e9219bc9b3 inherit pub_methods_classsparta_1_1ParameterBase" id="r_a6153ee8fe686a5ac716322e9219bc9b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html#a6153ee8fe686a5ac716322e9219bc9b3">associateParametersForModification</a> (std::vector&lt; const <a class="el" href="classsparta_1_1ParameterBase.html">ParameterBase</a> * &gt; params, const sparta::SpartaHandler &amp;modifier_callback)</td></tr>
<tr class="memdesc:a6153ee8fe686a5ac716322e9219bc9b3 inherit pub_methods_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate a parameter with this parameter for future modification.  <br /></td></tr>
<tr class="separator:a6153ee8fe686a5ac716322e9219bc9b3 inherit pub_methods_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518cfe952bb4a6f2c96ae1b4665a5853 inherit pub_methods_classsparta_1_1ParameterBase" id="r_a518cfe952bb4a6f2c96ae1b4665a5853"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html#a518cfe952bb4a6f2c96ae1b4665a5853">getWriteCount</a> () const</td></tr>
<tr class="memdesc:a518cfe952bb4a6f2c96ae1b4665a5853 inherit pub_methods_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of times this <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> has been written after initialization.  <br /></td></tr>
<tr class="separator:a518cfe952bb4a6f2c96ae1b4665a5853 inherit pub_methods_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c7817fce432b087dc34b3aeecec766 inherit pub_methods_classsparta_1_1ParameterBase" id="r_ad3c7817fce432b087dc34b3aeecec766"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html#ad3c7817fce432b087dc34b3aeecec766">getReadCount</a> () const</td></tr>
<tr class="memdesc:ad3c7817fce432b087dc34b3aeecec766 inherit pub_methods_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of times this <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> has been read after initialization or after the last write (or explicit <a class="el" href="classsparta_1_1ParameterBase.html#a03addcff7db396f643149458febf51e4" title="Resets the number of reads that wil be reported by getReadCount.">resetReadCount_()</a> call)  <br /></td></tr>
<tr class="separator:ad3c7817fce432b087dc34b3aeecec766 inherit pub_methods_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744fddc877597b98cafdef4fc39d060b inherit pub_methods_classsparta_1_1ParameterBase" id="r_a744fddc877597b98cafdef4fc39d060b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html#a744fddc877597b98cafdef4fc39d060b">isReadOrIgnored</a> () const</td></tr>
<tr class="memdesc:a744fddc877597b98cafdef4fc39d060b inherit pub_methods_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this parameter ignored or read at least once (barring any reset of the read count or ignore flag)  <br /></td></tr>
<tr class="separator:a744fddc877597b98cafdef4fc39d060b inherit pub_methods_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a3462f02478368c2241d20eea3bcd3 inherit pub_methods_classsparta_1_1ParameterBase" id="r_aa9a3462f02478368c2241d20eea3bcd3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html#aa9a3462f02478368c2241d20eea3bcd3">isIgnored</a> () const</td></tr>
<tr class="memdesc:aa9a3462f02478368c2241d20eea3bcd3 inherit pub_methods_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has this parameter been ignored (without having read count reset after)  <br /></td></tr>
<tr class="separator:aa9a3462f02478368c2241d20eea3bcd3 inherit pub_methods_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff9a1c345cc1c890eb5a9cdd738814f inherit pub_methods_classsparta_1_1ParameterBase" id="r_a1ff9a1c345cc1c890eb5a9cdd738814f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html#a1ff9a1c345cc1c890eb5a9cdd738814f">supportsCompression</a> () const</td></tr>
<tr class="memdesc:a1ff9a1c345cc1c890eb5a9cdd738814f inherit pub_methods_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar parameters <em>may</em> compress well, but we cannot really make a strong enough determination without knowing more about the parameter. Let's disable compression for these by default.  <br /></td></tr>
<tr class="separator:a1ff9a1c345cc1c890eb5a9cdd738814f inherit pub_methods_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0bd166cd24d9225d348a4d153383c4 inherit pub_methods_classsparta_1_1ParameterBase" id="r_afc0bd166cd24d9225d348a4d153383c4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html#afc0bd166cd24d9225d348a4d153383c4">setStringQuote</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:afc0bd166cd24d9225d348a4d153383c4 inherit pub_methods_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the quote sequence for printing strings.  <br /></td></tr>
<tr class="separator:afc0bd166cd24d9225d348a4d153383c4 inherit pub_methods_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsparta_1_1TreeNode"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classsparta_1_1TreeNode')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a></td></tr>
<tr class="memitem:aec70f36a682dadc1d571fcd723f12cd6 inherit pub_methods_classsparta_1_1TreeNode" id="r_aec70f36a682dadc1d571fcd723f12cd6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsparta_1_1Clock.html">Clock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#aec70f36a682dadc1d571fcd723f12cd6">getClock</a> () override</td></tr>
<tr class="memdesc:aec70f36a682dadc1d571fcd723f12cd6 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walks up parents (starting with self) until a parent with an associated local clock is found, then returns that clock.  <br /></td></tr>
<tr class="separator:aec70f36a682dadc1d571fcd723f12cd6 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ceac50d187c3e2fefab08f590f6f3c inherit pub_methods_classsparta_1_1TreeNode" id="r_ad2ceac50d187c3e2fefab08f590f6f3c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsparta_1_1Clock.html">Clock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#ad2ceac50d187c3e2fefab08f590f6f3c">getClock</a> () const</td></tr>
<tr class="separator:ad2ceac50d187c3e2fefab08f590f6f3c inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883ef289de0f961e1d69a988b50338d8 inherit pub_methods_classsparta_1_1TreeNode" id="r_a883ef289de0f961e1d69a988b50338d8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsparta_1_1Clock.html">Clock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a883ef289de0f961e1d69a988b50338d8">getLocalClock</a> ()</td></tr>
<tr class="memdesc:a883ef289de0f961e1d69a988b50338d8 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the clock associated directly with this Node. This is useful for configuration and simulator debug, but not at run-time.  <br /></td></tr>
<tr class="separator:a883ef289de0f961e1d69a988b50338d8 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1490e10061ce9dd5d53495f65b29f7d inherit pub_methods_classsparta_1_1TreeNode" id="r_ae1490e10061ce9dd5d53495f65b29f7d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsparta_1_1Clock.html">Clock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#ae1490e10061ce9dd5d53495f65b29f7d">getLocalClock</a> () const</td></tr>
<tr class="separator:ae1490e10061ce9dd5d53495f65b29f7d inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3077d3b25e965fd6924258b5eb77f61 inherit pub_methods_classsparta_1_1TreeNode" id="r_aa3077d3b25e965fd6924258b5eb77f61"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#aa3077d3b25e965fd6924258b5eb77f61">setClock</a> (const <a class="el" href="classsparta_1_1Clock.html">Clock</a> *clk)</td></tr>
<tr class="memdesc:aa3077d3b25e965fd6924258b5eb77f61 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a clock to this node. This clock will then be accessed by any descendant which has no assigned clock or an ancestor with an assigned clock between that descendant and this node. getClock returns the <a class="el" href="classsparta_1_1Clock.html" title="A representation of simulated time.">Clock</a> associated with the nearest ancestor.  <br /></td></tr>
<tr class="separator:aa3077d3b25e965fd6924258b5eb77f61 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6b76838262227a43b793429376f9a2 inherit pub_methods_classsparta_1_1TreeNode" id="r_a7a6b76838262227a43b793429376f9a2"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classsparta_1_1Scheduler.html">Scheduler</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getScheduler</b> (const bool must_exist=false)</td></tr>
<tr class="memdesc:a7a6b76838262227a43b793429376f9a2 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the scheduler associated with this tree node's root. <br /></td></tr>
<tr class="separator:a7a6b76838262227a43b793429376f9a2 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d6995924a0f193b70c9d9a332c1887 inherit pub_methods_classsparta_1_1TreeNode" id="r_ad1d6995924a0f193b70c9d9a332c1887"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classsparta_1_1Scheduler.html">Scheduler</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getScheduler</b> (const bool must_exist=false) const</td></tr>
<tr class="separator:ad1d6995924a0f193b70c9d9a332c1887 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb544ebd5bc75612acc891758d49ecc inherit pub_methods_classsparta_1_1TreeNode" id="r_a9cb544ebd5bc75612acc891758d49ecc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1TreeNode.html#a91f21b18f9f50f70111730361eff6ddb">WeakPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a9cb544ebd5bc75612acc891758d49ecc">getWeakPtr</a> ()</td></tr>
<tr class="memdesc:a9cb544ebd5bc75612acc891758d49ecc inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a weak pointer to this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>. This weak pointer is guaranteed to expire when this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> is destructed unless locked.  <br /></td></tr>
<tr class="separator:a9cb544ebd5bc75612acc891758d49ecc inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af492b13a1f98347d9e9c519bd35bb1f0 inherit pub_methods_classsparta_1_1TreeNode" id="r_af492b13a1f98347d9e9c519bd35bb1f0"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classsparta_1_1TreeNode.html#afa43836f90c9203c7b2c09647a0707d3">ConstWeakPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getWeakPtr</b> () const</td></tr>
<tr class="memdesc:af492b13a1f98347d9e9c519bd35bb1f0 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const variant of getWeakPtr. <br /></td></tr>
<tr class="separator:af492b13a1f98347d9e9c519bd35bb1f0 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413b70f45db0a7182347c109322b3b99 inherit pub_methods_classsparta_1_1TreeNode" id="r_a413b70f45db0a7182347c109322b3b99"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a413b70f45db0a7182347c109322b3b99">addLink</a> (<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *node, const std::string &amp;label)</td></tr>
<tr class="memdesc:a413b70f45db0a7182347c109322b3b99 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link this tree node with another tree node.  <br /></td></tr>
<tr class="separator:a413b70f45db0a7182347c109322b3b99 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955dd570e1c3f926d2371956535745e0 inherit pub_methods_classsparta_1_1TreeNode" id="r_a955dd570e1c3f926d2371956535745e0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a955dd570e1c3f926d2371956535745e0">activateLink</a> (const std::string &amp;label)</td></tr>
<tr class="memdesc:a955dd570e1c3f926d2371956535745e0 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate one of the links added with addLink.  <br /></td></tr>
<tr class="separator:a955dd570e1c3f926d2371956535745e0 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6366a494319eca35f13323d0934cbf07 inherit pub_methods_classsparta_1_1TreeNode" id="r_a6366a494319eca35f13323d0934cbf07"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>TreeNode</b> ()=delete</td></tr>
<tr class="memdesc:a6366a494319eca35f13323d0934cbf07 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not default-constructable. <br /></td></tr>
<tr class="separator:a6366a494319eca35f13323d0934cbf07 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559893cd7399ca8b98a6737ba4e7209a inherit pub_methods_classsparta_1_1TreeNode" id="r_a559893cd7399ca8b98a6737ba4e7209a"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>TreeNode</b> (const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &amp;)=delete</td></tr>
<tr class="memdesc:a559893cd7399ca8b98a6737ba4e7209a inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not copy-constructable. <br /></td></tr>
<tr class="separator:a559893cd7399ca8b98a6737ba4e7209a inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fdce693f0f3255e5fdb45ac6615cbe6 inherit pub_methods_classsparta_1_1TreeNode" id="r_a6fdce693f0f3255e5fdb45ac6615cbe6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a6fdce693f0f3255e5fdb45ac6615cbe6">TreeNode</a> (<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &amp;&amp;rhp)</td></tr>
<tr class="memdesc:a6fdce693f0f3255e5fdb45ac6615cbe6 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="separator:a6fdce693f0f3255e5fdb45ac6615cbe6 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead61f7ca2ab7f2510a4920682d558e5 inherit pub_methods_classsparta_1_1TreeNode" id="r_aead61f7ca2ab7f2510a4920682d558e5"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &amp;)=delete</td></tr>
<tr class="memdesc:aead61f7ca2ab7f2510a4920682d558e5 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not assign-constructable. <br /></td></tr>
<tr class="separator:aead61f7ca2ab7f2510a4920682d558e5 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3026dd9b5648f0614dcc27b97b4b61c7 inherit pub_methods_classsparta_1_1TreeNode" id="r_a3026dd9b5648f0614dcc27b97b4b61c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a3026dd9b5648f0614dcc27b97b4b61c7">TreeNode</a> (<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *parent, const std::string &amp;name, const std::string &amp;group, <a class="el" href="classsparta_1_1TreeNode.html#a7fa01f145455d583b8f16e0f923b7c7c">group_idx_type</a> group_idx, const std::string &amp;desc, bool is_indexable)</td></tr>
<tr class="memdesc:a3026dd9b5648f0614dcc27b97b4b61c7 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> full constructor. Initializes node and adds it as a child of an existing tree node (if parent is not null).  <br /></td></tr>
<tr class="separator:a3026dd9b5648f0614dcc27b97b4b61c7 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c65ab7c0b7170ef60b279f05fc0cab inherit pub_methods_classsparta_1_1TreeNode" id="r_a80c65ab7c0b7170ef60b279f05fc0cab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a80c65ab7c0b7170ef60b279f05fc0cab">TreeNode</a> (<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *parent, const std::string &amp;name, const std::string &amp;group, <a class="el" href="classsparta_1_1TreeNode.html#a7fa01f145455d583b8f16e0f923b7c7c">group_idx_type</a> group_idx, const std::string &amp;desc)</td></tr>
<tr class="memdesc:a80c65ab7c0b7170ef60b279f05fc0cab inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> constructor with no is_indexable parameter [defaults to true].  <br /></td></tr>
<tr class="separator:a80c65ab7c0b7170ef60b279f05fc0cab inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eea7ebab08a4ed9aa079ece5b759211 inherit pub_methods_classsparta_1_1TreeNode" id="r_a9eea7ebab08a4ed9aa079ece5b759211"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a9eea7ebab08a4ed9aa079ece5b759211">TreeNode</a> (const std::string &amp;name, const std::string &amp;group, <a class="el" href="classsparta_1_1TreeNode.html#a7fa01f145455d583b8f16e0f923b7c7c">group_idx_type</a> group_idx, const std::string &amp;desc)</td></tr>
<tr class="memdesc:a9eea7ebab08a4ed9aa079ece5b759211 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> constructor with no parent Node.  <br /></td></tr>
<tr class="separator:a9eea7ebab08a4ed9aa079ece5b759211 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34262fa0ae9db707bda24e1c5728482e inherit pub_methods_classsparta_1_1TreeNode" id="r_a34262fa0ae9db707bda24e1c5728482e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a34262fa0ae9db707bda24e1c5728482e">TreeNode</a> (<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *parent, const std::string &amp;name, const std::string &amp;desc)</td></tr>
<tr class="memdesc:a34262fa0ae9db707bda24e1c5728482e inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> constructor with no group information.  <br /></td></tr>
<tr class="separator:a34262fa0ae9db707bda24e1c5728482e inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d7ec9960d8d6196c39e4d8e3721bd3 inherit pub_methods_classsparta_1_1TreeNode" id="r_a98d7ec9960d8d6196c39e4d8e3721bd3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a98d7ec9960d8d6196c39e4d8e3721bd3">TreeNode</a> (<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *parent, const std::string &amp;group, <a class="el" href="classsparta_1_1TreeNode.html#a7fa01f145455d583b8f16e0f923b7c7c">group_idx_type</a> group_idx, const std::string &amp;desc)</td></tr>
<tr class="memdesc:a98d7ec9960d8d6196c39e4d8e3721bd3 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> constructor for anonymous node with group information.  <br /></td></tr>
<tr class="separator:a98d7ec9960d8d6196c39e4d8e3721bd3 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae136cf4e22a254e02ab08d632145ed31 inherit pub_methods_classsparta_1_1TreeNode" id="r_ae136cf4e22a254e02ab08d632145ed31"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#ae136cf4e22a254e02ab08d632145ed31">TreeNode</a> (const std::string &amp;name, const std::string &amp;desc)</td></tr>
<tr class="memdesc:ae136cf4e22a254e02ab08d632145ed31 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> constructor with no parent node or group information.  <br /></td></tr>
<tr class="separator:ae136cf4e22a254e02ab08d632145ed31 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e2a24a1cee8725161eee61a9a8af70 inherit pub_methods_classsparta_1_1TreeNode" id="r_ae6e2a24a1cee8725161eee61a9a8af70"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#ae6e2a24a1cee8725161eee61a9a8af70">~TreeNode</a> ()</td></tr>
<tr class="memdesc:ae6e2a24a1cee8725161eee61a9a8af70 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <br /></td></tr>
<tr class="separator:ae6e2a24a1cee8725161eee61a9a8af70 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2b4d2e10e2e64ecdf35f4d040f1117 inherit pub_methods_classsparta_1_1TreeNode" id="r_a4f2b4d2e10e2e64ecdf35f4d040f1117"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a4f2b4d2e10e2e64ecdf35f4d040f1117">addAlias</a> (const std::string &amp;alias)</td></tr>
<tr class="memdesc:a4f2b4d2e10e2e64ecdf35f4d040f1117 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a single alias for this node.  <br /></td></tr>
<tr class="separator:a4f2b4d2e10e2e64ecdf35f4d040f1117 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee6f68fd41da3956ef2201ca9de14ad inherit pub_methods_classsparta_1_1TreeNode" id="r_adee6f68fd41da3956ef2201ca9de14ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#adee6f68fd41da3956ef2201ca9de14ad">addAliases</a> (const <a class="el" href="classsparta_1_1TreeNode.html#a991e1785f763d44925f4a53d89a44675">AliasVector</a> &amp;v)</td></tr>
<tr class="memdesc:adee6f68fd41da3956ef2201ca9de14ad inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds each element of a vector of aliases to this node..  <br /></td></tr>
<tr class="separator:adee6f68fd41da3956ef2201ca9de14ad inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00f8c73f0a3a25df7bf68a5bc19c524 inherit pub_methods_classsparta_1_1TreeNode" id="r_ae00f8c73f0a3a25df7bf68a5bc19c524"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#ae00f8c73f0a3a25df7bf68a5bc19c524">addTag</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:ae00f8c73f0a3a25df7bf68a5bc19c524 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds single tag to this node.  <br /></td></tr>
<tr class="separator:ae00f8c73f0a3a25df7bf68a5bc19c524 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87c7a582545956ccdcab95b259ec3ae inherit pub_methods_classsparta_1_1TreeNode" id="r_ac87c7a582545956ccdcab95b259ec3ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#ac87c7a582545956ccdcab95b259ec3ae">addTags</a> (const std::vector&lt; std::string &gt; &amp;v)</td></tr>
<tr class="memdesc:ac87c7a582545956ccdcab95b259ec3ae inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds each elements of a vector of tags to this node.  <br /></td></tr>
<tr class="separator:ac87c7a582545956ccdcab95b259ec3ae inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb9301d222aa616093a280921f65d4a inherit pub_methods_classsparta_1_1TreeNode" id="r_abeb9301d222aa616093a280921f65d4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#abeb9301d222aa616093a280921f65d4a">stringizeTags</a> (std::stringstream &amp;ss) const</td></tr>
<tr class="memdesc:abeb9301d222aa616093a280921f65d4a inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render tags to a string in the form: " tags:[tag0, tag1]" If there are any tags. The leading space makes this a useful sub-utility of stringize because if there are no tags, returns empty string with no leading space.  <br /></td></tr>
<tr class="separator:abeb9301d222aa616093a280921f65d4a inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e16aaf48db706d4ed5f1a8f696310d7 inherit pub_methods_classsparta_1_1TreeNode" id="r_a0e16aaf48db706d4ed5f1a8f696310d7"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classsparta_1_1TreeNode.html#af5075c9b90f28041b6a7f3f80132c1b3">node_uid_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getNodeUID</b> () const</td></tr>
<tr class="memdesc:a0e16aaf48db706d4ed5f1a8f696310d7 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the unique ID of this node. <br /></td></tr>
<tr class="separator:a0e16aaf48db706d4ed5f1a8f696310d7 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa3602a9ab827b1351ef8f518c32576 inherit pub_methods_classsparta_1_1TreeNode" id="r_abfa3602a9ab827b1351ef8f518c32576"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#abfa3602a9ab827b1351ef8f518c32576">getName</a> () const override</td></tr>
<tr class="memdesc:abfa3602a9ab827b1351ef8f518c32576 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of this node.  <br /></td></tr>
<tr class="separator:abfa3602a9ab827b1351ef8f518c32576 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afd83be527cc01da733615ce85726dc inherit pub_methods_classsparta_1_1TreeNode" id="r_a7afd83be527cc01da733615ce85726dc"><td class="memItemLeft" align="right" valign="top">const std::string *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a7afd83be527cc01da733615ce85726dc">getNamePtr</a> () const</td></tr>
<tr class="memdesc:a7afd83be527cc01da733615ce85726dc inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of this node's string pointer which isinterned in <a class="el" href="classsparta_1_1StringManager.html" title="Manages string internment for SPARTA. This allows strings to be compared by pointer once interned.">StringManager</a>)  <br /></td></tr>
<tr class="separator:a7afd83be527cc01da733615ce85726dc inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec143fde6eb7584c343c98e62bba1aa4 inherit pub_methods_classsparta_1_1TreeNode" id="r_aec143fde6eb7584c343c98e62bba1aa4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#aec143fde6eb7584c343c98e62bba1aa4">isAnonymous</a> () const</td></tr>
<tr class="memdesc:aec143fde6eb7584c343c98e62bba1aa4 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this node anonymous.  <br /></td></tr>
<tr class="separator:aec143fde6eb7584c343c98e62bba1aa4 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a85c2485062f0e5ba383bb8d94fd3f inherit pub_methods_classsparta_1_1TreeNode" id="r_aa7a85c2485062f0e5ba383bb8d94fd3f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#aa7a85c2485062f0e5ba383bb8d94fd3f">isExpired</a> () const</td></tr>
<tr class="memdesc:aa7a85c2485062f0e5ba383bb8d94fd3f inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this expired (i.e. has it been the rhp of a move constructor)  <br /></td></tr>
<tr class="separator:aa7a85c2485062f0e5ba383bb8d94fd3f inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc60d1830eb57047f1f71bf1968588a inherit pub_methods_classsparta_1_1TreeNode" id="r_a3cc60d1830eb57047f1f71bf1968588a"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isIndexableByGroup</b> () const</td></tr>
<tr class="memdesc:a3cc60d1830eb57047f1f71bf1968588a inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this object is accessible through its parent's interfaces for getting children by group and index. <br /></td></tr>
<tr class="separator:a3cc60d1830eb57047f1f71bf1968588a inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcc01a3bfce8b3830e39aba1e63d9f6 inherit pub_methods_classsparta_1_1TreeNode" id="r_aebcc01a3bfce8b3830e39aba1e63d9f6"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#aebcc01a3bfce8b3830e39aba1e63d9f6">getGroup</a> () const</td></tr>
<tr class="memdesc:aebcc01a3bfce8b3830e39aba1e63d9f6 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the group name of this node.  <br /></td></tr>
<tr class="separator:aebcc01a3bfce8b3830e39aba1e63d9f6 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd50034f379a6e442d479535def905e inherit pub_methods_classsparta_1_1TreeNode" id="r_a6cd50034f379a6e442d479535def905e"><td class="memItemLeft" align="right" valign="top">const std::string *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a6cd50034f379a6e442d479535def905e">getGroupNamePtr</a> () const</td></tr>
<tr class="memdesc:a6cd50034f379a6e442d479535def905e inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the group name string pointer (interned in <a class="el" href="classsparta_1_1StringManager.html" title="Manages string internment for SPARTA. This allows strings to be compared by pointer once interned.">StringManager</a> singleton) of this node.  <br /></td></tr>
<tr class="separator:a6cd50034f379a6e442d479535def905e inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc69fe186075177c6559e84188982e9 inherit pub_methods_classsparta_1_1TreeNode" id="r_aadc69fe186075177c6559e84188982e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1TreeNode.html#a7fa01f145455d583b8f16e0f923b7c7c">group_idx_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#aadc69fe186075177c6559e84188982e9">getGroupIdx</a> () const</td></tr>
<tr class="memdesc:aadc69fe186075177c6559e84188982e9 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the group index of this node.  <br /></td></tr>
<tr class="separator:aadc69fe186075177c6559e84188982e9 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18cf1df166a0430f1ffd56b1f16ce732 inherit pub_methods_classsparta_1_1TreeNode" id="r_a18cf1df166a0430f1ffd56b1f16ce732"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; const std::string * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a18cf1df166a0430f1ffd56b1f16ce732">getTags</a> () const</td></tr>
<tr class="memdesc:a18cf1df166a0430f1ffd56b1f16ce732 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the set of tags associated with this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>.  <br /></td></tr>
<tr class="separator:a18cf1df166a0430f1ffd56b1f16ce732 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790acc1b3b08263b8f1941dc33fbb012 inherit pub_methods_classsparta_1_1TreeNode" id="r_a790acc1b3b08263b8f1941dc33fbb012"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasTag</b> (const std::string &amp;tag) const</td></tr>
<tr class="memdesc:a790acc1b3b08263b8f1941dc33fbb012 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this node have a specific tag (by name) <br /></td></tr>
<tr class="separator:a790acc1b3b08263b8f1941dc33fbb012 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b28db0c7afcacd7ef77c0243ef32364 inherit pub_methods_classsparta_1_1TreeNode" id="r_a8b28db0c7afcacd7ef77c0243ef32364"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a8b28db0c7afcacd7ef77c0243ef32364">hasTag</a> (const std::string *interned_tag_name) const</td></tr>
<tr class="memdesc:a8b28db0c7afcacd7ef77c0243ef32364 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this node have a specific tag (by string pointer interned with <a class="el" href="classsparta_1_1StringManager.html" title="Manages string internment for SPARTA. This allows strings to be compared by pointer once interned.">StringManager</a>). This is faster than the alternate hasTag method because it relies only on pointer comparisons.  <br /></td></tr>
<tr class="separator:a8b28db0c7afcacd7ef77c0243ef32364 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e94c653b4d23af19a26ad92b8a17bba inherit pub_methods_classsparta_1_1TreeNode" id="r_a2e94c653b4d23af19a26ad92b8a17bba"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a2e94c653b4d23af19a26ad92b8a17bba">getDesc</a> () const</td></tr>
<tr class="memdesc:a2e94c653b4d23af19a26ad92b8a17bba inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the description of this node.  <br /></td></tr>
<tr class="separator:a2e94c653b4d23af19a26ad92b8a17bba inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5faf0ebba15c75ea7e421b0b552e2de9 inherit pub_methods_classsparta_1_1TreeNode" id="r_a5faf0ebba15c75ea7e421b0b552e2de9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a5faf0ebba15c75ea7e421b0b552e2de9">isBuiltin</a> () const</td></tr>
<tr class="memdesc:a5faf0ebba15c75ea7e421b0b552e2de9 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this node in the builtins group.  <br /></td></tr>
<tr class="separator:a5faf0ebba15c75ea7e421b0b552e2de9 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340ab05847517f7e813da70275f8fc34 inherit pub_methods_classsparta_1_1TreeNode" id="r_a340ab05847517f7e813da70275f8fc34"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>markHidden</b> (bool hidden=true)</td></tr>
<tr class="memdesc:a340ab05847517f7e813da70275f8fc34 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> hidden for the purposes of printint out nodes. This does not make the node inaccessible, but causes it (and its subtree) to be hidden from typical recursive tree printouts. <br /></td></tr>
<tr class="separator:a340ab05847517f7e813da70275f8fc34 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3780c614eaa9c18ba2a162c32c2fa24 inherit pub_methods_classsparta_1_1TreeNode" id="r_ad3780c614eaa9c18ba2a162c32c2fa24"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#ad3780c614eaa9c18ba2a162c32c2fa24">isHidden</a> () const</td></tr>
<tr class="memdesc:ad3780c614eaa9c18ba2a162c32c2fa24 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> supposed to be hidden during tree printouts This value does not have to be respected by anything using <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> and is mainly a UI/printout convenience.  <br /></td></tr>
<tr class="separator:ad3780c614eaa9c18ba2a162c32c2fa24 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad250972578e11008fb7e3c8258945358 inherit pub_methods_classsparta_1_1TreeNode" id="r_ad250972578e11008fb7e3c8258945358"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#ad250972578e11008fb7e3c8258945358">validateName</a> (const std::string &amp;nm)</td></tr>
<tr class="memdesc:ad250972578e11008fb7e3c8258945358 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the given name string for this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>. Does not consider context (e.g. name collisions)  <br /></td></tr>
<tr class="separator:ad250972578e11008fb7e3c8258945358 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7400a57b30c63a2196d1c3f1bbf4466d inherit pub_methods_classsparta_1_1TreeNode" id="r_a7400a57b30c63a2196d1c3f1bbf4466d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a7400a57b30c63a2196d1c3f1bbf4466d">validateGroup</a> (const std::string &amp;name, const std::string &amp;group, <a class="el" href="classsparta_1_1TreeNode.html#a7fa01f145455d583b8f16e0f923b7c7c">group_idx_type</a> idx)</td></tr>
<tr class="memdesc:a7400a57b30c63a2196d1c3f1bbf4466d inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the given group name string and group index for this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>. Does not consider context (e.g. name collisions)  <br /></td></tr>
<tr class="separator:a7400a57b30c63a2196d1c3f1bbf4466d inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7946a8167a01fb800e2bc3eccab14bc2 inherit pub_methods_classsparta_1_1TreeNode" id="r_a7946a8167a01fb800e2bc3eccab14bc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a7946a8167a01fb800e2bc3eccab14bc2">validateDesc</a> (const std::string &amp;desc)</td></tr>
<tr class="memdesc:a7946a8167a01fb800e2bc3eccab14bc2 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the given description string for this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>.  <br /></td></tr>
<tr class="separator:a7946a8167a01fb800e2bc3eccab14bc2 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6ca285ffd1077f9622662c167315e9 inherit pub_methods_classsparta_1_1TreeNode" id="r_a7b6ca285ffd1077f9622662c167315e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a7b6ca285ffd1077f9622662c167315e9">addChild</a> (<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *child, bool inherit_phase=true)</td></tr>
<tr class="memdesc:a7b6ca285ffd1077f9622662c167315e9 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> to this node as a child.  <br /></td></tr>
<tr class="separator:a7b6ca285ffd1077f9622662c167315e9 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ee86186cf09b8dada20df11d635f37 inherit pub_methods_classsparta_1_1TreeNode" id="r_a57ee86186cf09b8dada20df11d635f37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a57ee86186cf09b8dada20df11d635f37">addChild</a> (<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &amp;child)</td></tr>
<tr class="memdesc:a57ee86186cf09b8dada20df11d635f37 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">AddChild by reference for convenience.  <br /></td></tr>
<tr class="separator:a57ee86186cf09b8dada20df11d635f37 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc0097b5c5a5eda666d42846fc0d655 inherit pub_methods_classsparta_1_1TreeNode" id="r_aefc0097b5c5a5eda666d42846fc0d655"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#aefc0097b5c5a5eda666d42846fc0d655">makeSubtreePrivate</a> ()</td></tr>
<tr class="memdesc:aefc0097b5c5a5eda666d42846fc0d655 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the entire subtree private.  <br /></td></tr>
<tr class="separator:aefc0097b5c5a5eda666d42846fc0d655 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c72f80e1e5b0847930c4067b22657b1 inherit pub_methods_classsparta_1_1TreeNode" id="r_a0c72f80e1e5b0847930c4067b22657b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a0c72f80e1e5b0847930c4067b22657b1">setScopeRoot</a> ()</td></tr>
<tr class="separator:a0c72f80e1e5b0847930c4067b22657b1 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b54fb21d8426f14d54c7388f68d2b4 inherit pub_methods_classsparta_1_1TreeNode" id="r_a73b54fb21d8426f14d54c7388f68d2b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a73b54fb21d8426f14d54c7388f68d2b4">isScopeRoot</a> () const</td></tr>
<tr class="separator:a73b54fb21d8426f14d54c7388f68d2b4 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46abf404b2bc1fff08e6d6bba27bd3ac inherit pub_methods_classsparta_1_1TreeNode" id="r_a46abf404b2bc1fff08e6d6bba27bd3ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a46abf404b2bc1fff08e6d6bba27bd3ac">addExtensionFactory</a> (const std::string &amp;extension_name, std::function&lt; ExtensionsBase *()&gt; factory)</td></tr>
<tr class="memdesc:a46abf404b2bc1fff08e6d6bba27bd3ac inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an extension factory to this tree node by its type (name).  <br /></td></tr>
<tr class="separator:a46abf404b2bc1fff08e6d6bba27bd3ac inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2433c4a7d26a10420ff908fdfe59ee01 inherit pub_methods_classsparta_1_1TreeNode" id="r_a2433c4a7d26a10420ff908fdfe59ee01"><td class="memItemLeft" align="right" valign="top">ExtensionsBase *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a2433c4a7d26a10420ff908fdfe59ee01">getExtension</a> (const std::string &amp;extension_name, bool no_factory_ok=false)</td></tr>
<tr class="memdesc:a2433c4a7d26a10420ff908fdfe59ee01 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an extension object by type string. Returns nullptr if not found (unrecognized).  <br /></td></tr>
<tr class="separator:a2433c4a7d26a10420ff908fdfe59ee01 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5469acef24d1a7d7058ce18cfb76c725 inherit pub_methods_classsparta_1_1TreeNode" id="r_a5469acef24d1a7d7058ce18cfb76c725"><td class="memItemLeft" align="right" valign="top">const ExtensionsBase *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a5469acef24d1a7d7058ce18cfb76c725">getExtension</a> (const std::string &amp;extension_name) const</td></tr>
<tr class="memdesc:a5469acef24d1a7d7058ce18cfb76c725 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an extension object by type string. Returns nullptr if not found (unrecognized).  <br /></td></tr>
<tr class="separator:a5469acef24d1a7d7058ce18cfb76c725 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd23bf68d7472b74099c35a5aafe0b9e inherit pub_methods_classsparta_1_1TreeNode" id="r_acd23bf68d7472b74099c35a5aafe0b9e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acd23bf68d7472b74099c35a5aafe0b9e inherit pub_methods_classsparta_1_1TreeNode"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#acd23bf68d7472b74099c35a5aafe0b9e">getExtensionAs</a> (const std::string &amp;extension_name)</td></tr>
<tr class="memdesc:acd23bf68d7472b74099c35a5aafe0b9e inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an extension, downcast to the given type.  <br /></td></tr>
<tr class="separator:acd23bf68d7472b74099c35a5aafe0b9e inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ecd57d84a123959187276ee2404c475 inherit pub_methods_classsparta_1_1TreeNode" id="r_a1ecd57d84a123959187276ee2404c475"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1ecd57d84a123959187276ee2404c475 inherit pub_methods_classsparta_1_1TreeNode"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a1ecd57d84a123959187276ee2404c475">getExtensionAs</a> (const std::string &amp;extension_name) const</td></tr>
<tr class="memdesc:a1ecd57d84a123959187276ee2404c475 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an extension, downcast to the given type.  <br /></td></tr>
<tr class="separator:a1ecd57d84a123959187276ee2404c475 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c99280dc2adae048d57fb001d05de61 inherit pub_methods_classsparta_1_1TreeNode" id="r_a8c99280dc2adae048d57fb001d05de61"><td class="memItemLeft" align="right" valign="top">ExtensionsBase *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a8c99280dc2adae048d57fb001d05de61">getExtension</a> ()</td></tr>
<tr class="memdesc:a8c99280dc2adae048d57fb001d05de61 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an extension without needing to specify any particular extension name. If no extensions exist, returns nullptr. If only one extension exists, returns that extension. If more than one extension exists, throws an exception.  <br /></td></tr>
<tr class="separator:a8c99280dc2adae048d57fb001d05de61 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4107352f9e07846b812d794d5a38a5 inherit pub_methods_classsparta_1_1TreeNode" id="r_a9d4107352f9e07846b812d794d5a38a5"><td class="memItemLeft" align="right" valign="top">const ExtensionsBase *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a9d4107352f9e07846b812d794d5a38a5">getExtension</a> () const</td></tr>
<tr class="memdesc:a9d4107352f9e07846b812d794d5a38a5 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an extension without needing to specify any particular extension name. If no extensions exist, returns nullptr. If only one extension exists, returns that extension. If more than one extension exists, throws an exception.  <br /></td></tr>
<tr class="separator:a9d4107352f9e07846b812d794d5a38a5 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb4f3d69315bfb965489d00f7be5148 inherit pub_methods_classsparta_1_1TreeNode" id="r_a5bb4f3d69315bfb965489d00f7be5148"><td class="memItemLeft" align="right" valign="top">ExtensionsBase *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a5bb4f3d69315bfb965489d00f7be5148">createExtension</a> (const std::string &amp;extension_name, bool replace=false)</td></tr>
<tr class="memdesc:a5bb4f3d69315bfb965489d00f7be5148 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an extension on demand. This is useful if you want to add an extension to a node that was not specified in any of the &ndash;extension-file, &ndash;arch, &ndash;config-file, or &ndash;node-config-file YAML files.  <br /></td></tr>
<tr class="separator:a5bb4f3d69315bfb965489d00f7be5148 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95a9a2b043fc39a1972871380d09eac inherit pub_methods_classsparta_1_1TreeNode" id="r_af95a9a2b043fc39a1972871380d09eac"><td class="memItemLeft" align="right" valign="top">ExtensionsBase *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#af95a9a2b043fc39a1972871380d09eac">createExtension</a> (bool replace=false)</td></tr>
<tr class="memdesc:af95a9a2b043fc39a1972871380d09eac inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an extension on demand without needing to specify any particular extension name. If the arch/config/extension YAML input files have exactly one extension configured for this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>, that extension will be created.  <br /></td></tr>
<tr class="separator:af95a9a2b043fc39a1972871380d09eac inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be07418bc8582d96fe2c3fb89ff4d94 inherit pub_methods_classsparta_1_1TreeNode" id="r_a1be07418bc8582d96fe2c3fb89ff4d94"><td class="memItemLeft" align="right" valign="top">ExtensionsBase *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a1be07418bc8582d96fe2c3fb89ff4d94">createExtension</a> (const char *extension_name, bool replace=false)</td></tr>
<tr class="separator:a1be07418bc8582d96fe2c3fb89ff4d94 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc907c86ba95d84c6e97f9421cbbc85 inherit pub_methods_classsparta_1_1TreeNode" id="r_a1dc907c86ba95d84c6e97f9421cbbc85"><td class="memTemplParams" colspan="2">template&lt;typename Extension , typename... Args&gt; </td></tr>
<tr class="memitem:a1dc907c86ba95d84c6e97f9421cbbc85 inherit pub_methods_classsparta_1_1TreeNode"><td class="memTemplItemLeft" align="right" valign="top">Extension *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a1dc907c86ba95d84c6e97f9421cbbc85">addExtension</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a1dc907c86ba95d84c6e97f9421cbbc85 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an extension, specifying the ExtensionsBase subclass type. Forward any arguments needed to your subclass extension's constructor. The typical use case for <a class="el" href="classsparta_1_1TreeNode.html#a1dc907c86ba95d84c6e97f9421cbbc85" title="Add an extension, specifying the ExtensionsBase subclass type. Forward any arguments needed to your s...">addExtension()</a> over the other apis is that these extensions are meant to be dynamic-only (on-demand only), bypassing the finalizeTree() checks that all extension parameters have been read. You can call <a class="el" href="classsparta_1_1TreeNode.html#a1dc907c86ba95d84c6e97f9421cbbc85" title="Add an extension, specifying the ExtensionsBase subclass type. Forward any arguments needed to your s...">addExtension()</a> whenever you want.  <br /></td></tr>
<tr class="separator:a1dc907c86ba95d84c6e97f9421cbbc85 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80b64d2c78346e93c5513dda617f547 inherit pub_methods_classsparta_1_1TreeNode" id="r_ac80b64d2c78346e93c5513dda617f547"><td class="memTemplParams" colspan="2">template&lt;typename Extension , typename... Args&gt; </td></tr>
<tr class="memitem:ac80b64d2c78346e93c5513dda617f547 inherit pub_methods_classsparta_1_1TreeNode"><td class="memTemplItemLeft" align="right" valign="top">Extension *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#ac80b64d2c78346e93c5513dda617f547">replaceExtension</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac80b64d2c78346e93c5513dda617f547 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace an extension, specifying the ExtensionsBase subclass type. This api is similar to <a class="el" href="classsparta_1_1TreeNode.html#a1dc907c86ba95d84c6e97f9421cbbc85" title="Add an extension, specifying the ExtensionsBase subclass type. Forward any arguments needed to your s...">addExtension()</a> in that you do not have to read these parameters prior to finalizeTree() to avoid "unread unbound parameter" exceptions.  <br /></td></tr>
<tr class="separator:ac80b64d2c78346e93c5513dda617f547 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91d6baf74fae76dd391c4e68b04a936 inherit pub_methods_classsparta_1_1TreeNode" id="r_ac91d6baf74fae76dd391c4e68b04a936"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>removeExtension</b> (const std::string &amp;extension_name)</td></tr>
<tr class="memdesc:ac91d6baf74fae76dd391c4e68b04a936 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an extension by its name. Returns true if successful, false if the extension was not found. <br /></td></tr>
<tr class="separator:ac91d6baf74fae76dd391c4e68b04a936 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b99ce49b9d44c9cc8e7b738601ef4b inherit pub_methods_classsparta_1_1TreeNode" id="r_a00b99ce49b9d44c9cc8e7b738601ef4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a00b99ce49b9d44c9cc8e7b738601ef4b">hasExtension</a> (const std::string &amp;extension_name) const</td></tr>
<tr class="memdesc:a00b99ce49b9d44c9cc8e7b738601ef4b inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this tree node has an extension by the given name.  <br /></td></tr>
<tr class="separator:a00b99ce49b9d44c9cc8e7b738601ef4b inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5a8c3649144eeeec5acacbba4f2b37 inherit pub_methods_classsparta_1_1TreeNode" id="r_aca5a8c3649144eeeec5acacbba4f2b37"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca5a8c3649144eeeec5acacbba4f2b37 inherit pub_methods_classsparta_1_1TreeNode"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#aca5a8c3649144eeeec5acacbba4f2b37">hasExtensionOfType</a> (const std::string &amp;extension_name) const noexcept</td></tr>
<tr class="memdesc:aca5a8c3649144eeeec5acacbba4f2b37 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this tree node has an extension by the given name and type.  <br /></td></tr>
<tr class="separator:aca5a8c3649144eeeec5acacbba4f2b37 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e9902e2233c6c0781c53652c0474c4 inherit pub_methods_classsparta_1_1TreeNode" id="r_af9e9902e2233c6c0781c53652c0474c4"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#af9e9902e2233c6c0781c53652c0474c4">getAllInstantiatedExtensionNames</a> () const</td></tr>
<tr class="memdesc:af9e9902e2233c6c0781c53652c0474c4 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of extension names for all <b>instantiated</b> extensions on this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>.  <br /></td></tr>
<tr class="separator:af9e9902e2233c6c0781c53652c0474c4 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae350a6316e5fc067d71de021b9d76d71 inherit pub_methods_classsparta_1_1TreeNode" id="r_ae350a6316e5fc067d71de021b9d76d71"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#ae350a6316e5fc067d71de021b9d76d71">getAllConfigExtensionNames</a> () const</td></tr>
<tr class="memdesc:ae350a6316e5fc067d71de021b9d76d71 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of extension names found for this node in all arch/config/extension files.  <br /></td></tr>
<tr class="separator:ae350a6316e5fc067d71de021b9d76d71 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319509d49b71536682de2c35856ae24c inherit pub_methods_classsparta_1_1TreeNode" id="r_a319509d49b71536682de2c35856ae24c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a319509d49b71536682de2c35856ae24c">getNumExtensions</a> () const</td></tr>
<tr class="memdesc:a319509d49b71536682de2c35856ae24c inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of extensions for this node.  <br /></td></tr>
<tr class="separator:a319509d49b71536682de2c35856ae24c inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d555432f77343119f980c47ac3768dc inherit pub_methods_classsparta_1_1TreeNode" id="r_a1d555432f77343119f980c47ac3768dc"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, const ExtensionsBase * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a1d555432f77343119f980c47ac3768dc">getAllExtensions</a> () const</td></tr>
<tr class="memdesc:a1d555432f77343119f980c47ac3768dc inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a map of extensions for this node.  <br /></td></tr>
<tr class="separator:a1d555432f77343119f980c47ac3768dc inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac64404e9cbc67844ce87a0507b73fd8 inherit pub_methods_classsparta_1_1TreeNode" id="r_aac64404e9cbc67844ce87a0507b73fd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#aac64404e9cbc67844ce87a0507b73fd8">lockdownParameters</a> ()</td></tr>
<tr class="memdesc:aac64404e9cbc67844ce87a0507b73fd8 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to put the device tree in lockdown phase. All LOCKED and HIDDEN parameters are frozen after this point. Regular parameters are not affected by this phase. This method requires a Simulation pointer and will assert at compile time if anyone tries to lockdown the tree without the context of a Simulation.  <br /></td></tr>
<tr class="separator:aac64404e9cbc67844ce87a0507b73fd8 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e430f72fd1a922df3c8dbc7be3f7d00 inherit pub_methods_classsparta_1_1TreeNode" id="r_a5e430f72fd1a922df3c8dbc7be3f7d00"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a5e430f72fd1a922df3c8dbc7be3f7d00">isAttached</a> () const</td></tr>
<tr class="memdesc:a5e430f72fd1a922df3c8dbc7be3f7d00 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this node part of a device tree with a proper <a class="el" href="classsparta_1_1RootTreeNode.html" title="TreeNode which represents the root (&quot;top&quot;) of a device tree.">RootTreeNode</a> at the root.  <br /></td></tr>
<tr class="separator:a5e430f72fd1a922df3c8dbc7be3f7d00 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8958d72a1f5aeff2ec36012913ac09c inherit pub_methods_classsparta_1_1TreeNode" id="r_aa8958d72a1f5aeff2ec36012913ac09c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#aa8958d72a1f5aeff2ec36012913ac09c">getParent</a> ()</td></tr>
<tr class="memdesc:aa8958d72a1f5aeff2ec36012913ac09c inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets immediate parent of this node if one exists.  <br /></td></tr>
<tr class="separator:aa8958d72a1f5aeff2ec36012913ac09c inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad888851269c4ccd2009b66b5d6cb111 inherit pub_methods_classsparta_1_1TreeNode" id="r_aad888851269c4ccd2009b66b5d6cb111"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#aad888851269c4ccd2009b66b5d6cb111">getParent</a> () const</td></tr>
<tr class="separator:aad888851269c4ccd2009b66b5d6cb111 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e274bfe8a716d699ad67e74212c87b9 inherit pub_methods_classsparta_1_1TreeNode" id="r_a3e274bfe8a716d699ad67e74212c87b9"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a3e274bfe8a716d699ad67e74212c87b9 inherit pub_methods_classsparta_1_1TreeNode"><td class="memTemplItemLeft" align="right" valign="top">const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a3e274bfe8a716d699ad67e74212c87b9">getParentAs</a> (bool must_exist=true) const</td></tr>
<tr class="memdesc:a3e274bfe8a716d699ad67e74212c87b9 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a parent casted to type T* if this node has a parent.  <br /></td></tr>
<tr class="separator:a3e274bfe8a716d699ad67e74212c87b9 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcfcd5236cbc9208cbcbbbfadd73ec37 inherit pub_methods_classsparta_1_1TreeNode" id="r_adcfcd5236cbc9208cbcbbbfadd73ec37"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;!std::is_pointer&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:adcfcd5236cbc9208cbcbbbfadd73ec37 inherit pub_methods_classsparta_1_1TreeNode"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#adcfcd5236cbc9208cbcbbbfadd73ec37">getParentAs</a> (bool must_exist=true) const</td></tr>
<tr class="separator:adcfcd5236cbc9208cbcbbbfadd73ec37 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c4ab072677438d088d7d99c1f585f6 inherit pub_methods_classsparta_1_1TreeNode" id="r_a05c4ab072677438d088d7d99c1f585f6"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a05c4ab072677438d088d7d99c1f585f6 inherit pub_methods_classsparta_1_1TreeNode"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a05c4ab072677438d088d7d99c1f585f6">getParentAs</a> (bool must_exist=true)</td></tr>
<tr class="separator:a05c4ab072677438d088d7d99c1f585f6 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51788dafac480f1e80ee6167e2c3da06 inherit pub_methods_classsparta_1_1TreeNode" id="r_a51788dafac480f1e80ee6167e2c3da06"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;!std::is_pointer&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a51788dafac480f1e80ee6167e2c3da06 inherit pub_methods_classsparta_1_1TreeNode"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a51788dafac480f1e80ee6167e2c3da06">getParentAs</a> (bool must_exist=true)</td></tr>
<tr class="separator:a51788dafac480f1e80ee6167e2c3da06 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31666fa4b498cd468991f2099e3fbbf7 inherit pub_methods_classsparta_1_1TreeNode" id="r_a31666fa4b498cd468991f2099e3fbbf7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a31666fa4b498cd468991f2099e3fbbf7">getRoot</a> ()</td></tr>
<tr class="memdesc:a31666fa4b498cd468991f2099e3fbbf7 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets farthest ancestor of this node.  <br /></td></tr>
<tr class="separator:a31666fa4b498cd468991f2099e3fbbf7 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6461997acf50ce6caa9ca2815a3a0e inherit pub_methods_classsparta_1_1TreeNode" id="r_a5e6461997acf50ce6caa9ca2815a3a0e"><td class="memItemLeft" align="right" valign="top">
virtual const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getRoot</b> () const</td></tr>
<tr class="separator:a5e6461997acf50ce6caa9ca2815a3a0e inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7432fe0422eaa5afed7848effbc7d8f inherit pub_methods_classsparta_1_1TreeNode" id="r_ad7432fe0422eaa5afed7848effbc7d8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#ad7432fe0422eaa5afed7848effbc7d8f">getScopeRoot</a> ()</td></tr>
<tr class="separator:ad7432fe0422eaa5afed7848effbc7d8f inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817663bb26d61b4970378614ed8a0908 inherit pub_methods_classsparta_1_1TreeNode" id="r_a817663bb26d61b4970378614ed8a0908"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a817663bb26d61b4970378614ed8a0908">getScopeRoot</a> () const</td></tr>
<tr class="separator:a817663bb26d61b4970378614ed8a0908 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f2e3a443fafcf26682291cfdeb19f1 inherit pub_methods_classsparta_1_1TreeNode" id="r_a55f2e3a443fafcf26682291cfdeb19f1"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getExpectedRoot</b> () const</td></tr>
<tr class="memdesc:a55f2e3a443fafcf26682291cfdeb19f1 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">build-time equivalent to getRoot before an object is actually attached to a tree. This is a mainly a framework and debugging tool for determining what the root of a node being constructed will be when complete <br /></td></tr>
<tr class="separator:a55f2e3a443fafcf26682291cfdeb19f1 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0074a4a62b20d8b414fe52939feaf9ca inherit pub_methods_classsparta_1_1TreeNode" id="r_a0074a4a62b20d8b414fe52939feaf9ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1app_1_1Simulation.html">app::Simulation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a0074a4a62b20d8b414fe52939feaf9ca">getSimulation</a> () const</td></tr>
<tr class="memdesc:a0074a4a62b20d8b414fe52939feaf9ca inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the simulation (if any) associated with this tree.  <br /></td></tr>
<tr class="separator:a0074a4a62b20d8b414fe52939feaf9ca inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58ee3afd3ce00f3d8c42cd75a65c097 inherit pub_methods_classsparta_1_1TreeNode" id="r_ac58ee3afd3ce00f3d8c42cd75a65c097"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#ac58ee3afd3ce00f3d8c42cd75a65c097">getNumChildren</a> () const</td></tr>
<tr class="memdesc:ac58ee3afd3ce00f3d8c42cd75a65c097 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of children that this node has including those in the sparta builtins group.  <br /></td></tr>
<tr class="separator:ac58ee3afd3ce00f3d8c42cd75a65c097 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d156d0d58625322688c5db23d7abcd6 inherit pub_methods_classsparta_1_1TreeNode" id="r_a4d156d0d58625322688c5db23d7abcd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a4d156d0d58625322688c5db23d7abcd6">getChildAt</a> (uint32_t idx) const</td></tr>
<tr class="memdesc:a4d156d0d58625322688c5db23d7abcd6 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a child at a position in the children vector in the order in which they were added to this node.  <br /></td></tr>
<tr class="separator:a4d156d0d58625322688c5db23d7abcd6 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63eb06c6b97cc1d58dde858e4d761550 inherit pub_methods_classsparta_1_1TreeNode" id="r_a63eb06c6b97cc1d58dde858e4d761550"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsparta_1_1TreeNode.html#af0a2fea735ac7c0116fd470ddb1b7744">ChildrenVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a63eb06c6b97cc1d58dde858e4d761550">getChildren</a> () const</td></tr>
<tr class="memdesc:a63eb06c6b97cc1d58dde858e4d761550 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a vector of all children of this node in any group in the order in which they were added to this node.  <br /></td></tr>
<tr class="separator:a63eb06c6b97cc1d58dde858e4d761550 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d8ac46557b407b8fb15b70a831cce6 inherit pub_methods_classsparta_1_1TreeNode" id="r_a71d8ac46557b407b8fb15b70a831cce6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a71d8ac46557b407b8fb15b70a831cce6">getChildren</a> (std::vector&lt; <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &amp;results, bool ignore_builtin_group=true, bool ignore_anonymous_nodes=true)</td></tr>
<tr class="memdesc:a71d8ac46557b407b8fb15b70a831cce6 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all children of this node in the order in which they were added to this node.  <br /></td></tr>
<tr class="separator:a71d8ac46557b407b8fb15b70a831cce6 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea0200191d0c9e5dc04bb558e6fda99 inherit pub_methods_classsparta_1_1TreeNode" id="r_acea0200191d0c9e5dc04bb558e6fda99"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:acea0200191d0c9e5dc04bb558e6fda99 inherit pub_methods_classsparta_1_1TreeNode"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#acea0200191d0c9e5dc04bb558e6fda99">getChildrenOfType</a> (std::vector&lt; T * &gt; &amp;results) const</td></tr>
<tr class="memdesc:acea0200191d0c9e5dc04bb558e6fda99 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">return all the children matching a particular type using dynamic cast.  <br /></td></tr>
<tr class="separator:acea0200191d0c9e5dc04bb558e6fda99 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71fca4d66ac8dee9f524fd3472c4bf8b inherit pub_methods_classsparta_1_1TreeNode" id="r_a71fca4d66ac8dee9f524fd3472c4bf8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a71fca4d66ac8dee9f524fd3472c4bf8b">findAncestorByName</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a71fca4d66ac8dee9f524fd3472c4bf8b inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find ancestor by name.  <br /></td></tr>
<tr class="separator:a71fca4d66ac8dee9f524fd3472c4bf8b inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70953b54ed0fe69a3f13af671b68e53 inherit pub_methods_classsparta_1_1TreeNode" id="r_ae70953b54ed0fe69a3f13af671b68e53"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae70953b54ed0fe69a3f13af671b68e53 inherit pub_methods_classsparta_1_1TreeNode"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#ae70953b54ed0fe69a3f13af671b68e53">findAncestorByType</a> ()</td></tr>
<tr class="memdesc:ae70953b54ed0fe69a3f13af671b68e53 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find ancestor by type.  <br /></td></tr>
<tr class="separator:ae70953b54ed0fe69a3f13af671b68e53 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e8b9f4aa2cc56fcba09b88ddf1f626 inherit pub_methods_classsparta_1_1TreeNode" id="r_ac4e8b9f4aa2cc56fcba09b88ddf1f626"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#ac4e8b9f4aa2cc56fcba09b88ddf1f626">findAncestorByTag</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:ac4e8b9f4aa2cc56fcba09b88ddf1f626 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first ancestor with a particular tag.  <br /></td></tr>
<tr class="separator:ac4e8b9f4aa2cc56fcba09b88ddf1f626 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf510819cee4ea78d009b01ea324474 inherit pub_methods_classsparta_1_1TreeNode" id="r_aedf510819cee4ea78d009b01ea324474"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aedf510819cee4ea78d009b01ea324474 inherit pub_methods_classsparta_1_1TreeNode"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#aedf510819cee4ea78d009b01ea324474">findAncestorResourceByType</a> ()</td></tr>
<tr class="memdesc:aedf510819cee4ea78d009b01ea324474 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an ancestor's resource with a certain type.  <br /></td></tr>
<tr class="separator:aedf510819cee4ea78d009b01ea324474 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1b9b2ae0628d9339688665fe1c2111 inherit pub_methods_classsparta_1_1TreeNode" id="r_a8b1b9b2ae0628d9339688665fe1c2111"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsparta_1_1TreeNode.html#a991e1785f763d44925f4a53d89a44675">AliasVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a8b1b9b2ae0628d9339688665fe1c2111">getAliases</a> () const</td></tr>
<tr class="memdesc:a8b1b9b2ae0628d9339688665fe1c2111 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a vector of all aliases of this node.  <br /></td></tr>
<tr class="separator:a8b1b9b2ae0628d9339688665fe1c2111 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53352d950db4b085566de453e0d2e00 inherit pub_methods_classsparta_1_1TreeNode" id="r_ae53352d950db4b085566de453e0d2e00"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#ae53352d950db4b085566de453e0d2e00">getChildrenIdentifiers</a> (std::vector&lt; std::string &gt; &amp;idents, bool ignore_builtin_group=true) const</td></tr>
<tr class="memdesc:ae53352d950db4b085566de453e0d2e00 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all child identifiers, aliases, group names, and group-aliases which can be used to refer to a child of this node.  <br /></td></tr>
<tr class="separator:ae53352d950db4b085566de453e0d2e00 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa799fcb616aca8d0e88e7c509bfbbb77 inherit pub_methods_classsparta_1_1TreeNode" id="r_aa799fcb616aca8d0e88e7c509bfbbb77"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const std::string * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#aa799fcb616aca8d0e88e7c509bfbbb77">getIdentifiers</a> () const</td></tr>
<tr class="memdesc:aa799fcb616aca8d0e88e7c509bfbbb77 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all the identifiers for this node (excluding groups)  <br /></td></tr>
<tr class="separator:aa799fcb616aca8d0e88e7c509bfbbb77 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace29f38285cf6318c8c2973e028c1588 inherit pub_methods_classsparta_1_1TreeNode" id="r_ace29f38285cf6318c8c2973e028c1588"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#ace29f38285cf6318c8c2973e028c1588">getGroupSize</a> (const std::string &amp;group)</td></tr>
<tr class="memdesc:ace29f38285cf6318c8c2973e028c1588 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of nodes in a group.  <br /></td></tr>
<tr class="separator:ace29f38285cf6318c8c2973e028c1588 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8509bfb982375b090e6e2d280bc0dd inherit pub_methods_classsparta_1_1TreeNode" id="r_a6a8509bfb982375b090e6e2d280bc0dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1TreeNode.html#a7fa01f145455d583b8f16e0f923b7c7c">group_idx_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a6a8509bfb982375b090e6e2d280bc0dd">getGroupIndexMax</a> (const std::string &amp;group)</td></tr>
<tr class="memdesc:a6a8509bfb982375b090e6e2d280bc0dd inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the largest index of a node in the given group.  <br /></td></tr>
<tr class="separator:a6a8509bfb982375b090e6e2d280bc0dd inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28436401cbe813f5ea99f4c09615fef4 inherit pub_methods_classsparta_1_1TreeNode" id="r_a28436401cbe813f5ea99f4c09615fef4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a28436401cbe813f5ea99f4c09615fef4">getGroup</a> (const std::string &amp;group, std::vector&lt; <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &amp;results)</td></tr>
<tr class="memdesc:a28436401cbe813f5ea99f4c09615fef4 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all nodes in a child group.  <br /></td></tr>
<tr class="separator:a28436401cbe813f5ea99f4c09615fef4 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae707e1cdf8038ea8aeac03ca2620d1e1 inherit pub_methods_classsparta_1_1TreeNode" id="r_ae707e1cdf8038ea8aeac03ca2620d1e1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#ae707e1cdf8038ea8aeac03ca2620d1e1">findChildren</a> (const std::string &amp;pattern, std::vector&lt; <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &amp;results, std::vector&lt; std::vector&lt; std::string &gt; &gt; &amp;replacements)</td></tr>
<tr class="memdesc:ae707e1cdf8038ea8aeac03ca2620d1e1 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all children starting at this node with a given pattern relative to this node by matching names an aliases. Appends each found child to &lt;results&gt;.  <br /></td></tr>
<tr class="separator:ae707e1cdf8038ea8aeac03ca2620d1e1 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e9cb392ac4901bc21ce583b36d0e01 inherit pub_methods_classsparta_1_1TreeNode" id="r_a34e9cb392ac4901bc21ce583b36d0e01"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a34e9cb392ac4901bc21ce583b36d0e01">findChildren</a> (const std::string &amp;pattern, std::vector&lt; <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &amp;results)</td></tr>
<tr class="memdesc:a34e9cb392ac4901bc21ce583b36d0e01 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of findChildren with no replacements vector.  <br /></td></tr>
<tr class="separator:a34e9cb392ac4901bc21ce583b36d0e01 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac4c7b95e6ce15d29464218e989ffd5 inherit pub_methods_classsparta_1_1TreeNode" id="r_a9ac4c7b95e6ce15d29464218e989ffd5"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a9ac4c7b95e6ce15d29464218e989ffd5">findImmediateChildren_</a> (std::regex &amp;expr, std::vector&lt; <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &amp;found, std::vector&lt; std::vector&lt; std::string &gt; &gt; &amp;replacements, bool allow_private=false)</td></tr>
<tr class="memdesc:a9ac4c7b95e6ce15d29464218e989ffd5 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds immediate children with some identity (name or alias) matching a regex.  <br /></td></tr>
<tr class="separator:a9ac4c7b95e6ce15d29464218e989ffd5 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a126851828a964a6c0890a343066a20 inherit pub_methods_classsparta_1_1TreeNode" id="r_a0a126851828a964a6c0890a343066a20"><td class="memItemLeft" align="right" valign="top">
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>findImmediateChildren_</b> (std::regex &amp;expr, std::vector&lt; <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &amp;found, bool allow_private=false)</td></tr>
<tr class="memdesc:a0a126851828a964a6c0890a343066a20 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of findImmediateChildren_ with no replacements vector. <br /></td></tr>
<tr class="separator:a0a126851828a964a6c0890a343066a20 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244fd94fe20fad6c06500c6474522d1c inherit pub_methods_classsparta_1_1TreeNode" id="r_a244fd94fe20fad6c06500c6474522d1c"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a244fd94fe20fad6c06500c6474522d1c">findImmediateChildren_</a> (std::regex &amp;expr, std::vector&lt; const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &amp;found, std::vector&lt; std::vector&lt; std::string &gt; &gt; &amp;replacements, bool allow_private=false) const</td></tr>
<tr class="memdesc:a244fd94fe20fad6c06500c6474522d1c inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const-qualified variant of findImmediateChildren_.  <br /></td></tr>
<tr class="separator:a244fd94fe20fad6c06500c6474522d1c inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6b8ae3870d202776e4e404d674eb82 inherit pub_methods_classsparta_1_1TreeNode" id="r_aef6b8ae3870d202776e4e404d674eb82"><td class="memItemLeft" align="right" valign="top">
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>findImmediateChildren_</b> (std::regex &amp;expr, std::vector&lt; const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &amp;found, bool allow_private=false) const</td></tr>
<tr class="memdesc:aef6b8ae3870d202776e4e404d674eb82 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of const-qualified findImmediateChildren_ with no replacements vector. <br /></td></tr>
<tr class="separator:aef6b8ae3870d202776e4e404d674eb82 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61c4f67a5045b80c62fd331519b969d inherit pub_methods_classsparta_1_1TreeNode" id="r_af61c4f67a5045b80c62fd331519b969d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#af61c4f67a5045b80c62fd331519b969d">locationMatchesPattern</a> (const std::string &amp;pattern, const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *pat_loc) const</td></tr>
<tr class="memdesc:af61c4f67a5045b80c62fd331519b969d inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given pattern (which may contain wildcards) can describe this node.  <br /></td></tr>
<tr class="separator:af61c4f67a5045b80c62fd331519b969d inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac598185049018290d5ea6cb674d10473 inherit pub_methods_classsparta_1_1TreeNode" id="r_ac598185049018290d5ea6cb674d10473"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#ac598185049018290d5ea6cb674d10473">getChild</a> (const std::string &amp;name, bool must_exist=true)</td></tr>
<tr class="memdesc:ac598185049018290d5ea6cb674d10473 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a child with this dotted path name.  <br /></td></tr>
<tr class="separator:ac598185049018290d5ea6cb674d10473 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0acc7bdbe1cde5dd450e2a5677316f inherit pub_methods_classsparta_1_1TreeNode" id="r_a6e0acc7bdbe1cde5dd450e2a5677316f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a6e0acc7bdbe1cde5dd450e2a5677316f">getChild</a> (const std::string &amp;name, bool must_exist=true) const</td></tr>
<tr class="memdesc:a6e0acc7bdbe1cde5dd450e2a5677316f inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded const-qualified.  <br /></td></tr>
<tr class="separator:a6e0acc7bdbe1cde5dd450e2a5677316f inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0703ca8742ef2de67a0d876ccb0c6e inherit pub_methods_classsparta_1_1TreeNode" id="r_a8e0703ca8742ef2de67a0d876ccb0c6e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a8e0703ca8742ef2de67a0d876ccb0c6e">getDeepestMatchingPath</a> (const std::string &amp;path) const</td></tr>
<tr class="memdesc:a8e0703ca8742ef2de67a0d876ccb0c6e inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the deepest whole node location starting from <em>this</em> node that matches some part of <em>path</em> starting at its beginning.  <br /></td></tr>
<tr class="separator:a8e0703ca8742ef2de67a0d876ccb0c6e inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdb43d52e9eb2d550b2ab40c4b2722c inherit pub_methods_classsparta_1_1TreeNode" id="r_affdb43d52e9eb2d550b2ab40c4b2722c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#affdb43d52e9eb2d550b2ab40c4b2722c">hasChild</a> (const std::string &amp;name) const noexcept</td></tr>
<tr class="memdesc:affdb43d52e9eb2d550b2ab40c4b2722c inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a child can be found with the given dotted path.  <br /></td></tr>
<tr class="separator:affdb43d52e9eb2d550b2ab40c4b2722c inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8132a8fd4d313c333a49979726a9b0b inherit pub_methods_classsparta_1_1TreeNode" id="r_ad8132a8fd4d313c333a49979726a9b0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#ad8132a8fd4d313c333a49979726a9b0b">hasImmediateChild</a> (const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *n) const noexcept</td></tr>
<tr class="memdesc:ad8132a8fd4d313c333a49979726a9b0b inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the node <em>n</em> is an immediate child of this node.  <br /></td></tr>
<tr class="separator:ad8132a8fd4d313c333a49979726a9b0b inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18a936bf3a826ff18bd374d2a6b531d inherit pub_methods_classsparta_1_1TreeNode" id="r_ab18a936bf3a826ff18bd374d2a6b531d"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value&gt;::type, class ConstT  = typename ptr_to_const_obj_ptr&lt;T&gt;::type&gt; </td></tr>
<tr class="memitem:ab18a936bf3a826ff18bd374d2a6b531d inherit pub_methods_classsparta_1_1TreeNode"><td class="memTemplItemLeft" align="right" valign="top">const ConstT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#ab18a936bf3a826ff18bd374d2a6b531d">getChildAs</a> (const std::string &amp;name, bool must_exist=true) const</td></tr>
<tr class="memdesc:ab18a936bf3a826ff18bd374d2a6b531d inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a child that is castable to T with the given dotted path.  <br /></td></tr>
<tr class="separator:ab18a936bf3a826ff18bd374d2a6b531d inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b665db735ea8bea394d85afd203fc0 inherit pub_methods_classsparta_1_1TreeNode" id="r_a95b665db735ea8bea394d85afd203fc0"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;!std::is_pointer&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a95b665db735ea8bea394d85afd203fc0 inherit pub_methods_classsparta_1_1TreeNode"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a95b665db735ea8bea394d85afd203fc0">getChildAs</a> (const std::string &amp;name, bool must_exist=true) const</td></tr>
<tr class="separator:a95b665db735ea8bea394d85afd203fc0 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f94b930f3b83dc49d0a114b79f725bf inherit pub_methods_classsparta_1_1TreeNode" id="r_a0f94b930f3b83dc49d0a114b79f725bf"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a0f94b930f3b83dc49d0a114b79f725bf inherit pub_methods_classsparta_1_1TreeNode"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a0f94b930f3b83dc49d0a114b79f725bf">getChildAs</a> (const std::string &amp;name, bool must_exist=true)</td></tr>
<tr class="separator:a0f94b930f3b83dc49d0a114b79f725bf inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51613b9aa45cc84a764c07ec34fb0043 inherit pub_methods_classsparta_1_1TreeNode" id="r_a51613b9aa45cc84a764c07ec34fb0043"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;!std::is_pointer&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a51613b9aa45cc84a764c07ec34fb0043 inherit pub_methods_classsparta_1_1TreeNode"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a51613b9aa45cc84a764c07ec34fb0043">getChildAs</a> (const std::string &amp;name, bool must_exist=true)</td></tr>
<tr class="separator:a51613b9aa45cc84a764c07ec34fb0043 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164eb7014e7e50a5b4921c139f712056 inherit pub_methods_classsparta_1_1TreeNode" id="r_a164eb7014e7e50a5b4921c139f712056"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value&gt;::type, class ConstT  = typename ptr_to_const_obj_ptr&lt;T&gt;::type&gt; </td></tr>
<tr class="memitem:a164eb7014e7e50a5b4921c139f712056 inherit pub_methods_classsparta_1_1TreeNode"><td class="memTemplItemLeft" align="right" valign="top">ConstT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a164eb7014e7e50a5b4921c139f712056">getAs</a> () const</td></tr>
<tr class="memdesc:a164eb7014e7e50a5b4921c139f712056 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves this node after casting to type T.  <br /></td></tr>
<tr class="separator:a164eb7014e7e50a5b4921c139f712056 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8976dc0bb4634cc07e51f7f66d64a17 inherit pub_methods_classsparta_1_1TreeNode" id="r_ab8976dc0bb4634cc07e51f7f66d64a17"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;!std::is_pointer&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ab8976dc0bb4634cc07e51f7f66d64a17 inherit pub_methods_classsparta_1_1TreeNode"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#ab8976dc0bb4634cc07e51f7f66d64a17">getAs</a> () const</td></tr>
<tr class="memdesc:ab8976dc0bb4634cc07e51f7f66d64a17 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves this node after casting to type const T.  <br /></td></tr>
<tr class="separator:ab8976dc0bb4634cc07e51f7f66d64a17 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a5d5c788727dfd1d382872e2711c0e inherit pub_methods_classsparta_1_1TreeNode" id="r_ad4a5d5c788727dfd1d382872e2711c0e"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ad4a5d5c788727dfd1d382872e2711c0e inherit pub_methods_classsparta_1_1TreeNode"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#ad4a5d5c788727dfd1d382872e2711c0e">getAs</a> ()</td></tr>
<tr class="memdesc:ad4a5d5c788727dfd1d382872e2711c0e inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves this node after casting to type const T.  <br /></td></tr>
<tr class="separator:ad4a5d5c788727dfd1d382872e2711c0e inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea061c7abb323917f0046feaca92545c inherit pub_methods_classsparta_1_1TreeNode" id="r_aea061c7abb323917f0046feaca92545c"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;!std::is_pointer&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aea061c7abb323917f0046feaca92545c inherit pub_methods_classsparta_1_1TreeNode"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#aea061c7abb323917f0046feaca92545c">getAs</a> ()</td></tr>
<tr class="memdesc:aea061c7abb323917f0046feaca92545c inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves this node after casting to type const T.  <br /></td></tr>
<tr class="separator:aea061c7abb323917f0046feaca92545c inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454fb71960c232bad1413c749c407a3b inherit pub_methods_classsparta_1_1TreeNode" id="r_a454fb71960c232bad1413c749c407a3b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a454fb71960c232bad1413c749c407a3b">findChildrenByTag</a> (const std::string &amp;tag, std::vector&lt; <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &amp;results, int32_t max_depth=-1)</td></tr>
<tr class="memdesc:a454fb71960c232bad1413c749c407a3b inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a set of all children having the selected tag which this node or descendants of this node within a distance of the given max_depth.  <br /></td></tr>
<tr class="separator:a454fb71960c232bad1413c749c407a3b inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cff588af283f20b1c3dc6f3b52053f inherit pub_methods_classsparta_1_1TreeNode" id="r_aa8cff588af283f20b1c3dc6f3b52053f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#aa8cff588af283f20b1c3dc6f3b52053f">isDescendantOf</a> (const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *ancestor, int32_t max_depth=-1) const</td></tr>
<tr class="memdesc:aa8cff588af283f20b1c3dc6f3b52053f inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this node is a descendant of the specified ancestor node within some number of generations (depth).  <br /></td></tr>
<tr class="separator:aa8cff588af283f20b1c3dc6f3b52053f inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6d4aac10bfa5345b587d84170441de inherit pub_methods_classsparta_1_1TreeNode" id="r_a1a6d4aac10bfa5345b587d84170441de"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a1a6d4aac10bfa5345b587d84170441de">getLocation</a> () const override final</td></tr>
<tr class="separator:a1a6d4aac10bfa5345b587d84170441de inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3290748a9c922f7c9c9dc1f919e0418 inherit pub_methods_classsparta_1_1TreeNode" id="r_aa3290748a9c922f7c9c9dc1f919e0418"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#aa3290748a9c922f7c9c9dc1f919e0418">getDisplayLocation</a> () const</td></tr>
<tr class="memdesc:aa3290748a9c922f7c9c9dc1f919e0418 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the location of this node in the device tree which <em>might</em> not be usable for navigating the device tree (it cannot be used as an argument for getChild/findChildren).  <br /></td></tr>
<tr class="separator:aa3290748a9c922f7c9c9dc1f919e0418 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad379d898cbd9b2b182b6c349650c8b6e inherit pub_methods_classsparta_1_1TreeNode" id="r_ad379d898cbd9b2b182b6c349650c8b6e"><td class="memItemLeft" align="right" valign="top">
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getExpectedLocation</b> () const</td></tr>
<tr class="memdesc:ad379d898cbd9b2b182b6c349650c8b6e inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">build-time equivalent to getLocation before an object is actually attached to a tree. This is a mainly a framework and debugging tool for determining what the location of a node currently being constructed will be when complete. <br /></td></tr>
<tr class="separator:ad379d898cbd9b2b182b6c349650c8b6e inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664c9d3ec69cbbfa5993e9b698e65518 inherit pub_methods_classsparta_1_1TreeNode" id="r_a664c9d3ec69cbbfa5993e9b698e65518"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a664c9d3ec69cbbfa5993e9b698e65518">renderSubtree</a> (int32_t max_depth=-1, bool show_builtins=false, bool names_only=false, bool hide_hidden=false, bool(*leaf_filt_fxn)(const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *)=nullptr) const</td></tr>
<tr class="memdesc:a664c9d3ec69cbbfa5993e9b698e65518 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders the subtree starting at this node as a string containing an indentation-based depth-first representation.  <br /></td></tr>
<tr class="separator:a664c9d3ec69cbbfa5993e9b698e65518 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7081d66107154ff903323fd174795340 inherit pub_methods_classsparta_1_1TreeNode" id="r_a7081d66107154ff903323fd174795340"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a7081d66107154ff903323fd174795340">getLevel</a> () const</td></tr>
<tr class="memdesc:a7081d66107154ff903323fd174795340 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the level of this node. 0 is root.  <br /></td></tr>
<tr class="separator:a7081d66107154ff903323fd174795340 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab113915ff2dc4b8ebfee5380eb912994 inherit pub_methods_classsparta_1_1TreeNode" id="r_ab113915ff2dc4b8ebfee5380eb912994"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab113915ff2dc4b8ebfee5380eb912994 inherit pub_methods_classsparta_1_1TreeNode"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#ab113915ff2dc4b8ebfee5380eb912994">getRecursiveNodeCount</a> () const</td></tr>
<tr class="memdesc:ab113915ff2dc4b8ebfee5380eb912994 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively gets the count of a nodes that are a subclass of a particular type (determined by dynamic_cast). Includes all descendants of this node in the tree, but excludes this node.  <br /></td></tr>
<tr class="separator:ab113915ff2dc4b8ebfee5380eb912994 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31ac794edcf81e88d28157056e91292 inherit pub_methods_classsparta_1_1TreeNode" id="r_af31ac794edcf81e88d28157056e91292"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#af31ac794edcf81e88d28157056e91292">getPossibleNotifications</a> (std::vector&lt; <a class="el" href="structsparta_1_1TreeNode_1_1NotificationInfo.html">NotificationInfo</a> &gt; &amp;infos) const</td></tr>
<tr class="memdesc:af31ac794edcf81e88d28157056e91292 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets information on the possible notifications generated by this node (excludes children).  <br /></td></tr>
<tr class="separator:af31ac794edcf81e88d28157056e91292 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae14d74895ad69d6e8ce3f767342800 inherit pub_methods_classsparta_1_1TreeNode" id="r_a2ae14d74895ad69d6e8ce3f767342800"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a2ae14d74895ad69d6e8ce3f767342800">dumpPossibleNotifications</a> (std::ostream &amp;o) const noexcept</td></tr>
<tr class="memdesc:a2ae14d74895ad69d6e8ce3f767342800 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps a listing of the notifications which this node can generate to the ostream o.  <br /></td></tr>
<tr class="separator:a2ae14d74895ad69d6e8ce3f767342800 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ccf18c0631ba2d1a665567db7618a6 inherit pub_methods_classsparta_1_1TreeNode" id="r_aa6ccf18c0631ba2d1a665567db7618a6"><td class="memTemplParams" colspan="2">template&lt;typename DataT  = ANY_TYPE&gt; </td></tr>
<tr class="memitem:aa6ccf18c0631ba2d1a665567db7618a6 inherit pub_methods_classsparta_1_1TreeNode"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#aa6ccf18c0631ba2d1a665567db7618a6">locateNotificationSources</a> (std::vector&lt; <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> * &gt; &amp;nodes, const std::string &amp;name=&quot;&quot;)</td></tr>
<tr class="memdesc:aa6ccf18c0631ba2d1a665567db7618a6 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all possible notification info from NotificationSources within this node's subtree.  <br /></td></tr>
<tr class="separator:aa6ccf18c0631ba2d1a665567db7618a6 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9dfcfbc1e6b004ff0d80ec3d38cbbd2 inherit pub_methods_classsparta_1_1TreeNode" id="r_af9dfcfbc1e6b004ff0d80ec3d38cbbd2"><td class="memTemplParams" colspan="2">template&lt;typename DataT  = ANY_TYPE&gt; </td></tr>
<tr class="memitem:af9dfcfbc1e6b004ff0d80ec3d38cbbd2 inherit pub_methods_classsparta_1_1TreeNode"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#af9dfcfbc1e6b004ff0d80ec3d38cbbd2">dumpLocatedNotificationSources</a> (std::ostream &amp;o, const std::string &amp;name=&quot;&quot;)</td></tr>
<tr class="memdesc:af9dfcfbc1e6b004ff0d80ec3d38cbbd2 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the relevant NotificationSources from locateNotificationSources and prints them to the output <em>o</em>.  <br /></td></tr>
<tr class="separator:af9dfcfbc1e6b004ff0d80ec3d38cbbd2 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f97e7a78ab1d0874515d2752381561 inherit pub_methods_classsparta_1_1TreeNode" id="r_a53f97e7a78ab1d0874515d2752381561"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a53f97e7a78ab1d0874515d2752381561">getPossibleSubtreeNotifications</a> (std::vector&lt; <a class="el" href="structsparta_1_1TreeNode_1_1NotificationInfo.html">NotificationInfo</a> &gt; &amp;infos) const noexcept</td></tr>
<tr class="memdesc:a53f97e7a78ab1d0874515d2752381561 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets information on the possible notifications generated by this node and all its descendants.  <br /></td></tr>
<tr class="separator:a53f97e7a78ab1d0874515d2752381561 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c94c97462083a4d9f1892c72cc14c40 inherit pub_methods_classsparta_1_1TreeNode" id="r_a3c94c97462083a4d9f1892c72cc14c40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a3c94c97462083a4d9f1892c72cc14c40">dumpPossibleSubtreeNotifications</a> (std::ostream &amp;o) const noexcept</td></tr>
<tr class="memdesc:a3c94c97462083a4d9f1892c72cc14c40 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps a listing of the notifications which this node and its descendants can generate to the ostream o.  <br /></td></tr>
<tr class="separator:a3c94c97462083a4d9f1892c72cc14c40 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91bb3b5d18785bd49e3933847eab1011 inherit pub_methods_classsparta_1_1TreeNode" id="r_a91bb3b5d18785bd49e3933847eab1011"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a91bb3b5d18785bd49e3933847eab1011">canGenerateNotification</a> (const std::type_info &amp;tinfo, const std::string *name) const</td></tr>
<tr class="memdesc:a91bb3b5d18785bd49e3933847eab1011 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> generate a notification of the given type having the given name or pattern.  <br /></td></tr>
<tr class="separator:a91bb3b5d18785bd49e3933847eab1011 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1acb8b497a9e8d9f3fc5ecae88cf1700 inherit pub_methods_classsparta_1_1TreeNode" id="r_a1acb8b497a9e8d9f3fc5ecae88cf1700"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a1acb8b497a9e8d9f3fc5ecae88cf1700">canGenerateNotification</a> (const std::type_info &amp;tinfo, const std::string &amp;name) const</td></tr>
<tr class="memdesc:a1acb8b497a9e8d9f3fc5ecae88cf1700 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> generate a notification of the given type having the given name (does not require interned string - will intern automatically with <a class="el" href="classsparta_1_1StringManager.html" title="Manages string internment for SPARTA. This allows strings to be compared by pointer once interned.">StringManager</a>).  <br /></td></tr>
<tr class="separator:a1acb8b497a9e8d9f3fc5ecae88cf1700 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace577b7bae0092cb2dc2f54b37b24273 inherit pub_methods_classsparta_1_1TreeNode" id="r_ace577b7bae0092cb2dc2f54b37b24273"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#ace577b7bae0092cb2dc2f54b37b24273">canGenerateNotification</a> (const <a class="el" href="structsparta_1_1TreeNode_1_1NotificationInfo.html">NotificationInfo</a> &amp;info) const</td></tr>
<tr class="memdesc:ace577b7bae0092cb2dc2f54b37b24273 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> generate a notification of the given <a class="el" href="structsparta_1_1TreeNode_1_1NotificationInfo.html" title="Notification type/name information.">NotificationInfo</a>.  <br /></td></tr>
<tr class="separator:ace577b7bae0092cb2dc2f54b37b24273 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae324a0d15005548d4c2ed44147d100e3 inherit pub_methods_classsparta_1_1TreeNode" id="r_ae324a0d15005548d4c2ed44147d100e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#ae324a0d15005548d4c2ed44147d100e3">canSubtreeGenerateNotification</a> (const std::type_info &amp;tinfo, const std::string *name) const</td></tr>
<tr class="memdesc:ae324a0d15005548d4c2ed44147d100e3 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> or its descendants (of any distance) generate a notification of the given type having the given name.  <br /></td></tr>
<tr class="separator:ae324a0d15005548d4c2ed44147d100e3 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed2ede13a267a23e4794c085be6621d inherit pub_methods_classsparta_1_1TreeNode" id="r_a5ed2ede13a267a23e4794c085be6621d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a5ed2ede13a267a23e4794c085be6621d">canSubtreeGenerateNotification</a> (const std::type_info &amp;tinfo, const std::string &amp;name) const</td></tr>
<tr class="memdesc:a5ed2ede13a267a23e4794c085be6621d inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> or its descendants (of any distance) generate a notification of the given type having the given name (does not require interned string)  <br /></td></tr>
<tr class="separator:a5ed2ede13a267a23e4794c085be6621d inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42372c597a4836b2505a1200c5aaf08f inherit pub_methods_classsparta_1_1TreeNode" id="r_a42372c597a4836b2505a1200c5aaf08f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a42372c597a4836b2505a1200c5aaf08f">canSubtreeGenerateNotifications</a> (const std::type_info &amp;tinfo, const std::vector&lt; const std::string * &gt; &amp;names) const</td></tr>
<tr class="memdesc:a42372c597a4836b2505a1200c5aaf08f inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if any a subtree can generate any of several notification names which may be patterns.  <br /></td></tr>
<tr class="separator:a42372c597a4836b2505a1200c5aaf08f inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6260f885d559f61593a2158545d275fb inherit pub_methods_classsparta_1_1TreeNode" id="r_a6260f885d559f61593a2158545d275fb"><td class="memTemplParams" colspan="2">template&lt;typename DataT , typename T , void(T::*)(const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &amp;, const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &amp;, const DataT &amp;) TMethod&gt; </td></tr>
<tr class="memitem:a6260f885d559f61593a2158545d275fb inherit pub_methods_classsparta_1_1TreeNode"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a6260f885d559f61593a2158545d275fb">registerForNotification</a> (T *obj, const std::string &amp;name, bool ensure_possible=true)</td></tr>
<tr class="memdesc:a6260f885d559f61593a2158545d275fb inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a callback method to listen for all notifications having the specified data type DataT and name (or any name if name is "") occuring on this node or any descendant (subtree).  <br /></td></tr>
<tr class="separator:a6260f885d559f61593a2158545d275fb inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6260f885d559f61593a2158545d275fb inherit pub_methods_classsparta_1_1TreeNode" id="r_a6260f885d559f61593a2158545d275fb"><td class="memTemplParams" colspan="2">template&lt;typename DataT , typename T , void(T::*)(const DataT &amp;) TMethod&gt; </td></tr>
<tr class="memitem:a6260f885d559f61593a2158545d275fb inherit pub_methods_classsparta_1_1TreeNode"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a6260f885d559f61593a2158545d275fb">registerForNotification</a> (T *obj, const std::string &amp;name, bool ensure_possible=true)</td></tr>
<tr class="separator:a6260f885d559f61593a2158545d275fb inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4da13fd6f93c76c3df9ded6a20b6b2 inherit pub_methods_classsparta_1_1TreeNode" id="r_a8f4da13fd6f93c76c3df9ded6a20b6b2"><td class="memTemplParams" colspan="2">template&lt;typename DataT , typename T , void(T::*)(const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &amp;, const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &amp;, const DataT &amp;) TMethod&gt; </td></tr>
<tr class="memitem:a8f4da13fd6f93c76c3df9ded6a20b6b2 inherit pub_methods_classsparta_1_1TreeNode"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a8f4da13fd6f93c76c3df9ded6a20b6b2">deregisterForNotification</a> (T *obj, const std::string &amp;name)</td></tr>
<tr class="memdesc:a8f4da13fd6f93c76c3df9ded6a20b6b2 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes at most one registration made with registerForNotification.  <br /></td></tr>
<tr class="separator:a8f4da13fd6f93c76c3df9ded6a20b6b2 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4da13fd6f93c76c3df9ded6a20b6b2 inherit pub_methods_classsparta_1_1TreeNode" id="r_a8f4da13fd6f93c76c3df9ded6a20b6b2"><td class="memTemplParams" colspan="2">template&lt;typename DataT , typename T , void(T::*)(const DataT &amp;) TMethod&gt; </td></tr>
<tr class="memitem:a8f4da13fd6f93c76c3df9ded6a20b6b2 inherit pub_methods_classsparta_1_1TreeNode"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a8f4da13fd6f93c76c3df9ded6a20b6b2">deregisterForNotification</a> (T *obj, const std::string &amp;name)</td></tr>
<tr class="separator:a8f4da13fd6f93c76c3df9ded6a20b6b2 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7b4d01402471a3021541fb7b6794c1 inherit pub_methods_classsparta_1_1TreeNode" id="r_a0e7b4d01402471a3021541fb7b6794c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a0e7b4d01402471a3021541fb7b6794c1">hasObserversRegisteredForNotification</a> (const std::type_info &amp;tinfo, const std::string *name) const noexcept</td></tr>
<tr class="memdesc:a0e7b4d01402471a3021541fb7b6794c1 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> (not descendants) has any observers for this type of event and name.  <br /></td></tr>
<tr class="separator:a0e7b4d01402471a3021541fb7b6794c1 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7191a8362fd6e301d2e6f8c37922a87 inherit pub_methods_classsparta_1_1TreeNode" id="r_aa7191a8362fd6e301d2e6f8c37922a87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#aa7191a8362fd6e301d2e6f8c37922a87">getDelegatesRegisteredForNotification</a> (const std::type_info &amp;tinfo, const std::string *name, std::vector&lt; <a class="el" href="classsparta_1_1TreeNode_1_1delegate.html">delegate</a> &gt; &amp;dels) noexcept</td></tr>
<tr class="memdesc:aa7191a8362fd6e301d2e6f8c37922a87 inherit pub_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the vector of delegates registered for a notification on this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>.  <br /></td></tr>
<tr class="separator:aa7191a8362fd6e301d2e6f8c37922a87 inherit pub_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsparta_1_1ResourceContainer"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classsparta_1_1ResourceContainer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsparta_1_1ResourceContainer.html">sparta::ResourceContainer</a></td></tr>
<tr class="memitem:a8a479c2bec0574b1dcf850aeca787b8d inherit pub_methods_classsparta_1_1ResourceContainer" id="r_a8a479c2bec0574b1dcf850aeca787b8d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceContainer.html#a8a479c2bec0574b1dcf850aeca787b8d">ResourceContainer</a> ()</td></tr>
<tr class="memdesc:a8a479c2bec0574b1dcf850aeca787b8d inherit pub_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consturct with a null, unlocked resource.  <br /></td></tr>
<tr class="separator:a8a479c2bec0574b1dcf850aeca787b8d inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41702e667255a5ebe25bf3490f4c5b9 inherit pub_methods_classsparta_1_1ResourceContainer" id="r_ac41702e667255a5ebe25bf3490f4c5b9"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>ResourceContainer</b> (const <a class="el" href="classsparta_1_1ResourceContainer.html">ResourceContainer</a> &amp;)=delete</td></tr>
<tr class="memdesc:ac41702e667255a5ebe25bf3490f4c5b9 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy construction disbled. <br /></td></tr>
<tr class="separator:ac41702e667255a5ebe25bf3490f4c5b9 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0813d7f0d4d4854c4416f5d1273b5e23 inherit pub_methods_classsparta_1_1ResourceContainer" id="r_a0813d7f0d4d4854c4416f5d1273b5e23"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>ResourceContainer</b> (<a class="el" href="classsparta_1_1ResourceContainer.html">ResourceContainer</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a0813d7f0d4d4854c4416f5d1273b5e23 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:a0813d7f0d4d4854c4416f5d1273b5e23 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977139ced57391b242cbf5a7c9f0057e inherit pub_methods_classsparta_1_1ResourceContainer" id="r_a977139ced57391b242cbf5a7c9f0057e"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceContainer.html#a977139ced57391b242cbf5a7c9f0057e">~ResourceContainer</a> ()</td></tr>
<tr class="memdesc:a977139ced57391b242cbf5a7c9f0057e inherit pub_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a977139ced57391b242cbf5a7c9f0057e inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e1258a847b8f0f7fefa5c9831a7b30 inherit pub_methods_classsparta_1_1ResourceContainer" id="r_aa3e1258a847b8f0f7fefa5c9831a7b30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Resource.html">Resource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceContainer.html#aa3e1258a847b8f0f7fefa5c9831a7b30">getResource</a> ()</td></tr>
<tr class="memdesc:aa3e1258a847b8f0f7fefa5c9831a7b30 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the resource contained by this node if any. May only be called after finalization begins or during teardown.  <br /></td></tr>
<tr class="separator:aa3e1258a847b8f0f7fefa5c9831a7b30 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82fd8bcb21af2b6346a7456248ee8804 inherit pub_methods_classsparta_1_1ResourceContainer" id="r_a82fd8bcb21af2b6346a7456248ee8804"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsparta_1_1Resource.html">Resource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceContainer.html#a82fd8bcb21af2b6346a7456248ee8804">getResource</a> () const</td></tr>
<tr class="memdesc:a82fd8bcb21af2b6346a7456248ee8804 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const variant of getResource.  <br /></td></tr>
<tr class="separator:a82fd8bcb21af2b6346a7456248ee8804 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c09a05a5ec552674712e70c9d44ca9 inherit pub_methods_classsparta_1_1ResourceContainer" id="r_ac1c09a05a5ec552674712e70c9d44ca9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceContainer.html#ac1c09a05a5ec552674712e70c9d44ca9">hasResource</a> () const</td></tr>
<tr class="memdesc:ac1c09a05a5ec552674712e70c9d44ca9 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this node has a resource. This method exists in case the <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> is being explored by a tool or interactive UI. Typical <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> clients (such as Resources) will assume that there is a resource if they are expecting one.  <br /></td></tr>
<tr class="separator:ac1c09a05a5ec552674712e70c9d44ca9 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6dc7a027715d3981f50bc0823bde07 inherit pub_methods_classsparta_1_1ResourceContainer" id="r_a8a6dc7a027715d3981f50bc0823bde07"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a8a6dc7a027715d3981f50bc0823bde07 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memTemplItemLeft" align="right" valign="top">const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceContainer.html#a8a6dc7a027715d3981f50bc0823bde07">getResourceAs</a> () const</td></tr>
<tr class="memdesc:a8a6dc7a027715d3981f50bc0823bde07 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the resource contained by this node (if any) as the given type.  <br /></td></tr>
<tr class="separator:a8a6dc7a027715d3981f50bc0823bde07 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822ceaa97abb81b3b1a94b168662ab02 inherit pub_methods_classsparta_1_1ResourceContainer" id="r_a822ceaa97abb81b3b1a94b168662ab02"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;!std::is_pointer&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a822ceaa97abb81b3b1a94b168662ab02 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceContainer.html#a822ceaa97abb81b3b1a94b168662ab02">getResourceAs</a> () const</td></tr>
<tr class="memdesc:a822ceaa97abb81b3b1a94b168662ab02 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of getResourceAs for const access with a non-pointer template type.  <br /></td></tr>
<tr class="separator:a822ceaa97abb81b3b1a94b168662ab02 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1947e9a45d8d05360358f320df932f8c inherit pub_methods_classsparta_1_1ResourceContainer" id="r_a1947e9a45d8d05360358f320df932f8c"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a1947e9a45d8d05360358f320df932f8c inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceContainer.html#a1947e9a45d8d05360358f320df932f8c">getResourceAs</a> ()</td></tr>
<tr class="memdesc:a1947e9a45d8d05360358f320df932f8c inherit pub_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-const overload of getResourceAs.  <br /></td></tr>
<tr class="separator:a1947e9a45d8d05360358f320df932f8c inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1099102e1ae7b48a4c82ac552e00bebe inherit pub_methods_classsparta_1_1ResourceContainer" id="r_a1099102e1ae7b48a4c82ac552e00bebe"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = typename std::enable_if&lt;!std::is_pointer&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a1099102e1ae7b48a4c82ac552e00bebe inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceContainer.html#a1099102e1ae7b48a4c82ac552e00bebe">getResourceAs</a> ()</td></tr>
<tr class="memdesc:a1099102e1ae7b48a4c82ac552e00bebe inherit pub_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-const overload of getResourceAs.  <br /></td></tr>
<tr class="separator:a1099102e1ae7b48a4c82ac552e00bebe inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be07910a07b37568990abe61bdf25a8 inherit pub_methods_classsparta_1_1ResourceContainer" id="r_a3be07910a07b37568990abe61bdf25a8"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceContainer.html#a3be07910a07b37568990abe61bdf25a8">getResourceType</a> () const</td></tr>
<tr class="memdesc:a3be07910a07b37568990abe61bdf25a8 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the typename of the resource that this node will eventually contain.  <br /></td></tr>
<tr class="separator:a3be07910a07b37568990abe61bdf25a8 inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae244126daf829d0ef231a1f7707a6c3b inherit pub_methods_classsparta_1_1ResourceContainer" id="r_ae244126daf829d0ef231a1f7707a6c3b"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceContainer.html#ae244126daf829d0ef231a1f7707a6c3b">getResourceTypeRaw</a> () const</td></tr>
<tr class="memdesc:ae244126daf829d0ef231a1f7707a6c3b inherit pub_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the typename of the resource that this node will eventually contain.  <br /></td></tr>
<tr class="separator:ae244126daf829d0ef231a1f7707a6c3b inherit pub_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsparta_1_1PhasedObject"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classsparta_1_1PhasedObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsparta_1_1PhasedObject.html">sparta::PhasedObject</a></td></tr>
<tr class="memitem:adc31c312d56f17422baba4fb5c6f92c1 inherit pub_methods_classsparta_1_1PhasedObject" id="r_adc31c312d56f17422baba4fb5c6f92c1"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>PhasedObject</b> (<a class="el" href="classsparta_1_1PhasedObject.html">PhasedObject</a> &amp;&amp;)=default</td></tr>
<tr class="separator:adc31c312d56f17422baba4fb5c6f92c1 inherit pub_methods_classsparta_1_1PhasedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade690bdb9df72fd6bad8847fbdf226f1 inherit pub_methods_classsparta_1_1PhasedObject" id="r_ade690bdb9df72fd6bad8847fbdf226f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1PhasedObject.html#afe9c78396c961fd96f0975867197b366">TreePhase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1PhasedObject.html#ade690bdb9df72fd6bad8847fbdf226f1">getPhase</a> () const</td></tr>
<tr class="memdesc:ade690bdb9df72fd6bad8847fbdf226f1 inherit pub_methods_classsparta_1_1PhasedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the trees current phase.  <br /></td></tr>
<tr class="separator:ade690bdb9df72fd6bad8847fbdf226f1 inherit pub_methods_classsparta_1_1PhasedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05218ff46e1e188b655c4da0a4719085 inherit pub_methods_classsparta_1_1PhasedObject" id="r_a05218ff46e1e188b655c4da0a4719085"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1PhasedObject.html#a05218ff46e1e188b655c4da0a4719085">isBuilding</a> () const</td></tr>
<tr class="memdesc:a05218ff46e1e188b655c4da0a4719085 inherit pub_methods_classsparta_1_1PhasedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this node (and thus the entire tree above and below it) currently in the TREE_BUILDING phase.  <br /></td></tr>
<tr class="separator:a05218ff46e1e188b655c4da0a4719085 inherit pub_methods_classsparta_1_1PhasedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4b14b23643204798dbc994f3cca77e inherit pub_methods_classsparta_1_1PhasedObject" id="r_aba4b14b23643204798dbc994f3cca77e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1PhasedObject.html#aba4b14b23643204798dbc994f3cca77e">isBuilt</a> () const</td></tr>
<tr class="memdesc:aba4b14b23643204798dbc994f3cca77e inherit pub_methods_classsparta_1_1PhasedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this node (and thus the entire tree above it) "built". Checks that getPhase has passed TREE_BUILDING.  <br /></td></tr>
<tr class="separator:aba4b14b23643204798dbc994f3cca77e inherit pub_methods_classsparta_1_1PhasedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693545aae3e991b023459d03250ec92b inherit pub_methods_classsparta_1_1PhasedObject" id="r_a693545aae3e991b023459d03250ec92b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1PhasedObject.html#a693545aae3e991b023459d03250ec92b">isConfigured</a> () const</td></tr>
<tr class="memdesc:a693545aae3e991b023459d03250ec92b inherit pub_methods_classsparta_1_1PhasedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this node (and thus the entire tree above it) "configured". Checks that getPhase has <em>passed</em> TREE_CONFIGURING (i.e. FINALIZED, FINALIZING, TEARDOWN, etc).  <br /></td></tr>
<tr class="separator:a693545aae3e991b023459d03250ec92b inherit pub_methods_classsparta_1_1PhasedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a8f0a9a0e2bdd7437b7a8a13b48e93 inherit pub_methods_classsparta_1_1PhasedObject" id="r_af8a8f0a9a0e2bdd7437b7a8a13b48e93"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1PhasedObject.html#af8a8f0a9a0e2bdd7437b7a8a13b48e93">isConfiguring</a> () const</td></tr>
<tr class="memdesc:af8a8f0a9a0e2bdd7437b7a8a13b48e93 inherit pub_methods_classsparta_1_1PhasedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this node (and thus the entire tree above it) currently in the TREE_CONFIGURING phase.  <br /></td></tr>
<tr class="separator:af8a8f0a9a0e2bdd7437b7a8a13b48e93 inherit pub_methods_classsparta_1_1PhasedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c50c75766fa4096ba77b12c3a53edd1 inherit pub_methods_classsparta_1_1PhasedObject" id="r_a5c50c75766fa4096ba77b12c3a53edd1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1PhasedObject.html#a5c50c75766fa4096ba77b12c3a53edd1">isFinalizing</a> () const</td></tr>
<tr class="memdesc:a5c50c75766fa4096ba77b12c3a53edd1 inherit pub_methods_classsparta_1_1PhasedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this node (and thus the entire tree above it) "finalized".  <br /></td></tr>
<tr class="separator:a5c50c75766fa4096ba77b12c3a53edd1 inherit pub_methods_classsparta_1_1PhasedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8edefaf47c41a0be179827e657955d5 inherit pub_methods_classsparta_1_1PhasedObject" id="r_ac8edefaf47c41a0be179827e657955d5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1PhasedObject.html#ac8edefaf47c41a0be179827e657955d5">isFinalized</a> () const</td></tr>
<tr class="memdesc:ac8edefaf47c41a0be179827e657955d5 inherit pub_methods_classsparta_1_1PhasedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this node (and thus the entire tree above it) "finalized".  <br /></td></tr>
<tr class="separator:ac8edefaf47c41a0be179827e657955d5 inherit pub_methods_classsparta_1_1PhasedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8555fc19699141ca78722846bd2e2dc3 inherit pub_methods_classsparta_1_1PhasedObject" id="r_a8555fc19699141ca78722846bd2e2dc3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1PhasedObject.html#a8555fc19699141ca78722846bd2e2dc3">isTearingDown</a> () const</td></tr>
<tr class="memdesc:a8555fc19699141ca78722846bd2e2dc3 inherit pub_methods_classsparta_1_1PhasedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this node (and thus the entire tree above it) in the "teardown" phase.  <br /></td></tr>
<tr class="separator:a8555fc19699141ca78722846bd2e2dc3 inherit pub_methods_classsparta_1_1PhasedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsparta_1_1ArchDataContainer"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classsparta_1_1ArchDataContainer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsparta_1_1ArchDataContainer.html">sparta::ArchDataContainer</a></td></tr>
<tr class="memitem:a500b3d7a15538143d9e7d6fdea994e30 inherit pub_methods_classsparta_1_1ArchDataContainer" id="r_a500b3d7a15538143d9e7d6fdea994e30"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classsparta_1_1ArchData.html">ArchData</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ArchDataContainer.html#a500b3d7a15538143d9e7d6fdea994e30">getAssociatedArchDatas</a> ()</td></tr>
<tr class="memdesc:a500b3d7a15538143d9e7d6fdea994e30 inherit pub_methods_classsparta_1_1ArchDataContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves all ArchDatas associated with this <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> so that children can use it to allocate their data.  <br /></td></tr>
<tr class="separator:a500b3d7a15538143d9e7d6fdea994e30 inherit pub_methods_classsparta_1_1ArchDataContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c55bc976fbc40ab4eee8cda5bcf6851 inherit pub_methods_classsparta_1_1ArchDataContainer" id="r_a3c55bc976fbc40ab4eee8cda5bcf6851"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classsparta_1_1ArchData.html">ArchData</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ArchDataContainer.html#a3c55bc976fbc40ab4eee8cda5bcf6851">getAssociatedArchDatas</a> () const</td></tr>
<tr class="memdesc:a3c55bc976fbc40ab4eee8cda5bcf6851 inherit pub_methods_classsparta_1_1ArchDataContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const variant of getAssociatedArchDatas.  <br /></td></tr>
<tr class="separator:a3c55bc976fbc40ab4eee8cda5bcf6851 inherit pub_methods_classsparta_1_1ArchDataContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4bff55ea4a5703b720aea8c66f7f3e6 inherit pub_methods_classsparta_1_1ArchDataContainer" id="r_af4bff55ea4a5703b720aea8c66f7f3e6"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>ArchDataContainer</b> ()=default</td></tr>
<tr class="memdesc:af4bff55ea4a5703b720aea8c66f7f3e6 inherit pub_methods_classsparta_1_1ArchDataContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:af4bff55ea4a5703b720aea8c66f7f3e6 inherit pub_methods_classsparta_1_1ArchDataContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba47c80ce109e690f35171781201153 inherit pub_methods_classsparta_1_1ArchDataContainer" id="r_a2ba47c80ce109e690f35171781201153"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>ArchDataContainer</b> (<a class="el" href="classsparta_1_1ArchDataContainer.html">ArchDataContainer</a> &amp;)=delete</td></tr>
<tr class="memdesc:a2ba47c80ce109e690f35171781201153 inherit pub_methods_classsparta_1_1ArchDataContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy construction disabled. <br /></td></tr>
<tr class="separator:a2ba47c80ce109e690f35171781201153 inherit pub_methods_classsparta_1_1ArchDataContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22e5fc7d2ce25293f53a5c808dbea4c inherit pub_methods_classsparta_1_1ArchDataContainer" id="r_ac22e5fc7d2ce25293f53a5c808dbea4c"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>ArchDataContainer</b> (<a class="el" href="classsparta_1_1ArchDataContainer.html">ArchDataContainer</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:ac22e5fc7d2ce25293f53a5c808dbea4c inherit pub_methods_classsparta_1_1ArchDataContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:ac22e5fc7d2ce25293f53a5c808dbea4c inherit pub_methods_classsparta_1_1ArchDataContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3b7270932f010fbe0613bf7e862dfb inherit pub_methods_classsparta_1_1ArchDataContainer" id="r_abb3b7270932f010fbe0613bf7e862dfb"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ArchDataContainer.html#abb3b7270932f010fbe0613bf7e862dfb">~ArchDataContainer</a> ()</td></tr>
<tr class="memdesc:abb3b7270932f010fbe0613bf7e862dfb inherit pub_methods_classsparta_1_1ArchDataContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <br /></td></tr>
<tr class="separator:abb3b7270932f010fbe0613bf7e862dfb inherit pub_methods_classsparta_1_1ArchDataContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac9f229421bbf30864b87e1d8d0b87b63" id="r_ac9f229421bbf30864b87e1d8d0b87b63"><td class="memTemplParams" colspan="2">template&lt;class U , class C1 &gt; </td></tr>
<tr class="memitem:ac9f229421bbf30864b87e1d8d0b87b63"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structsparta_1_1is__vector.html">is_vector</a>&lt; C1 &gt;::value, <a class="el" href="classsparta_1_1Parameter.html">Parameter</a>&lt; ValueType &gt; &amp; &gt;<a class="el" href="#ad75bb728b6180aa7caad038ef7ad5d7f">::type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac9f229421bbf30864b87e1d8d0b87b63">operator_insert_</a> (U e)</td></tr>
<tr class="separator:ac9f229421bbf30864b87e1d8d0b87b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c640d813504d794d67b50a456944357" id="r_a6c640d813504d794d67b50a456944357"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c640d813504d794d67b50a456944357">setValueFromStringImpl_</a> (const std::string &amp;str, bool poke=false) override final</td></tr>
<tr class="memdesc:a6c640d813504d794d67b50a456944357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements setValueFromString.  <br /></td></tr>
<tr class="separator:a6c640d813504d794d67b50a456944357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43e3b2c14e93c55198c4a539fc005aa" id="r_aa43e3b2c14e93c55198c4a539fc005aa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa43e3b2c14e93c55198c4a539fc005aa">setValueFromStringVectorImpl_</a> (const std::vector&lt; std::string &gt; &amp;vec, bool poke=false) override final</td></tr>
<tr class="memdesc:aa43e3b2c14e93c55198c4a539fc005aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements setValueFromStringVectorImpl_.  <br /></td></tr>
<tr class="separator:aa43e3b2c14e93c55198c4a539fc005aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5aa8e225f7294ea2fe9affcc15ef97" id="r_a2b5aa8e225f7294ea2fe9affcc15ef97"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b5aa8e225f7294ea2fe9affcc15ef97">setItemValueFromStringImpl_</a> (const std::vector&lt; uint32_t &gt; &amp;indices, const std::string &amp;str) override final</td></tr>
<tr class="memdesc:a2b5aa8e225f7294ea2fe9affcc15ef97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements setItemValueFromStringImpl_.  <br /></td></tr>
<tr class="separator:a2b5aa8e225f7294ea2fe9affcc15ef97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ec20115fc09a5da95e1efe6de7712b" id="r_aa3ec20115fc09a5da95e1efe6de7712b"><td class="memItemLeft" align="right" valign="top">const ValueType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3ec20115fc09a5da95e1efe6de7712b">getValue_</a> () const</td></tr>
<tr class="memdesc:aa3ec20115fc09a5da95e1efe6de7712b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iternal getValue_ wrapper which does not increment the read counter.  <br /></td></tr>
<tr class="separator:aa3ec20115fc09a5da95e1efe6de7712b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a822ca562a0e7cfbb70ca60c509031" id="r_a14a822ca562a0e7cfbb70ca60c509031"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a14a822ca562a0e7cfbb70ca60c509031"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, double &gt;<a class="el" href="#ad75bb728b6180aa7caad038ef7ad5d7f">::type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a14a822ca562a0e7cfbb70ca60c509031">getDoubleValue_</a> () const</td></tr>
<tr class="separator:a14a822ca562a0e7cfbb70ca60c509031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ecb91c7d429228593a7701e33c5d34" id="r_a90ecb91c7d429228593a7701e33c5d34"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a90ecb91c7d429228593a7701e33c5d34"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_arithmetic&lt; T &gt;::value, double &gt;<a class="el" href="#ad75bb728b6180aa7caad038ef7ad5d7f">::type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a90ecb91c7d429228593a7701e33c5d34">getDoubleValue_</a> () const</td></tr>
<tr class="separator:a90ecb91c7d429228593a7701e33c5d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classsparta_1_1ParameterBase"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classsparta_1_1ParameterBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classsparta_1_1ParameterBase.html">sparta::ParameterBase</a></td></tr>
<tr class="memitem:aaad5463c9c64d156059ccc9c3f0e8380 inherit pro_methods_classsparta_1_1ParameterBase" id="r_aaad5463c9c64d156059ccc9c3f0e8380"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html#aaad5463c9c64d156059ccc9c3f0e8380">unread_</a> () const</td></tr>
<tr class="memdesc:aaad5463c9c64d156059ccc9c3f0e8380 inherit pro_methods_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark this parameter as unread and unignored This is used or preloading defaults to parameters and then clearing the write count. It is intended to be used by <a class="el" href="classsparta_1_1ParameterSet.html" title="Generic container of Parameters.">ParameterSet</a>.  <br /></td></tr>
<tr class="separator:aaad5463c9c64d156059ccc9c3f0e8380 inherit pro_methods_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e3f0af10beb201fd8e49f770c6ea73 inherit pro_methods_classsparta_1_1ParameterBase" id="r_ac3e3f0af10beb201fd8e49f770c6ea73"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>invokeModifierCB_</b> ()</td></tr>
<tr class="memdesc:ac3e3f0af10beb201fd8e49f770c6ea73 inherit pro_methods_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke any register callbacks for this parameter. These callbacks are used by Parameters to make modifications to other parameters. <br /></td></tr>
<tr class="separator:ac3e3f0af10beb201fd8e49f770c6ea73 inherit pro_methods_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0663f6e558287f2d89b8d573504d9eb9 inherit pro_methods_classsparta_1_1ParameterBase" id="r_a0663f6e558287f2d89b8d573504d9eb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html#a0663f6e558287f2d89b8d573504d9eb9">incrementReadCount_</a> () const</td></tr>
<tr class="memdesc:a0663f6e558287f2d89b8d573504d9eb9 inherit pro_methods_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the number of reads that will be reported by getReadCount.  <br /></td></tr>
<tr class="separator:a0663f6e558287f2d89b8d573504d9eb9 inherit pro_methods_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03addcff7db396f643149458febf51e4 inherit pro_methods_classsparta_1_1ParameterBase" id="r_a03addcff7db396f643149458febf51e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html#a03addcff7db396f643149458febf51e4">resetReadCount_</a> () const</td></tr>
<tr class="memdesc:a03addcff7db396f643149458febf51e4 inherit pro_methods_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the number of reads that wil be reported by getReadCount.  <br /></td></tr>
<tr class="separator:a03addcff7db396f643149458febf51e4 inherit pro_methods_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ee4bdd406f554623d7709e17dfa614 inherit pro_methods_classsparta_1_1ParameterBase" id="r_a97ee4bdd406f554623d7709e17dfa614"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html#a97ee4bdd406f554623d7709e17dfa614">resetWriteCount_</a> ()</td></tr>
<tr class="memdesc:a97ee4bdd406f554623d7709e17dfa614 inherit pro_methods_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the number of writes that wil be reported by getWriteCount.  <br /></td></tr>
<tr class="separator:a97ee4bdd406f554623d7709e17dfa614 inherit pro_methods_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55bec773f43345955122381515d0173 inherit pro_methods_classsparta_1_1ParameterBase" id="r_af55bec773f43345955122381515d0173"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html#af55bec773f43345955122381515d0173">ignore_</a> () const</td></tr>
<tr class="memdesc:af55bec773f43345955122381515d0173 inherit pro_methods_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag as ignored. See <a class="el" href="#aa038c634ce8cc174ab250c94e7422772" title="Marks this parameter as ignored.">Parameter&lt;T&gt;::ignore</a>.  <br /></td></tr>
<tr class="separator:af55bec773f43345955122381515d0173 inherit pro_methods_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b7033f61214146640a83e64fb1f9b1 inherit pro_methods_classsparta_1_1ParameterBase" id="r_ac0b7033f61214146640a83e64fb1f9b1"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>usingFinalConfig_</b> ()</td></tr>
<tr class="memdesc:ac0b7033f61214146640a83e64fb1f9b1 inherit pro_methods_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask the simulator if we are using a final config. <br /></td></tr>
<tr class="separator:ac0b7033f61214146640a83e64fb1f9b1 inherit pro_methods_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa5c793d436deda683384bc989615ef inherit pro_methods_classsparta_1_1ParameterBase" id="r_a6fa5c793d436deda683384bc989615ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html#a6fa5c793d436deda683384bc989615ef">incrementWriteCount_</a> ()</td></tr>
<tr class="memdesc:a6fa5c793d436deda683384bc989615ef inherit pro_methods_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the number of writes that will be reported by getWriteCount.  <br /></td></tr>
<tr class="separator:a6fa5c793d436deda683384bc989615ef inherit pro_methods_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d86d257ad2c5cd7fceced18a4351e2 inherit pro_methods_classsparta_1_1ParameterBase" id="r_aa6d86d257ad2c5cd7fceced18a4351e2"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>logLoadedDefaultValue_</b> () const</td></tr>
<tr class="memdesc:aa6d86d257ad2c5cd7fceced18a4351e2 inherit pro_methods_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log the default loaded to this parameter to the global parameters logger for debugging. <br /></td></tr>
<tr class="separator:aa6d86d257ad2c5cd7fceced18a4351e2 inherit pro_methods_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab639ac53e587869d2d7981a1b89e8285 inherit pro_methods_classsparta_1_1ParameterBase" id="r_ab639ac53e587869d2d7981a1b89e8285"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>logAssignedValue_</b> () const</td></tr>
<tr class="memdesc:ab639ac53e587869d2d7981a1b89e8285 inherit pro_methods_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log the most recently assigned value given to this parameter to the global parameters logger for debugging. <br /></td></tr>
<tr class="separator:ab639ac53e587869d2d7981a1b89e8285 inherit pro_methods_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8e89c2cc054d0f04adcff951783991 inherit pro_methods_classsparta_1_1ParameterBase" id="r_ace8e89c2cc054d0f04adcff951783991"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html#ace8e89c2cc054d0f04adcff951783991">addToSet_</a> (<a class="el" href="classsparta_1_1ParameterSet.html">ParameterSet</a> *ps)</td></tr>
<tr class="memdesc:ace8e89c2cc054d0f04adcff951783991 inherit pro_methods_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add this parameter to a set - an action which is protected and requires the friendship that the Parameter&lt;&gt; class has.  <br /></td></tr>
<tr class="separator:ace8e89c2cc054d0f04adcff951783991 inherit pro_methods_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classsparta_1_1TreeNode"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classsparta_1_1TreeNode')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a></td></tr>
<tr class="memitem:aa662b6ea451b3f69664881508e048f8a inherit pro_methods_classsparta_1_1TreeNode" id="r_aa662b6ea451b3f69664881508e048f8a"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint32_t, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#aa662b6ea451b3f69664881508e048f8a">recursGetDeepestMatchingPath_</a> (const std::string &amp;path, size_t name_pos) const</td></tr>
<tr class="memdesc:aa662b6ea451b3f69664881508e048f8a inherit pro_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the deepest node path mathing the input <em>path</em>. Implements getDeepestMatchingPath.  <br /></td></tr>
<tr class="separator:aa662b6ea451b3f69664881508e048f8a inherit pro_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeefcb776a4574cd8075f92caaeb4676d inherit pro_methods_classsparta_1_1TreeNode" id="r_aeefcb776a4574cd8075f92caaeb4676d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#aeefcb776a4574cd8075f92caaeb4676d">setExpectedParent_</a> (const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *parent)</td></tr>
<tr class="memdesc:aeefcb776a4574cd8075f92caaeb4676d inherit pro_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks a node as an expected parent without actually adding this node as a child. This is used almost exclusively for printing error messages which include a device-tree location BEFORE actually inserting this node into the device tree since node construction can fail.  <br /></td></tr>
<tr class="separator:aeefcb776a4574cd8075f92caaeb4676d inherit pro_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774d31f6b6d00ff9d18dbcba38785657 inherit pro_methods_classsparta_1_1TreeNode" id="r_a774d31f6b6d00ff9d18dbcba38785657"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a774d31f6b6d00ff9d18dbcba38785657">enterFinalizing_</a> ()</td></tr>
<tr class="memdesc:a774d31f6b6d00ff9d18dbcba38785657 inherit pro_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively enter TREE_FINALIZING phase.  <br /></td></tr>
<tr class="separator:a774d31f6b6d00ff9d18dbcba38785657 inherit pro_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9928daa22b0eba5897a854a266dc6684 inherit pro_methods_classsparta_1_1TreeNode" id="r_a9928daa22b0eba5897a854a266dc6684"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a9928daa22b0eba5897a854a266dc6684">finalizeTree_</a> ()</td></tr>
<tr class="memdesc:a9928daa22b0eba5897a854a266dc6684 inherit pro_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively create resources based on tree configuration. enter_finalize_ should be invoked after this method successfully completes for an entire tree. Finalizes in the order of construction.  <br /></td></tr>
<tr class="separator:a9928daa22b0eba5897a854a266dc6684 inherit pro_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22142bfb1cc678347ae0e371aeb8520a inherit pro_methods_classsparta_1_1TreeNode" id="r_a22142bfb1cc678347ae0e371aeb8520a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a22142bfb1cc678347ae0e371aeb8520a">validateTree_</a> ()</td></tr>
<tr class="memdesc:a22142bfb1cc678347ae0e371aeb8520a inherit pro_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates the finalized tree and validates each node (e.g. ensures statistics can be evaluated)  <br /></td></tr>
<tr class="separator:a22142bfb1cc678347ae0e371aeb8520a inherit pro_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8744a27ae66472ac72860f0fdc9b0149 inherit pro_methods_classsparta_1_1TreeNode" id="r_a8744a27ae66472ac72860f0fdc9b0149"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a8744a27ae66472ac72860f0fdc9b0149">enterFinalized_</a> ()</td></tr>
<tr class="memdesc:a8744a27ae66472ac72860f0fdc9b0149 inherit pro_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively enter TREE_FINALIZED phase.  <br /></td></tr>
<tr class="separator:a8744a27ae66472ac72860f0fdc9b0149 inherit pro_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2cab43bc4edc2befcfab06e08c4797e inherit pro_methods_classsparta_1_1TreeNode" id="r_ac2cab43bc4edc2befcfab06e08c4797e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#ac2cab43bc4edc2befcfab06e08c4797e">enterConfig_</a> () noexcept</td></tr>
<tr class="memdesc:ac2cab43bc4edc2befcfab06e08c4797e inherit pro_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively enter TREE_CONFIGURING phase.  <br /></td></tr>
<tr class="separator:ac2cab43bc4edc2befcfab06e08c4797e inherit pro_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed70a4d3e810f583e394752685233c69 inherit pro_methods_classsparta_1_1TreeNode" id="r_aed70a4d3e810f583e394752685233c69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#aed70a4d3e810f583e394752685233c69">bindTreeEarly_</a> ()</td></tr>
<tr class="memdesc:aed70a4d3e810f583e394752685233c69 inherit pro_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively invoke TreeNode::onBindTreeEarly_ and Resource::onBindTreeEarly_ (in that order for each node)  <br /></td></tr>
<tr class="separator:aed70a4d3e810f583e394752685233c69 inherit pro_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3865c3ca676372326557b644bc1c305 inherit pro_methods_classsparta_1_1TreeNode" id="r_ae3865c3ca676372326557b644bc1c305"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#ae3865c3ca676372326557b644bc1c305">bindTreeLate_</a> ()</td></tr>
<tr class="memdesc:ae3865c3ca676372326557b644bc1c305 inherit pro_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively invoke TreeNode::onBindTreeEarly_ and Resource::onBindTreeLate_ (in that order for each node)  <br /></td></tr>
<tr class="separator:ae3865c3ca676372326557b644bc1c305 inherit pro_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c82ded98e4ee01463a9fbd05a56d5f inherit pro_methods_classsparta_1_1TreeNode" id="r_a36c82ded98e4ee01463a9fbd05a56d5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a36c82ded98e4ee01463a9fbd05a56d5f">simulationTerminating_</a> ()</td></tr>
<tr class="memdesc:a36c82ded98e4ee01463a9fbd05a56d5f inherit pro_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hook to allow simulation resources to clean-up before simulation is ended.  <br /></td></tr>
<tr class="separator:a36c82ded98e4ee01463a9fbd05a56d5f inherit pro_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7234b200ace13c97244698a7370d0971 inherit pro_methods_classsparta_1_1TreeNode" id="r_a7234b200ace13c97244698a7370d0971"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a7234b200ace13c97244698a7370d0971">validatePostRun_</a> (const <a class="el" href="classsparta_1_1PostRunValidationInfo.html">PostRunValidationInfo</a> &amp;info) const</td></tr>
<tr class="memdesc:a7234b200ace13c97244698a7370d0971 inherit pro_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hook to check the state of the simulator post-run and throw exceptions if something is incorrect.  <br /></td></tr>
<tr class="separator:a7234b200ace13c97244698a7370d0971 inherit pro_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac08b48b8d658459cd947170e0b92a0b inherit pro_methods_classsparta_1_1TreeNode" id="r_aac08b48b8d658459cd947170e0b92a0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#aac08b48b8d658459cd947170e0b92a0b">dumpDebugContent_</a> (std::ostream &amp;out) const noexcept</td></tr>
<tr class="memdesc:aac08b48b8d658459cd947170e0b92a0b inherit pro_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows resources to write out detailed textual debugging information about the node. This is typically called by a simulator when shutting down due to an exception (or depending on simulator config). However, it could also be called at other times.  <br /></td></tr>
<tr class="separator:aac08b48b8d658459cd947170e0b92a0b inherit pro_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7ae09a1aa188a5570ec00d90a37d21 inherit pro_methods_classsparta_1_1TreeNode" id="r_a3f7ae09a1aa188a5570ec00d90a37d21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a3f7ae09a1aa188a5570ec00d90a37d21">enterTeardown_</a> () noexcept</td></tr>
<tr class="memdesc:a3f7ae09a1aa188a5570ec00d90a37d21 inherit pro_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively enter TREE_TEARDOWN phase while alerting nodes through onEnteringTeardown_ and alterting Resources through Resource::onStartingTeardown_. Nodes already in TREE_TEARDOWN phase will not be alerted (neither will their associated Resources). All nodes are visited regardless of their parent's phase.  <br /></td></tr>
<tr class="separator:a3f7ae09a1aa188a5570ec00d90a37d21 inherit pro_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0f48ca47859f290f346425fea67443 inherit pro_methods_classsparta_1_1TreeNode" id="r_a6b0f48ca47859f290f346425fea67443"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a6b0f48ca47859f290f346425fea67443">verifyUniqueChildIdentifier_</a> (const std::string &amp;ident, bool ignore_group_collision=false)</td></tr>
<tr class="memdesc:a6b0f48ca47859f290f346425fea67443 inherit pro_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies that the given identifier is unique for all children of this node by comparing against names, groups, and aliases. Throws <a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a> if not unique.  <br /></td></tr>
<tr class="separator:a6b0f48ca47859f290f346425fea67443 inherit pro_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad747a7ea6e0fdfb7421fc2bcc4db9e8f inherit pro_methods_classsparta_1_1TreeNode" id="r_ad747a7ea6e0fdfb7421fc2bcc4db9e8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#ad747a7ea6e0fdfb7421fc2bcc4db9e8f">removeChildForTeardown_</a> (<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *child)</td></tr>
<tr class="memdesc:ad747a7ea6e0fdfb7421fc2bcc4db9e8f inherit pro_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Removes" the given child by invoking onDestroyingChild_ then removing this child from the children_ list  <br /></td></tr>
<tr class="separator:ad747a7ea6e0fdfb7421fc2bcc4db9e8f inherit pro_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52ced91b3e4228df74f70678e0e9f7e inherit pro_methods_classsparta_1_1TreeNode" id="r_af52ced91b3e4228df74f70678e0e9f7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#af52ced91b3e4228df74f70678e0e9f7e">removeFromParentForTeardown_</a> (<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *parent)</td></tr>
<tr class="memdesc:af52ced91b3e4228df74f70678e0e9f7e inherit pro_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protected Wrapper for <a class="el" href="classsparta_1_1TreeNode.html#aa8958d72a1f5aeff2ec36012913ac09c" title="Gets immediate parent of this node if one exists.">getParent()</a>-&gt;removeChildForTeardown_ which allows subclases of <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> to indirectly invoke removeChildForTeardown_ with themselves as the argument.  <br /></td></tr>
<tr class="separator:af52ced91b3e4228df74f70678e0e9f7e inherit pro_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de0d978208d5a7f050a829da9db6558 inherit pro_methods_classsparta_1_1TreeNode" id="r_a6de0d978208d5a7f050a829da9db6558"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>detachFromParent_</b> ()</td></tr>
<tr class="memdesc:a6de0d978208d5a7f050a829da9db6558 inherit pro_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a node from its parent with the expectation this node will be immediately destroyed (i.e. is an xvalue) <br /></td></tr>
<tr class="separator:a6de0d978208d5a7f050a829da9db6558 inherit pro_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ceb5bf7eed5807a8cfd36e36d7919e inherit pro_methods_classsparta_1_1TreeNode" id="r_a26ceb5bf7eed5807a8cfd36e36d7919e"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>detachFromChildren_</b> ()</td></tr>
<tr class="memdesc:a26ceb5bf7eed5807a8cfd36e36d7919e inherit pro_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a node from its children with the expectation this node will be immediately destroyed (i.e. is an xvalue) <br /></td></tr>
<tr class="separator:a26ceb5bf7eed5807a8cfd36e36d7919e inherit pro_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811cf5ec3c1f09465768fba8bce6788e inherit pro_methods_classsparta_1_1TreeNode" id="r_a811cf5ec3c1f09465768fba8bce6788e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a811cf5ec3c1f09465768fba8bce6788e">areParametersLocked_</a> () const</td></tr>
<tr class="memdesc:a811cf5ec3c1f09465768fba8bce6788e inherit pro_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method informs whether the tree is past the lockdown phase for all LOCKED and HIDDEN parameters. Modifying LOCKED and HIDDEN parameters after this phase is disallowed. Tree can be locked down during TREE_BUILDING phase or TREE_CONFIGURING phase. During TREE_FINALIZING phase, all parameters are locked down as is.  <br /></td></tr>
<tr class="separator:a811cf5ec3c1f09465768fba8bce6788e inherit pro_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859010859da20b3dd6e1d300b12a90d4 inherit pro_methods_classsparta_1_1TreeNode" id="r_a859010859da20b3dd6e1d300b12a90d4"><td class="memTemplParams" colspan="2">template&lt;typename DataT &gt; </td></tr>
<tr class="memitem:a859010859da20b3dd6e1d300b12a90d4 inherit pro_methods_classsparta_1_1TreeNode"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a859010859da20b3dd6e1d300b12a90d4">postPropagatingNotification_</a> (const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *origin, const DataT &amp;data, const std::string *name_id)</td></tr>
<tr class="memdesc:a859010859da20b3dd6e1d300b12a90d4 inherit pro_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a notification propagating up the tree.  <br /></td></tr>
<tr class="separator:a859010859da20b3dd6e1d300b12a90d4 inherit pro_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754479f743ac2addfcce2747ef1afb3f inherit pro_methods_classsparta_1_1TreeNode" id="r_a754479f743ac2addfcce2747ef1afb3f"><td class="memTemplParams" colspan="2">template&lt;typename DataT , typename T , void(T::*)(const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &amp;, const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> &amp;, const DataT &amp;) TMethod&gt; </td></tr>
<tr class="memitem:a754479f743ac2addfcce2747ef1afb3f inherit pro_methods_classsparta_1_1TreeNode"><td class="memTemplItemLeft" align="right" valign="top">DelegateVector::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a754479f743ac2addfcce2747ef1afb3f">findDelegate_</a> (<a class="el" href="classsparta_1_1TreeNode.html#ab92c3c0688d1c33036a224f4ce57b715">DelegateVector</a> &amp;dvec, T *obj, const std::string &amp;target_name)</td></tr>
<tr class="memdesc:a754479f743ac2addfcce2747ef1afb3f inherit pro_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a delegate associated with the given type T, object pointer, DataT, and TMethod within a DelevateVector. The intent of this function is to help see if a delegate is already registered with a calback by checking all known information associated with that callback against the input arguments.  <br /></td></tr>
<tr class="separator:a754479f743ac2addfcce2747ef1afb3f inherit pro_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754479f743ac2addfcce2747ef1afb3f inherit pro_methods_classsparta_1_1TreeNode" id="r_a754479f743ac2addfcce2747ef1afb3f"><td class="memTemplParams" colspan="2">template&lt;typename DataT , typename T , void(T::*)(const DataT &amp;) TMethod&gt; </td></tr>
<tr class="memitem:a754479f743ac2addfcce2747ef1afb3f inherit pro_methods_classsparta_1_1TreeNode"><td class="memTemplItemLeft" align="right" valign="top">DelegateVector::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a754479f743ac2addfcce2747ef1afb3f">findDelegate_</a> (<a class="el" href="classsparta_1_1TreeNode.html#ab92c3c0688d1c33036a224f4ce57b715">DelegateVector</a> &amp;dvec, T *obj, const std::string &amp;target_name)</td></tr>
<tr class="separator:a754479f743ac2addfcce2747ef1afb3f inherit pro_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d32cacde7a58997e485ab87a50e961 inherit pro_methods_classsparta_1_1TreeNode" id="r_a01d32cacde7a58997e485ab87a50e961"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a01d32cacde7a58997e485ab87a50e961">broadcastRegistrationForNotificationToChildren_</a> (const std::type_info &amp;tinfo, const std::vector&lt; const std::string * &gt; &amp;name_ids, <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *obs_node, const <a class="el" href="classsparta_1_1TreeNode_1_1delegate.html">delegate</a> *del, const bool allow_private)</td></tr>
<tr class="memdesc:a01d32cacde7a58997e485ab87a50e961 inherit pro_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively notifies children that the notification described is now (or still is) being observed at the observation point <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> <em>obs_node</em> with the newly registered delegate <em>del</em>.  <br /></td></tr>
<tr class="separator:a01d32cacde7a58997e485ab87a50e961 inherit pro_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746152de43052580e24b26d3f890f1a2 inherit pro_methods_classsparta_1_1TreeNode" id="r_a746152de43052580e24b26d3f890f1a2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a746152de43052580e24b26d3f890f1a2">broadcastDeregistrationForNotificationToChildren_</a> (const std::type_info &amp;tinfo, const std::vector&lt; const std::string * &gt; &amp;name_ids, <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *obs_node, const <a class="el" href="classsparta_1_1TreeNode_1_1delegate.html">delegate</a> *del, const bool allow_private)</td></tr>
<tr class="memdesc:a746152de43052580e24b26d3f890f1a2 inherit pro_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively notifies children that the notification described has lost one particular observer (<em>del</em>) which was observing at the observation point <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> <em>obs_node</em> with the delegate <em>del</em>.  <br /></td></tr>
<tr class="separator:a746152de43052580e24b26d3f890f1a2 inherit pro_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b778eda31fa56c9a66bd79bc77b01eb inherit pro_methods_classsparta_1_1TreeNode" id="r_a5b778eda31fa56c9a66bd79bc77b01eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a5b778eda31fa56c9a66bd79bc77b01eb">broadcastRegistrationForNotificationListStringToChildren_</a> (const std::type_info &amp;tinfo, const std::string &amp;name, <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *obs_node, const <a class="el" href="classsparta_1_1TreeNode_1_1delegate.html">delegate</a> *del, const bool private_only)</td></tr>
<tr class="memdesc:a5b778eda31fa56c9a66bd79bc77b01eb inherit pro_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point to broadcastRegistrationForNotificationToChildren_ recursion. Breaks a name string.  <br /></td></tr>
<tr class="separator:a5b778eda31fa56c9a66bd79bc77b01eb inherit pro_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c939995118db03f0a3fba145eab1aa inherit pro_methods_classsparta_1_1TreeNode" id="r_a59c939995118db03f0a3fba145eab1aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a59c939995118db03f0a3fba145eab1aa">broadcastDeregistrationForNotificationListStringToChildren_</a> (const std::type_info &amp;tinfo, const std::string &amp;name, <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *obs_node, const <a class="el" href="classsparta_1_1TreeNode_1_1delegate.html">delegate</a> *del, const bool private_only)</td></tr>
<tr class="memdesc:a59c939995118db03f0a3fba145eab1aa inherit pro_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symmetric oppostie of broadcastRegistrationForNotificationListStringToChildren_.  <br /></td></tr>
<tr class="separator:a59c939995118db03f0a3fba145eab1aa inherit pro_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ec15f8443eb1f90447942deb20d26f inherit pro_methods_classsparta_1_1TreeNode" id="r_a62ec15f8443eb1f90447942deb20d26f"><td class="memTemplParams" colspan="2">template&lt;typename DataT &gt; </td></tr>
<tr class="memitem:a62ec15f8443eb1f90447942deb20d26f inherit pro_methods_classsparta_1_1TreeNode"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a62ec15f8443eb1f90447942deb20d26f">invokeDelegatesOn_</a> (<a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *to_invoke, const DataT &amp;data, const std::string *name_id)</td></tr>
<tr class="memdesc:a62ec15f8443eb1f90447942deb20d26f inherit pro_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protected wrapper for invokeDelegates_ which allows a <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> to invoke delegates on another <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> using itself as the origin.  <br /></td></tr>
<tr class="separator:a62ec15f8443eb1f90447942deb20d26f inherit pro_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classsparta_1_1ResourceContainer"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classsparta_1_1ResourceContainer')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classsparta_1_1ResourceContainer.html">sparta::ResourceContainer</a></td></tr>
<tr class="memitem:af399ae644f27a3982dd3a2a788ae8d24 inherit pro_methods_classsparta_1_1ResourceContainer" id="r_af399ae644f27a3982dd3a2a788ae8d24"><td class="memItemLeft" align="right" valign="top">
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getResourceTypeName_</b> () const</td></tr>
<tr class="memdesc:af399ae644f27a3982dd3a2a788ae8d24 inherit pro_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the rtti type name (demangled) of the resource type held by this container. If there is no resource held, returns empty string. <br /></td></tr>
<tr class="separator:af399ae644f27a3982dd3a2a788ae8d24 inherit pro_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7941bfaff4076700bbf155f9a600a8f inherit pro_methods_classsparta_1_1ResourceContainer" id="r_ae7941bfaff4076700bbf155f9a600a8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceContainer.html#ae7941bfaff4076700bbf155f9a600a8f">setResource_</a> (<a class="el" href="classsparta_1_1Resource.html">Resource</a> *r)</td></tr>
<tr class="memdesc:ae7941bfaff4076700bbf155f9a600a8f inherit pro_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows subclasses to assign the resource associated with this node.  <br /></td></tr>
<tr class="separator:ae7941bfaff4076700bbf155f9a600a8f inherit pro_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22867f593bad8970c253325b7a3543c8 inherit pro_methods_classsparta_1_1ResourceContainer" id="r_a22867f593bad8970c253325b7a3543c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceContainer.html#a22867f593bad8970c253325b7a3543c8">unsetResource_</a> ()</td></tr>
<tr class="memdesc:a22867f593bad8970c253325b7a3543c8 inherit pro_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows a resource to unset the resource set with setResource_.  <br /></td></tr>
<tr class="separator:a22867f593bad8970c253325b7a3543c8 inherit pro_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20cbff011fb2cf11ffd35b167445e79d inherit pro_methods_classsparta_1_1ResourceContainer" id="r_a20cbff011fb2cf11ffd35b167445e79d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceContainer.html#a20cbff011fb2cf11ffd35b167445e79d">lockResource_</a> ()</td></tr>
<tr class="memdesc:a20cbff011fb2cf11ffd35b167445e79d inherit pro_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows subclasses to assign the resource associated with this node.  <br /></td></tr>
<tr class="separator:a20cbff011fb2cf11ffd35b167445e79d inherit pro_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854becbfda6c01a57fb00d02372b54b7 inherit pro_methods_classsparta_1_1ResourceContainer" id="r_a854becbfda6c01a57fb00d02372b54b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Resource.html">Resource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceContainer.html#a854becbfda6c01a57fb00d02372b54b7">getResource_</a> () noexcept</td></tr>
<tr class="memdesc:a854becbfda6c01a57fb00d02372b54b7 inherit pro_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the currently held resource of this node (if any). This method can be called at any time.  <br /></td></tr>
<tr class="separator:a854becbfda6c01a57fb00d02372b54b7 inherit pro_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f96706c7bdcd9d6b61d4bd9ef88e4a5 inherit pro_methods_classsparta_1_1ResourceContainer" id="r_a6f96706c7bdcd9d6b61d4bd9ef88e4a5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsparta_1_1Resource.html">Resource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceContainer.html#a6f96706c7bdcd9d6b61d4bd9ef88e4a5">getResource_</a> () const noexcept</td></tr>
<tr class="memdesc:a6f96706c7bdcd9d6b61d4bd9ef88e4a5 inherit pro_methods_classsparta_1_1ResourceContainer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const variant of getResource_.  <br /></td></tr>
<tr class="separator:a6f96706c7bdcd9d6b61d4bd9ef88e4a5 inherit pro_methods_classsparta_1_1ResourceContainer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classsparta_1_1PhasedObject"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classsparta_1_1PhasedObject')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classsparta_1_1PhasedObject.html">sparta::PhasedObject</a></td></tr>
<tr class="memitem:a59b0c6f93493d362a720a665ce443ccd inherit pro_methods_classsparta_1_1PhasedObject" id="r_a59b0c6f93493d362a720a665ce443ccd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1PhasedObject.html#a59b0c6f93493d362a720a665ce443ccd">setPhase_</a> (<a class="el" href="classsparta_1_1PhasedObject.html#afe9c78396c961fd96f0975867197b366">TreePhase</a> phase)</td></tr>
<tr class="memdesc:a59b0c6f93493d362a720a665ce443ccd inherit pro_methods_classsparta_1_1PhasedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current phase.  <br /></td></tr>
<tr class="separator:a59b0c6f93493d362a720a665ce443ccd inherit pro_methods_classsparta_1_1PhasedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classsparta_1_1TreeNode"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_static_methods_classsparta_1_1TreeNode')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a></td></tr>
<tr class="memitem:aacb943215632699fbddc6554dacfbdf7 inherit pub_static_methods_classsparta_1_1TreeNode" id="r_aacb943215632699fbddc6554dacfbdf7"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#aacb943215632699fbddc6554dacfbdf7">createSearchRegexPattern</a> (const std::string &amp;pat)</td></tr>
<tr class="memdesc:aacb943215632699fbddc6554dacfbdf7 inherit pub_static_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a regex pattern for a node child path containing any number of wildcard characters (not a dot-separated location) which can be used to test against child node names.  <br /></td></tr>
<tr class="separator:aacb943215632699fbddc6554dacfbdf7 inherit pub_static_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cac07d5f406fa1300d0e283e2a1f498 inherit pub_static_methods_classsparta_1_1TreeNode" id="r_a2cac07d5f406fa1300d0e283e2a1f498"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a2cac07d5f406fa1300d0e283e2a1f498">hasWildcardCharacters</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a2cac07d5f406fa1300d0e283e2a1f498 inherit pub_static_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a given node name has any wildcard characters which will be substituted in createSearchRegexPattern.  <br /></td></tr>
<tr class="separator:a2cac07d5f406fa1300d0e283e2a1f498 inherit pub_static_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef80729c2131ffb68b5e62b5002c321 inherit pub_static_methods_classsparta_1_1TreeNode" id="r_a1ef80729c2131ffb68b5e62b5002c321"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a1ef80729c2131ffb68b5e62b5002c321">getNextName</a> (const std::string &amp;name, size_t &amp;pos)</td></tr>
<tr class="memdesc:a1ef80729c2131ffb68b5e62b5002c321 inherit pub_static_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next name between two '.' chars in a string starting at <em>pos</em>.  <br /></td></tr>
<tr class="separator:a1ef80729c2131ffb68b5e62b5002c321 inherit pub_static_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b06f89a9d37325701620637e44f2e2 inherit pub_static_methods_classsparta_1_1TreeNode" id="r_a83b06f89a9d37325701620637e44f2e2"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a83b06f89a9d37325701620637e44f2e2">matchesGlobLike</a> (const std::string &amp;pattern, const std::string &amp;other)</td></tr>
<tr class="memdesc:a83b06f89a9d37325701620637e44f2e2 inherit pub_static_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a glob-like search pattern matches some other string.  <br /></td></tr>
<tr class="separator:a83b06f89a9d37325701620637e44f2e2 inherit pub_static_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001153882adf23d6f32cfbffe9af861a inherit pub_static_methods_classsparta_1_1TreeNode" id="r_a001153882adf23d6f32cfbffe9af861a"><td class="memItemLeft" align="right" valign="top">
static const std::map&lt; const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *, <a class="el" href="classsparta_1_1TreeNode.html#a91f21b18f9f50f70111730361eff6ddb">WeakPtr</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getParentlessNodes</b> ()</td></tr>
<tr class="separator:a001153882adf23d6f32cfbffe9af861a inherit pub_static_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77344269c5bac67061d2f85756579fbe inherit pub_static_methods_classsparta_1_1TreeNode" id="r_a77344269c5bac67061d2f85756579fbe"><td class="memItemLeft" align="right" valign="top">
static const std::map&lt; const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *, <a class="el" href="classsparta_1_1TreeNode.html#a91f21b18f9f50f70111730361eff6ddb">WeakPtr</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getAllNodes</b> ()</td></tr>
<tr class="memdesc:a77344269c5bac67061d2f85756579fbe inherit pub_static_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the vector of all TreeNodes currently known to be constructed. <br /></td></tr>
<tr class="separator:a77344269c5bac67061d2f85756579fbe inherit pub_static_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66d5a9570ecf75c70a23c052254ccc7 inherit pub_static_methods_classsparta_1_1TreeNode" id="r_ad66d5a9570ecf75c70a23c052254ccc7"><td class="memItemLeft" align="right" valign="top">
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>formatAllNodes</b> ()</td></tr>
<tr class="memdesc:ad66d5a9570ecf75c70a23c052254ccc7 inherit pub_static_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the list of all TreeNodes currently known to be constructed. <br /></td></tr>
<tr class="separator:ad66d5a9570ecf75c70a23c052254ccc7 inherit pub_static_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae614c29aa798fd41da2dd178a359272f inherit pub_static_methods_classsparta_1_1TreeNode" id="r_ae614c29aa798fd41da2dd178a359272f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#ae614c29aa798fd41da2dd178a359272f">isNodeConstructed</a> (const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *)</td></tr>
<tr class="memdesc:ae614c29aa798fd41da2dd178a359272f inherit pub_static_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a given node constructed?  <br /></td></tr>
<tr class="separator:ae614c29aa798fd41da2dd178a359272f inherit pub_static_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9faa603b824c850070637195f6d4e2a9 inherit pub_static_methods_classsparta_1_1TreeNode" id="r_a9faa603b824c850070637195f6d4e2a9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a9faa603b824c850070637195f6d4e2a9">getVirtualGlobalNode</a> ()</td></tr>
<tr class="memdesc:a9faa603b824c850070637195f6d4e2a9 inherit pub_static_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the virtual global node singleton. This node can have no parent and no children. It receives notifications from all nodes in the simulator as if it were the parent of every node in the simulation that has no parent.  <br /></td></tr>
<tr class="separator:a9faa603b824c850070637195f6d4e2a9 inherit pub_static_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2e0aceb5596a4f21fc5e1ad34c2ac7 inherit pub_static_methods_classsparta_1_1TreeNode" id="r_a4c2e0aceb5596a4f21fc5e1ad34c2ac7"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; const std::string * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a4c2e0aceb5596a4f21fc5e1ad34c2ac7">parseNotificationNameString</a> (const std::string &amp;csl)</td></tr>
<tr class="memdesc:a4c2e0aceb5596a4f21fc5e1ad34c2ac7 inherit pub_static_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a comma-separated list of notification names (or patterns) separated by commas and ignoring whitespace around commas.  <br /></td></tr>
<tr class="separator:a4c2e0aceb5596a4f21fc5e1ad34c2ac7 inherit pub_static_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba01f766f0b8212967d2a25ceae475a inherit pub_static_methods_classsparta_1_1TreeNode" id="r_a3ba01f766f0b8212967d2a25ceae475a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a3ba01f766f0b8212967d2a25ceae475a">notificationCategoryMatch</a> (const std::string *query_id, const std::string *node_id)</td></tr>
<tr class="memdesc:a3ba01f766f0b8212967d2a25ceae475a inherit pub_static_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two notification categories match where one is an actual category.  <br /></td></tr>
<tr class="separator:a3ba01f766f0b8212967d2a25ceae475a inherit pub_static_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classsparta_1_1ParameterBase"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_static_attribs_classsparta_1_1ParameterBase')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classsparta_1_1ParameterBase.html">sparta::ParameterBase</a></td></tr>
<tr class="memitem:af099e48ffbb479b0dad141cad5e76bc7 inherit pub_static_attribs_classsparta_1_1ParameterBase" id="r_af099e48ffbb479b0dad141cad5e76bc7"><td class="memItemLeft" align="right" valign="top">static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html#af099e48ffbb479b0dad141cad5e76bc7">PARAMETER_NODE_TAG</a> [] = &quot;SPARTA_Parameter&quot;</td></tr>
<tr class="memdesc:af099e48ffbb479b0dad141cad5e76bc7 inherit pub_static_attribs_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1Tag.html" title="Tag(): Simple class to provide nested sequence numbering.">Tag</a> added to <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> nodes.  <br /></td></tr>
<tr class="separator:af099e48ffbb479b0dad141cad5e76bc7 inherit pub_static_attribs_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classsparta_1_1TreeNode"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_static_attribs_classsparta_1_1TreeNode')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a></td></tr>
<tr class="memitem:a0c31b9fc57737636c1b76f7ec7ed0315 inherit pub_static_attribs_classsparta_1_1TreeNode" id="r_a0c31b9fc57737636c1b76f7ec7ed0315"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classsparta_1_1TreeNode.html#a7fa01f145455d583b8f16e0f923b7c7c">group_idx_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a0c31b9fc57737636c1b76f7ec7ed0315">GROUP_IDX_NONE</a> = (<a class="el" href="classsparta_1_1TreeNode.html#a7fa01f145455d583b8f16e0f923b7c7c">group_idx_type</a>)-1</td></tr>
<tr class="memdesc:a0c31b9fc57737636c1b76f7ec7ed0315 inherit pub_static_attribs_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">GroupIndex indicating that a node has no group index because it belongs to no group.  <br /></td></tr>
<tr class="separator:a0c31b9fc57737636c1b76f7ec7ed0315 inherit pub_static_attribs_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d729b6c83cfc71c7cff6a4017ab690 inherit pub_static_attribs_classsparta_1_1TreeNode" id="r_a21d729b6c83cfc71c7cff6a4017ab690"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classsparta_1_1TreeNode.html#af5075c9b90f28041b6a7f3f80132c1b3">node_uid_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a21d729b6c83cfc71c7cff6a4017ab690">MAX_NODE_UID</a></td></tr>
<tr class="memdesc:a21d729b6c83cfc71c7cff6a4017ab690 inherit pub_static_attribs_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value of node_uid_ before the framework throws an exception.  <br /></td></tr>
<tr class="separator:a21d729b6c83cfc71c7cff6a4017ab690 inherit pub_static_attribs_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361467ba0817226281612c6cfdf1671b inherit pub_static_attribs_classsparta_1_1TreeNode" id="r_a361467ba0817226281612c6cfdf1671b"><td class="memItemLeft" align="right" valign="top">static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a361467ba0817226281612c6cfdf1671b">GROUP_NAME_NONE</a> [] = &quot;&quot;</td></tr>
<tr class="memdesc:a361467ba0817226281612c6cfdf1671b inherit pub_static_attribs_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group name indicating that a node belongs to no group.  <br /></td></tr>
<tr class="separator:a361467ba0817226281612c6cfdf1671b inherit pub_static_attribs_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8d1112f2f15f5709e2fe10077443a5 inherit pub_static_attribs_classsparta_1_1TreeNode" id="r_a2c8d1112f2f15f5709e2fe10077443a5"><td class="memItemLeft" align="right" valign="top">static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a2c8d1112f2f15f5709e2fe10077443a5">NODE_NAME_NONE</a> [] = &quot;&quot;</td></tr>
<tr class="memdesc:a2c8d1112f2f15f5709e2fe10077443a5 inherit pub_static_attribs_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node name for anonymous node.  <br /></td></tr>
<tr class="separator:a2c8d1112f2f15f5709e2fe10077443a5 inherit pub_static_attribs_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2736aba2c285e0c9eb56bd5ad219aac1 inherit pub_static_attribs_classsparta_1_1TreeNode" id="r_a2736aba2c285e0c9eb56bd5ad219aac1"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a2736aba2c285e0c9eb56bd5ad219aac1">DEBUG_DUMP_SECTION_DIVIDER</a></td></tr>
<tr class="memdesc:a2736aba2c285e0c9eb56bd5ad219aac1 inherit pub_static_attribs_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">String dividing sections in a debug dump file.  <br /></td></tr>
<tr class="separator:a2736aba2c285e0c9eb56bd5ad219aac1 inherit pub_static_attribs_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08dafe7762de39f9cf9448d58b238bd6 inherit pub_static_attribs_classsparta_1_1TreeNode" id="r_a08dafe7762de39f9cf9448d58b238bd6"><td class="memItemLeft" align="right" valign="top">static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a08dafe7762de39f9cf9448d58b238bd6">NODE_NAME_VIRTUAL_GLOBAL</a> [] = &quot;_SPARTA_virtual_global_&quot;</td></tr>
<tr class="memdesc:a08dafe7762de39f9cf9448d58b238bd6 inherit pub_static_attribs_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node name for the virtual glopbal node.  <br /></td></tr>
<tr class="separator:a08dafe7762de39f9cf9448d58b238bd6 inherit pub_static_attribs_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7414db91285d570ee6de31f33f2d318a inherit pub_static_attribs_classsparta_1_1TreeNode" id="r_a7414db91285d570ee6de31f33f2d318a"><td class="memItemLeft" align="right" valign="top">static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a7414db91285d570ee6de31f33f2d318a">LOCATION_NODE_SEPARATOR_ATTACHED</a> = '.'</td></tr>
<tr class="memdesc:a7414db91285d570ee6de31f33f2d318a inherit pub_static_attribs_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separator character between node identifiers in a location string when the child is attached to the parent.  <br /></td></tr>
<tr class="separator:a7414db91285d570ee6de31f33f2d318a inherit pub_static_attribs_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5616cd3a24c63ea04e9a54379a48ea inherit pub_static_attribs_classsparta_1_1TreeNode" id="r_a4a5616cd3a24c63ea04e9a54379a48ea"><td class="memItemLeft" align="right" valign="top">static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a4a5616cd3a24c63ea04e9a54379a48ea">LOCATION_NODE_SEPARATOR_EXPECTING</a> = ','</td></tr>
<tr class="memdesc:a4a5616cd3a24c63ea04e9a54379a48ea inherit pub_static_attribs_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separator character between node identifiers in a location string when the child is being attached to the parent but has not been entirely attached (i.g. during construction of the child node)  <br /></td></tr>
<tr class="separator:a4a5616cd3a24c63ea04e9a54379a48ea inherit pub_static_attribs_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dcff9c08bb51455a8ee1ad0a065b9ed inherit pub_static_attribs_classsparta_1_1TreeNode" id="r_a9dcff9c08bb51455a8ee1ad0a065b9ed"><td class="memItemLeft" align="right" valign="top">static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a9dcff9c08bb51455a8ee1ad0a065b9ed">LOCATION_NODE_SEPARATOR_UNATTACHED</a> = '~'</td></tr>
<tr class="memdesc:a9dcff9c08bb51455a8ee1ad0a065b9ed inherit pub_static_attribs_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separator character preceding a node identifiers in a location string when that node has no parent and is not in the process of being attached to one.  <br /></td></tr>
<tr class="separator:a9dcff9c08bb51455a8ee1ad0a065b9ed inherit pub_static_attribs_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0207cd37def4befc0825fa4e2118d861 inherit pub_static_attribs_classsparta_1_1TreeNode" id="r_a0207cd37def4befc0825fa4e2118d861"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a0207cd37def4befc0825fa4e2118d861">RENDER_SUBTREE_INDENT</a> = 2</td></tr>
<tr class="memdesc:a0207cd37def4befc0825fa4e2118d861 inherit pub_static_attribs_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spaces to indent for each tree level in <a class="el" href="classsparta_1_1TreeNode.html#a664c9d3ec69cbbfa5993e9b698e65518" title="Renders the subtree starting at this node as a string containing an indentation-based depth-first rep...">sparta::TreeNode::renderSubtree</a>.  <br /></td></tr>
<tr class="separator:a0207cd37def4befc0825fa4e2118d861 inherit pub_static_attribs_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb0eed181c22d020796770813cff2ff inherit pub_static_attribs_classsparta_1_1TreeNode" id="r_a2cb0eed181c22d020796770813cff2ff"><td class="memItemLeft" align="right" valign="top">static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a2cb0eed181c22d020796770813cff2ff">GROUP_NAME_BUILTIN</a> [] = &quot;_SPARTA_builtin_group_&quot;</td></tr>
<tr class="memdesc:a2cb0eed181c22d020796770813cff2ff inherit pub_static_attribs_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserved name for built-in nodes.  <br /></td></tr>
<tr class="separator:a2cb0eed181c22d020796770813cff2ff inherit pub_static_attribs_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb91033f1351c5dc6b31c35d4c2ae9a inherit pub_static_attribs_classsparta_1_1TreeNode" id="r_adfb91033f1351c5dc6b31c35d4c2ae9a"><td class="memItemLeft" align="right" valign="top">static const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#adfb91033f1351c5dc6b31c35d4c2ae9a">CHILD_FIND_THRESHOLD</a> = 100000</td></tr>
<tr class="memdesc:adfb91033f1351c5dc6b31c35d4c2ae9a inherit pub_static_attribs_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threshold for number of findChildren calls after finalization before a warning message is printed about framework misuse.  <br /></td></tr>
<tr class="separator:adfb91033f1351c5dc6b31c35d4c2ae9a inherit pub_static_attribs_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8830a6be5d9f6e60e4bff8124d19b289 inherit pub_static_attribs_classsparta_1_1TreeNode" id="r_a8830a6be5d9f6e60e4bff8124d19b289"><td class="memItemLeft" align="right" valign="top">static const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a8830a6be5d9f6e60e4bff8124d19b289">CHILD_GET_THRESHOLD</a> = 100000</td></tr>
<tr class="memdesc:a8830a6be5d9f6e60e4bff8124d19b289 inherit pub_static_attribs_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threshold for number of getChild calls after finalization before a warning message is printed about framework misuse.  <br /></td></tr>
<tr class="separator:a8830a6be5d9f6e60e4bff8124d19b289 inherit pub_static_attribs_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462dd7d49771534977161285834213ad inherit pub_static_attribs_classsparta_1_1TreeNode" id="r_a462dd7d49771534977161285834213ad"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a462dd7d49771534977161285834213ad">TEARDOWN_ERROR_LIMIT</a> = 5</td></tr>
<tr class="memdesc:a462dd7d49771534977161285834213ad inherit pub_static_attribs_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of teardown-phase-related messages that can be printed before the rest will be suppressed.  <br /></td></tr>
<tr class="separator:a462dd7d49771534977161285834213ad inherit pub_static_attribs_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbbbe78bdb65b46ed07ca8de5e4da89 inherit pub_static_attribs_classsparta_1_1TreeNode" id="r_a5fbbbe78bdb65b46ed07ca8de5e4da89"><td class="memItemLeft" align="right" valign="top">static const std::vector&lt; std::pair&lt; const char *, std::function&lt; void(std::string &amp;)&gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a5fbbbe78bdb65b46ed07ca8de5e4da89">TREE_NODE_PATTERN_SUBS</a></td></tr>
<tr class="memdesc:a5fbbbe78bdb65b46ed07ca8de5e4da89 inherit pub_static_attribs_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of pattern susbtitutions when creating a search pattern from a <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> name containing wildcards.  <br /></td></tr>
<tr class="separator:a5fbbbe78bdb65b46ed07ca8de5e4da89 inherit pub_static_attribs_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_classsparta_1_1TreeNode"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_types_classsparta_1_1TreeNode')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a></td></tr>
<tr class="memitem:ab92c3c0688d1c33036a224f4ce57b715 inherit pro_types_classsparta_1_1TreeNode" id="r_ab92c3c0688d1c33036a224f4ce57b715"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="classsparta_1_1TreeNode_1_1delegate.html">delegate</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#ab92c3c0688d1c33036a224f4ce57b715">DelegateVector</a></td></tr>
<tr class="memdesc:ab92c3c0688d1c33036a224f4ce57b715 inherit pro_types_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of delegates representing a list of observers to notify.  <br /></td></tr>
<tr class="separator:ab92c3c0688d1c33036a224f4ce57b715 inherit pro_types_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdceb31f74d5a8e554defe592af90f54 inherit pro_types_classsparta_1_1TreeNode" id="r_abdceb31f74d5a8e554defe592af90f54"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; <a class="el" href="classsparta_1_1TreeNode_1_1type__info__container.html">type_info_container</a>, <a class="el" href="classsparta_1_1TreeNode.html#ab92c3c0688d1c33036a224f4ce57b715">DelegateVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#abdceb31f74d5a8e554defe592af90f54">NotificationObserverMap</a></td></tr>
<tr class="memdesc:abdceb31f74d5a8e554defe592af90f54 inherit pro_types_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of delegate vectors containing all observers.  <br /></td></tr>
<tr class="separator:abdceb31f74d5a8e554defe592af90f54 inherit pro_types_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classsparta_1_1ParameterBase"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_static_methods_classsparta_1_1ParameterBase')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classsparta_1_1ParameterBase.html">sparta::ParameterBase</a></td></tr>
<tr class="memitem:a3d4a296d46f0ea803117b6726063301b inherit pro_static_methods_classsparta_1_1ParameterBase" id="r_a3d4a296d46f0ea803117b6726063301b"><td class="memItemLeft" align="right" valign="top">
static void&#160;</td><td class="memItemRight" valign="bottom"><b>logCurrentBackTrace_</b> ()</td></tr>
<tr class="memdesc:a3d4a296d46f0ea803117b6726063301b inherit pro_static_methods_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log the current backtrace to the global parameters logger. <br /></td></tr>
<tr class="separator:a3d4a296d46f0ea803117b6726063301b inherit pro_static_methods_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classsparta_1_1TreeNode"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_static_methods_classsparta_1_1TreeNode')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a></td></tr>
<tr class="memitem:ab50c28d990477787fe2a043555302120 inherit pro_static_methods_classsparta_1_1TreeNode" id="r_ab50c28d990477787fe2a043555302120"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#ab50c28d990477787fe2a043555302120">identityMatchesPattern_</a> (const std::string &amp;ident, std::regex &amp;expr, std::vector&lt; std::string &gt; &amp;replacements)</td></tr>
<tr class="memdesc:ab50c28d990477787fe2a043555302120 inherit pro_static_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs pattern matching on a identity string.  <br /></td></tr>
<tr class="separator:ab50c28d990477787fe2a043555302120 inherit pro_static_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe31e2005a4befa9fe1ab92f04d3e666 inherit pro_static_methods_classsparta_1_1TreeNode" id="r_afe31e2005a4befa9fe1ab92f04d3e666"><td class="memItemLeft" align="right" valign="top">
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>identityMatchesPattern_</b> (const std::string &amp;ident, std::regex &amp;expr)</td></tr>
<tr class="memdesc:afe31e2005a4befa9fe1ab92f04d3e666 inherit pro_static_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of identityMatchesPattern_ with no replacements vector. <br /></td></tr>
<tr class="separator:afe31e2005a4befa9fe1ab92f04d3e666 inherit pro_static_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a42a6710fd8458fb5699c259229e6a inherit pro_static_methods_classsparta_1_1TreeNode" id="r_a84a42a6710fd8458fb5699c259229e6a"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html#a84a42a6710fd8458fb5699c259229e6a">getPreviousName_</a> (const std::string &amp;name, size_t &amp;pos)</td></tr>
<tr class="memdesc:a84a42a6710fd8458fb5699c259229e6a inherit pro_static_methods_classsparta_1_1TreeNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the previous name between two '.' chars in a string starting at <em>pos</em>.  <br /></td></tr>
<tr class="separator:a84a42a6710fd8458fb5699c259229e6a inherit pro_static_methods_classsparta_1_1TreeNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classsparta_1_1ParameterBase"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_attribs_classsparta_1_1ParameterBase')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classsparta_1_1ParameterBase.html">sparta::ParameterBase</a></td></tr>
<tr class="memitem:a8fb9f1d7c8ebdbd8b86511d7c6d6ffd1 inherit pro_attribs_classsparta_1_1ParameterBase" id="r_a8fb9f1d7c8ebdbd8b86511d7c6d6ffd1"><td class="memItemLeft" align="right" valign="top">sparta::SpartaHandler&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html#a8fb9f1d7c8ebdbd8b86511d7c6d6ffd1">modifier_callback_</a></td></tr>
<tr class="memdesc:a8fb9f1d7c8ebdbd8b86511d7c6d6ffd1 inherit pro_attribs_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifier callback called when the parameter is written.  <br /></td></tr>
<tr class="separator:a8fb9f1d7c8ebdbd8b86511d7c6d6ffd1 inherit pro_attribs_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae466d47df27c960132e82965016b0ce2 inherit pro_attribs_classsparta_1_1ParameterBase" id="r_ae466d47df27c960132e82965016b0ce2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html#ae466d47df27c960132e82965016b0ce2">ignored_</a></td></tr>
<tr class="memdesc:ae466d47df27c960132e82965016b0ce2 inherit pro_attribs_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has this parameter been ignored. Resettable. Mutable so that it can be accessed from a const Parmeter.  <br /></td></tr>
<tr class="separator:ae466d47df27c960132e82965016b0ce2 inherit pro_attribs_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98f43dbdcbadca1c3d29c10e5a1c90b inherit pro_attribs_classsparta_1_1ParameterBase" id="r_ac98f43dbdcbadca1c3d29c10e5a1c90b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html#ac98f43dbdcbadca1c3d29c10e5a1c90b">string_quote_</a></td></tr>
<tr class="memdesc:ac98f43dbdcbadca1c3d29c10e5a1c90b inherit pro_attribs_classsparta_1_1ParameterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The quote sequence for printing strings. Defaults to empty string.  <br /></td></tr>
<tr class="separator:ac98f43dbdcbadca1c3d29c10e5a1c90b inherit pro_attribs_classsparta_1_1ParameterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename ValueType&gt;<br />
class sparta::Parameter&lt; ValueType &gt;</div><p><a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> instance, templated to contain only a specific type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>type of data held by this parameter Supported types include are all bound types of <a class="el" href="classsparta_1_1KeyValue.html#a2c9ee59707093f6a0255f60564d9d909" title="Map of internal typeid names to C++ names.">sparta::KeyValue::GBL_type_name_map</a> contained within any number of std::vector levels </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01118">1118</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ad75bb728b6180aa7caad038ef7ad5d7f" name="ad75bb728b6180aa7caad038ef7ad5d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad75bb728b6180aa7caad038ef7ad5d7f">&#9670;&#160;</a></span>type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::type = ValueType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type held by this parameter. This cannot change at run-time. </p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01145">1145</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<a id="a7f6a9f537344e21a846ebea4e217787e" name="a7f6a9f537344e21a846ebea4e217787e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f6a9f537344e21a846ebea4e217787e">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::value_type = ValueType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01146">1146</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a42c937893d3974e6143c5dd88d86d1c7" name="a42c937893d3974e6143c5dd88d86d1c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c937893d3974e6143c5dd88d86d1c7">&#9670;&#160;</a></span>ParameterAttribute</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a42c937893d3974e6143c5dd88d86d1c7">sparta::Parameter::ParameterAttribute</a> : std::uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ParameterAttribute enum class which describes special attributes of this parameter. </p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01126">1126</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aad0e025d41c2a0e8041edcfeaf36d339" name="aad0e025d41c2a0e8041edcfeaf36d339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad0e025d41c2a0e8041edcfeaf36d339">&#9670;&#160;</a></span>Parameter() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::Parameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>def</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>doc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>isvolatile</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a parameter. </p>
<dl class="section note"><dt>Note</dt><dd>Within a <a class="el" href="classsparta_1_1ParameterSet.html" title="Generic container of Parameters.">ParameterSet</a> subclass body, it's usually preferable to use PARAMETER* macros instead of constructing these manually. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Param/Node name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">def</td><td>Default value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">doc</td><td>Docstring </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isvolatile</td><td>Is this parameter volatile (are writes after read allowed)? A param can never be written after finalization, but some may be automatically calculated and changed multiple times based on other values and their own. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01160">1160</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Parameter_aad0e025d41c2a0e8041edcfeaf36d339_cgraph.png" border="0" usemap="#aclasssparta_1_1Parameter_aad0e025d41c2a0e8041edcfeaf36d339_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Parameter_aad0e025d41c2a0e8041edcfeaf36d339_cgraph" id="aclasssparta_1_1Parameter_aad0e025d41c2a0e8041edcfeaf36d339_cgraph">
<area shape="rect" title="Construct a parameter." alt="" coords="5,39,135,79"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#aa6d86d257ad2c5cd7fceced18a4351e2" title="Log the default loaded to this parameter to the global parameters logger for debugging." alt="" coords="183,5,351,46"/>
<area shape="poly" title=" " alt="" coords="134,45,167,40,168,45,135,51"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#a9571624685f3aa0c2a0a124038dc1040" title="Set volatile flag (allows write after read)" alt="" coords="190,71,344,111"/>
<area shape="poly" title=" " alt="" coords="135,67,175,73,174,79,134,72"/>
<area shape="rect" href="classsparta_1_1PhasedObject.html#ade690bdb9df72fd6bad8847fbdf226f1" title="Gets the trees current phase." alt="" coords="403,37,548,78"/>
<area shape="poly" title=" " alt="" coords="343,76,387,69,388,74,344,81"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#ad3c7817fce432b087dc34b3aeecec766" title="Number of times this Parameter has been read after initialization or after the last write (or explici..." alt="" coords="399,103,552,143"/>
<area shape="poly" title=" " alt="" coords="344,100,384,106,383,112,343,105"/>
</map>
</div>

</div>
</div>
<a id="abef156e555746ae268ab4b36ef8281b2" name="abef156e555746ae268ab4b36ef8281b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abef156e555746ae268ab4b36ef8281b2">&#9670;&#160;</a></span>Parameter() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::Parameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>def</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>doc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1ParameterSet.html">ParameterSet</a> *</td>          <td class="paramname"><span class="paramname"><em>ps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>isvolatile</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor used by the PARAMETER macro. </p>
<dl class="section note"><dt>Note</dt><dd>This constructor delegates to the previous one defined above, and adds to the right <a class="el" href="classsparta_1_1ParameterSet.html" title="Generic container of Parameters.">ParameterSet</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01183">1183</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Parameter_abef156e555746ae268ab4b36ef8281b2_cgraph.png" border="0" usemap="#aclasssparta_1_1Parameter_abef156e555746ae268ab4b36ef8281b2_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Parameter_abef156e555746ae268ab4b36ef8281b2_cgraph" id="aclasssparta_1_1Parameter_abef156e555746ae268ab4b36ef8281b2_cgraph">
<area shape="rect" title="Constructor used by the PARAMETER macro." alt="" coords="5,5,135,46"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#ace8e89c2cc054d0f04adcff951783991" title="Add this parameter to a set &#45; an action which is protected and requires the friendship that the Param..." alt="" coords="183,5,336,46"/>
<area shape="poly" title=" " alt="" coords="135,23,167,23,167,28,135,28"/>
</map>
</div>

</div>
</div>
<a id="ac2a9771a031bcb3812059bd4e432b72b" name="ac2a9771a031bcb3812059bd4e432b72b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a9771a031bcb3812059bd4e432b72b">&#9670;&#160;</a></span>Parameter() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::Parameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>def</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>doc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a42c937893d3974e6143c5dd88d86d1c7">ParameterAttribute</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>attr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1ParameterSet.html">ParameterSet</a> *</td>          <td class="paramname"><span class="paramname"><em>ps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>isvolatile</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01194">1194</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aed1ec52a744453cfb389342e905567af" name="aed1ec52a744453cfb389342e905567af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed1ec52a744453cfb389342e905567af">&#9670;&#160;</a></span>addDependentValidationCallback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::addDependentValidationCallback </td>
          <td>(</td>
          <td class="paramtype">bool(*</td>          <td class="paramname"><span class="paramname"><em>method&#160;</em></span>)(ValueType &amp;, const <a class="el" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a> *), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds dependency callback via a global function or lambda. </p>
<p>Refer to other overload of addDependentValidationCallback for further explanation</p>
<p>Usage: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> global_function(<span class="keywordtype">bool</span>&amp;, <span class="keyword">const</span> <a class="code hl_class" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a>*) { <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">MyClass my_class;</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="comment">// Given some Parameter&lt;bool&gt; parameter_global_check;</span></div>
<div class="line"><span class="comment">// Given some Parameter&lt;bool&gt; parameter_lambda_check;</span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">parameter_global_check-&gt;addDependentValidationCallback(&amp;global_function, <span class="stringliteral">&quot;constraint1&quot;</span>)</div>
<div class="line">parameter_lambda_check-&gt;addDependentValidationCallback([](std::vector&lt;bool&gt;&amp; val, <span class="keyword">const</span> <a class="code hl_class" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a>*){<span class="keywordflow">return</span> val == <span class="keyword">true</span>;},</div>
<div class="line">                                                       <span class="stringliteral">&quot;constraint2&quot;</span>)</div>
<div class="ttc" id="aclasssparta_1_1TreeNode_html"><div class="ttname"><a href="classsparta_1_1TreeNode.html">sparta::TreeNode</a></div><div class="ttdoc">Node in a composite tree representing a sparta Tree item.</div><div class="ttdef"><b>Definition</b> <a href="TreeNode_8hpp_source.html#l00203">TreeNode.hpp:204</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01259">1259</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<a id="a2434a8379e8dfa6efc3302b659a018f0" name="a2434a8379e8dfa6efc3302b659a018f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2434a8379e8dfa6efc3302b659a018f0">&#9670;&#160;</a></span>addDependentValidationCallback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<div class="memtemplate">
template&lt;class T , bool(T::*)(ValueType &amp;, const <a class="el" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a> *) TMethod&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::addDependentValidationCallback </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds dependency callback to a class member function. </p>
<p>Usage: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyClass {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">bool</span> Method(<span class="keywordtype">bool</span>&amp;, <span class="keyword">const</span> <a class="code hl_class" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a>*) { <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div>
<div class="line">};</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">MyClass my_class;</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="comment">// Given some Parameter&lt;bool&gt; parameter;</span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">parameter-&gt;addDependentValidationCallback&lt;MyClass, &amp;MyClass::Method&gt;(my_class, <span class="stringliteral">&quot;constraint1&quot;</span>);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01231">1231</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<a id="a9823b9579def8710f640e149bd6797a2" name="a9823b9579def8710f640e149bd6797a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9823b9579def8710f640e149bd6797a2">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classsparta_1_1ParameterBase.html#af4e84978d016d9540c19af0918dba0fa">ParameterBase::const_iterator</a> <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get begin iterator. </p>
<dl class="section note"><dt>Note</dt><dd>Increments read count </dd></dl>

<p>Implements <a class="el" href="classsparta_1_1ParameterBase.html#a66c630b2bba3350fc214078ebb2222f4">sparta::ParameterBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01459">1459</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<a id="a96220dce75014ed76dc0a2339731ab2e" name="a96220dce75014ed76dc0a2339731ab2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96220dce75014ed76dc0a2339731ab2e">&#9670;&#160;</a></span>clearVectorValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::clearVectorValue </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the parameter is a vector type, clears the value so that it becomes an empty vector (regardless of dimensionality) </p>
<dl class="section note"><dt>Note</dt><dd>Has no effect if parameter is a non-vector type </dd></dl>

<p>Implements <a class="el" href="classsparta_1_1ParameterBase.html#a13a637320d9e37896abc10576d4a9219">sparta::ParameterBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01690">1690</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<a id="a6f5f572605d3105b096bc97c37a08379" name="a6f5f572605d3105b096bc97c37a08379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f5f572605d3105b096bc97c37a08379">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classsparta_1_1ParameterBase.html#af4e84978d016d9540c19af0918dba0fa">ParameterBase::const_iterator</a> <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get begin iterator. </p>
<dl class="section note"><dt>Note</dt><dd>Increments read count </dd></dl>

<p>Implements <a class="el" href="classsparta_1_1ParameterBase.html#ac9d92482734658f695ca20e5d9651e38">sparta::ParameterBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01467">1467</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Parameter_a6f5f572605d3105b096bc97c37a08379_cgraph.png" border="0" usemap="#aclasssparta_1_1Parameter_a6f5f572605d3105b096bc97c37a08379_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Parameter_a6f5f572605d3105b096bc97c37a08379_cgraph" id="aclasssparta_1_1Parameter_a6f5f572605d3105b096bc97c37a08379_cgraph">
<area shape="rect" title="Get begin iterator." alt="" coords="5,13,156,38"/>
<area shape="rect" href="classsparta_1_1Parameter.html#ab87eae331f49a25fa566a427dbd30b03" title="Gets the number of values in this Parameter." alt="" coords="204,5,333,46"/>
<area shape="poly" title=" " alt="" coords="156,23,188,23,188,28,156,28"/>
</map>
</div>

</div>
</div>
<a id="aa65810457dc3f37939bc3c51fcf6af90" name="aa65810457dc3f37939bc3c51fcf6af90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa65810457dc3f37939bc3c51fcf6af90">&#9670;&#160;</a></span>equals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1ParameterBase.html">ParameterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the value of this equals <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The parameter to compere with </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classsparta_1_1ParameterBase.html#a59394941292e0bd8814b3bf7128d9470">sparta::ParameterBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01678">1678</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<a id="a13216927d662fcb5de9a36ce2179dd76" name="a13216927d662fcb5de9a36ce2179dd76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13216927d662fcb5de9a36ce2179dd76">&#9670;&#160;</a></span>getDefault()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::getDefault </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the default value. </p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01276">1276</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<a id="a756acb6cf2ac52b0bfdbc20e5b30afda" name="a756acb6cf2ac52b0bfdbc20e5b30afda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a756acb6cf2ac52b0bfdbc20e5b30afda">&#9670;&#160;</a></span>getDefaultAsString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::getDefaultAsString </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the default value as a string, even if type is a vector. </p>
<p>Refer to 'sparta::stringize' for vector-to-string formatting. </p>

<p>Implements <a class="el" href="classsparta_1_1ParameterBase.html#a8efb894303cfabf6145b4db90d8f0e2e">sparta::ParameterBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01286">1286</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<a id="a8242e8a62a61455cd2414d34908e4287" name="a8242e8a62a61455cd2414d34908e4287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8242e8a62a61455cd2414d34908e4287">&#9670;&#160;</a></span>getDimensionality()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::getDimensionality </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the number of dimensions of this <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a>. A scalar has 0 dimensions. A parameter of type vector&lt;uint32_t&gt; would have a dimensionality of 1. vector&lt;vector&lt;uint32_t&gt;&gt; would have a dimensionality of 2. </p>
<dl class="section note"><dt>Note</dt><dd>Does not increment read count </dd></dl>

<p>Implements <a class="el" href="classsparta_1_1ParameterBase.html#a6dad9c19c9c94d4d8e6d818bed15a692">sparta::ParameterBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01451">1451</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<a id="ab538e978a97d98c7092d428514ac9c52" name="ab538e978a97d98c7092d428514ac9c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab538e978a97d98c7092d428514ac9c52">&#9670;&#160;</a></span>getDoubleValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::getDoubleValue </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast value to double if possible. Throw if not. </p>

<p>Implements <a class="el" href="classsparta_1_1ParameterBase.html#a593f164c8173d78b7d1cfaf1866bf070">sparta::ParameterBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01427">1427</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<a id="a14a822ca562a0e7cfbb70ca60c509031" name="a14a822ca562a0e7cfbb70ca60c509031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a822ca562a0e7cfbb70ca60c509031">&#9670;&#160;</a></span>getDoubleValue_() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, double &gt;<a class="el" href="#ad75bb728b6180aa7caad038ef7ad5d7f">::type</a> <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::getDoubleValue_ </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01811">1811</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<a id="a90ecb91c7d429228593a7701e33c5d34" name="a90ecb91c7d429228593a7701e33c5d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ecb91c7d429228593a7701e33c5d34">&#9670;&#160;</a></span>getDoubleValue_() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_arithmetic&lt; T &gt;::value, double &gt;<a class="el" href="#ad75bb728b6180aa7caad038ef7ad5d7f">::type</a> <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::getDoubleValue_ </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01817">1817</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<a id="aaa4ee1dcd6a654426b11908083647238" name="aaa4ee1dcd6a654426b11908083647238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4ee1dcd6a654426b11908083647238">&#9670;&#160;</a></span>getItemValueFromString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::getItemValueFromString </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>peek</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override from <a class="el" href="classsparta_1_1ParameterBase.html" title="Non-templated base class for generic parameter access and iteration.">ParameterBase</a>. </p>
<dl class="section warning"><dt>Warning</dt><dd>peek is highly discouraged outside of framework use since it undermines SPARTA's protection for parameter write-after-reads </dd></dl>

<p>Implements <a class="el" href="classsparta_1_1ParameterBase.html#a11b2f68d5b3c7edb192dc5a1dc57f47e">sparta::ParameterBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01321">1321</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<a id="a037e5e41f14b3de6daf736357d78dd6c" name="a037e5e41f14b3de6daf736357d78dd6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037e5e41f14b3de6daf736357d78dd6c">&#9670;&#160;</a></span>getNumericDisplayBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Printing_8hpp.html#afabfc368950e958421c5eba711aadee5">sparta::utils::DisplayBase</a> <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::getNumericDisplayBase </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the numeric base for displaying the value of this parameter. </p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01709">1709</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<a id="ab87eae331f49a25fa566a427dbd30b03" name="ab87eae331f49a25fa566a427dbd30b03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab87eae331f49a25fa566a427dbd30b03">&#9670;&#160;</a></span>getNumValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::getNumValues </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>peek</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of values in this <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of values in this parameter if a vector. If not a vector, returns 1. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Increments reference count if this parameter is a vector type (see isVector). Otherwise, has no effect. </dd></dl>

<p>Implements <a class="el" href="classsparta_1_1ParameterBase.html#a1aef03b182d09beae70776f9326aebd3">sparta::ParameterBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01438">1438</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<a id="a8b33ce993b9abe4e81ce42eb97857eff" name="a8b33ce993b9abe4e81ce42eb97857eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b33ce993b9abe4e81ce42eb97857eff">&#9670;&#160;</a></span>getTypeName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::string <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::getTypeName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the human-readable name of this parameter's type. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classsparta_1_1ParameterBase.html#afa78d629519086dc16626f7e64817381" title="Gets the compiler-independent readable type string of the value currently held.">sparta::ParameterBase::getTypeName</a> </dd></dl>

<p>Implements <a class="el" href="classsparta_1_1ParameterBase.html#afa78d629519086dc16626f7e64817381">sparta::ParameterBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01270">1270</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<a id="a4002f93df7129d4a1b9007fc626e2462" name="a4002f93df7129d4a1b9007fc626e2462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4002f93df7129d4a1b9007fc626e2462">&#9670;&#160;</a></span>getValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ValueType &amp; <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::getValue </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current value of this <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>current value of parameter. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Increments reference count </dd></dl>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01403">1403</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Parameter_a4002f93df7129d4a1b9007fc626e2462_cgraph.png" border="0" usemap="#aclasssparta_1_1Parameter_a4002f93df7129d4a1b9007fc626e2462_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Parameter_a4002f93df7129d4a1b9007fc626e2462_cgraph" id="aclasssparta_1_1Parameter_a4002f93df7129d4a1b9007fc626e2462_cgraph">
<area shape="rect" title="Gets the current value of this Parameter." alt="" coords="5,39,135,79"/>
<area shape="rect" href="classsparta_1_1Parameter.html#aa3ec20115fc09a5da95e1efe6de7712b" title="Iternal getValue_ wrapper which does not increment the read counter." alt="" coords="196,5,325,46"/>
<area shape="poly" title=" " alt="" coords="134,45,180,37,181,42,135,50"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#a0663f6e558287f2d89b8d573504d9eb9" title="Increment the number of reads that will be reported by getReadCount." alt="" coords="183,71,338,111"/>
<area shape="poly" title=" " alt="" coords="135,67,168,73,167,78,134,72"/>
</map>
</div>

</div>
</div>
<a id="aa3ec20115fc09a5da95e1efe6de7712b" name="aa3ec20115fc09a5da95e1efe6de7712b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ec20115fc09a5da95e1efe6de7712b">&#9670;&#160;</a></span>getValue_()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ValueType &amp; <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::getValue_ </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iternal getValue_ wrapper which does not increment the read counter. </p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01805">1805</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<a id="acb696e84552242fd4280958d49623994" name="acb696e84552242fd4280958d49623994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb696e84552242fd4280958d49623994">&#9670;&#160;</a></span>getValueAsString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::getValueAsString </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns value as a string, even if type is a vector. </p>
<dl class="section return"><dt>Returns</dt><dd>string representation of current value </dd></dl>
<dl class="section note"><dt>Note</dt><dd>does not increment read counter</dd></dl>
<p>Refer to 'sparta::stringize' for vector-to-string formatting. </p>

<p>Implements <a class="el" href="classsparta_1_1ParameterBase.html#af6c4cc8b71bedec1ee718f0218a7b905">sparta::ParameterBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01297">1297</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<a id="a37be5fa8bb230e79e14533226f0b021e" name="a37be5fa8bb230e79e14533226f0b021e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37be5fa8bb230e79e14533226f0b021e">&#9670;&#160;</a></span>getValueAsStringAt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::getValueAsStringAt </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>peek</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Treats this parameter as a vector and gets the value as a string at a specific index. If parameter is not a vector, it is treated as a 1-element vector. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a></td><td>if idx is out of bounds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>peek is highly discouraged outside of framework use since it undermines SPARTA's protection for parameter write-after-reads </dd></dl>

<p>Implements <a class="el" href="classsparta_1_1ParameterBase.html#a433e7c3a84aea61fc57839e82e3cd173">sparta::ParameterBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01312">1312</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<a id="a2dc86aeeee15bb10ce2fc5633116b0ef" name="a2dc86aeeee15bb10ce2fc5633116b0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc86aeeee15bb10ce2fc5633116b0ef">&#9670;&#160;</a></span>getVectorSizeAt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::getVectorSizeAt </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>peek</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of a nested vector within the parameter located by indices. </p>
<dl class="section warning"><dt>Warning</dt><dd>peek is highly discouraged outside of framework use since it undermines SPARTA's protection for parameter write-after-reads </dd></dl>

<p>Implements <a class="el" href="classsparta_1_1ParameterBase.html#aab7fe8c6c8743bb9e7b07f34ea46384a">sparta::ParameterBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01338">1338</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<a id="aa038c634ce8cc174ab250c94e7422772" name="aa038c634ce8cc174ab250c94e7422772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa038c634ce8cc174ab250c94e7422772">&#9670;&#160;</a></span>ignore()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::ignore </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks this parameter as ignored. </p>
<dl class="section note"><dt>Note</dt><dd>This method is intentionally omitted from <a class="el" href="classsparta_1_1ParameterBase.html" title="Non-templated base class for generic parameter access and iteration.">ParameterBase</a> so that only components consuming parameters can choose to ignore. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Read counts must may be reset by sparta infrastructure so this method may have no effect if called within a <a class="el" href="classsparta_1_1ParameterSet.html" title="Generic container of Parameters.">ParameterSet</a> constructor. The point of this behavior is to prevent early reads of the parameter value from appearing as if the <a class="el" href="classsparta_1_1Resource.html" title="The is the base class for all types of resources used by the SPARTA framework.">Resource</a> that owns this parameter read it. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#abeece5f57cd4bab7adb5c5ef51545b73" title="Mark this parameter as unread and unignored.">unread</a></dd></dl>
<p>When instantiating a <a class="el" href="classsparta_1_1Resource.html" title="The is the base class for all types of resources used by the SPARTA framework.">Resource</a>, every parameter must be either read (e.g. through getValue, operator ValueType, operator==), or ignored with this method. </p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01380">1380</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Parameter_aa038c634ce8cc174ab250c94e7422772_cgraph.png" border="0" usemap="#aclasssparta_1_1Parameter_aa038c634ce8cc174ab250c94e7422772_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Parameter_aa038c634ce8cc174ab250c94e7422772_cgraph" id="aclasssparta_1_1Parameter_aa038c634ce8cc174ab250c94e7422772_cgraph">
<area shape="rect" title="Marks this parameter as ignored." alt="" coords="5,5,135,46"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#af55bec773f43345955122381515d0173" title="Flag as ignored. See Parameter&lt;T&gt;::ignore." alt="" coords="183,5,336,46"/>
<area shape="poly" title=" " alt="" coords="135,23,167,23,167,28,135,28"/>
</map>
</div>

</div>
</div>
<a id="a88f846e287e35a8bd50b0678f7070e95" name="a88f846e287e35a8bd50b0678f7070e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f846e287e35a8bd50b0678f7070e95">&#9670;&#160;</a></span>isDefaultOverridden()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::isDefaultOverridden </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Has the default value (NOT the current value) for parameter been overridden in any way (including partially changed). </p>
<dl class="section warning"><dt>Warning</dt><dd>This does not provide information about the current value held by the parameter, only the default value.</dd></dl>
<p>In SPARTA, parameter defaults are supplied at construction-time through constants or constructors, but these defaults can also be changed during initialization in order to support custom architectural configuration baselines. An overridden default value does not necessarily imply a change in the current value held by this parameter. To see if the current value (getValueAsString or <a class="el" href="#a4002f93df7129d4a1b9007fc626e2462" title="Gets the current value of this Parameter.">Parameter&lt;t&gt;::getValue</a>) has changed, use isDefault (i.e. is this parameter's value equal to the default?) </p>

<p>Implements <a class="el" href="classsparta_1_1ParameterBase.html#a70c49466ee9754366c936f62b0154818">sparta::ParameterBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01621">1621</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<a id="a94522f8ab3cd8b3eb642066559f1e2ad" name="a94522f8ab3cd8b3eb642066559f1e2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94522f8ab3cd8b3eb642066559f1e2ad">&#9670;&#160;</a></span>isVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::isVector </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this parameter a vector? </p>
<dl class="section note"><dt>Note</dt><dd>THis is an invariant and does not increment the read count </dd></dl>

<p>Implements <a class="el" href="classsparta_1_1ParameterBase.html#a13939f0e329fccd915d54fb4c4c2afb9">sparta::ParameterBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01446">1446</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<a id="a2744386e81aea13c257e4c2ae7b279d0" name="a2744386e81aea13c257e4c2ae7b279d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2744386e81aea13c257e4c2ae7b279d0">&#9670;&#160;</a></span>isVisibilityAllowed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::isVisibilityAllowed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query if this parameter is safe to be displayed via prints, dumps. A parameter should not be displayed if it is HIDDEN and the subtree containing this parameter is already locked. </p>

<p>Implements <a class="el" href="classsparta_1_1ParameterBase.html#a8afbf15ebf293bb4f2f8c5618bdbe2b0">sparta::ParameterBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01768">1768</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Parameter_a2744386e81aea13c257e4c2ae7b279d0_cgraph.png" border="0" usemap="#aclasssparta_1_1Parameter_a2744386e81aea13c257e4c2ae7b279d0_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Parameter_a2744386e81aea13c257e4c2ae7b279d0_cgraph" id="aclasssparta_1_1Parameter_a2744386e81aea13c257e4c2ae7b279d0_cgraph">
<area shape="rect" title="Query if this parameter is safe to be displayed via prints, dumps. A parameter should not be displaye..." alt="" coords="5,5,135,46"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a811cf5ec3c1f09465768fba8bce6788e" title="This method informs whether the tree is past the lockdown phase for all LOCKED and HIDDEN parameters...." alt="" coords="183,5,394,46"/>
<area shape="poly" title=" " alt="" coords="135,23,167,23,167,28,135,28"/>
</map>
</div>

</div>
</div>
<a id="a2cdfa7fa59064b6fd0d3b95e3b2a1013" name="a2cdfa7fa59064b6fd0d3b95e3b2a1013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cdfa7fa59064b6fd0d3b95e3b2a1013">&#9670;&#160;</a></span>operator const ValueType &amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::operator const ValueType &amp; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a the value currently held by this <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Value currenty held by this <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01353">1353</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Parameter_a2cdfa7fa59064b6fd0d3b95e3b2a1013_cgraph.png" border="0" usemap="#aclasssparta_1_1Parameter_a2cdfa7fa59064b6fd0d3b95e3b2a1013_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Parameter_a2cdfa7fa59064b6fd0d3b95e3b2a1013_cgraph" id="aclasssparta_1_1Parameter_a2cdfa7fa59064b6fd0d3b95e3b2a1013_cgraph">
<area shape="rect" title="Gets a the value currently held by this Parameter." alt="" coords="5,39,185,79"/>
<area shape="rect" href="classsparta_1_1Parameter.html#a4002f93df7129d4a1b9007fc626e2462" title="Gets the current value of this Parameter." alt="" coords="233,39,362,79"/>
<area shape="poly" title=" " alt="" coords="185,56,217,56,217,62,185,62"/>
<area shape="rect" href="classsparta_1_1Parameter.html#aa3ec20115fc09a5da95e1efe6de7712b" title="Iternal getValue_ wrapper which does not increment the read counter." alt="" coords="423,5,552,46"/>
<area shape="poly" title=" " alt="" coords="362,45,407,37,408,42,363,50"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#a0663f6e558287f2d89b8d573504d9eb9" title="Increment the number of reads that will be reported by getReadCount." alt="" coords="410,71,565,111"/>
<area shape="poly" title=" " alt="" coords="363,67,395,73,394,78,362,72"/>
</map>
</div>

</div>
</div>
<a id="ad5ac7466386653f4a480018187145328" name="ad5ac7466386653f4a480018187145328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ac7466386653f4a480018187145328">&#9670;&#160;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1Parameter.html">Parameter</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhp</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> objects by value. </p>
<dl class="section post"><dt>Postcondition</dt><dd>Increments read count </dd></dl>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01485">1485</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Parameter_ad5ac7466386653f4a480018187145328_cgraph.png" border="0" usemap="#aclasssparta_1_1Parameter_ad5ac7466386653f4a480018187145328_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Parameter_ad5ac7466386653f4a480018187145328_cgraph" id="aclasssparta_1_1Parameter_ad5ac7466386653f4a480018187145328_cgraph">
<area shape="rect" title="Compares two Parameter objects by value." alt="" coords="5,39,135,79"/>
<area shape="rect" href="classsparta_1_1Parameter.html#a4002f93df7129d4a1b9007fc626e2462" title="Gets the current value of this Parameter." alt="" coords="183,39,312,79"/>
<area shape="poly" title=" " alt="" coords="135,56,167,56,167,62,135,62"/>
<area shape="rect" href="classsparta_1_1Parameter.html#aa3ec20115fc09a5da95e1efe6de7712b" title="Iternal getValue_ wrapper which does not increment the read counter." alt="" coords="373,5,502,46"/>
<area shape="poly" title=" " alt="" coords="312,45,357,37,358,42,313,50"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#a0663f6e558287f2d89b8d573504d9eb9" title="Increment the number of reads that will be reported by getReadCount." alt="" coords="360,71,515,111"/>
<area shape="poly" title=" " alt="" coords="313,67,345,73,344,78,312,72"/>
</map>
</div>

</div>
</div>
<a id="a917f7a286151ba1d0852feffe79ee39a" name="a917f7a286151ba1d0852feffe79ee39a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a917f7a286151ba1d0852feffe79ee39a">&#9670;&#160;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_base_of&lt; <a class="el" href="classsparta_1_1ParameterBase.html">ParameterBase</a>, T &gt;::value, bool &gt;<a class="el" href="#ad75bb728b6180aa7caad038ef7ad5d7f">::type</a> <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>rhp</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments read count. </p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01532">1532</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Parameter_a917f7a286151ba1d0852feffe79ee39a_cgraph.png" border="0" usemap="#aclasssparta_1_1Parameter_a917f7a286151ba1d0852feffe79ee39a_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Parameter_a917f7a286151ba1d0852feffe79ee39a_cgraph" id="aclasssparta_1_1Parameter_a917f7a286151ba1d0852feffe79ee39a_cgraph">
<area shape="rect" title="Increments read count." alt="" coords="5,39,135,79"/>
<area shape="rect" href="classsparta_1_1Parameter.html#a4002f93df7129d4a1b9007fc626e2462" title="Gets the current value of this Parameter." alt="" coords="183,39,312,79"/>
<area shape="poly" title=" " alt="" coords="135,56,167,56,167,62,135,62"/>
<area shape="rect" href="classsparta_1_1Parameter.html#aa3ec20115fc09a5da95e1efe6de7712b" title="Iternal getValue_ wrapper which does not increment the read counter." alt="" coords="373,5,502,46"/>
<area shape="poly" title=" " alt="" coords="312,45,357,37,358,42,313,50"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#a0663f6e558287f2d89b8d573504d9eb9" title="Increment the number of reads that will be reported by getReadCount." alt="" coords="360,71,515,111"/>
<area shape="poly" title=" " alt="" coords="313,67,345,73,344,78,312,72"/>
</map>
</div>

</div>
</div>
<a id="aaa69ab01de249a2f932ff61014f7f3bb" name="aaa69ab01de249a2f932ff61014f7f3bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa69ab01de249a2f932ff61014f7f3bb">&#9670;&#160;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ValueType &amp; <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::operator() </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the value currently held by this <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Value currently held by this <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01361">1361</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Parameter_aaa69ab01de249a2f932ff61014f7f3bb_cgraph.png" border="0" usemap="#aclasssparta_1_1Parameter_aaa69ab01de249a2f932ff61014f7f3bb_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Parameter_aaa69ab01de249a2f932ff61014f7f3bb_cgraph" id="aclasssparta_1_1Parameter_aaa69ab01de249a2f932ff61014f7f3bb_cgraph">
<area shape="rect" title="Gets the value currently held by this Parameter." alt="" coords="5,39,135,79"/>
<area shape="rect" href="classsparta_1_1Parameter.html#a4002f93df7129d4a1b9007fc626e2462" title="Gets the current value of this Parameter." alt="" coords="183,39,312,79"/>
<area shape="poly" title=" " alt="" coords="135,56,167,56,167,62,135,62"/>
<area shape="rect" href="classsparta_1_1Parameter.html#aa3ec20115fc09a5da95e1efe6de7712b" title="Iternal getValue_ wrapper which does not increment the read counter." alt="" coords="373,5,502,46"/>
<area shape="poly" title=" " alt="" coords="312,45,357,37,358,42,313,50"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#a0663f6e558287f2d89b8d573504d9eb9" title="Increment the number of reads that will be reported by getReadCount." alt="" coords="360,71,515,111"/>
<area shape="poly" title=" " alt="" coords="313,67,345,73,344,78,312,72"/>
</map>
</div>

</div>
</div>
<a id="acf90330443b0d393ce1c35b4e432bc59" name="acf90330443b0d393ce1c35b4e432bc59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf90330443b0d393ce1c35b4e432bc59">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1Parameter.html">Parameter</a>&lt; <a class="el" href="#ad75bb728b6180aa7caad038ef7ad5d7f">type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhp</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> objects by value. </p>
<dl class="section post"><dt>Postcondition</dt><dd>Increments read count </dd></dl>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01510">1510</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Parameter_acf90330443b0d393ce1c35b4e432bc59_cgraph.png" border="0" usemap="#aclasssparta_1_1Parameter_acf90330443b0d393ce1c35b4e432bc59_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Parameter_acf90330443b0d393ce1c35b4e432bc59_cgraph" id="aclasssparta_1_1Parameter_acf90330443b0d393ce1c35b4e432bc59_cgraph">
<area shape="rect" title="Compares two Parameter objects by value." alt="" coords="5,39,135,79"/>
<area shape="rect" href="classsparta_1_1Parameter.html#a4002f93df7129d4a1b9007fc626e2462" title="Gets the current value of this Parameter." alt="" coords="183,39,312,79"/>
<area shape="poly" title=" " alt="" coords="135,56,167,56,167,62,135,62"/>
<area shape="rect" href="classsparta_1_1Parameter.html#aa3ec20115fc09a5da95e1efe6de7712b" title="Iternal getValue_ wrapper which does not increment the read counter." alt="" coords="373,5,502,46"/>
<area shape="poly" title=" " alt="" coords="312,45,357,37,358,42,313,50"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#a0663f6e558287f2d89b8d573504d9eb9" title="Increment the number of reads that will be reported by getReadCount." alt="" coords="360,71,515,111"/>
<area shape="poly" title=" " alt="" coords="313,67,345,73,344,78,312,72"/>
</map>
</div>

</div>
</div>
<a id="a730bc68591e8ac73b2251035ef7f631c" name="a730bc68591e8ac73b2251035ef7f631c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730bc68591e8ac73b2251035ef7f631c">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_base_of&lt; <a class="el" href="classsparta_1_1ParameterBase.html">ParameterBase</a>, T &gt;::value, bool &gt;<a class="el" href="#ad75bb728b6180aa7caad038ef7ad5d7f">::type</a> <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>rhp</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments read count. </p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01552">1552</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Parameter_a730bc68591e8ac73b2251035ef7f631c_cgraph.png" border="0" usemap="#aclasssparta_1_1Parameter_a730bc68591e8ac73b2251035ef7f631c_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Parameter_a730bc68591e8ac73b2251035ef7f631c_cgraph" id="aclasssparta_1_1Parameter_a730bc68591e8ac73b2251035ef7f631c_cgraph">
<area shape="rect" title="Increments read count." alt="" coords="5,39,135,79"/>
<area shape="rect" href="classsparta_1_1Parameter.html#a4002f93df7129d4a1b9007fc626e2462" title="Gets the current value of this Parameter." alt="" coords="183,39,312,79"/>
<area shape="poly" title=" " alt="" coords="135,56,167,56,167,62,135,62"/>
<area shape="rect" href="classsparta_1_1Parameter.html#aa3ec20115fc09a5da95e1efe6de7712b" title="Iternal getValue_ wrapper which does not increment the read counter." alt="" coords="373,5,502,46"/>
<area shape="poly" title=" " alt="" coords="312,45,357,37,358,42,313,50"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#a0663f6e558287f2d89b8d573504d9eb9" title="Increment the number of reads that will be reported by getReadCount." alt="" coords="360,71,515,111"/>
<area shape="poly" title=" " alt="" coords="313,67,345,73,344,78,312,72"/>
</map>
</div>

</div>
</div>
<a id="aa873586c6dd7c8fee0afb157135a46e4" name="aa873586c6dd7c8fee0afb157135a46e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa873586c6dd7c8fee0afb157135a46e4">&#9670;&#160;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<div class="memtemplate">
template&lt;class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Parameter.html">Parameter</a>&lt; ValueType &gt; &amp; <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for constructing vectors. </p>
<dl class="section note"><dt>Note</dt><dd>Does not impact getWriteCount. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This should be used for initializing parameters only. This method is currently public so that distant subclasses can access it. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Write count is incremented and read count reset</dd></dl>
<p>Allows: </p><div class="fragment"><div class="line">param &lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 3;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01733">1733</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Parameter_aa873586c6dd7c8fee0afb157135a46e4_cgraph.png" border="0" usemap="#aclasssparta_1_1Parameter_aa873586c6dd7c8fee0afb157135a46e4_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Parameter_aa873586c6dd7c8fee0afb157135a46e4_cgraph" id="aclasssparta_1_1Parameter_aa873586c6dd7c8fee0afb157135a46e4_cgraph">
<area shape="rect" title="Helper for constructing vectors." alt="" coords="5,5,135,46"/>
<area shape="rect" href="classsparta_1_1Parameter.html#aa3ec20115fc09a5da95e1efe6de7712b" title="Iternal getValue_ wrapper which does not increment the read counter." alt="" coords="183,5,312,46"/>
<area shape="poly" title=" " alt="" coords="135,23,167,23,167,28,135,28"/>
</map>
</div>

</div>
</div>
<a id="a8c74a2913e9738e3854fcb72d8fb7a63" name="a8c74a2913e9738e3854fcb72d8fb7a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c74a2913e9738e3854fcb72d8fb7a63">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1Parameter.html">Parameter</a>&lt; <a class="el" href="#ad75bb728b6180aa7caad038ef7ad5d7f">type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhp</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> objects by value. </p>
<dl class="section post"><dt>Postcondition</dt><dd>Increments read count </dd></dl>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01518">1518</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Parameter_a8c74a2913e9738e3854fcb72d8fb7a63_cgraph.png" border="0" usemap="#aclasssparta_1_1Parameter_a8c74a2913e9738e3854fcb72d8fb7a63_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Parameter_a8c74a2913e9738e3854fcb72d8fb7a63_cgraph" id="aclasssparta_1_1Parameter_a8c74a2913e9738e3854fcb72d8fb7a63_cgraph">
<area shape="rect" title="Compares two Parameter objects by value." alt="" coords="5,39,135,79"/>
<area shape="rect" href="classsparta_1_1Parameter.html#a4002f93df7129d4a1b9007fc626e2462" title="Gets the current value of this Parameter." alt="" coords="183,39,312,79"/>
<area shape="poly" title=" " alt="" coords="135,56,167,56,167,62,135,62"/>
<area shape="rect" href="classsparta_1_1Parameter.html#aa3ec20115fc09a5da95e1efe6de7712b" title="Iternal getValue_ wrapper which does not increment the read counter." alt="" coords="373,5,502,46"/>
<area shape="poly" title=" " alt="" coords="312,45,357,37,358,42,313,50"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#a0663f6e558287f2d89b8d573504d9eb9" title="Increment the number of reads that will be reported by getReadCount." alt="" coords="360,71,515,111"/>
<area shape="poly" title=" " alt="" coords="313,67,345,73,344,78,312,72"/>
</map>
</div>

</div>
</div>
<a id="a3565f68b825e7fafea55f9c47ed1db77" name="a3565f68b825e7fafea55f9c47ed1db77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3565f68b825e7fafea55f9c47ed1db77">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_base_of&lt; <a class="el" href="classsparta_1_1ParameterBase.html">ParameterBase</a>, T &gt;::value, bool &gt;<a class="el" href="#ad75bb728b6180aa7caad038ef7ad5d7f">::type</a> <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>rhp</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments read count. </p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01559">1559</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Parameter_a3565f68b825e7fafea55f9c47ed1db77_cgraph.png" border="0" usemap="#aclasssparta_1_1Parameter_a3565f68b825e7fafea55f9c47ed1db77_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Parameter_a3565f68b825e7fafea55f9c47ed1db77_cgraph" id="aclasssparta_1_1Parameter_a3565f68b825e7fafea55f9c47ed1db77_cgraph">
<area shape="rect" title="Increments read count." alt="" coords="5,39,135,79"/>
<area shape="rect" href="classsparta_1_1Parameter.html#a4002f93df7129d4a1b9007fc626e2462" title="Gets the current value of this Parameter." alt="" coords="183,39,312,79"/>
<area shape="poly" title=" " alt="" coords="135,56,167,56,167,62,135,62"/>
<area shape="rect" href="classsparta_1_1Parameter.html#aa3ec20115fc09a5da95e1efe6de7712b" title="Iternal getValue_ wrapper which does not increment the read counter." alt="" coords="373,5,502,46"/>
<area shape="poly" title=" " alt="" coords="312,45,357,37,358,42,313,50"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#a0663f6e558287f2d89b8d573504d9eb9" title="Increment the number of reads that will be reported by getReadCount." alt="" coords="360,71,515,111"/>
<area shape="poly" title=" " alt="" coords="313,67,345,73,344,78,312,72"/>
</map>
</div>

</div>
</div>
<a id="a05a58d898f4d773903dc6ecb6260a797" name="a05a58d898f4d773903dc6ecb6260a797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a58d898f4d773903dc6ecb6260a797">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1Parameter.html">Parameter</a>&lt; ValueType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment - deleted explicitly. </p>
<dl class="section note"><dt>Note</dt><dd>This explicit delete of the copy assignment operator is to work around cases where we have one parameter A getting its value at run time from another parameter B, using the simple syntax A = B. The issue with this is that it's rather ambiguous whether this syntax attempts to copy a parameter value into A from B, or copy the entire <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> object. Hence, explicitly deleted. Use <a class="el" href="#a4002f93df7129d4a1b9007fc626e2462" title="Gets the current value of this Parameter.">getValue()</a> calls for value copy. </dd></dl>

</div>
</div>
<a id="a1f23570d658ad7780ce5a88472ab7efb" name="a1f23570d658ad7780ce5a88472ab7efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f23570d658ad7780ce5a88472ab7efb">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the specified value to this parameter. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000051">Todo</a></b></dt><dd>Perform independent parameter validation and throw exception if failed. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Write count is incremented and read count reset</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the user is initializing the parameters using a final config, then parameters assignments are not allocated. The user must use the <code>override*</code> methods. This does <em>not</em> apply to parameters whose visibility is hidden </dd></dl>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01590">1590</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Parameter_a1f23570d658ad7780ce5a88472ab7efb_cgraph.png" border="0" usemap="#aclasssparta_1_1Parameter_a1f23570d658ad7780ce5a88472ab7efb_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Parameter_a1f23570d658ad7780ce5a88472ab7efb_cgraph" id="aclasssparta_1_1Parameter_a1f23570d658ad7780ce5a88472ab7efb_cgraph">
<area shape="rect" title="Assigns the specified value to this parameter." alt="" coords="5,150,135,190"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a1a6d4aac10bfa5345b587d84170441de" title=" " alt="" coords="408,5,602,31"/>
<area shape="poly" title=" " alt="" coords="80,148,119,93,148,64,181,41,233,21,287,10,341,5,392,4,392,9,342,10,288,15,234,26,184,46,151,68,123,96,85,151"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#a6fa5c793d436deda683384bc989615ef" title="Increments the number of writes that will be reported by getWriteCount." alt="" coords="194,55,349,96"/>
<area shape="poly" title=" " alt="" coords="105,147,182,106,197,100,199,105,184,111,108,152"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#ac3e3f0af10beb201fd8e49f770c6ea73" title="Invoke any register callbacks for this parameter. These callbacks are used by Parameters to make modi..." alt="" coords="195,120,348,161"/>
<area shape="poly" title=" " alt="" coords="135,158,179,152,180,157,136,163"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#ad3780c614eaa9c18ba2a162c32c2fa24" title="Is this TreeNode supposed to be hidden during tree printouts This value does not have to be respected..." alt="" coords="183,185,360,211"/>
<area shape="poly" title=" " alt="" coords="136,177,168,181,167,186,135,182"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#ab639ac53e587869d2d7981a1b89e8285" title="Log the most recently assigned value given to this parameter to the global parameters logger for debu..." alt="" coords="195,235,348,276"/>
<area shape="poly" title=" " alt="" coords="114,189,184,221,197,227,195,232,182,226,112,194"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#ac0b7033f61214146640a83e64fb1f9b1" title="Ask the simulator if we are using a final config." alt="" coords="195,300,348,341"/>
<area shape="poly" title=" " alt="" coords="88,189,129,237,155,263,184,285,193,291,191,295,181,290,152,267,125,241,84,193"/>
<area shape="poly" title=" " alt="" coords="349,54,434,33,435,38,350,59"/>
<area shape="rect" href="classsparta_1_1PhasedObject.html#ade690bdb9df72fd6bad8847fbdf226f1" title="Gets the trees current phase." alt="" coords="432,55,578,96"/>
<area shape="poly" title=" " alt="" coords="350,73,417,73,417,78,350,78"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#a2d42e4b8c58c2970f4f1e28e76448b12" title="Is this a volatile parmaeter?" alt="" coords="428,120,582,161"/>
<area shape="poly" title=" " alt="" coords="347,94,416,113,414,118,346,99"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#a03addcff7db396f643149458febf51e4" title="Resets the number of reads that wil be reported by getReadCount." alt="" coords="428,186,582,226"/>
<area shape="poly" title=" " alt="" coords="341,94,362,107,378,123,386,140,395,155,410,171,418,176,415,181,406,175,390,159,382,142,373,126,358,111,338,99"/>
</map>
</div>

</div>
</div>
<a id="aec9c08be5bee629ffed4dc7ca0e8fb72" name="aec9c08be5bee629ffed4dc7ca0e8fb72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec9c08be5bee629ffed4dc7ca0e8fb72">&#9670;&#160;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1Parameter.html">Parameter</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhp</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> objects by value. </p>
<dl class="section post"><dt>Postcondition</dt><dd>Increments read count </dd></dl>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01476">1476</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Parameter_aec9c08be5bee629ffed4dc7ca0e8fb72_cgraph.png" border="0" usemap="#aclasssparta_1_1Parameter_aec9c08be5bee629ffed4dc7ca0e8fb72_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Parameter_aec9c08be5bee629ffed4dc7ca0e8fb72_cgraph" id="aclasssparta_1_1Parameter_aec9c08be5bee629ffed4dc7ca0e8fb72_cgraph">
<area shape="rect" title="Compares two Parameter objects by value." alt="" coords="5,39,135,79"/>
<area shape="rect" href="classsparta_1_1Parameter.html#a4002f93df7129d4a1b9007fc626e2462" title="Gets the current value of this Parameter." alt="" coords="183,39,312,79"/>
<area shape="poly" title=" " alt="" coords="135,56,167,56,167,62,135,62"/>
<area shape="rect" href="classsparta_1_1Parameter.html#aa3ec20115fc09a5da95e1efe6de7712b" title="Iternal getValue_ wrapper which does not increment the read counter." alt="" coords="373,5,502,46"/>
<area shape="poly" title=" " alt="" coords="312,45,357,37,358,42,313,50"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#a0663f6e558287f2d89b8d573504d9eb9" title="Increment the number of reads that will be reported by getReadCount." alt="" coords="360,71,515,111"/>
<area shape="poly" title=" " alt="" coords="313,67,345,73,344,78,312,72"/>
</map>
</div>

</div>
</div>
<a id="a14647c23e7dacee88576fbfa57d40cea" name="a14647c23e7dacee88576fbfa57d40cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14647c23e7dacee88576fbfa57d40cea">&#9670;&#160;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_base_of&lt; <a class="el" href="classsparta_1_1ParameterBase.html">ParameterBase</a>, T &gt;::value, bool &gt;<a class="el" href="#ad75bb728b6180aa7caad038ef7ad5d7f">::type</a> <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>rhp</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments read count. </p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01525">1525</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Parameter_a14647c23e7dacee88576fbfa57d40cea_cgraph.png" border="0" usemap="#aclasssparta_1_1Parameter_a14647c23e7dacee88576fbfa57d40cea_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Parameter_a14647c23e7dacee88576fbfa57d40cea_cgraph" id="aclasssparta_1_1Parameter_a14647c23e7dacee88576fbfa57d40cea_cgraph">
<area shape="rect" title="Increments read count." alt="" coords="5,39,135,79"/>
<area shape="rect" href="classsparta_1_1Parameter.html#a4002f93df7129d4a1b9007fc626e2462" title="Gets the current value of this Parameter." alt="" coords="183,39,312,79"/>
<area shape="poly" title=" " alt="" coords="135,56,167,56,167,62,135,62"/>
<area shape="rect" href="classsparta_1_1Parameter.html#aa3ec20115fc09a5da95e1efe6de7712b" title="Iternal getValue_ wrapper which does not increment the read counter." alt="" coords="373,5,502,46"/>
<area shape="poly" title=" " alt="" coords="312,45,357,37,358,42,313,50"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#a0663f6e558287f2d89b8d573504d9eb9" title="Increment the number of reads that will be reported by getReadCount." alt="" coords="360,71,515,111"/>
<area shape="poly" title=" " alt="" coords="313,67,345,73,344,78,312,72"/>
</map>
</div>

</div>
</div>
<a id="af49bc4b97ea2eeca7a52a59f88a95ceb" name="af49bc4b97ea2eeca7a52a59f88a95ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af49bc4b97ea2eeca7a52a59f88a95ceb">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1Parameter.html">Parameter</a>&lt; <a class="el" href="#ad75bb728b6180aa7caad038ef7ad5d7f">type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhp</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> objects by value. </p>
<dl class="section post"><dt>Postcondition</dt><dd>Increments read count </dd></dl>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01493">1493</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Parameter_af49bc4b97ea2eeca7a52a59f88a95ceb_cgraph.png" border="0" usemap="#aclasssparta_1_1Parameter_af49bc4b97ea2eeca7a52a59f88a95ceb_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Parameter_af49bc4b97ea2eeca7a52a59f88a95ceb_cgraph" id="aclasssparta_1_1Parameter_af49bc4b97ea2eeca7a52a59f88a95ceb_cgraph">
<area shape="rect" title="Compares two Parameter objects by value." alt="" coords="5,39,135,79"/>
<area shape="rect" href="classsparta_1_1Parameter.html#a4002f93df7129d4a1b9007fc626e2462" title="Gets the current value of this Parameter." alt="" coords="183,39,312,79"/>
<area shape="poly" title=" " alt="" coords="135,56,167,56,167,62,135,62"/>
<area shape="rect" href="classsparta_1_1Parameter.html#aa3ec20115fc09a5da95e1efe6de7712b" title="Iternal getValue_ wrapper which does not increment the read counter." alt="" coords="373,5,502,46"/>
<area shape="poly" title=" " alt="" coords="312,45,357,37,358,42,313,50"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#a0663f6e558287f2d89b8d573504d9eb9" title="Increment the number of reads that will be reported by getReadCount." alt="" coords="360,71,515,111"/>
<area shape="poly" title=" " alt="" coords="313,67,345,73,344,78,312,72"/>
</map>
</div>

</div>
</div>
<a id="af9c2f60e9c069f511048a38035110bf4" name="af9c2f60e9c069f511048a38035110bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9c2f60e9c069f511048a38035110bf4">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_base_of&lt; <a class="el" href="classsparta_1_1ParameterBase.html">ParameterBase</a>, T &gt;::value, bool &gt;<a class="el" href="#ad75bb728b6180aa7caad038ef7ad5d7f">::type</a> <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>rhp</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments read count. </p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01539">1539</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Parameter_af9c2f60e9c069f511048a38035110bf4_cgraph.png" border="0" usemap="#aclasssparta_1_1Parameter_af9c2f60e9c069f511048a38035110bf4_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Parameter_af9c2f60e9c069f511048a38035110bf4_cgraph" id="aclasssparta_1_1Parameter_af9c2f60e9c069f511048a38035110bf4_cgraph">
<area shape="rect" title="Increments read count." alt="" coords="5,39,135,79"/>
<area shape="rect" href="classsparta_1_1Parameter.html#a4002f93df7129d4a1b9007fc626e2462" title="Gets the current value of this Parameter." alt="" coords="183,39,312,79"/>
<area shape="poly" title=" " alt="" coords="135,56,167,56,167,62,135,62"/>
<area shape="rect" href="classsparta_1_1Parameter.html#aa3ec20115fc09a5da95e1efe6de7712b" title="Iternal getValue_ wrapper which does not increment the read counter." alt="" coords="373,5,502,46"/>
<area shape="poly" title=" " alt="" coords="312,45,357,37,358,42,313,50"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#a0663f6e558287f2d89b8d573504d9eb9" title="Increment the number of reads that will be reported by getReadCount." alt="" coords="360,71,515,111"/>
<area shape="poly" title=" " alt="" coords="313,67,345,73,344,78,312,72"/>
</map>
</div>

</div>
</div>
<a id="ac0cd56b4806dd0c99f4c21c0f2608bd1" name="ac0cd56b4806dd0c99f4c21c0f2608bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0cd56b4806dd0c99f4c21c0f2608bd1">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1Parameter.html">Parameter</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhp</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> objects by value. </p>
<dl class="section post"><dt>Postcondition</dt><dd>Increments read count </dd></dl>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01502">1502</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Parameter_ac0cd56b4806dd0c99f4c21c0f2608bd1_cgraph.png" border="0" usemap="#aclasssparta_1_1Parameter_ac0cd56b4806dd0c99f4c21c0f2608bd1_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Parameter_ac0cd56b4806dd0c99f4c21c0f2608bd1_cgraph" id="aclasssparta_1_1Parameter_ac0cd56b4806dd0c99f4c21c0f2608bd1_cgraph">
<area shape="rect" title="Compares two Parameter objects by value." alt="" coords="5,39,135,79"/>
<area shape="rect" href="classsparta_1_1Parameter.html#a4002f93df7129d4a1b9007fc626e2462" title="Gets the current value of this Parameter." alt="" coords="183,39,312,79"/>
<area shape="poly" title=" " alt="" coords="135,56,167,56,167,62,135,62"/>
<area shape="rect" href="classsparta_1_1Parameter.html#aa3ec20115fc09a5da95e1efe6de7712b" title="Iternal getValue_ wrapper which does not increment the read counter." alt="" coords="373,5,502,46"/>
<area shape="poly" title=" " alt="" coords="312,45,357,37,358,42,313,50"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#a0663f6e558287f2d89b8d573504d9eb9" title="Increment the number of reads that will be reported by getReadCount." alt="" coords="360,71,515,111"/>
<area shape="poly" title=" " alt="" coords="313,67,345,73,344,78,312,72"/>
</map>
</div>

</div>
</div>
<a id="a9d464b0fd543f8743959616fe65d0c78" name="a9d464b0fd543f8743959616fe65d0c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d464b0fd543f8743959616fe65d0c78">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_base_of&lt; <a class="el" href="classsparta_1_1ParameterBase.html">ParameterBase</a>, T &gt;::value, bool &gt;<a class="el" href="#ad75bb728b6180aa7caad038ef7ad5d7f">::type</a> <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>rhp</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments read count. </p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01546">1546</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Parameter_a9d464b0fd543f8743959616fe65d0c78_cgraph.png" border="0" usemap="#aclasssparta_1_1Parameter_a9d464b0fd543f8743959616fe65d0c78_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Parameter_a9d464b0fd543f8743959616fe65d0c78_cgraph" id="aclasssparta_1_1Parameter_a9d464b0fd543f8743959616fe65d0c78_cgraph">
<area shape="rect" title="Increments read count." alt="" coords="5,39,135,79"/>
<area shape="rect" href="classsparta_1_1Parameter.html#a4002f93df7129d4a1b9007fc626e2462" title="Gets the current value of this Parameter." alt="" coords="183,39,312,79"/>
<area shape="poly" title=" " alt="" coords="135,56,167,56,167,62,135,62"/>
<area shape="rect" href="classsparta_1_1Parameter.html#aa3ec20115fc09a5da95e1efe6de7712b" title="Iternal getValue_ wrapper which does not increment the read counter." alt="" coords="373,5,502,46"/>
<area shape="poly" title=" " alt="" coords="312,45,357,37,358,42,313,50"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#a0663f6e558287f2d89b8d573504d9eb9" title="Increment the number of reads that will be reported by getReadCount." alt="" coords="360,71,515,111"/>
<area shape="poly" title=" " alt="" coords="313,67,345,73,344,78,312,72"/>
</map>
</div>

</div>
</div>
<a id="ac9f229421bbf30864b87e1d8d0b87b63" name="ac9f229421bbf30864b87e1d8d0b87b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f229421bbf30864b87e1d8d0b87b63">&#9670;&#160;</a></span>operator_insert_()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<div class="memtemplate">
template&lt;class U , class C1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structsparta_1_1is__vector.html">is_vector</a>&lt; C1 &gt;::value, <a class="el" href="classsparta_1_1Parameter.html">Parameter</a>&lt; ValueType &gt; &amp; &gt;<a class="el" href="#ad75bb728b6180aa7caad038ef7ad5d7f">::type</a> <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::operator_insert_ </td>
          <td>(</td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01777">1777</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<a id="ac67dc16f6b1fd26003673070dc5c2950" name="ac67dc16f6b1fd26003673070dc5c2950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac67dc16f6b1fd26003673070dc5c2950">&#9670;&#160;</a></span>overrideDefaultClearVectorValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::overrideDefaultClearVectorValue </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the parameter is a vector type, clears the default value so that it becomes an empty vector (regardless of dimensionality) </p>
<dl class="section note"><dt>Note</dt><dd>Has no effect if parameter is a non-vector type </dd></dl>

<p>Implements <a class="el" href="classsparta_1_1ParameterBase.html#a3f1779bf8ef296f27942d4f84d04ea6b">sparta::ParameterBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01662">1662</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<a id="adaf07b72e853b048e7be152b94d6d64f" name="adaf07b72e853b048e7be152b94d6d64f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf07b72e853b048e7be152b94d6d64f">&#9670;&#160;</a></span>overrideDefaultFromString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::overrideDefaultFromString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the default value of this non-vector parameter for architecture baseline configuration purposes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to write to default </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>This parameter is allowed to have been written but must not have been read yet. This parameter must not be a vector </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Does not attempt to resture current value from default. </dd>
<dd>
Does not increment write count </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not assign new defaults to Parameters without understanding how architecture configurations interact with defaults </dd></dl>

<p>Implements <a class="el" href="classsparta_1_1ParameterBase.html#aa6cfbd834d246b84a0bf668c3592b73a">sparta::ParameterBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01625">1625</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Parameter_adaf07b72e853b048e7be152b94d6d64f_cgraph.png" border="0" usemap="#aclasssparta_1_1Parameter_adaf07b72e853b048e7be152b94d6d64f_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Parameter_adaf07b72e853b048e7be152b94d6d64f_cgraph" id="aclasssparta_1_1Parameter_adaf07b72e853b048e7be152b94d6d64f_cgraph">
<area shape="rect" title="Sets the default value of this non&#45;vector parameter for architecture baseline configuration purposes." alt="" coords="5,27,178,68"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a1a6d4aac10bfa5345b587d84170441de" title=" " alt="" coords="226,5,420,31"/>
<area shape="poly" title=" " alt="" coords="178,34,210,30,210,35,178,39"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#ad3c7817fce432b087dc34b3aeecec766" title="Number of times this Parameter has been read after initialization or after the last write (or explici..." alt="" coords="246,55,400,96"/>
<area shape="poly" title=" " alt="" coords="178,55,231,62,230,67,178,61"/>
</map>
</div>

</div>
</div>
<a id="abf575259cd01e2f21e2839409ecfb11c" name="abf575259cd01e2f21e2839409ecfb11c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf575259cd01e2f21e2839409ecfb11c">&#9670;&#160;</a></span>overrideDefaultFromStringVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::overrideDefaultFromStringVector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the default value of this vector parameter for architecture baseline configuration purposes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to write to default </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>This parameter is allowed to have been written but must not have been read yet. This parameter must not be a vector </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Does not attempt to resture current value from default. </dd>
<dd>
Does not increment write count </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not assign new defaults to Parameters without understanding how architecture configurations interact with defaults </dd></dl>

<p>Implements <a class="el" href="classsparta_1_1ParameterBase.html#a030c203c6e22e9a20537d265e4b9dfc8">sparta::ParameterBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01633">1633</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Parameter_abf575259cd01e2f21e2839409ecfb11c_cgraph.png" border="0" usemap="#aclasssparta_1_1Parameter_abf575259cd01e2f21e2839409ecfb11c_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Parameter_abf575259cd01e2f21e2839409ecfb11c_cgraph" id="aclasssparta_1_1Parameter_abf575259cd01e2f21e2839409ecfb11c_cgraph">
<area shape="rect" title="Sets the default value of this vector parameter for architecture baseline configuration purposes." alt="" coords="5,27,216,68"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a1a6d4aac10bfa5345b587d84170441de" title=" " alt="" coords="264,5,458,31"/>
<area shape="poly" title=" " alt="" coords="216,32,248,29,249,34,216,38"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#ad3c7817fce432b087dc34b3aeecec766" title="Number of times this Parameter has been read after initialization or after the last write (or explici..." alt="" coords="284,55,438,96"/>
<area shape="poly" title=" " alt="" coords="216,57,269,63,268,68,216,62"/>
</map>
</div>

</div>
</div>
<a id="a2d414f91f18e584169d18cc55a9aa209" name="a2d414f91f18e584169d18cc55a9aa209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d414f91f18e584169d18cc55a9aa209">&#9670;&#160;</a></span>overrideDefaultItemValueFromString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::overrideDefaultItemValueFromString </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partially override the default default value in some element at an n-dimensional array specified. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This parameter is allowed to have been written but must not have been read yet. This parameter must not be a vector </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Does not attempt to resture current value from default. </dd></dl>

<p>Implements <a class="el" href="classsparta_1_1ParameterBase.html#aa98b7bfff53ae7e11ef08b7c434592f1">sparta::ParameterBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01641">1641</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<a id="a109e4b60b180e8baa424a096b4933f23" name="a109e4b60b180e8baa424a096b4933f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109e4b60b180e8baa424a096b4933f23">&#9670;&#160;</a></span>overrideDefaultResizeVectorsFromString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::overrideDefaultResizeVectorsFromString </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override the default value by clearing the possibly-nested vector (if this parameter is a vector). The nested vector contens can then be set by overrideDefaultItemValueFromString. </p>

<p>Implements <a class="el" href="classsparta_1_1ParameterBase.html#ab53aee2706af9952ab239b17fbacae60">sparta::ParameterBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01654">1654</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<a id="a98993f7c2db4f9639a8f18dee402c0a0" name="a98993f7c2db4f9639a8f18dee402c0a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98993f7c2db4f9639a8f18dee402c0a0">&#9670;&#160;</a></span>peekValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ValueType &amp; <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::peekValue </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current value of this <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> without incrementing the read count. This should be used when validating parameters in a <a class="el" href="classsparta_1_1Resource.html" title="The is the base class for all types of resources used by the SPARTA framework.">Resource</a> Constructor. </p>
<dl class="section return"><dt>Returns</dt><dd>current value of parameter. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>peek is highly discouraged outside of framework use since it undermines SPARTA's protection for parameter write-after-reads. If using this command for a model without a thorough understanding tree construction phases and parameter application, you may experience unexpected values for your parameters or read parameters that differ from the final assigned parameter. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01420">1420</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Parameter_a98993f7c2db4f9639a8f18dee402c0a0_cgraph.png" border="0" usemap="#aclasssparta_1_1Parameter_a98993f7c2db4f9639a8f18dee402c0a0_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Parameter_a98993f7c2db4f9639a8f18dee402c0a0_cgraph" id="aclasssparta_1_1Parameter_a98993f7c2db4f9639a8f18dee402c0a0_cgraph">
<area shape="rect" title="Gets the current value of this Parameter without incrementing the read count. This should be used whe..." alt="" coords="5,5,135,46"/>
<area shape="rect" href="classsparta_1_1Parameter.html#aa3ec20115fc09a5da95e1efe6de7712b" title="Iternal getValue_ wrapper which does not increment the read counter." alt="" coords="183,5,312,46"/>
<area shape="poly" title=" " alt="" coords="135,23,167,23,167,28,135,28"/>
</map>
</div>

</div>
</div>
<a id="a614aef390723e61cd91e11d66f9b88e8" name="a614aef390723e61cd91e11d66f9b88e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614aef390723e61cd91e11d66f9b88e8">&#9670;&#160;</a></span>resizeVectorsFromString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::resizeVectorsFromString </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to resize a vector nested within this parameter to contain the vector indicated by indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Set of indices referring to nested vectors that must be accessible (at a minimum) by future reads. Nested vetors containing non-vector types will not be resized by this method. See resizeVectorsFromString_ for implementation details </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classsparta_1_1ParameterBase.html#a385ea7d0addeacbc547cc6783398eb37">sparta::ParameterBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01682">1682</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<a id="a21b8a21f76fdfa4e5a2d2d97c2aab8eb" name="a21b8a21f76fdfa4e5a2d2d97c2aab8eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b8a21f76fdfa4e5a2d2d97c2aab8eb">&#9670;&#160;</a></span>restoreValueFromDefaultImpl_()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::restoreValueFromDefaultImpl_ </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements restoreValueFromDefault. </p>

<p>Implements <a class="el" href="classsparta_1_1ParameterBase.html#a43994ee295622f182d6d8bc137101bd6">sparta::ParameterBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01667">1667</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Parameter_a21b8a21f76fdfa4e5a2d2d97c2aab8eb_cgraph.png" border="0" usemap="#aclasssparta_1_1Parameter_a21b8a21f76fdfa4e5a2d2d97c2aab8eb_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Parameter_a21b8a21f76fdfa4e5a2d2d97c2aab8eb_cgraph" id="aclasssparta_1_1Parameter_a21b8a21f76fdfa4e5a2d2d97c2aab8eb_cgraph">
<area shape="rect" title="Implements restoreValueFromDefault." alt="" coords="5,55,203,96"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a1a6d4aac10bfa5345b587d84170441de" title=" " alt="" coords="454,5,648,31"/>
<area shape="poly" title=" " alt="" coords="191,52,250,41,346,29,438,21,438,27,347,34,251,46,192,57"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#ad3c7817fce432b087dc34b3aeecec766" title="Number of times this Parameter has been read after initialization or after the last write (or explici..." alt="" coords="252,55,405,96"/>
<area shape="poly" title=" " alt="" coords="203,73,236,73,236,78,203,78"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#a6fa5c793d436deda683384bc989615ef" title="Increments the number of writes that will be reported by getWriteCount." alt="" coords="251,120,406,161"/>
<area shape="poly" title=" " alt="" coords="177,94,242,113,240,118,175,99"/>
<area shape="poly" title=" " alt="" coords="385,118,404,105,419,89,427,73,436,57,452,41,462,36,465,40,456,46,440,60,432,76,423,93,408,110,388,122"/>
<area shape="rect" href="classsparta_1_1PhasedObject.html#ade690bdb9df72fd6bad8847fbdf226f1" title="Gets the trees current phase." alt="" coords="478,55,624,96"/>
<area shape="poly" title=" " alt="" coords="399,117,464,98,465,103,401,123"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#a2d42e4b8c58c2970f4f1e28e76448b12" title="Is this a volatile parmaeter?" alt="" coords="474,120,628,161"/>
<area shape="poly" title=" " alt="" coords="406,138,459,138,459,144,406,144"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#a03addcff7db396f643149458febf51e4" title="Resets the number of reads that wil be reported by getReadCount." alt="" coords="474,186,628,226"/>
<area shape="poly" title=" " alt="" coords="401,159,465,178,464,183,399,164"/>
</map>
</div>

</div>
</div>
<a id="a2b5aa8e225f7294ea2fe9affcc15ef97" name="a2b5aa8e225f7294ea2fe9affcc15ef97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b5aa8e225f7294ea2fe9affcc15ef97">&#9670;&#160;</a></span>setItemValueFromStringImpl_()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::setItemValueFromStringImpl_ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements setItemValueFromStringImpl_. </p>

<p>Implements <a class="el" href="classsparta_1_1ParameterBase.html#ad497162da9ed733b0308486050f7be9a">sparta::ParameterBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01792">1792</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<a id="ac27173c5407e013cb0a8631d34e5a66f" name="ac27173c5407e013cb0a8631d34e5a66f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac27173c5407e013cb0a8631d34e5a66f">&#9670;&#160;</a></span>setNumericDisplayBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Printing_8hpp.html#afabfc368950e958421c5eba711aadee5">sparta::utils::DisplayBase</a> <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::setNumericDisplayBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Printing_8hpp.html#afabfc368950e958421c5eba711aadee5">sparta::utils::DisplayBase</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the numeric base for displaying the value of this parameter. </p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01698">1698</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<a id="a6c640d813504d794d67b50a456944357" name="a6c640d813504d794d67b50a456944357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c640d813504d794d67b50a456944357">&#9670;&#160;</a></span>setValueFromStringImpl_()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::setValueFromStringImpl_ </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>poke</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements setValueFromString. </p>

<p>Implements <a class="el" href="classsparta_1_1ParameterBase.html#ab1735fa0af35f844031ad0c23248d01f">sparta::ParameterBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01784">1784</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<a id="aa43e3b2c14e93c55198c4a539fc005aa" name="aa43e3b2c14e93c55198c4a539fc005aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43e3b2c14e93c55198c4a539fc005aa">&#9670;&#160;</a></span>setValueFromStringVectorImpl_()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::setValueFromStringVectorImpl_ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>poke</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements setValueFromStringVectorImpl_. </p>

<p>Implements <a class="el" href="classsparta_1_1ParameterBase.html#a945e4ff5a3d78dd1aea043b5b86a1dfc">sparta::ParameterBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01788">1788</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<a id="abeece5f57cd4bab7adb5c5ef51545b73" name="abeece5f57cd4bab7adb5c5ef51545b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeece5f57cd4bab7adb5c5ef51545b73">&#9670;&#160;</a></span>unread()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::unread </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark this parameter as unread and unignored. </p>
<dl class="section note"><dt>Note</dt><dd>This method is intentionally omitted from <a class="el" href="classsparta_1_1ParameterBase.html" title="Non-templated base class for generic parameter access and iteration.">ParameterBase</a> so that only components consuming parameters can choose to ignore. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aa038c634ce8cc174ab250c94e7422772" title="Marks this parameter as ignored.">ignore</a></dd></dl>
<p>This is useful within a resource constructor which first validates parameters and then uses them. The validation would be considered a read (unless peekValue) were used. Also clears ignored_flag </p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01394">1394</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1Parameter_abeece5f57cd4bab7adb5c5ef51545b73_cgraph.png" border="0" usemap="#aclasssparta_1_1Parameter_abeece5f57cd4bab7adb5c5ef51545b73_cgraph" alt=""/></div>
<map name="aclasssparta_1_1Parameter_abeece5f57cd4bab7adb5c5ef51545b73_cgraph" id="aclasssparta_1_1Parameter_abeece5f57cd4bab7adb5c5ef51545b73_cgraph">
<area shape="rect" title="Mark this parameter as unread and unignored." alt="" coords="5,5,135,46"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#aaad5463c9c64d156059ccc9c3f0e8380" title="Mark this parameter as unread and unignored This is used or preloading defaults to parameters and the..." alt="" coords="183,5,336,46"/>
<area shape="poly" title=" " alt="" coords="135,23,167,23,167,28,135,28"/>
<area shape="rect" href="classsparta_1_1ParameterBase.html#a03addcff7db396f643149458febf51e4" title="Resets the number of reads that wil be reported by getReadCount." alt="" coords="384,5,537,46"/>
<area shape="poly" title=" " alt="" coords="336,23,369,23,369,28,336,28"/>
</map>
</div>

</div>
</div>
<a id="a42bf97905838535b6cd8528caad5a923" name="a42bf97905838535b6cd8528caad5a923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42bf97905838535b6cd8528caad5a923">&#9670;&#160;</a></span>validateDependencies()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::validateDependencies </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>err_names</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes all validation callbacks for a particular node in the device tree and returns true if none of them fail. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> in device tree associated with the object for which these parameters are being validated.</td></tr>
    <tr><td class="paramname">err_names</td><td>string which will be appended with the names of any ValidationCheckCallbacks that failed in a comma-delimited list. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classsparta_1_1ParameterBase.html#abf3a9a37a83bf71cddd5bbe3f78458ec">sparta::ParameterBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01733">1733</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<a id="ae59973ad0c3690f62beadc6554d0991c" name="ae59973ad0c3690f62beadc6554d0991c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae59973ad0c3690f62beadc6554d0991c">&#9670;&#160;</a></span>validateIndependently()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsparta_1_1Parameter.html">sparta::Parameter</a>&lt; ValueType &gt;::validateIndependently </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>err_names</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs validation independently of all other Parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_names</td><td>String which will be appended with names of any failed validators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if any independent validators fail; true otherwise. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Appends to err_names a comma delimited list of any validators that failed. </dd></dl>

<p>Implements <a class="el" href="classsparta_1_1ParameterBase.html#a814c127c5df43d3824b67561843be8df">sparta::ParameterBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l01713">1713</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/github/workspace/sparta/sparta/simulation/<a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesparta.html">sparta</a></li><li class="navelem"><a class="el" href="classsparta_1_1Parameter.html">Parameter</a></li>
    <li class="footer">Generated on Mon Feb 9 2026 03:27:56 for The Sparta Modeling Framework by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
