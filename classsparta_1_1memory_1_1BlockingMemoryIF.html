<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Sparta Modeling Framework: sparta::memory::BlockingMemoryIF Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">The Sparta Modeling Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classsparta_1_1memory_1_1BlockingMemoryIF.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsparta_1_1memory_1_1BlockingMemoryIF-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">sparta::memory::BlockingMemoryIF Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Pure-virtual memory interface which represents a simple, immediately accessible (blocking) address-space with meaningful read and write accees support. Partially implements <a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html" title="Memory interface which represents a simple, immediately accessible (blocking) address-space with supp...">DebugMemoryIF</a>, which adds peek and poke support as well as access addr and size validation.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="BlockingMemoryIF_8hpp_source.html">BlockingMemoryIF.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sparta::memory::BlockingMemoryIF:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1memory_1_1BlockingMemoryIF__inherit__graph.png" border="0" usemap="#asparta_1_1memory_1_1BlockingMemoryIF_inherit__map" alt="Inheritance graph"/></div>
<map name="asparta_1_1memory_1_1BlockingMemoryIF_inherit__map" id="asparta_1_1memory_1_1BlockingMemoryIF_inherit__map">
<area shape="rect" title="Pure&#45;virtual memory interface which represents a simple, immediately accessible (blocking) address&#45;sp..." alt="" coords="264,103,429,143"/>
<area shape="rect" href="classsparta_1_1memory_1_1BlockingMemoryIFNode.html" title="Pure&#45;virtual memory interface that builds on the BlockingMemoryIF, acting as a TreeNode in the SPARTA..." alt="" coords="497,37,662,78"/>
<area shape="poly" title=" " alt="" coords="435,95,504,76,505,81,437,101"/>
<area shape="rect" href="classsparta_1_1memory_1_1CachedMemory.html" title="Memory that can be used as a cache for core models." alt="" coords="477,103,682,143"/>
<area shape="poly" title=" " alt="" coords="445,120,476,120,476,126,445,126"/>
<area shape="rect" href="classsparta_1_1memory_1_1DMIBlockingMemoryIF.html" title="Class that provides a BlockingMemoryIF over a raw pointer." alt="" coords="485,168,674,209"/>
<area shape="poly" title=" " alt="" coords="437,145,505,165,504,170,435,151"/>
<area shape="rect" href="classsparta_1_1memory_1_1DebugMemoryIF.html" title="Memory interface which represents a simple, immediately accessible (blocking) address&#45;space with supp..." alt="" coords="5,110,216,136"/>
<area shape="poly" title=" " alt="" coords="231,120,263,120,263,126,231,126"/>
<area shape="rect" href="classsparta_1_1memory_1_1BlockingMemoryObjectIFNode.html" title="BlockingMemoryIFNode implementation with binding to a MemoryObject instantiated separately and specif..." alt="" coords="748,5,914,46"/>
<area shape="poly" title=" " alt="" coords="677,43,748,34,748,39,678,48"/>
<area shape="rect" href="classsparta_1_1memory_1_1SimpleMemoryMapNode.html" title="Memory mapping object which implements BlockingMemoryIFNode. Supports a simple mapping of incoming ad..." alt="" coords="730,71,932,111"/>
<area shape="poly" title=" " alt="" coords="678,68,730,75,730,80,677,73"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for sparta::memory::BlockingMemoryIF:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1memory_1_1BlockingMemoryIF__coll__graph.png" border="0" usemap="#asparta_1_1memory_1_1BlockingMemoryIF_coll__map" alt="Collaboration graph"/></div>
<map name="asparta_1_1memory_1_1BlockingMemoryIF_coll__map" id="asparta_1_1memory_1_1BlockingMemoryIF_coll__map">
<area shape="rect" title="Pure&#45;virtual memory interface which represents a simple, immediately accessible (blocking) address&#45;sp..." alt="" coords="28,169,193,210"/>
<area shape="rect" href="classsparta_1_1memory_1_1DebugMemoryIF.html" title="Memory interface which represents a simple, immediately accessible (blocking) address&#45;space with supp..." alt="" coords="5,94,216,120"/>
<area shape="poly" title=" " alt="" coords="113,135,113,169,108,169,108,135"/>
<area shape="rect" href="classsparta_1_1memory_1_1TranslationIF.html" title="Blocking translation interface with 1:1 translation unless subclassed." alt="" coords="15,5,206,31"/>
<area shape="poly" title=" " alt="" coords="113,47,113,94,108,94,108,47"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a27d1b36cb9fc030de5880fcad11a551e" id="r_a27d1b36cb9fc030de5880fcad11a551e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27d1b36cb9fc030de5880fcad11a551e">stringize</a> (bool pretty=false) const</td></tr>
<tr class="memdesc:a27d1b36cb9fc030de5880fcad11a551e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render description of this <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html" title="Pure-virtual memory interface which represents a simple, immediately accessible (blocking) address-sp...">BlockingMemoryIF</a> as a string.  <br /></td></tr>
<tr class="separator:a27d1b36cb9fc030de5880fcad11a551e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction</div></td></tr>
<tr class="memitem:a9a8c5d968f26baac8aee245f69e629e2" id="r_a9a8c5d968f26baac8aee245f69e629e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a8c5d968f26baac8aee245f69e629e2">BlockingMemoryIF</a> (const std::string &amp;desc, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> block_size, const <a class="el" href="structsparta_1_1memory_1_1DebugMemoryIF_1_1AccessWindow.html">DebugMemoryIF::AccessWindow</a> &amp;window, <a class="el" href="classsparta_1_1memory_1_1TranslationIF.html">TranslationIF</a> *transif=nullptr)</td></tr>
<tr class="memdesc:a9a8c5d968f26baac8aee245f69e629e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a blocking memory interface.  <br /></td></tr>
<tr class="separator:a9a8c5d968f26baac8aee245f69e629e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Memory Access</div></td></tr>
<tr class="memitem:a5b4101acaca8b05c104178ed095d1a80" id="r_a5b4101acaca8b05c104178ed095d1a80"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b4101acaca8b05c104178ed095d1a80">tryRead</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size, uint8_t *buf, const void *in_supplement=nullptr, void *out_supplement=nullptr)</td></tr>
<tr class="memdesc:a5b4101acaca8b05c104178ed095d1a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read memory of size <em>size</em> at address <em>addr</em>.  <br /></td></tr>
<tr class="separator:a5b4101acaca8b05c104178ed095d1a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc22520a86cc03110b62033f325e45c0" id="r_acc22520a86cc03110b62033f325e45c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc22520a86cc03110b62033f325e45c0">read</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size, uint8_t *buf, const void *in_supplement=nullptr, void *out_supplement=nullptr)</td></tr>
<tr class="memdesc:acc22520a86cc03110b62033f325e45c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to read memory.  <br /></td></tr>
<tr class="separator:acc22520a86cc03110b62033f325e45c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85336d877e0227b567f05f901c0e782" id="r_ae85336d877e0227b567f05f901c0e782"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae85336d877e0227b567f05f901c0e782">tryWrite</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size, const uint8_t *buf, const void *in_supplement=nullptr, void *out_supplement=nullptr)</td></tr>
<tr class="memdesc:ae85336d877e0227b567f05f901c0e782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to write memory of size <em>size</em> at address <em>addr</em>.  <br /></td></tr>
<tr class="separator:ae85336d877e0227b567f05f901c0e782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabcf3f10b82cd9130538164358074d7" id="r_afabcf3f10b82cd9130538164358074d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afabcf3f10b82cd9130538164358074d7">write</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size, const uint8_t *buf, const void *in_supplement=nullptr, void *out_supplement=nullptr)</td></tr>
<tr class="memdesc:afabcf3f10b82cd9130538164358074d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to write memory.  <br /></td></tr>
<tr class="separator:afabcf3f10b82cd9130538164358074d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab879c2cb4b5a6e0e0a16516235d024e1" id="r_ab879c2cb4b5a6e0e0a16516235d024e1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classsparta_1_1memory_1_1DMIBlockingMemoryIF.html">DMIBlockingMemoryIF</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab879c2cb4b5a6e0e0a16516235d024e1">getDMI</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size)</td></tr>
<tr class="memdesc:ab879c2cb4b5a6e0e0a16516235d024e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a DMI blocking interface to access the given address/size.  <br /></td></tr>
<tr class="separator:ab879c2cb4b5a6e0e0a16516235d024e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e02e6da4f120023cf4728b2b6b7f7cb" id="r_a6e02e6da4f120023cf4728b2b6b7f7cb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e02e6da4f120023cf4728b2b6b7f7cb">invalidateAllDMI</a> ()</td></tr>
<tr class="memdesc:a6e02e6da4f120023cf4728b2b6b7f7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate all DMI's.  <br /></td></tr>
<tr class="separator:a6e02e6da4f120023cf4728b2b6b7f7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classsparta_1_1memory_1_1DebugMemoryIF')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html">sparta::memory::DebugMemoryIF</a></td></tr>
<tr class="memitem:ae47924af1683c0df0d0521b661c051a6 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_ae47924af1683c0df0d0521b661c051a6"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>DebugMemoryIF</b> ()=delete</td></tr>
<tr class="memdesc:ae47924af1683c0df0d0521b661c051a6 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constuctor. <br /></td></tr>
<tr class="separator:ae47924af1683c0df0d0521b661c051a6 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216bb8e3ff6974157a2a792408bc4314 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a216bb8e3ff6974157a2a792408bc4314"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a216bb8e3ff6974157a2a792408bc4314">DebugMemoryIF</a> (const std::string &amp;desc, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> block_size, const <a class="el" href="structsparta_1_1memory_1_1DebugMemoryIF_1_1AccessWindow.html">AccessWindow</a> &amp;window, <a class="el" href="classsparta_1_1memory_1_1TranslationIF.html">TranslationIF</a> *transif=nullptr)</td></tr>
<tr class="memdesc:a216bb8e3ff6974157a2a792408bc4314 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a DebugMemoryInterface.  <br /></td></tr>
<tr class="separator:a216bb8e3ff6974157a2a792408bc4314 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc718c72432a36e9271ca56511f911c inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a0bc718c72432a36e9271ca56511f911c"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a0bc718c72432a36e9271ca56511f911c">~DebugMemoryIF</a> ()</td></tr>
<tr class="memdesc:a0bc718c72432a36e9271ca56511f911c inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virutal destructor.  <br /></td></tr>
<tr class="separator:a0bc718c72432a36e9271ca56511f911c inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff89438e6b7853ae0ea0fd43372dc2f inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a2ff89438e6b7853ae0ea0fd43372dc2f"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classsparta_1_1memory_1_1TranslationIF.html">TranslationIF</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a2ff89438e6b7853ae0ea0fd43372dc2f">getTranslationIF</a> ()</td></tr>
<tr class="memdesc:a2ff89438e6b7853ae0ea0fd43372dc2f inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the translation interface associated with this Debug memory interface (if any).  <br /></td></tr>
<tr class="separator:a2ff89438e6b7853ae0ea0fd43372dc2f inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff33a34afa19cb71943d7f12102d2b2 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a2ff33a34afa19cb71943d7f12102d2b2"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a2ff33a34afa19cb71943d7f12102d2b2">getDescription</a> ()</td></tr>
<tr class="memdesc:a2ff33a34afa19cb71943d7f12102d2b2 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the description specified at construction.  <br /></td></tr>
<tr class="separator:a2ff33a34afa19cb71943d7f12102d2b2 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec5c7bd3d39673eacfea9c54341d768 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_afec5c7bd3d39673eacfea9c54341d768"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#afec5c7bd3d39673eacfea9c54341d768">getBlockSize</a> () const</td></tr>
<tr class="memdesc:afec5c7bd3d39673eacfea9c54341d768 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the block size of memory represented by this interface. Read and write accesses must not span block boundaries (where addr % block_size == 0).  <br /></td></tr>
<tr class="separator:afec5c7bd3d39673eacfea9c54341d768 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88eaaf49740910933179b3b489e10c41 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a88eaaf49740910933179b3b489e10c41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a88eaaf49740910933179b3b489e10c41">getRange</a> () const</td></tr>
<tr class="memdesc:a88eaaf49740910933179b3b489e10c41 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total span of this interface's valid address range.  <br /></td></tr>
<tr class="separator:a88eaaf49740910933179b3b489e10c41 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813c0abcfcf0f1da307c0fe66eaead12 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a813c0abcfcf0f1da307c0fe66eaead12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a813c0abcfcf0f1da307c0fe66eaead12">getLowEnd</a> () const</td></tr>
<tr class="memdesc:a813c0abcfcf0f1da307c0fe66eaead12 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the lowest address accessible.  <br /></td></tr>
<tr class="separator:a813c0abcfcf0f1da307c0fe66eaead12 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619defc758b28691ce97c4e37f8d232d inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a619defc758b28691ce97c4e37f8d232d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a619defc758b28691ce97c4e37f8d232d">getHighEnd</a> () const</td></tr>
<tr class="memdesc:a619defc758b28691ce97c4e37f8d232d inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the highest address accessible + 1.  <br /></td></tr>
<tr class="separator:a619defc758b28691ce97c4e37f8d232d inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bafb07c039aab8148305aefc68c578 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a60bafb07c039aab8148305aefc68c578"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a60bafb07c039aab8148305aefc68c578">getAccessibleSize</a> () const</td></tr>
<tr class="memdesc:a60bafb07c039aab8148305aefc68c578 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total accessible size of this interface's valid addresses within the total size (getRange) excluding holes between access windows.  <br /></td></tr>
<tr class="separator:a60bafb07c039aab8148305aefc68c578 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c3357ec5fd3e290636854b46b7719d inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_ad5c3357ec5fd3e290636854b46b7719d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structsparta_1_1memory_1_1DebugMemoryIF_1_1AccessWindow.html">AccessWindow</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#ad5c3357ec5fd3e290636854b46b7719d">getWindows</a> () const</td></tr>
<tr class="memdesc:ad5c3357ec5fd3e290636854b46b7719d inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the vector of windows representing this interface.  <br /></td></tr>
<tr class="separator:ad5c3357ec5fd3e290636854b46b7719d inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1237a04a9fdfb296be4dc712fddbd0e inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_ab1237a04a9fdfb296be4dc712fddbd0e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#ab1237a04a9fdfb296be4dc712fddbd0e">isAddressInWindows</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr) const noexcept</td></tr>
<tr class="memdesc:ab1237a04a9fdfb296be4dc712fddbd0e inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given address is in an access window defined for this interface.  <br /></td></tr>
<tr class="separator:ab1237a04a9fdfb296be4dc712fddbd0e inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35fa48697f197f9357be0d6c5fae0c6 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_ae35fa48697f197f9357be0d6c5fae0c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#ae35fa48697f197f9357be0d6c5fae0c6">verifyInAccessWindows</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size) const</td></tr>
<tr class="memdesc:ae35fa48697f197f9357be0d6c5fae0c6 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies that the range [addr, addr+size) is within the access windows for this interface.  <br /></td></tr>
<tr class="separator:ae35fa48697f197f9357be0d6c5fae0c6 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56bff166f0c2e250be9450a8a152becc inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a56bff166f0c2e250be9450a8a152becc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a56bff166f0c2e250be9450a8a152becc">isInAccessWindows</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size) const</td></tr>
<tr class="memdesc:a56bff166f0c2e250be9450a8a152becc inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the range [addr, addr+size) is within the access windows for this interface.  <br /></td></tr>
<tr class="separator:a56bff166f0c2e250be9450a8a152becc inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb92bd2905d208cab60935b46dcd67a9 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_acb92bd2905d208cab60935b46dcd67a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#acb92bd2905d208cab60935b46dcd67a9">verifyNoBlockSpan</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size) const</td></tr>
<tr class="memdesc:acb92bd2905d208cab60935b46dcd67a9 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies that the given address does not span block boundaries defined for this interface.  <br /></td></tr>
<tr class="separator:acb92bd2905d208cab60935b46dcd67a9 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4efd1a8b860fd5224a78b4f17f06853d inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a4efd1a8b860fd5224a78b4f17f06853d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a4efd1a8b860fd5224a78b4f17f06853d">doesAccessSpan</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size) const noexcept</td></tr>
<tr class="memdesc:a4efd1a8b860fd5224a78b4f17f06853d inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given address spans block boundaries defined for this interface. Accesses which span blocks are illegal for read/write accesses, but allowed for peak/poke debug accesses.  <br /></td></tr>
<tr class="separator:a4efd1a8b860fd5224a78b4f17f06853d inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d460c6428bfcb6d1e37b3b908f17eef inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a1d460c6428bfcb6d1e37b3b908f17eef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a1d460c6428bfcb6d1e37b3b908f17eef">tryPeek</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size, uint8_t *buf) const</td></tr>
<tr class="memdesc:a1d460c6428bfcb6d1e37b3b908f17eef inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to 'peek' memory without having any side effects, size-limitations, alignment constraints except that all bytes peeked are inside an access window for this interface.  <br /></td></tr>
<tr class="separator:a1d460c6428bfcb6d1e37b3b908f17eef inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af806a7b9bf291eb5e1ae1311e70398f2 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_af806a7b9bf291eb5e1ae1311e70398f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#af806a7b9bf291eb5e1ae1311e70398f2">peek</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size, uint8_t *buf) const</td></tr>
<tr class="memdesc:af806a7b9bf291eb5e1ae1311e70398f2 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper on tryPeek which throws a <a class="el" href="classsparta_1_1memory_1_1MemoryAccessError.html" title="Indicates that there was an issue accessing a SPARTA memory object or interface.">MemoryAccessError</a> if the peek is not legal.  <br /></td></tr>
<tr class="separator:af806a7b9bf291eb5e1ae1311e70398f2 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca95f6e332e2c05d78fa5c08ff73965 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_afca95f6e332e2c05d78fa5c08ff73965"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#afca95f6e332e2c05d78fa5c08ff73965">tryPoke</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size, const uint8_t *buf)</td></tr>
<tr class="memdesc:afca95f6e332e2c05d78fa5c08ff73965 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to 'poke' memory without having any side effects other than changing the bytes within the range [ <em>addr</em> , <em>addr</em> + <em>size</em> ). Poke has no size-limitations or alignment constraints except that all bytes peeked are inside an access window for this interface.  <br /></td></tr>
<tr class="separator:afca95f6e332e2c05d78fa5c08ff73965 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5d6378acc3c8737db0f6416b8082df inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_abb5d6378acc3c8737db0f6416b8082df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#abb5d6378acc3c8737db0f6416b8082df">poke</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size, const uint8_t *buf)</td></tr>
<tr class="memdesc:abb5d6378acc3c8737db0f6416b8082df inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper on tryPoke which throws a <a class="el" href="classsparta_1_1memory_1_1MemoryAccessError.html" title="Indicates that there was an issue accessing a SPARTA memory object or interface.">MemoryAccessError</a> if the poke is not legal.  <br /></td></tr>
<tr class="separator:abb5d6378acc3c8737db0f6416b8082df inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Access and Query Implementations</div></td></tr>
<tr class="memitem:a2c04f71050bbda78ff6bbf87a57fbc01" id="r_a2c04f71050bbda78ff6bbf87a57fbc01"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c04f71050bbda78ff6bbf87a57fbc01">tryRead_</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size, uint8_t *buf, const void *in_supplement, void *out_supplement)=0</td></tr>
<tr class="memdesc:a2c04f71050bbda78ff6bbf87a57fbc01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements tryRead.  <br /></td></tr>
<tr class="separator:a2c04f71050bbda78ff6bbf87a57fbc01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f4639204dbf2a145e07ab7d575d108" id="r_a73f4639204dbf2a145e07ab7d575d108"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73f4639204dbf2a145e07ab7d575d108">tryWrite_</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size, const uint8_t *buf, const void *in_supplement, void *out_supplement)=0</td></tr>
<tr class="memdesc:a73f4639204dbf2a145e07ab7d575d108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements tryWrite.  <br /></td></tr>
<tr class="separator:a73f4639204dbf2a145e07ab7d575d108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af452363d3d4646a71fd71242cb20d4dd" id="r_af452363d3d4646a71fd71242cb20d4dd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af452363d3d4646a71fd71242cb20d4dd">tryPoke_</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size, const uint8_t *buf) override</td></tr>
<tr class="memdesc:af452363d3d4646a71fd71242cb20d4dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override of DebugMemoryIF::tryPoke_ which forwards the call to tryWrite_.  <br /></td></tr>
<tr class="separator:af452363d3d4646a71fd71242cb20d4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html">sparta::memory::DebugMemoryIF</a></td></tr>
<tr class="memitem:a65c02153d3a5600ccd331c8888aa99b5 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a65c02153d3a5600ccd331c8888aa99b5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a65c02153d3a5600ccd331c8888aa99b5">block_size_</a></td></tr>
<tr class="memdesc:a65c02153d3a5600ccd331c8888aa99b5 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of a block accessed through this interface.  <br /></td></tr>
<tr class="separator:a65c02153d3a5600ccd331c8888aa99b5 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3017884c6a75c3c142c996bc621e68 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a7a3017884c6a75c3c142c996bc621e68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a7a3017884c6a75c3c142c996bc621e68">block_mask_</a></td></tr>
<tr class="memdesc:a7a3017884c6a75c3c142c996bc621e68 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask applied to an address to get only bits representing the block ID.  <br /></td></tr>
<tr class="separator:a7a3017884c6a75c3c142c996bc621e68 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ca96578aee4568ca9f7f65d97f8622 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF" id="r_ac8ca96578aee4568ca9f7f65d97f8622"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#ac8ca96578aee4568ca9f7f65d97f8622">block_idx_lsb_</a></td></tr>
<tr class="memdesc:ac8ca96578aee4568ca9f7f65d97f8622 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">rshift applied to an address to get the block ID  <br /></td></tr>
<tr class="separator:ac8ca96578aee4568ca9f7f65d97f8622 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3ebb4e5d6568ef4cf7ed73c4b3efb5 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF" id="r_aed3ebb4e5d6568ef4cf7ed73c4b3efb5"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structsparta_1_1memory_1_1DebugMemoryIF_1_1AccessWindow.html">AccessWindow</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#aed3ebb4e5d6568ef4cf7ed73c4b3efb5">acc_windows_</a></td></tr>
<tr class="memdesc:aed3ebb4e5d6568ef4cf7ed73c4b3efb5 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of access windows representing this memory.  <br /></td></tr>
<tr class="separator:aed3ebb4e5d6568ef4cf7ed73c4b3efb5 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76ed77db27ed4a7c3c08d75a965faf6 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF" id="r_aa76ed77db27ed4a7c3c08d75a965faf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1memory_1_1TranslationIF.html">TranslationIF</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#aa76ed77db27ed4a7c3c08d75a965faf6">trans_</a></td></tr>
<tr class="memdesc:aa76ed77db27ed4a7c3c08d75a965faf6 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1memory_1_1Translation.html" title="An older class used to help in encapsulate read/virtual addresses.">Translation</a> interface created for this interface. Externally owned.  <br /></td></tr>
<tr class="separator:aa76ed77db27ed4a7c3c08d75a965faf6 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2182d932a817fceab277b60492a5203 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF" id="r_ad2182d932a817fceab277b60492a5203"><td class="memItemLeft" align="right" valign="top">const std::string *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#ad2182d932a817fceab277b60492a5203">desc_ptr_</a></td></tr>
<tr class="memdesc:ad2182d932a817fceab277b60492a5203 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description pointer.  <br /></td></tr>
<tr class="separator:ad2182d932a817fceab277b60492a5203 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c0a329c864f37b5021277ce4349dc0 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a64c0a329c864f37b5021277ce4349dc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a64c0a329c864f37b5021277ce4349dc0">total_range_</a></td></tr>
<tr class="memdesc:a64c0a329c864f37b5021277ce4349dc0 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range of addresses from highest accessible to lowest.  <br /></td></tr>
<tr class="separator:a64c0a329c864f37b5021277ce4349dc0 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece4fca05034cac697a447f391027fbf inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF" id="r_aece4fca05034cac697a447f391027fbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#aece4fca05034cac697a447f391027fbf">low_end_</a></td></tr>
<tr class="memdesc:aece4fca05034cac697a447f391027fbf inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowest accessible address.  <br /></td></tr>
<tr class="separator:aece4fca05034cac697a447f391027fbf inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11cbfa9ae6babb7e56cdc56366a3ae33 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a11cbfa9ae6babb7e56cdc56366a3ae33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a11cbfa9ae6babb7e56cdc56366a3ae33">high_end_</a></td></tr>
<tr class="memdesc:a11cbfa9ae6babb7e56cdc56366a3ae33 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Highest accessible address + 1.  <br /></td></tr>
<tr class="separator:a11cbfa9ae6babb7e56cdc56366a3ae33 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616fca295fada16fa14ec939588265be inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a616fca295fada16fa14ec939588265be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a616fca295fada16fa14ec939588265be">accessible_size_</a></td></tr>
<tr class="memdesc:a616fca295fada16fa14ec939588265be inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes accessible through this interface.  <br /></td></tr>
<tr class="separator:a616fca295fada16fa14ec939588265be inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Pure-virtual memory interface which represents a simple, immediately accessible (blocking) address-space with meaningful read and write accees support. Partially implements <a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html" title="Memory interface which represents a simple, immediately accessible (blocking) address-space with supp...">DebugMemoryIF</a>, which adds peek and poke support as well as access addr and size validation. </p>
<p>This interface and its subclasses <b>must</b> reject accesses where the first and last address read are on different memory blocks (based on the block size specified at construction)</p>
<p>This interface operates on post-translated addresses from the <a class="el" href="classsparta_1_1memory_1_1TranslationIF.html" title="Blocking translation interface with 1:1 translation unless subclassed.">TranslationIF</a> available through getTranslationIF</p>
<p>Through <a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html" title="Memory interface which represents a simple, immediately accessible (blocking) address-space with supp...">DebugMemoryIF</a>, this class is associated with, but does not use a <a class="el" href="classsparta_1_1memory_1_1TranslationIF.html" title="Blocking translation interface with 1:1 translation unless subclassed.">TranslationIF</a></p>
<dl class="section note"><dt>Note</dt><dd>The memory behind this interface is not required to have a contiguous representation in simulator host memory. This interface makes no assumptions about storage.</dd></dl>
<p>This interface does not support non-blocking accesses or access attributes.</p>
<p>Example </p><div class="fragment"><div class="line"><span class="keyword">using </span><a class="code hl_namespace" href="namespacesparta_1_1memory.html">sparta::memory</a>;</div>
<div class="line"><span class="comment">// BlockingMemoryIF* bmi;</span></div>
<div class="line"><span class="comment">// addr_t varrd;</span></div>
<div class="line"><span class="comment">// const uint8_t data[4];</span></div>
<div class="line"><span class="comment">// uint8_t buf[4];</span></div>
<div class="line"><a class="code hl_typedef" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> paddr = bmi-&gt;getTranslationIF()-&gt;translate(vaddr);</div>
<div class="line">bmi-&gt;write(paddr, 4, data);</div>
<div class="line">bmi-&gt;read(paddr, 4, buf);</div>
<div class="line">bmi-&gt;peek(paddr, 4, buf);</div>
<div class="line"><span class="comment">// Note: Translation is only required if the interface does not</span></div>
<div class="line"><span class="comment">// represent direct access to physical memory</span></div>
<div class="ttc" id="anamespacesparta_1_1memory_html"><div class="ttname"><a href="namespacesparta_1_1memory.html">sparta::memory</a></div><div class="ttdoc">Namespace containing memory interfaces, types, and storage objects.</div><div class="ttdef"><b>Definition</b> <a href="AddressTypes_8hpp_source.html#l00018">AddressTypes.hpp:19</a></div></div>
<div class="ttc" id="anamespacesparta_1_1memory_html_abf087efa080d7cc51647e4920b42a401"><div class="ttname"><a href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">sparta::memory::addr_t</a></div><div class="ttdeci">uint64_t addr_t</div><div class="ttdoc">Type for generic address representation in generic interfaces, errors and printouts within SPARTA.</div><div class="ttdef"><b>Definition</b> <a href="AddressTypes_8hpp_source.html#l00024">AddressTypes.hpp:24</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="BlockingMemoryIF_8hpp_source.html#l00059">59</a> of file <a class="el" href="BlockingMemoryIF_8hpp_source.html">BlockingMemoryIF.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9a8c5d968f26baac8aee245f69e629e2" name="a9a8c5d968f26baac8aee245f69e629e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8c5d968f26baac8aee245f69e629e2">&#9670;&#160;</a></span>BlockingMemoryIF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sparta::memory::BlockingMemoryIF::BlockingMemoryIF </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>desc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>block_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsparta_1_1memory_1_1DebugMemoryIF_1_1AccessWindow.html">DebugMemoryIF::AccessWindow</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>window</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1memory_1_1TranslationIF.html">TranslationIF</a> *</td>          <td class="paramname"><span class="paramname"><em>transif</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a blocking memory interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Refer to <a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#ae47924af1683c0df0d0521b661c051a6" title="Default constuctor.">DebugMemoryIF::DebugMemoryIF</a> </td></tr>
    <tr><td class="paramname">block_size</td><td>Refer to <a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#ae47924af1683c0df0d0521b661c051a6" title="Default constuctor.">DebugMemoryIF::DebugMemoryIF</a> </td></tr>
    <tr><td class="paramname">window</td><td>Refer to <a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#ae47924af1683c0df0d0521b661c051a6" title="Default constuctor.">DebugMemoryIF::DebugMemoryIF</a> </td></tr>
    <tr><td class="paramname">transif</td><td>Refer to <a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#ae47924af1683c0df0d0521b661c051a6" title="Default constuctor.">DebugMemoryIF::DebugMemoryIF</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000040">Todo</a></b></dt><dd>Support vectors of windows with holes </dd></dl>

<p class="definition">Definition at line <a class="el" href="BlockingMemoryIF_8hpp_source.html#l00081">81</a> of file <a class="el" href="BlockingMemoryIF_8hpp_source.html">BlockingMemoryIF.hpp</a>.</p>

</div>
</div>
<a id="a92f5e1f9975bc0b3f396bd086de49788" name="a92f5e1f9975bc0b3f396bd086de49788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f5e1f9975bc0b3f396bd086de49788">&#9670;&#160;</a></span>~BlockingMemoryIF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual sparta::memory::BlockingMemoryIF::~BlockingMemoryIF </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BlockingMemoryIF_8hpp_source.html#l00088">88</a> of file <a class="el" href="BlockingMemoryIF_8hpp_source.html">BlockingMemoryIF.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab879c2cb4b5a6e0e0a16516235d024e1" name="ab879c2cb4b5a6e0e0a16516235d024e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab879c2cb4b5a6e0e0a16516235d024e1">&#9670;&#160;</a></span>getDMI()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classsparta_1_1memory_1_1DMIBlockingMemoryIF.html">DMIBlockingMemoryIF</a> * sparta::memory::BlockingMemoryIF::getDMI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a DMI blocking interface to access the given address/size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>A guest physical address that is to be accessed via DMI </td></tr>
    <tr><td class="paramname">size</td><td>The intended size of data to get. Must be in the access window </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryObjectIFNode.html#a72967a30f3e37d5949e4597e96b17969">sparta::memory::BlockingMemoryObjectIFNode</a>, and <a class="el" href="classsparta_1_1memory_1_1SimpleMemoryMapNode.html#a3f4a8bd8a72c0c3916201b8d6d66a37b">sparta::memory::SimpleMemoryMapNode</a>.</p>

<p class="definition">Definition at line <a class="el" href="BlockingMemoryIF_8hpp_source.html#l00238">238</a> of file <a class="el" href="BlockingMemoryIF_8hpp_source.html">BlockingMemoryIF.hpp</a>.</p>

</div>
</div>
<a id="a6e02e6da4f120023cf4728b2b6b7f7cb" name="a6e02e6da4f120023cf4728b2b6b7f7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e02e6da4f120023cf4728b2b6b7f7cb">&#9670;&#160;</a></span>invalidateAllDMI()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sparta::memory::BlockingMemoryIF::invalidateAllDMI </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invalidate all DMI's. </p>

<p>Reimplemented in <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryObjectIFNode.html#a52a6fe1af37ef70bb4c4f89036cee9ba">sparta::memory::BlockingMemoryObjectIFNode</a>.</p>

<p class="definition">Definition at line <a class="el" href="BlockingMemoryIF_8hpp_source.html#l00247">247</a> of file <a class="el" href="BlockingMemoryIF_8hpp_source.html">BlockingMemoryIF.hpp</a>.</p>

</div>
</div>
<a id="acc22520a86cc03110b62033f325e45c0" name="acc22520a86cc03110b62033f325e45c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc22520a86cc03110b62033f325e45c0">&#9670;&#160;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::memory::BlockingMemoryIF::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>in_supplement</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>out_supplement</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to read memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Post-translated address from which to read (see getTranslationIF) </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to read into <em>buf</em>. Note that <em>addr</em> and <em>size</em> cannot define an access which spans multiple blocks </td></tr>
    <tr><td class="paramname">buf</td><td>buffer whose content will be overwritten by <em>size</em> bytes read from memory </td></tr>
    <tr><td class="paramname">supplement</td><td>caller-defined object identifying this memory access for notifications &amp; debug purposes. This pointer is passed to any subsequent memory interfaces. Can be any pointer, and nullptr indicates no info. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a></td><td>if the access is invalid as defined by this interface or the underyling memory implementaiton </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>Memory state may change if memory implementation has actions triggered on reads </dd></dl>

<p class="definition">Definition at line <a class="el" href="BlockingMemoryIF_8hpp_source.html#l00153">153</a> of file <a class="el" href="BlockingMemoryIF_8hpp_source.html">BlockingMemoryIF.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1memory_1_1BlockingMemoryIF_acc22520a86cc03110b62033f325e45c0_cgraph.png" border="0" usemap="#aclasssparta_1_1memory_1_1BlockingMemoryIF_acc22520a86cc03110b62033f325e45c0_cgraph" alt=""/></div>
<map name="aclasssparta_1_1memory_1_1BlockingMemoryIF_acc22520a86cc03110b62033f325e45c0_cgraph" id="aclasssparta_1_1memory_1_1BlockingMemoryIF_acc22520a86cc03110b62033f325e45c0_cgraph">
<area shape="rect" title="Attempts to read memory." alt="" coords="5,119,171,159"/>
<area shape="rect" href="classsparta_1_1memory_1_1BlockingMemoryIF.html#a5b4101acaca8b05c104178ed095d1a80" title="Attempt to read memory of size size at address addr." alt="" coords="235,53,400,94"/>
<area shape="poly" title=" " alt="" coords="161,116,228,96,230,101,163,121"/>
<area shape="rect" href="classsparta_1_1memory_1_1DebugMemoryIF.html#ae35fa48697f197f9357be0d6c5fae0c6" title="Verifies that the range [addr, addr+size) is within the access windows for this interface." alt="" coords="219,119,417,159"/>
<area shape="poly" title=" " alt="" coords="171,136,203,136,203,142,171,142"/>
<area shape="rect" href="classsparta_1_1memory_1_1DebugMemoryIF.html#acb92bd2905d208cab60935b46dcd67a9" title="Verifies that the given address does not span block boundaries defined for this interface." alt="" coords="219,184,417,225"/>
<area shape="poly" title=" " alt="" coords="163,157,230,177,228,182,161,162"/>
<area shape="rect" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a4efd1a8b860fd5224a78b4f17f06853d" title="Determines if the given address spans block boundaries defined for this interface...." alt="" coords="465,152,663,193"/>
<area shape="poly" title=" " alt="" coords="384,92,418,105,507,143,504,148,416,109,382,97"/>
<area shape="rect" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a56bff166f0c2e250be9450a8a152becc" title="Determines if the range [addr, addr+size) is within the access windows for this interface." alt="" coords="465,5,663,46"/>
<area shape="poly" title=" " alt="" coords="400,55,449,45,450,51,401,60"/>
<area shape="rect" href="classsparta_1_1memory_1_1BlockingMemoryIF.html#a2c04f71050bbda78ff6bbf87a57fbc01" title="Implements tryRead." alt="" coords="482,71,647,111"/>
<area shape="poly" title=" " alt="" coords="401,77,467,81,466,87,401,82"/>
<area shape="poly" title=" " alt="" coords="417,189,449,185,450,190,418,194"/>
</map>
</div>

</div>
</div>
<a id="a27d1b36cb9fc030de5880fcad11a551e" name="a27d1b36cb9fc030de5880fcad11a551e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d1b36cb9fc030de5880fcad11a551e">&#9670;&#160;</a></span>stringize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string sparta::memory::BlockingMemoryIF::stringize </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>pretty</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Render description of this <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html" title="Pure-virtual memory interface which represents a simple, immediately accessible (blocking) address-sp...">BlockingMemoryIF</a> as a string. </p>

<p class="definition">Definition at line <a class="el" href="BlockingMemoryIF_8hpp_source.html#l00255">255</a> of file <a class="el" href="BlockingMemoryIF_8hpp_source.html">BlockingMemoryIF.hpp</a>.</p>

</div>
</div>
<a id="af452363d3d4646a71fd71242cb20d4dd" name="af452363d3d4646a71fd71242cb20d4dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af452363d3d4646a71fd71242cb20d4dd">&#9670;&#160;</a></span>tryPoke_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sparta::memory::BlockingMemoryIF::tryPoke_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override of DebugMemoryIF::tryPoke_ which forwards the call to tryWrite_. </p>
<dl class="section note"><dt>Note</dt><dd>Arguments addr and size are guaranteed to be within access window </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Never</td><td>throws. An implementation which throws is invalid</td></tr>
  </table>
  </dd>
</dl>
<p>Subclasses must override this method </p>

<p>Implements <a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html">sparta::memory::DebugMemoryIF</a>.</p>

<p>Reimplemented in <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryObjectIFNode.html#a63dcb7646c5a7b54d2dac72f3f66cb67">sparta::memory::BlockingMemoryObjectIFNode</a>, and <a class="el" href="classsparta_1_1memory_1_1SimpleMemoryMapNode.html#a59673b7242f8c466a41c99cd7410e7b9">sparta::memory::SimpleMemoryMapNode</a>.</p>

<p class="definition">Definition at line <a class="el" href="BlockingMemoryIF_8hpp_source.html#l00305">305</a> of file <a class="el" href="BlockingMemoryIF_8hpp_source.html">BlockingMemoryIF.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1memory_1_1BlockingMemoryIF_af452363d3d4646a71fd71242cb20d4dd_cgraph.png" border="0" usemap="#aclasssparta_1_1memory_1_1BlockingMemoryIF_af452363d3d4646a71fd71242cb20d4dd_cgraph" alt=""/></div>
<map name="aclasssparta_1_1memory_1_1BlockingMemoryIF_af452363d3d4646a71fd71242cb20d4dd_cgraph" id="aclasssparta_1_1memory_1_1BlockingMemoryIF_af452363d3d4646a71fd71242cb20d4dd_cgraph">
<area shape="rect" title="Override of DebugMemoryIF::tryPoke_ which forwards the call to tryWrite_." alt="" coords="5,5,171,46"/>
<area shape="rect" href="classsparta_1_1memory_1_1BlockingMemoryIF.html#a73f4639204dbf2a145e07ab7d575d108" title="Implements tryWrite." alt="" coords="219,5,384,46"/>
<area shape="poly" title=" " alt="" coords="171,23,203,23,203,28,171,28"/>
</map>
</div>

</div>
</div>
<a id="a5b4101acaca8b05c104178ed095d1a80" name="a5b4101acaca8b05c104178ed095d1a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b4101acaca8b05c104178ed095d1a80">&#9670;&#160;</a></span>tryRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sparta::memory::BlockingMemoryIF::tryRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>in_supplement</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>out_supplement</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read memory of size <em>size</em> at address <em>addr</em>. </p>
<dl class="section note"><dt>Note</dt><dd>Unless the underlying memory object can reject accesses within the given access window for some reason and the caller needs to be able to test this, the read function is preferred. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Post-translated address from which to read (see getTranslationIF) </td></tr>
    <tr><td class="paramname">size</td><td>Size of read (in bytes). <em>addr</em> and <em>addr</em> + <em>size</em> must not land on different sides of a block boundary. Must be &gt; 0. </td></tr>
    <tr><td class="paramname">buf</td><td><a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a> of data to populate with <em>size</em> bytes from memory object. Content of <em>buf</em> is undefined if read fails </td></tr>
    <tr><td class="paramname">supplement</td><td>caller-defined object identifying this memory access for notifications &amp; debug purposes. This pointer is passed to any subsequent memory interfaces. Can be any pointer, and nullptr indicates no info. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if read successful, false if not </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><em>buf</em> will be populated with read results. Even if the read was unsuccessful (returned false) the first <em>size</em> bytes may have been modified. Other memory state may change if the memory implementation has actions triggered on writes </dd></dl>

<p>Reimplemented in <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIFNode.html#a7249fca2609ee2a456a2752890574085">sparta::memory::BlockingMemoryIFNode</a>, and <a class="el" href="classsparta_1_1memory_1_1DMIBlockingMemoryIF.html#a92eada4b892613dbd4f93a15234b0d58">sparta::memory::DMIBlockingMemoryIF</a>.</p>

<p class="definition">Definition at line <a class="el" href="BlockingMemoryIF_8hpp_source.html#l00119">119</a> of file <a class="el" href="BlockingMemoryIF_8hpp_source.html">BlockingMemoryIF.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1memory_1_1BlockingMemoryIF_a5b4101acaca8b05c104178ed095d1a80_cgraph.png" border="0" usemap="#aclasssparta_1_1memory_1_1BlockingMemoryIF_a5b4101acaca8b05c104178ed095d1a80_cgraph" alt=""/></div>
<map name="aclasssparta_1_1memory_1_1BlockingMemoryIF_a5b4101acaca8b05c104178ed095d1a80_cgraph" id="aclasssparta_1_1memory_1_1BlockingMemoryIF_a5b4101acaca8b05c104178ed095d1a80_cgraph">
<area shape="rect" title="Attempt to read memory of size size at address addr." alt="" coords="5,71,171,111"/>
<area shape="rect" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a4efd1a8b860fd5224a78b4f17f06853d" title="Determines if the given address spans block boundaries defined for this interface...." alt="" coords="219,5,417,46"/>
<area shape="poly" title=" " alt="" coords="161,68,228,48,230,53,163,73"/>
<area shape="rect" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a56bff166f0c2e250be9450a8a152becc" title="Determines if the range [addr, addr+size) is within the access windows for this interface." alt="" coords="219,71,417,111"/>
<area shape="poly" title=" " alt="" coords="171,88,203,88,203,94,171,94"/>
<area shape="rect" href="classsparta_1_1memory_1_1BlockingMemoryIF.html#a2c04f71050bbda78ff6bbf87a57fbc01" title="Implements tryRead." alt="" coords="235,136,400,177"/>
<area shape="poly" title=" " alt="" coords="163,109,230,129,228,134,161,114"/>
</map>
</div>

</div>
</div>
<a id="a2c04f71050bbda78ff6bbf87a57fbc01" name="a2c04f71050bbda78ff6bbf87a57fbc01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c04f71050bbda78ff6bbf87a57fbc01">&#9670;&#160;</a></span>tryRead_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sparta::memory::BlockingMemoryIF::tryRead_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>in_supplement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>out_supplement</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements tryRead. </p>
<dl class="section note"><dt>Note</dt><dd>Arguments addr and size are guaranteed to be within access window </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Never</td><td>throws. An implementation which throws is invalid</td></tr>
  </table>
  </dd>
</dl>
<p>Subclasses must override this method </p>

<p>Implemented in <a class="el" href="classsparta_1_1memory_1_1SimpleMemoryMapNode.html#ad3ca20b53b303b7c9ecc96fc5e373a00">sparta::memory::SimpleMemoryMapNode</a>.</p>

</div>
</div>
<a id="ae85336d877e0227b567f05f901c0e782" name="ae85336d877e0227b567f05f901c0e782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae85336d877e0227b567f05f901c0e782">&#9670;&#160;</a></span>tryWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sparta::memory::BlockingMemoryIF::tryWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>in_supplement</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>out_supplement</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to write memory of size <em>size</em> at address <em>addr</em>. </p>
<dl class="section note"><dt>Note</dt><dd>Unless the underlying memory object can reject accesses within the given access window for some reason and the caller needs to be able to test this, the write function is preferred. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Post-translated address to which to write (see getTranslationIF) </td></tr>
    <tr><td class="paramname">size</td><td>Size of write (in bytes). <em>addr</em> and <em>addr</em> + <em>size</em> must not land on different sides of a block boundary. Must be &gt; 0. </td></tr>
    <tr><td class="paramname">buf</td><td><a class="el" href="classsparta_1_1Buffer.html" title="A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collaps...">Buffer</a> of data to copy <em>size</em> bytes into memory object </td></tr>
    <tr><td class="paramname">supplement</td><td>caller-defined object identifying this memory access for notifications &amp; debug purposes. This pointer is passed to any subsequent memory interfaces. Can be any pointer, and nullptr indicates no info. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if write successful, false if not </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Memory state will reflect the bytes written. </dd>
<dd>
Data in memory is not expected to be modified upon an illegal write If the write was unsuccessful, memory will not be modified. </dd></dl>

<p>Reimplemented in <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIFNode.html#a9af8c79e356ada7d88b1a86c531fbb4e">sparta::memory::BlockingMemoryIFNode</a>, and <a class="el" href="classsparta_1_1memory_1_1DMIBlockingMemoryIF.html#a6050ca36f7253e0eb1009f0d28b488f7">sparta::memory::DMIBlockingMemoryIF</a>.</p>

<p class="definition">Definition at line <a class="el" href="BlockingMemoryIF_8hpp_source.html#l00186">186</a> of file <a class="el" href="BlockingMemoryIF_8hpp_source.html">BlockingMemoryIF.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1memory_1_1BlockingMemoryIF_ae85336d877e0227b567f05f901c0e782_cgraph.png" border="0" usemap="#aclasssparta_1_1memory_1_1BlockingMemoryIF_ae85336d877e0227b567f05f901c0e782_cgraph" alt=""/></div>
<map name="aclasssparta_1_1memory_1_1BlockingMemoryIF_ae85336d877e0227b567f05f901c0e782_cgraph" id="aclasssparta_1_1memory_1_1BlockingMemoryIF_ae85336d877e0227b567f05f901c0e782_cgraph">
<area shape="rect" title="Attempt to write memory of size size at address addr." alt="" coords="5,71,171,111"/>
<area shape="rect" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a4efd1a8b860fd5224a78b4f17f06853d" title="Determines if the given address spans block boundaries defined for this interface...." alt="" coords="219,5,417,46"/>
<area shape="poly" title=" " alt="" coords="161,68,228,48,230,53,163,73"/>
<area shape="rect" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a56bff166f0c2e250be9450a8a152becc" title="Determines if the range [addr, addr+size) is within the access windows for this interface." alt="" coords="219,71,417,111"/>
<area shape="poly" title=" " alt="" coords="171,88,203,88,203,94,171,94"/>
<area shape="rect" href="classsparta_1_1memory_1_1BlockingMemoryIF.html#a73f4639204dbf2a145e07ab7d575d108" title="Implements tryWrite." alt="" coords="235,136,400,177"/>
<area shape="poly" title=" " alt="" coords="163,109,230,129,228,134,161,114"/>
</map>
</div>

</div>
</div>
<a id="a73f4639204dbf2a145e07ab7d575d108" name="a73f4639204dbf2a145e07ab7d575d108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f4639204dbf2a145e07ab7d575d108">&#9670;&#160;</a></span>tryWrite_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sparta::memory::BlockingMemoryIF::tryWrite_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>in_supplement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>out_supplement</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements tryWrite. </p>
<dl class="section note"><dt>Note</dt><dd>Arguments addr and size are guaranteed to be within access window </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Never</td><td>throws. An implementation which throws is invalid</td></tr>
  </table>
  </dd>
</dl>
<p>Subclasses must override this method </p>

<p>Implemented in <a class="el" href="classsparta_1_1memory_1_1SimpleMemoryMapNode.html#a0f97e2332d88c690d1bf73436c87e99c">sparta::memory::SimpleMemoryMapNode</a>.</p>

</div>
</div>
<a id="afabcf3f10b82cd9130538164358074d7" name="afabcf3f10b82cd9130538164358074d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afabcf3f10b82cd9130538164358074d7">&#9670;&#160;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::memory::BlockingMemoryIF::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>in_supplement</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>out_supplement</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to write memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Post-translated address to which to write (see getTranslationIF) </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to write from <em>buf</em>. Note that <em>addr</em> and <em>size</em> cannot define an access which spans multiple blocks </td></tr>
    <tr><td class="paramname">buf</td><td>read-only buffer whose content should be written to memory. </td></tr>
    <tr><td class="paramname">supplement</td><td>caller-defined object identifying this memory access for notifications &amp; debug purposes. This pointer is passed to any subsequent memory interfaces. Can be any pointer, and nullptr indicates no info. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a></td><td>if the access is invalid as defined by this interface or the underyling memory implementaiton </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>Memory state will reflect the bytes written. </dd>
<dd>
Data in memory is not expected to be modified upon an failed write </dd></dl>

<p class="definition">Definition at line <a class="el" href="BlockingMemoryIF_8hpp_source.html#l00221">221</a> of file <a class="el" href="BlockingMemoryIF_8hpp_source.html">BlockingMemoryIF.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1memory_1_1BlockingMemoryIF_afabcf3f10b82cd9130538164358074d7_cgraph.png" border="0" usemap="#aclasssparta_1_1memory_1_1BlockingMemoryIF_afabcf3f10b82cd9130538164358074d7_cgraph" alt=""/></div>
<map name="aclasssparta_1_1memory_1_1BlockingMemoryIF_afabcf3f10b82cd9130538164358074d7_cgraph" id="aclasssparta_1_1memory_1_1BlockingMemoryIF_afabcf3f10b82cd9130538164358074d7_cgraph">
<area shape="rect" title="Attempts to write memory." alt="" coords="5,119,171,159"/>
<area shape="rect" href="classsparta_1_1memory_1_1BlockingMemoryIF.html#ae85336d877e0227b567f05f901c0e782" title="Attempt to write memory of size size at address addr." alt="" coords="235,53,400,94"/>
<area shape="poly" title=" " alt="" coords="161,116,228,96,230,101,163,121"/>
<area shape="rect" href="classsparta_1_1memory_1_1DebugMemoryIF.html#ae35fa48697f197f9357be0d6c5fae0c6" title="Verifies that the range [addr, addr+size) is within the access windows for this interface." alt="" coords="219,119,417,159"/>
<area shape="poly" title=" " alt="" coords="171,136,203,136,203,142,171,142"/>
<area shape="rect" href="classsparta_1_1memory_1_1DebugMemoryIF.html#acb92bd2905d208cab60935b46dcd67a9" title="Verifies that the given address does not span block boundaries defined for this interface." alt="" coords="219,184,417,225"/>
<area shape="poly" title=" " alt="" coords="163,157,230,177,228,182,161,162"/>
<area shape="rect" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a4efd1a8b860fd5224a78b4f17f06853d" title="Determines if the given address spans block boundaries defined for this interface...." alt="" coords="465,152,663,193"/>
<area shape="poly" title=" " alt="" coords="384,92,418,105,507,143,504,148,416,109,382,97"/>
<area shape="rect" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a56bff166f0c2e250be9450a8a152becc" title="Determines if the range [addr, addr+size) is within the access windows for this interface." alt="" coords="465,5,663,46"/>
<area shape="poly" title=" " alt="" coords="400,55,449,45,450,51,401,60"/>
<area shape="rect" href="classsparta_1_1memory_1_1BlockingMemoryIF.html#a73f4639204dbf2a145e07ab7d575d108" title="Implements tryWrite." alt="" coords="482,71,647,111"/>
<area shape="poly" title=" " alt="" coords="401,77,467,81,466,87,401,82"/>
<area shape="poly" title=" " alt="" coords="417,189,449,185,450,190,418,194"/>
</map>
</div>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/github/workspace/sparta/sparta/memory/<a class="el" href="BlockingMemoryIF_8hpp_source.html">BlockingMemoryIF.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesparta.html">sparta</a></li><li class="navelem"><a class="el" href="namespacesparta_1_1memory.html">memory</a></li><li class="navelem"><a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html">BlockingMemoryIF</a></li>
    <li class="footer">Generated on Fri Aug 22 2025 17:16:16 for The Sparta Modeling Framework by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
