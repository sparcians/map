<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Sparta Modeling Framework: Report Definition Format (.rrep,.yaml)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">The Sparta Modeling Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('report_def_format.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Report Definition Format (.rrep,.yaml)</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul>
  <li class="level1">
    <a href="#report_def_overview">Overview</a>
  </li>
  <li class="level1">
    <a href="#report_def_structure">Structure</a>
    <ul>
      <li class="level2">
        <a href="#report_def_field">Report Fields</a>
      </li>
      <li class="level2">
        <a href="#report_def_example">Example Report Definition</a>
      </li>
      <li class="level2">
        <a href="#report_def_field_declarations">Field Declarations</a>
      </li>
      <li class="level2">
        <a href="#report_def_field_name_variables">Field Name Variables</a>
      </li>
      <li class="level2">
        <a href="#report_def_subreports">Subreports</a>
      </li>
      <li class="level2">
        <a href="#report_def_scope_wildcards">Scope Wildcards</a>
      </li>
      <li class="level2">
        <a href="#report_def_expressions">Statistical Expressions</a>
      </li>
      <li class="level2">
        <a href="#report_def_includes">Include Directives</a>
      </li>
      <li class="level2">
        <a href="#report_def_style">Style section</a>
      </li>
      <li class="level2">
        <a href="#report_def_autopop">Autopopulation Blocks</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#report_def_var_name_ambiguity">Field Declaration Path/Expression Ambiguity</a>
  </li>
  <li class="level1">
    <a href="#report_def_directive_ref">Report Definition Directive and Option Reference</a>
  </li>
  <li class="level1">
    <a href="#report_def_lims">Limitations of Report Definitions</a>
  </li>
</ul>
</div>
<div class="textblock"><p>This page describes the grammar and usage of a report definition file</p>
<h1><a class="anchor" id="report_def_overview"></a>
Overview</h1>
<p>Report definitions are YAML files which describe to the sparta simulation framework how to construct the content of a report from a given context in a Sparta device tree. Specifically, the report definition defines exactly what counters and statistics are added to a report and how they are named in the report.</p>
<p>Report definitions do not contain information about report duration or context.</p>
<dl class="section user"><dt>Important:</dt><dd><b>A report definition can affect only the contents of the report that is instantiated based on that definition. Reprot definitions have no impact on any instrumentation in the simulation and cannot change the behavior of the simulation proper under any circumstance. It it does, it should be considered a bug. Reports will never affect other reports either - they are entirely passive</b></dd></dl>
<p>Report definitions do not directly dictate how or to what file the report is finally rendered. Report definitions only modify report content, which has the sole purpose of observing the simulation instrumentation and collecting results. The resposibility of rendering the report content and any values collected to a file, files, or database(s) is left entirely to Report Formatters. See <a class="el" href="end_user.html#report_gen">3.2 Report Generation</a>. Report formatters can obviously use the content of a report to determine output. Report definitions can also contain some style hints which the report formatter may choose to interpret (see <a class="el" href="#report_def_style">Style section</a>)</p>
<p>In this way, the same report definition can be used to generate text, csv, python, json, and html output.</p>
<h1><a class="anchor" id="report_def_structure"></a>
Structure</h1>
<p>The report definition is a YAML file consisting of nested dictionaries which specify scope in the Sparta device tree on which the report is being constructed.</p>
<p>Report definitions respect the <a href="http://www.yaml.org/spec/1.2/spec.html">YAML 1.2 specification</a> though only a subset is used by the report definiton parser</p>
<p>These reports begin with some optional fields which are represented as YAML key-value pairs. Comments in YAML are started with a '#' character. These can begin at any line and follow other text on any line. </p><div class="fragment"><div class="line">name: MyReport # Name of report (optional)</div>
<div class="line">author: Me # Author of the report (optional)</div>
</div><!-- fragment --><p>Following these pairs usually comes the content section. A YAML dictionary key whose associated value is yet another nested dictionary is said to be a 'section' or 'block' for the purposes of this documentation when that key is a reserved word (e.g. content, subreport, autopopulate). All fields in a report must be specified within a content block.</p>
<div class="fragment"><div class="line">content: # Begin a report content section. No more report meta-data below <span class="keyword">this</span> point (except in subreports)</div>
</div><!-- fragment --><p><em>In the implementation of the YAML report definition parser, scope qualifiers and the content section can be intermixed and the order is not really important as long as all report fields are specified within a content section. </em></p>
<h2><a class="anchor" id="report_def_field"></a>
Report Fields</h2>
<p>To resolve amgiguity between the multiple meanings of "statistics", reports will be said to contain a number of ordered, named "Fields" where each field will retrieve its current value from a counter, statistic, or expression referencing the former and a number of simple (cmath) (1) <a class="el" href="classsparta_1_1CounterBase.html" title="The base class for all Counters.">sparta::CounterBase</a>, (2) StatisticDef. The name of each field is specified in the report as a string, optionally containing <a class="el" href="#report_def_field_name_variables">Field Name Variables</a></p>
<p>These field names and expressions are part of the report only and have no impact on any instrumentation in the simulation under any circumstances.</p>
<p>Field names within a report must be unique. However, <a class="el" href="#report_def_subreports">Subreports</a> can be used to get around this restriction. <a class="el" href="#report_def_field_name_variables">Field Name Variables</a> help accomplish this.</p>
<p><em>The code in sparta::Report refers to it's report fields as "statistics" because it makes sense within the scope of that code. Fom an end-user perspective, it is less confusing toe call them fields.</em></p>
<p>Report fields can be added using a report definition using either <a class="el" href="#report_def_field_declarations">Field Declarations</a> or <a class="el" href="#report_def_autopop">Autopopulation Blocks</a>.</p>
<h2><a class="anchor" id="report_def_example"></a>
Example Report Definition</h2>
<div class="fragment"><div class="line"><span class="preprocessor"># Example Report.</span></div>
<div class="line"><span class="preprocessor"># Instantiate from global scope (&quot;&quot;)</span></div>
<div class="line"><span class="preprocessor">#</span></div>
<div class="line">name: <span class="stringliteral">&quot;Example Report&quot;</span></div>
<div class="line">style:</div>
<div class="line">  decimal_places: 2</div>
<div class="line">content:</div>
<div class="line">  top: # Changes scope to TOP</div>
<div class="line">  subreport:</div>
<div class="line">     name: Automatic Summary</div>
<div class="line">     style:</div>
<div class="line">       show_descriptions: <span class="keyword">true</span></div>
<div class="line">     content:</div>
<div class="line">        autopopulate:</div>
<div class="line">           attributes: vis:summary</div>
<div class="line">        max_report_depth: 1</div>
<div class="line">  subreport:</div>
<div class="line">      name: Misc Stats</div>
<div class="line">      content:</div>
<div class="line">         core0.foo.stats.bar : BAR 0</div>
<div class="line">         core1.foo.stats.bar : BAR 1</div>
<div class="line">         core*.foo.stats.bin : BIN %1</div>
<div class="line">         core0:</div>
<div class="line">            foo.stats:</div>
<div class="line">               buz : <span class="stringliteral">&quot;BUZ 0&quot;</span></div>
</div><!-- fragment --><p>Assume a device tree which looks like this: </p><pre class="fragment">  - top
  - core0
  - foo
  - stats
  - bar (statistic, SUMMARY visibility)
  - bin (statistic)
  - buz (statistic)
  - core1
  - foo
  - stats
  - bar (statistic, SUMMARY visibility)
  - bin (statistic)
  - buz (statistic)</pre><p>The report above would be called "Example Report" and every field in every subreport would be formatted to 2 decimal places (see <a class="el" href="#report_def_style">Style section</a>).</p>
<p>Note the "top:" line just within the highest content section. This is a scope qualifier which tells the report parser that any node names or node name patterns nested within the dictionaries associated with that "top:" section will be resolved within the scope of "top". For example, "core0.foo" would resolve to "top.core0.foo" within that block.</p>
<p>A subreport called "Automatic Summary" would be created and would be populated by all counters/stats below the top-level "top" node which were created with "SUMMARY" (<a class="el" href="classsparta_1_1InstrumentationNode.html#a855b6ecdd93e412052ae264032002ce1a9d52d2ffaeb5218434fa19c8dd3ced2f" title="The next two visibility levels are for High-importance data. These are split up in the (100M,...">sparta::InstrumentationNode::Visibility::VIS_SUMMARY</a>) level visibility. See <a class="el" href="#report_def_autopop">Autopopulation Blocks</a>). The fields added by autopopulation will be given unique names. This is typically accomplished by creating a nested subreport for each node below the place where the autopopulation was performed ("top" in this case). However, because the max_report_depth was set to 1 for this autopopulate block, only 1 level of subreports will be created based on the child nodes seen (core0 and core1 in this case). Each with summary-level visibility (top.core0.foo.stats.bar and top.core1.foo.stats.bar in this example) will be added to the appropriate subreports with names relative to that subreport. Therefore the "Automatic Summary" subreport will contain 2 subreports each containing 1 field. So following the end of the first subreport section, the report content is: </p><pre class="fragment">  Report "Example Report"
  Subreport "Autmatic Summary"
  Subreport core0
  Field "foo.stats.bar" -&gt; top.core0.foo.stats.bar
  Subreport core1
  Field "foo.stats.bar" -&gt; top.core1.foo.stats.bar</pre><p><b>Note that this is not a real rendering of the report, but just a depiction of the current structure of the report. The actual rendering of the report is totally dependant on the report output formatter used to render the report (sparta::report::format).</b></p>
<p>Because the "show_descriptions" style was set, if this report were rendered with the html formatter (or any other formatter that recognizes the show_descriptions style) then descriptions for each field in the "Automatic Summary" section would be shown beside each report field</p>
<p>A second subreport of the "Example Report" would be created and called "Misc Stats". This second subreport would contain 5 fields as specified in the content section of that report.</p>
<p>The first two stats come from the lines </p><pre class="fragment">  core0.foo.stats.bar : BAR 0
  core1.foo.stats.bar : BAR 1</pre><p> These are explicit <a class="el" href="#report_def_field_declarations">Field Declarations</a> in the form of a leaf YAML key-value pair. Each of these lines creates a new field in the current report/subreport with the given name to the right of the ':'. This field points to the node (counter/stat) or expression (<a class="el" href="#report_def_expressions">Statistical Expressions</a>) on the left side. The node referenced on the left is resolved relative to the current scope ("top") in this case. The field name can be omitted and replaced with "" to indicate it is an unnamed field. Report output formatters handle rendering unnamed fields differently.</p>
<p>The third field declaration: </p><pre class="fragment">  core*.foo.stats.bin : BIN %1</pre><p> adds 2 fields to the report. This declaration contains a <b>wildcard</b> in the <u>node location</u> as well as a <b>variable</b> in the field <u>name</u>.</p>
<p>The wildcard in the node location indicates that when resolving this location to an actual node within the current scope ("top" in this case), proceed with any child having that name. In this example, "core*" could be substituted with "core0" and "core1". This is a very primitive glob-like pattern matching language.</p>
<p>Since both "core0" and "core1" will be matched, this line will result in the addition of a field for "top.core0.foo.stats.bin" as well as "top.core1.foo.stats.bin". See <a class="el" href="#report_def_scope_wildcards">Scope Wildcards</a> for more detail on these wildcards.</p>
<p>The substitutions made when pattern matching "core*" to "core0" and "core1" are available to the field name on the right of the ':'. "%1" refers to the first (most recent) subsitution on the substitution stack for the current context. When "core*" is matched to "core0", "%1" refers to "0" and when "core*" is matched to "core1", "%1" refers to "1". The field names of the two nodes added as a result of this line are "BIN 0" and "BIN 1". See <a class="el" href="#report_def_field_name_variables">Field Name Variables</a> for more detail on field name variables.</p>
<p>The final few lines of this content section are just nested scope qualifiers. </p><pre class="fragment">  core0:
     foo.stats:
        buz : "BUZ 0"</pre><p>"core0" just changes the current scope for anything in the nested dictionary associated with it. Since the scope enclosing this node is "top", the scope inside this section is "top.core0". The following line changes the scope to "top.core0.foo.stats". The third line is a field definition line which simply creates a field named "BUZ 0:" which points to the node "top.core0.foo.stats.buz".</p>
<p>It should be obvious from these lines that the current scope is a stack, and when the dictionary associated with each of these lines ends, the scope is set back to what it was before the dictionary was started. Any lines with the same indention as "core0" after these few line would have the scope of "top" because they are not within the "core0" scope qualifier's associated dictionary.</p>
<p>The final report contents after parsing this entire report definition are:</p>
<pre class="fragment">  Report "Example Report"
  Subreport "Autmatic Summary"
  Subreport core0
  Field "foo.stats.bar" -&gt; top.core0.foo.stats.bar
  Subreport core1
  Field "foo.stats.bar" -&gt; top.core1.foo.stats.bar
  Subreport "Misc Stats"
  Field "BAR 0" -&gt; core0.foo.stats.bar
  Field "BAR 1" -&gt; core1.foo.stats.bar
  Field "BIN 0" -&gt; core0.foo.stats.bin
  Field "BIN 1" -&gt; core1.foo.stats.bin
  Field "BUZ 0" -&gt; core0.foo.stats.buz</pre><h2><a class="anchor" id="report_def_field_declarations"></a>
Field Declarations</h2>
<p>Field declarations are leaf key-value pairs in YAML files within a content section but outside of some other block (e.g. autopopulate). These pairs each add one or more fields in the report (See <a class="el" href="#report_def_field">Report Fields</a>) and dictate how those fields get their values whenever the report is rendered.</p>
<p>A field has the following signature: </p><div class="fragment"><div class="line">value_expression : field_name</div>
</div><!-- fragment --><p> <em>value_expression</em> indicates how the field gets its value. This can be a node location relative to the current enclosing scope which may contain wildcards. Alternatively, this may be a statistical expression (<a class="el" href="classsparta_1_1statistics_1_1expression_1_1grammar_1_1ExpressionGrammar.html">sparta::statistics::expression::grammar::ExpressionGrammar</a>). When interpreting a report definition, an attempt is made to interpret this as a node location. If the string is not a properly formed node location string (alphanumeric with underscores and dot-separators) or if it does not resolve to any nodes in the simulation's device tree then it will be interpreted as an expression (See <a class="el" href="#report_def_expressions">Statistical Expressions</a>). If it is not a valid expression, an exception is thrown.</p>
<p><em>field_name</em> names the field. If the left side of a field declaration or any enclosing scope node contains wildcards, then this name should contain a variable as explained in <a class="el" href="#report_def_field_name_variables">Field Name Variables</a>.</p>
<p>See <a class="el" href="#report_def_example">Example Report Definition</a> for some example usages</p>
<h2><a class="anchor" id="report_def_field_name_variables"></a>
Field Name Variables</h2>
<p>The wildcards contained in report scope qualifiers and <a class="el" href="#report_def_field_declarations">Field Declarations</a> node paths allow a number of nodes having similar paths matching a given pattern to be added to a report in a single line in the report definition. However, this functionality can often cause report field name collisions. For example, the following line will always cause a report field name collision (and cause an exception to be thrown) if there is more than one matching node. </p><div class="fragment"><div class="line">top.core*.stats.foo : foo_field</div>
</div><!-- fragment --><p> The report being built may allow a field named "foo_field" to be added referring to "top.core0.stats.foo". If the pattern above also matches another node, say "top.core1.stats.foo", then it will attempt to add a field named "foo_field" to the report AGAIN for the next pattern match. This will result in an exception being thrown.</p>
<p>To avoid such name collisions, variables can be used in the report field name. Consider the following tree: </p><pre class="fragment">  top
  - core0
  - stats
  - foo0
  - foo1
  - core1
  - stats
  - foo0
  - foo1</pre><p>And the following example report definition: </p><pre class="fragment">  content:
  top:
      core*.stats:
          foo* : "My Core%1 Foo%2 Stat"
    #     foo* : "My Core%-2 Foo%-1 Stat"  # Alternative</pre><p>In this example, we see wildcards in a <b>scope qualifier</b> line ("core*.stats") and in a <b>report field definition</b> node location. After evaluating the "core*.stats" line with the example simulation tree shown above, the report definition interpreter will be tracking the contexts {"top.core0.stats", "top.core1.stats"}. It will also be tracking a stack of substitutions which can later be referenced by the report field name in variables. At this point, the stack of replacements for each context being tracked looks like: </p><pre class="fragment">  context "top.core0.stats" replacements_stack = ["0"]
  context "top.core1.stats" replacements_stack = ["1"]</pre><p>When the node location "foo*" portion of the report field declaration line is encountered, the interpreter evaluates the locations for each tracked context. The resulting set of contexts being tracked is {"top.core0.stats.foo0", "top.core0.stats.foo1", "top.core1.stats.foo0", "top.core1.stats.foo1"}. Each of these new contexts inherits the replacements stack from the context from which the pattern was matched. This results in a new set of replacement stacks being tracked </p><pre class="fragment">  context "top.core0.stats.foo0" replacements_stack = ["0", "0"] &lt;- top of stack
  context "top.core0.stats.foo1" replacements_stack = ["0", "1"] &lt;- top of stack
  context "top.core1.stats.foo0" replacements_stack = ["1", "0"] &lt;- top of stack
  context "top.core1.stats.foo1" replacements_stack = ["1", "1"] &lt;- top of stack</pre><p>At this point, the interpreter found 4 nodes refering to the given report field declaration and must create 4 report fields: one for each of the current contexts. Variables in the report field name can refer to the contents of the replacements stack for the context for which each field is being added.</p>
<p>%<em>X</em> refers to a position from the top of the replacements stack <em>X</em>-1. %1 refers to the top of the stack, %2 to the second from the top, and so on. In this example, %1 is the "foo" number and %2 is the "core" number. %0 refers to the fully-qualified context. %-<em>X</em> indexes the replacements stack for the current context in reverse.</p>
<p>%-1 refers to the least recent substitution made in the current context, %-2 to the second least recent and so on. Referring to replacements in this way is less flexible since a report definition that uses these variables may be moved to a new scope or included (see <a class="el" href="#report_def_includes">Include Directives</a>) inside another report definition unexpectedly. If the containing report definition uses wildcards to resolve its tree scope, it will change the values see in %-<em>x</em> variables. Therefore, this is discouraged.</p>
<p>Alternatively, one can totally omit the report field name as in: </p><div class="fragment"><div class="line">top.core*.stats.foo : <span class="stringliteral">&quot;&quot;</span></div>
</div><!-- fragment --><p> This is generally less desirable as it relies on the report output formatter to display a useful name when showing this field, which may not be the case depending on how the report is rendered.</p>
<h2><a class="anchor" id="report_def_subreports"></a>
Subreports</h2>
<p>A single report can contain multiple subreports to better organize its content.</p>
<div class="fragment"><div class="line"><span class="preprocessor"># report.yaml</span></div>
<div class="line">content:</div>
<div class="line">    top:</div>
<div class="line">        autopopulate:</div>
<div class="line">            attributes: <span class="stringliteral">&quot;!=vis:hidden&quot;</span>  # generate a report with all stats that are not hidden</div>
<div class="line"> </div>
<div class="line">    subreport:</div>
<div class="line">        name: <span class="stringliteral">&quot;Another Section in the same report&quot;</span></div>
<div class="line">        content:</div>
<div class="line">            <span class="stringliteral">&quot;core0.stats.my_counter1 + core0.stats.my_counter2&quot;</span> : <span class="stringliteral">&quot;counter1_plus_counter2&quot;</span></div>
</div><!-- fragment --><h2><a class="anchor" id="report_def_scope_wildcards"></a>
Scope Wildcards</h2>
<p>Wildcards can be inserted into Node Scope qualifiers to simultaneously descend subtrees within the sparta device tree. This is useful when there are mutliple instantiations of a simular component (e.g. multiple cores). To see the same statistic across each core, one could supply a node location containing a wildcard like so: </p><div class="fragment"><div class="line">top.core*.foo.bar.stats.mystat</div>
</div><!-- fragment --><p>As long as this location was evaluated from the global scope (higher than top), it would find every "mystat" matching this patttern. If the simulation had 12 core instances ("core0" through "core11") which each had identical subtrees, this would find 12 instances of mystat.</p>
<p>If each "core*" in this hypothetical system contained different subtrees and some did NOT have a "mystat" statistic as indicated by the path, the found set would contain fewer than 12 results. <b>When interpreting a report definition file this is not a problem <u>as long as at least 1 node can be found matching this pattern.</u></b></p>
<p>These wildcards are part of a very limited glob-like pattern matching language. There is no limit to the number of wildcards that can be used in a single string. The following wildcards are supported:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Wildcard   </th><th class="markdownTableHeadNone">Meaning    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">*   </td><td class="markdownTableBodyNone">Any number of characters    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">+   </td><td class="markdownTableBodyNone">One or more characters    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">?   </td><td class="markdownTableBodyNone">Zero or One character   </td></tr>
</table>
<p>When evaluating an tree location with wildcards, the substitutions for each match are tracked. These substitutions can be accessed through variables in report field declarations. See <a class="el" href="#report_def_field_name_variables">Field Name Variables</a>. Even the substitutions in enclosing scope qualifiers (on other lines) are accessible.</p>
<h2><a class="anchor" id="report_def_expressions"></a>
Statistical Expressions</h2>
<p>Expressions can be used instead of a statistic/counter name when defining report fields (as in <a class="el" href="#report_def_field">Report Fields</a>). These are arithmetic expressions supporting most some operators and tokens: +, -, *, /, **, (, ), and -unary. Thes expressions support references to other counters and stats, a number of builtin constants, simulation variables, and functions of various arities. Other counters/stats can be referenced relative to the current context in the report def just as simple named counters/stats are referenced in basic report entries.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Constant   </th><th class="markdownTableHeadNone">Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">c_pi   </td><td class="markdownTableBodyNone">boost::math::constants::pi&lt;double&gt;()    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">c_root_pi   </td><td class="markdownTableBodyNone">boost::math::constants::root_pi&lt;double&gt;()    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">c_root_half_pi   </td><td class="markdownTableBodyNone">boost::math::constants::root_half_pi&lt;double&gt;()    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">c_root_two_pi   </td><td class="markdownTableBodyNone">boost::math::constants::root_two_pi&lt;double&gt;()    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">c_root_ln_four   </td><td class="markdownTableBodyNone">boost::math::constants::root_ln_four&lt;double&gt;()    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">c_e   </td><td class="markdownTableBodyNone">boost::math::constants::e&lt;double&gt;()    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">c_half   </td><td class="markdownTableBodyNone">boost::math::constants::half&lt;double&gt;()    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">c_euler   </td><td class="markdownTableBodyNone">boost::math::constants::euler&lt;double&gt;()    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">c_root_two   </td><td class="markdownTableBodyNone">boost::math::constants::root_two&lt;double&gt;()    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">c_ln_two   </td><td class="markdownTableBodyNone">boost::math::constants::ln_two&lt;double&gt;()    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">c_ln_ln_two   </td><td class="markdownTableBodyNone">boost::math::constants::ln_ln_two&lt;double&gt;()    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">c_third   </td><td class="markdownTableBodyNone">boost::math::constants::third&lt;double&gt;()    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">c_twothirds   </td><td class="markdownTableBodyNone">boost::math::constants::twothirds&lt;double&gt;()    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">c_pi_minus_three   </td><td class="markdownTableBodyNone">boost::math::constants::pi_minus_three&lt;double&gt;()    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">c_four_minus_pi   </td><td class="markdownTableBodyNone">boost::math::constants::four_minus_pi&lt;double&gt;()    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">c_nan   </td><td class="markdownTableBodyNone">NAN    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">c_inf   </td><td class="markdownTableBodyNone">INFINITY   </td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Variable   </th><th class="markdownTableHeadNone">Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">g_ticks   </td><td class="markdownTableBodyNone">(singleton) Scheduler ticks    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">g_seconds   </td><td class="markdownTableBodyNone">(singleton) Scheduler simulated seconds elapsed    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">g_milliseconds   </td><td class="markdownTableBodyNone">(singleton) Scheduler simulated milliseconds elapsed    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">g_microseconds   </td><td class="markdownTableBodyNone">(singleton) Scheduler simulated microseconds elapsed    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">g_nanoseconds   </td><td class="markdownTableBodyNone">(singleton) Scheduler simulated nanoseconds elapsed    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">g_picoseconds   </td><td class="markdownTableBodyNone">(singleton) Scheduler simulated picoseconds elapsed   </td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Unary Function   </th><th class="markdownTableHeadNone">Implementation    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">abs(x)   </td><td class="markdownTableBodyNone">std::fabs(x) <em>(abs in stat expressions maps to fabs</em>)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">fabs(x)   </td><td class="markdownTableBodyNone">std::fabs(x)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">acos(x)   </td><td class="markdownTableBodyNone">std::acos(x)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">asin(x)   </td><td class="markdownTableBodyNone">std::asin(x)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">atan(x)   </td><td class="markdownTableBodyNone">std::atan(x)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ceil(x)   </td><td class="markdownTableBodyNone">std::ceil(x)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">trunc(x)   </td><td class="markdownTableBodyNone">std::trunc(x)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">round(x)   </td><td class="markdownTableBodyNone">std::round(x)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cos(x)   </td><td class="markdownTableBodyNone">std::cos(x)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">cosh(x)   </td><td class="markdownTableBodyNone">std::cosh(x)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">exp(x)   </td><td class="markdownTableBodyNone">std::exp(x)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">exp2(x)   </td><td class="markdownTableBodyNone">std::exp2(x)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">floor(x)   </td><td class="markdownTableBodyNone">std::floor(x)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ln(x)   </td><td class="markdownTableBodyNone">std::log(x)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">log2(x)   </td><td class="markdownTableBodyNone">std::log2(x)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">log10(x)   </td><td class="markdownTableBodyNone">std::log10(x)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">sin(x)   </td><td class="markdownTableBodyNone">std::sin(x)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">sinh(x)   </td><td class="markdownTableBodyNone">std::sinh(x)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">sqrt(x)   </td><td class="markdownTableBodyNone">std::sqrt(x)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">cbrt(x)   </td><td class="markdownTableBodyNone">std::cbrt(x)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tan(x)   </td><td class="markdownTableBodyNone">std::tan(x)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">tanh(x)   </td><td class="markdownTableBodyNone">std::tanh(x)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">isnan(x)   </td><td class="markdownTableBodyNone">std::isnan(x)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">isinf(x)   </td><td class="markdownTableBodyNone">std::isinf(x)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">signbit(x)   </td><td class="markdownTableBodyNone">std::signbit(x)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">logb(x)   </td><td class="markdownTableBodyNone">std::logb(x)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">erf(x)   </td><td class="markdownTableBodyNone">std::erf(x)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">erfc(x)   </td><td class="markdownTableBodyNone">std::erfc(x)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">lgamma(x)   </td><td class="markdownTableBodyNone">std::lgamma(x)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">tgamma(x)   </td><td class="markdownTableBodyNone">std::tgamma(x)   </td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Binary Function   </th><th class="markdownTableHeadNone">Implementation    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">pow(a,b)   </td><td class="markdownTableBodyNone">std::pow(a, b)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">atan2(a,b)   </td><td class="markdownTableBodyNone">std::atan2(a, b)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">min(a,b)   </td><td class="markdownTableBodyNone">std::min&lt;double&gt;(a, b)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">max(a,b)   </td><td class="markdownTableBodyNone">std::max&lt;double&gt;(a, b)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">fmod(a,b)   </td><td class="markdownTableBodyNone">std::fmod(a, b)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">remainder(a,b)   </td><td class="markdownTableBodyNone">std::remainder(a, b)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">hypot(a,b)   </td><td class="markdownTableBodyNone">std::hypot(a, b)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ifnan(a,b)   </td><td class="markdownTableBodyNone">(std::isnan(a) or std::isinf(a)) ? b : a   </td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Ternary Function   </th><th class="markdownTableHeadNone">Implementation    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cond(a,b,c)   </td><td class="markdownTableBodyNone">a ? b : c   </td></tr>
</table>
<p><b style="color:#ff0000;">WARNING: Expressions inside a (YAML) report definition cannot begin with a '*' character unless fully enclosed in double-quotes</b>.<br  />
This is because a YAML scalar cannot begin with an asterisk</p>
<p>See <a class="el" href="classsparta_1_1statistics_1_1expression_1_1grammar_1_1ExpressionGrammar.html">sparta::statistics::expression::grammar::ExpressionGrammar</a> for implementation of this expression grammar</p>
<h2><a class="anchor" id="report_def_includes"></a>
Include Directives</h2>
<p>As in the support for parameter/configuration format <a class="el" href="param_format.html">Parameter/Configuration Format (.cfg,.yaml)</a>, the report YAML representation allows for <code>include</code> keywords:</p>
<div class="fragment"><div class="line">name: <span class="stringliteral">&quot;Include example&quot;</span></div>
<div class="line">author: <span class="stringliteral">&quot;knute&quot;</span></div>
<div class="line">content:</div>
<div class="line">    top:</div>
<div class="line">        core0:</div>
<div class="line">            <span class="stringliteral">&quot;#include&quot;</span> : core_stats.yaml</div>
</div><!-- fragment --><h2><a class="anchor" id="report_def_style"></a>
Style section</h2>
<p>The style section of a report is a dictionary associated with a 'style' keyword <b>outside the content section</b> of a report. The style section contains style hints that some output formatters will interpret.</p>
<p>To see a full list of the style hints and default behavior, look at documentation for each report output formatter in sparta::report::format.</p>
<p>A few of the availsble style options include </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Style   </th><th class="markdownTableHeadNone">Effect   </th><th class="markdownTableHeadNone">Supported Output Formatter    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">decimal_places   </td><td class="markdownTableBodyNone">Number of digits after the decimal place for non-integer values   </td><td class="markdownTableBodyNone">html, json    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">collapsible_children   </td><td class="markdownTableBodyNone">When rendering HTML output, children can be dynamically collapsed via interactive javascript   </td><td class="markdownTableBodyNone">html    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">num_stat_columns   </td><td class="markdownTableBodyNone">Number of statistic columns for HTML output. Can be used to make reports more dense   </td><td class="markdownTableBodyNone">html    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">show_descriptions   </td><td class="markdownTableBodyNone">Show a description next to each report value in HTML output   </td><td class="markdownTableBodyNone">html   </td></tr>
</table>
<h2><a class="anchor" id="report_def_autopop"></a>
Autopopulation Blocks</h2>
<p>Within a content section, the key "autopopulate" indicates that a number of fields will be added to the report automatically based on some criteria.</p>
<p>Autopopulate can be used in two forms: as a single, concise key-value pair and as a nested dictionary with multiple detailed options.</p>
<p>When used concisely, the autopopulate key is followed by a value that is a filter expression. This simple filtering language filters nodes based on their visibility semantics. It is explained below.</p>
<div class="fragment"><div class="line">content:</div>
<div class="line"><span class="preprocessor"># other content</span></div>
<div class="line"><span class="preprocessor"># ...</span></div>
<div class="line">autopopulate: <span class="stringliteral">&quot;!=vis:hidden &amp;&amp; !=vis:summary&quot;</span></div>
</div><!-- fragment --><div class="fragment"><div class="line">content:</div>
<div class="line"><span class="preprocessor"># other content</span></div>
<div class="line"><span class="preprocessor"># ...</span></div>
<div class="line">autopopulate: <span class="keyword">true</span> # Anything and everything</div>
</div><!-- fragment --><p>The more verbose usage: </p><div class="fragment"><div class="line">content:</div>
<div class="line"><span class="preprocessor"># other content</span></div>
<div class="line"><span class="preprocessor"># ...</span></div>
<div class="line">autopopulate:</div>
<div class="line">    attributes: vis:summary</div>
<div class="line">       max_report_depth: 0  # Stops making subreports at depth N. 0 means no subreports</div>
<div class="line">       max_recursion_depth: -1 # Never stop recursion of the <a class="code hl_namespace" href="namespacesparta.html">sparta</a> tree</div>
<div class="ttc" id="anamespacesparta_html"><div class="ttname"><a href="namespacesparta.html">sparta</a></div><div class="ttdoc">Macros for handling exponential backoff.</div><div class="ttdef"><b>Definition</b> <a href="AppTriggers_8hpp_source.html#l00022">AppTriggers.hpp:22</a></div></div>
</div><!-- fragment --><h4>Tree Filtering Expressions</h4>
<p>Tree filter expressions use a simple custom grammar for accepting or rejecting an instrumentation node in a sparta tree based on its attributes and visibility semantics. See <a class="el" href="classsparta_1_1InstrumentationNode.html">sparta::InstrumentationNode</a>.</p>
<p>Instrumentation nodes have a visiblity value in the range of <a class="el" href="classsparta_1_1InstrumentationNode.html#a855b6ecdd93e412052ae264032002ce1a01a69b1a50e88559f40efc68ba7e5224" title="Hidden hint. Lowest possible visibility.">sparta::InstrumentationNode::VIS_HIDDEN</a> (0) to <a class="el" href="classsparta_1_1InstrumentationNode.html#a855b6ecdd93e412052ae264032002ce1a3ce278dc9da833cf07ae0151b59185dc" title="Maximum possible visibility.">sparta::InstrumentationNode::VIS_MAX</a>. A few common values in the range are contained in the <a class="el" href="classsparta_1_1InstrumentationNode.html#a855b6ecdd93e412052ae264032002ce1" title="Common visibility levels. Visibility is a continum (visibility can be anywhere in [0 to MAX_VISIBILIT...">sparta::InstrumentationNode::Visibility</a> enum.</p>
<h4>Visibility Filtering</h4>
<p>Tree filtering expressions can filter for this visibility level. To accept only nodes with visibility of <a class="el" href="classsparta_1_1InstrumentationNode.html#a855b6ecdd93e412052ae264032002ce1ae8a4ef9c9e35f4316227cdd7bf0ab1dd" title="Normal visibility (default)">sparta::InstrumentationNode::VIS_NORMAL</a> or higher, use: </p><div class="fragment"><div class="line"><span class="stringliteral">&quot;&gt;=vis:normal&quot;</span></div>
</div><!-- fragment --><p>Visibility filtering is always in the form<br  />
 &#160;&#160;&#160;&#160;<em>&lt;visibility_comparison&gt;</em>vis:<em>&lt;visibility_value&gt;</em></p>
<p>To require visibility be anything but <a class="el" href="classsparta_1_1InstrumentationNode.html#a855b6ecdd93e412052ae264032002ce1a01a69b1a50e88559f40efc68ba7e5224" title="Hidden hint. Lowest possible visibility.">sparta::InstrumentationNode::VIS_HIDDEN</a>, use </p><div class="fragment"><div class="line"><span class="stringliteral">&quot;!=vis:hidden&quot;</span></div>
</div><!-- fragment --><p>Visibility can also be an integer. </p><div class="fragment"><div class="line"><span class="stringliteral">&quot;&lt;vis:100&quot;</span></div>
</div><!-- fragment --><p>Grammar constants for visibility include (see <a class="el" href="classsparta_1_1InstrumentationNode.html#a855b6ecdd93e412052ae264032002ce1" title="Common visibility levels. Visibility is a continum (visibility can be anywhere in [0 to MAX_VISIBILIT...">sparta::InstrumentationNode::Visibility</a>) </p><ul>
<li>summary </li>
<li>normal </li>
<li>detail </li>
<li>support </li>
<li>hidden</li>
</ul>
<p>Visibility Comparison Operators are (in no particular order): </p><ul>
<li>"==" </li>
<li>"&gt;=" </li>
<li>"&lt;=" </li>
<li>"&lt;" </li>
<li>"&gt;" </li>
<li>"!="</li>
</ul>
<p>The "==" comparison is implicitly used if no visibility comparison operator is chosen</p>
<h4>Type filtering</h4>
<p>Filtering can be performed based on node type attributes. For example, counters can be rejected. </p><div class="fragment"><div class="line"><span class="stringliteral">&quot;!=type:counter&quot;</span></div>
</div><!-- fragment --><p>Type filtering is always in the form<br  />
 &#160;&#160;&#160;&#160;<em>&lt;type_comparison&gt;</em>type:<em>&lt;type_name&gt;</em></p>
<p>Type Comparison Operators are (in no paticualr order): </p><ul>
<li>"==" </li>
<li>"!="</li>
</ul>
<p>The "==" comparison is implicitly used if no type comparison operator is chosen</p>
<p>Grammar constants or type include </p><ul>
<li>statistic, statisticdef, stat, statdef </li>
<li>counter </li>
<li>parameter, param (<b>Currently unsupported in Reports</b>) </li>
<li>histogram (<b>Currently unsupported in Reports</b>)</li>
</ul>
<h4>Name and Tag filtering</h4>
<p>Similarly to type and visiblity, nodes can be filtered by their local name and tag-set. These attributes do not support comparison using relative operators (&lt;, &gt;, etc.). ==, != and regex operators are supported. The 'regex' operator attempts to match a given regex pattern with the name of name of the node or any tag of the node depending on how it is invoked.</p>
<p>Type Comparison Operators are (in no paticualr order): </p><ul>
<li>"==" </li>
<li>"!=" </li>
<li>"regex"</li>
</ul>
<p>Some example expression to filter by a name might be </p><div class="fragment"><div class="line"><span class="stringliteral">&quot;name:node_i_am_looking_for&quot;</span></div>
<div class="line"><span class="stringliteral">&quot;!=name:name_of_an_inaccurate_counter&quot;</span></div>
<div class="line"><span class="stringliteral">&quot;regex name:ctr_foo_.*&quot;</span> # Accept counters whose names have a ctr_foo_ prefix</div>
</div><!-- fragment --><p>Tag filtering is similar to name filtering, but the comparison operators have semantics that apply to the whole tag set. The truth table is </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Required for "true" evaluation    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">"=="   </td><td class="markdownTableBodyNone">Any tag matches comparison string    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">"!="   </td><td class="markdownTableBodyNone">No tag matches comparison string    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">"regex"   </td><td class="markdownTableBodyNone">Any tag matches regular expression pattern   </td></tr>
</table>
<p>There is no !regex operator. Instead the inversion operators "!" and "not" can be used after a regex operation. Refer to the next section.</p>
<p>Some example expression to filter by a tag might be </p><div class="fragment"><div class="line"><span class="stringliteral">&quot;tag:power&quot;</span></div>
<div class="line"><span class="stringliteral">&quot;!=name:dummy_.*&quot;</span></div>
<div class="line"><span class="stringliteral">&quot;regex tag:power_.*&quot;</span> # Accept counters having tags beginning with <span class="stringliteral">&quot;power_&quot;</span></div>
</div><!-- fragment --><h4>Compound filtering</h4>
<p>Visibility and type filtering can be combined in to the same expression with logical operators. Just as in C, these operators are more loosely bound than any other operators (with a lower number indicating looser binding)</p>
<p>One could filter for only statistics (not counters) which have "summary" level visibility, a tag indicating they are 'power'-related stats, and a name that does not contain the string 'fiz' </p><div class="fragment"><div class="line"><span class="stringliteral">&quot;vis:summary &amp;&amp; type:stat &amp;&amp; tag:power &amp;&amp; not regex name:.*fiz.*&quot;</span></div>
</div><!-- fragment --><p>More complex filters can be created using parentheses. This expression accepts statistics with "summary" visibility OR counters with "hidden visibility" </p><div class="fragment"><div class="line"><span class="stringliteral">&quot;(vis:summary &amp;&amp; type:stat) || (vis:hidden &amp;&amp; type:counter)&quot;</span></div>
</div><!-- fragment --><h4>Logical Operators include</h4>
<ol>
<li>
"^^"  </li>
<li>
"||"  </li>
<li>
"&amp;&amp;"  </li>
<li>
"!"  </li>
<li>
"not"  </li>
</ol>
<h4>Parentheses are, of course, supported.</h4>
<p>The grammar is fully defined and implemented sparta::tree::filter::grammar::Grammar</p>
<p><em>Often, these expressions contain characters not accepted by YAML and must be written in quotes.</em></p>
<h1><a class="anchor" id="report_def_var_name_ambiguity"></a>
Field Declaration Path/Expression Ambiguity</h1>
<p>Because some reserved words in the report definition grammar may be the same as nodes in the sparta tree, ambiguity can be created.</p>
<p>By default, any report field names are assumed to be node names unless a node by that name does not exist in the current scope. Then, the report definition parser attempts to interpret the field name as an expression.</p>
<p>For example, the folling tree can present problems when trying to look at the cycles <b>variable</b> (not the top.cpu1.stats.cycles node) on the st0 or st1 nodes. </p><pre class="fragment">  top
  - cpu0
  - cpu1
  - st0
  - st1
  - stats
  - cycles</pre><p>The following will only find the nodes "top.cpu1.stats.cycles" and add them to the report. </p><div class="fragment"><div class="line">content:</div>
<div class="line">top.mss.cpu*.st*:</div>
<div class="line">cycles: <span class="stringliteral">&quot;%l&quot;</span></div>
</div><!-- fragment --><p>To use the "cycles" variable to get the number of cycles of the clock on the top.cpu1.st0 and st1 nodes, the following definition could be used. </p><div class="fragment"><div class="line">content:</div>
<div class="line">top.mss.cpu*.st?:</div>
<div class="line">cycles: <span class="stringliteral">&quot;Clock for st%1 cpu%2&quot;</span></div>
</div><!-- fragment --><p>Resolving ambiguity of node names vs. statistic expression variables is not explicitly supported in the language. One must be clever about either naming tree nodes more specifically or using wildcards that specifically</p>
<p><em>It is an eventual goal to add full regular expression support instead of glob-like pattern matching. This should allow the user to define pattern-matching node-scope strings that eliminate all ambiguity (if pattern matching must be used)</em></p>
<h1><a class="anchor" id="report_def_directive_ref"></a>
Report Definition Directive and Option Reference</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Directive   </th><th class="markdownTableHeadNone">Report Definition File Context   </th><th class="markdownTableHeadNone">Semantic    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">name   </td><td class="markdownTableBodyNone">Immediate child of a subreport section or at the top-level of a report definition   </td><td class="markdownTableBodyNone">Name of the report (for output formatters that display a title)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">author   </td><td class="markdownTableBodyNone">Immediate child of a subreport section or at the top-level of a report definition   </td><td class="markdownTableBodyNone">Author of the report (for output formatters that display an author)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">style   </td><td class="markdownTableBodyNone">Immediate child of a subreport section or at the top-level of a report definition   </td><td class="markdownTableBodyNone">Begins a style section where key-value pairs can be used to specify style. Styles are output-formatter-specific. See <a class="el" href="#report_def_style">Style section</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">content   </td><td class="markdownTableBodyNone">Immediate child of a subreport section or at the top-level of a report definition   </td><td class="markdownTableBodyNone">Begins a content section. Parser is considered to be in this content section until it enters a subrerport or exits the dictionary associated with the 'content' key    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">subreport   </td><td class="markdownTableBodyNone">Within a 'content' section more recently than the nearest parent subreport section   </td><td class="markdownTableBodyNone">Begins a subreport of the most recent subreport (or top-level report if no subreports specified). See <a class="el" href="#report_def_subreports">Subreports</a>. This should be considered as "ending" the current content section until this particular content section ends.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">include   </td><td class="markdownTableBodyNone">Within a 'content' section more recently than the nearest parent subreport section   </td><td class="markdownTableBodyNone">Includes another report definition file at the <b>current node context</b>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">autopopulate   </td><td class="markdownTableBodyNone">Within a 'content' section more recently than nearest parent subreport section   </td><td class="markdownTableBodyNone">Specifies autopopulation of report fields based on some filter expression and other options    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">attributes   </td><td class="markdownTableBodyNone">Immediately within an 'autopopulate' block   </td><td class="markdownTableBodyNone">Specifies the attribute filter expression for autopopulation. See <a class="el" href="#report_def_autopop">Autopopulation Blocks</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">max_recursion_depth   </td><td class="markdownTableBodyNone">Immediately within an 'autopopulate' block   </td><td class="markdownTableBodyNone">Specifies the maximum recursion depth when autopopulating. This prevents autopopulation from recursing any deeper than N children. If 0, only looks at node(s) indicated by current scope and never looks at children. Defaults to -1 (no recursion limit)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">max_report_depth   </td><td class="markdownTableBodyNone">Immediately within an 'autopopulate' block   </td><td class="markdownTableBodyNone">Specifies the depth of nested subreports to create. If 0, all fields will be added to the top level report. This may cause name collisions which cause errors when instantiating the report. Defualts to -1 which means no limit   </td></tr>
</table>
<h1><a class="anchor" id="report_def_lims"></a>
Limitations of Report Definitions</h1>
<ul>
<li>Cannot specify absolute paths of objects. All report content is relative to the context within which the report is constructed. Repo </li>
<li>Does not allow depth-first traversal of report context specifiers (i.e. cannot visit all children of one substitution of a report context qualifier with a wildcard before moving on to the next substitution for that wildcard) </li>
<li>Cannot always resolve ambiguity between node names and variables in statistic expressions </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Feb 9 2026 03:27:54 for The Sparta Modeling Framework by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
