<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Sparta Modeling Framework: sparta Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">The Sparta Modeling Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespacesparta.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">sparta Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Macros for handling exponential backoff.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesparta_1_1app.html">app</a></td></tr>
<tr class="memdesc:namespacesparta_1_1app"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparta Application framework. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesparta_1_1exp__backoff.html">exp_backoff</a></td></tr>
<tr class="memdesc:namespacesparta_1_1exp__backoff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains utilities and types of exponential backoff helpers. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesparta_1_1log.html">log</a></td></tr>
<tr class="memdesc:namespacesparta_1_1log"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diagnostic logging framework. This node generates logging messages of a specific category. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesparta_1_1memory.html">memory</a></td></tr>
<tr class="memdesc:namespacesparta_1_1memory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace containing memory interfaces, types, and storage objects. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesparta_1_1statistics.html">statistics</a></td></tr>
<tr class="memdesc:namespacesparta_1_1statistics"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace containing methods for computing and generating statistical information using instrumentation extracted from sparta structures such as Counters. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1____RegisterDefintionSet.html">__RegisterDefintionSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type that holds a set of register definitions.  <a href="classsparta_1_1____RegisterDefintionSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ArchData.html">ArchData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains a set of contiguous line of architectural data which can be referred to by any architected object model. When <a class="el" href="classsparta_1_1ArchData.html#a656bd7fd07e1cc1705962b102b1bb116" title="Organizes the Segments into overlapping regions as needed, eventually calling ArchDataSegment::place ...">layout()</a> is called, reserves space for each element in a registered set of <a class="el" href="classsparta_1_1ArchDataSegment.html">ArchDataSegment</a> instances at offsets within Lines within the <a class="el" href="classsparta_1_1ArchData.html" title="Contains a set of contiguous line of architectural data which can be referred to by any architected o...">ArchData</a>.  <a href="classsparta_1_1ArchData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ArchDataContainer.html">ArchDataContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container class for any number of <a class="el" href="classsparta_1_1ArchData.html" title="Contains a set of contiguous line of architectural data which can be referred to by any architected o...">ArchData</a> pointers owned externally.  <a href="classsparta_1_1ArchDataContainer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ArchDataSegment.html">ArchDataSegment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Array.html">Array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a> is essentially a fixed size vector, maintains a concept of validity of its indexes, and provides access via stl iteration and general get methods.  <a href="classsparta_1_1Array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1AssertContext.html">AssertContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a helper traits class for determining whehther a type has a member named getClock.  <a href="classsparta_1_1AssertContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1AssignOnceObject.html">AssignOnceObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object which can only have it's value set once. Throws exception if being set more than once.  <a href="classsparta_1_1AssignOnceObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1AsyncEvent.html">AsyncEvent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">In a multi-threaded sim environment, this event is used to schedule an event asynchronously.  <a href="classsparta_1_1AsyncEvent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Audience.html">Audience</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class used maintain a list of <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">sparta::Scheduleable</a> objects; used by observation-type classes.  <a href="classsparta_1_1Audience.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1BasicHistogram.html">BasicHistogram</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Baz.html">Baz</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsparta_1_1bit__reference__to__bool.html">bit_reference_to_bool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type for converting _Bit_reference types into bool types for the purpose of determining how to lexically cast a string into that type.  <a href="structsparta_1_1bit__reference__to__bool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsparta_1_1bit__reference__to__bool_3_01typename_01std_1_1__Bit__reference_01_4.html">bit_reference_to_bool&lt; typename std::_Bit_reference &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1BoolEnum.html">BoolEnum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class responsible for handling State&lt;bool&gt; instances and converts bool instances into actual EnumTValueType instances to satisfy exisiting function signatures.  <a href="classsparta_1_1BoolEnum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1bounded__int.html">bounded_int</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded integer type with range-checking.  <a href="classsparta_1_1bounded__int.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Buffer.html">Buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data structure allowing appending at the end, beginning, or middle, but erase anywhere with collapse.  <a href="classsparta_1_1Buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Bus.html">Bus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that defines a <a class="el" href="classsparta_1_1Bus.html" title="Class that defines a Bus type.">Bus</a> type.  <a href="classsparta_1_1Bus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1BusSet.html">BusSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> that represents a set of Buses.  <a href="classsparta_1_1BusSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1CircularBuffer.html">CircularBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data structure allowing appending at the end, beginning, or insert in the middle, but erase anywhere with collapse.  <a href="classsparta_1_1CircularBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Clock.html">Clock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A representation of simulated time.  <a href="classsparta_1_1Clock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ClockManager.html">ClockManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages building a clock tree.  <a href="classsparta_1_1ClockManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ContextCounter.html">ContextCounter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container type that allows a modeler to build, store, and charge counts to a specific context.  <a href="classsparta_1_1ContextCounter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Counter.html">Counter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a counter of type counter_type (uint64_t). 2 and greater than 0 with a ceiling specified. A ceiling value that is a power of two is optimized to perform operations faster.  <a href="classsparta_1_1Counter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1CounterBase.html">CounterBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for all Counters.  <a href="classsparta_1_1CounterBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1CycleCounter.html">CycleCounter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a cycle counter.  <a href="classsparta_1_1CycleCounter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1CycleHistogramBase.html">CycleHistogramBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1CycleHistogramBase.html" title="CycleHistogramBase class for uint64_t values.">CycleHistogramBase</a> class for uint64_t values.  <a href="classsparta_1_1CycleHistogramBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1CycleHistogramStandalone.html">CycleHistogramStandalone</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1CycleHistogramStandalone.html" title="CycleHistogramStandalone class for uint64_t values.">CycleHistogramStandalone</a> class for uint64_t values.  <a href="classsparta_1_1CycleHistogramStandalone.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1CycleHistogramTreeNode.html">CycleHistogramTreeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1CycleHistogramTreeNode.html" title="CycleHistogramTreeNode class for uint64_t values.">CycleHistogramTreeNode</a> class for uint64_t values.  <a href="classsparta_1_1CycleHistogramTreeNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1DAG.html">DAG</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1DataContainer.html">DataContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by <a class="el" href="classsparta_1_1DataInPort.html" title="DataInPort receives data from sender using a DataOutPort.">DataInPort</a> and <a class="el" href="classsparta_1_1SyncInPort.html" title="Class that defines an synchronized input port on modules on two different clocks.">SyncInPort</a>, this class holds received data from these ports and remembers the time in which the data was set. It also maintains the validity of the data.  <a href="classsparta_1_1DataContainer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1DataInPort.html">DataInPort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1DataInPort.html" title="DataInPort receives data from sender using a DataOutPort.">DataInPort</a> receives data from sender using a <a class="el" href="classsparta_1_1DataOutPort.html" title="DataOutPort is used for transferring any data to another module.">DataOutPort</a>.  <a href="classsparta_1_1DataInPort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1DataOutPort.html">DataOutPort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1DataOutPort.html" title="DataOutPort is used for transferring any data to another module.">DataOutPort</a> is used for transferring any data to another module.  <a href="classsparta_1_1DataOutPort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1DataView.html">DataView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">View into a backend block of memory in an <a class="el" href="classsparta_1_1ArchData.html" title="Contains a set of contiguous line of architectural data which can be referred to by any architected o...">ArchData</a>.  <a href="classsparta_1_1DataView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1DynamicResourceTreeNode.html">DynamicResourceTreeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> subclass representing a node in the device tree which creates and owns a resource. This node is created at run-time and, although it takes a parameter set at construction, is not part of the SPARTA configuration phase and is not user configurable through any <a class="el" href="classsparta_1_1ParameterSet.html" title="Generic container of Parameters.">sparta::ParameterSet</a>.  <a href="classsparta_1_1DynamicResourceTreeNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1EnumCycleHistogram.html">EnumCycleHistogram</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1EnumCycleHistogram.html" title="EnumCycleHistogram class for C++ Enum values.">EnumCycleHistogram</a> class for C++ Enum values.  <a href="classsparta_1_1EnumCycleHistogram.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1EnumHistogram.html">EnumHistogram</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1EnumHistogram.html" title="EnumHistogram class for sparta::utils::Enum.">EnumHistogram</a> class for <a class="el" href="classsparta_1_1utils_1_1Enum.html" title="Class that wraps a C++ class enum and allows conversion between POD and the enum type....">sparta::utils::Enum</a>.  <a href="classsparta_1_1EnumHistogram.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Event.html">Event</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1Event.html" title="Event is a simple class for scheduling random events on the Scheduler.">Event</a> is a simple class for scheduling random events on the <a class="el" href="classsparta_1_1Scheduler.html" title="A class that lets you schedule events now and in the future.">Scheduler</a>.  <a href="classsparta_1_1Event.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1EventGroup.html">EventGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group a series of events together for precedence establishment.  <a href="classsparta_1_1EventGroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1EventNode.html">EventNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1EventNode.html" title="EventNode is the base class for all event types in SPARTA. Not to be used by the modeler....">EventNode</a> is the base class for all event types in SPARTA. Not to be used by the modeler. Its main purpose is to look for a clock and scheduler for the event.  <a href="classsparta_1_1EventNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1EventSet.html">EventSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of Events that a unit (or <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">sparta::TreeNode</a>, <a class="el" href="classsparta_1_1Resource.html" title="The is the base class for all types of resources used by the SPARTA framework.">sparta::Resource</a>) contains and are visible through a sparta Tree.  <a href="classsparta_1_1EventSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ExportedPort.html">ExportedPort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that "exports" a port that's contained in the same <a class="el" href="classsparta_1_1ResourceTreeNode.html" title="TreeNode subclass representing a node in the device tree which contains a single ResourceFactory and ...">ResourceTreeNode</a> structure.  <a href="classsparta_1_1ExportedPort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ExtensionRegistration.html">ExtensionRegistration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1FrontArray.html">FrontArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type of <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a> with special allocation policies to support writing to the front most valid entry in the <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">Array</a>, as well as reading the nth valid entry in the array.  <a href="classsparta_1_1FrontArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1FunctionManager.html">FunctionManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singleton Function Manager class. This class contains two maps and one constant string token. These maps contain a string as key and function pointers as value. The string key is the same as the name of the free functions as defined by the users and the keys are the function pointers to those methods. One map is dedicated for HistogramTreeNodes while the other is dedicated for CycleHistogramTreeNodes. This was necessary because these two classes do not share a common polymorphic base.  <a href="classsparta_1_1FunctionManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1FutureStatisticRange.html">FutureStatisticRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception indicating that the range of a <a class="el" href="classsparta_1_1StatisticInstance.html" title="Instance of either a StatisticDef or CounterBase or an Expression. Has a sample window (simulator tic...">StatisticInstance</a> starts or ends in the future (probably caused by to checkpointing)  <a href="classsparta_1_1FutureStatisticRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1GlobalEvent.html">GlobalEvent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type of "global" reusable event.  <a href="classsparta_1_1GlobalEvent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1GlobalEventProxy.html">GlobalEventProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class of <a class="el" href="classsparta_1_1GlobalEvent.html" title="A type of &quot;global&quot; reusable event.">GlobalEvent</a>.  <a href="classsparta_1_1GlobalEventProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1GlobalOrderingPoint.html">GlobalOrderingPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to set precedence between <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">Scheduleable</a> types across simulation.  <a href="classsparta_1_1GlobalOrderingPoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1GlobalTreeNode.html">GlobalTreeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> which represents some "global" namespace of the device tree, containing only RootTreeNodes, for performing searches.  <a href="classsparta_1_1GlobalTreeNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1HistogramBase.html">HistogramBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Histogram base class for uint64_t values.  <a href="classsparta_1_1HistogramBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1HistogramStandalone.html">HistogramStandalone</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1HistogramTreeNode.html">HistogramTreeNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1InPort.html">InPort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all <a class="el" href="classsparta_1_1InPort.html" title="Base class for all InPort types.">InPort</a> types.  <a href="classsparta_1_1InPort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1InstrumentationNode.html">InstrumentationNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class requiring.  <a href="classsparta_1_1InstrumentationNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1IntParameterSet.html">IntParameterSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsparta_1_1is__sparta__enum.html">is_sparta_enum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect whether template parameter is <a class="el" href="classsparta_1_1utils_1_1Enum.html" title="Class that wraps a C++ class enum and allows conversion between POD and the enum type....">sparta::utils::Enum</a> type.  <a href="structsparta_1_1is__sparta__enum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsparta_1_1is__sparta__enum_3_01sparta_1_1utils_1_1Enum_3_01T_01_4_01_4.html">is_sparta_enum&lt; sparta::utils::Enum&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect whether template parameter is <a class="el" href="classsparta_1_1utils_1_1Enum.html" title="Class that wraps a C++ class enum and allows conversion between POD and the enum type....">sparta::utils::Enum</a> type.  <a href="structsparta_1_1is__sparta__enum_3_01sparta_1_1utils_1_1Enum_3_01T_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsparta_1_1is__vector.html">is_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated for determining if ValueType is std::vector for use in metaprogramming constructs. This is intended to be be consumed by enable_if.  <a href="structsparta_1_1is__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsparta_1_1is__vector_3_01std_1_1vector_3_01T_01_4_01_4.html">is_vector&lt; std::vector&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1KeyValue.html">KeyValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type-to-type name map. Not really necessary, but useful.  <a href="classsparta_1_1KeyValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1LineStringStream.html">LineStringStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for building a set of lines through an ostream-like interface.  <a href="classsparta_1_1LineStringStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1MemoryProfiler.html">MemoryProfiler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility used to periodically collect heap usage statistics throughout a simulation. Supported phases for inspection include Build, Configure, Bind, and Simulate.  <a href="classsparta_1_1MemoryProfiler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1MirrorNotificationSource.html">MirrorNotificationSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">essentially a pass through notification source that is a placeholder in a shadow tree.  <a href="classsparta_1_1MirrorNotificationSource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1NotificationSource.html">NotificationSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> that generates a specific type of notification which propagates up a tree of TreeNodes (using the NotificationPropagator base class.  <a href="classsparta_1_1NotificationSource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1NotificationSourceBase.html">NotificationSourceBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> that generates a single specific type of notification which propagates up a tree of TreeNodes using <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>'s builtin functionality.  <a href="classsparta_1_1NotificationSourceBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ObjectAllocator.html">ObjectAllocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1OneWayBool.html">OneWayBool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean with a default capable of being changed to the opposite value only. it can never set to the default even if already at the default value.  <a href="classsparta_1_1OneWayBool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1OutPort.html">OutPort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all <a class="el" href="classsparta_1_1OutPort.html" title="Base class for all OutPort types.">OutPort</a> types.  <a href="classsparta_1_1OutPort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Parameter.html">Parameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> instance, templated to contain only a specific type.  <a href="classsparta_1_1Parameter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterBase.html">ParameterBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-templated base class for generic parameter access and iteration.  <a href="classsparta_1_1ParameterBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterException.html">ParameterException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception indicating a misconfigured <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> or invalid <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> access.  <a href="classsparta_1_1ParameterException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterSet.html">ParameterSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic container of Parameters.  <a href="classsparta_1_1ParameterSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ParameterTree.html">ParameterTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> Tree. This represents a tree of parameters read from some source but does not necessarily correspond to the parameters in the simulation itself or even to the simulation tree. This is meant to provide a hierarchical view into simulation parameters before they are actually applied to a real <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> tree.  <a href="classsparta_1_1ParameterTree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1PayloadEvent.html">PayloadEvent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to schedule a <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">Scheduleable</a> in the future with a payload, typed on both the data type and the scheduling phase. This is the preferred class to use in simulation, but the main API is found in <a class="el" href="classsparta_1_1PhasedPayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, but the class itself is not typed on t...">sparta::PhasedPayloadEvent</a>.  <a href="classsparta_1_1PayloadEvent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1PhasedObject.html">PhasedObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object having a specific phase in the sparta construction paradigm.  <a href="classsparta_1_1PhasedObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1PhasedPayloadEvent.html">PhasedPayloadEvent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to schedule a <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">Scheduleable</a> in the future with a payload, but the class itself is not typed on the phase, but is constructed with one. The preference, however, is for the modeler to use <a class="el" href="classsparta_1_1PayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...">sparta::PayloadEvent</a> instead.  <a href="classsparta_1_1PhasedPayloadEvent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1PhasedSingleCycleUniqueEvent.html">PhasedSingleCycleUniqueEvent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An event that can only be schedule one cycle into the future.  <a href="classsparta_1_1PhasedSingleCycleUniqueEvent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1PhasedUniqueEvent.html">PhasedUniqueEvent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type of <a class="el" href="classsparta_1_1Event.html" title="Event is a simple class for scheduling random events on the Scheduler.">Event</a> that uniquely schedules itself on the schedule within a single time quantum. This <a class="el" href="classsparta_1_1UniqueEvent.html" title="A type of Event that uniquely schedules itself on the schedule within a single time quantum....">UniqueEvent</a> is <em>not</em> typed on the SchedulingPhase. It is discouraged to use this class &ndash; use <a class="el" href="classsparta_1_1UniqueEvent.html" title="A type of Event that uniquely schedules itself on the schedule within a single time quantum....">UniqueEvent</a> templatized on the SchedulingPhase.  <a href="classsparta_1_1PhasedUniqueEvent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Pipe.html">Pipe</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A very simple pipe, not part of the DES paradigm.  <a href="classsparta_1_1Pipe.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Pipeline.html">Pipeline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple pipeline.  <a href="classsparta_1_1Pipeline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Port.html">Port</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The port interface used to bind port types together and defines a port behavior.  <a href="classsparta_1_1Port.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1PortSet.html">PortSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> that represents a set of ports used by a <a class="el" href="classsparta_1_1Resource.html" title="The is the base class for all types of resources used by the SPARTA framework.">Resource</a>.  <a href="classsparta_1_1PortSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1PostRunValidationInfo.html">PostRunValidationInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information describing the type of validation being done.  <a href="classsparta_1_1PostRunValidationInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1PriorityQueue.html">PriorityQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data structure that allows pushing/emplacing into it with a given sorter.  <a href="classsparta_1_1PriorityQueue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsparta_1_1ptr__to__const__obj__ptr.html">ptr_to_const_obj_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template type helper that removes a pointer, adds a const, and then re-adds the pointer. This is useful to turn "T" [T=U*] into "U const *" in places where simply using "const T" results in "U* const".  <a href="structsparta_1_1ptr__to__const__obj__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Queue.html">Queue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data structure that allows appending at the back and invalidating from the front.  <a href="classsparta_1_1Queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ReadOnlyCounter.html">ReadOnlyCounter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a non-writable and non-observable counter with a very similar interface to <a class="el" href="classsparta_1_1Counter.html" title="Represents a counter of type counter_type (uint64_t). 2 and greater than 0 with a ceiling specified....">sparta::Counter</a>. The value of this counter In most cases, a normal counter should be used. However, if a value must be stored as an integer outside of counter for any reason, a ReadOnly counter can be used to wrap that value and expose it to sparta Report and statistics infrastructure.  <a href="classsparta_1_1ReadOnlyCounter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Register.html">Register</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of a <a class="el" href="classsparta_1_1RegisterBase.html" title="Base class to represents an architected register of any size that is a power of 2 and greater than 0 ...">RegisterBase</a>.  <a href="classsparta_1_1Register.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1RegisterBankTable.html">RegisterBankTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container of register banks as a helper for <a class="el" href="classsparta_1_1RegisterSet.html" title="Holds and can create a set of Register objects having various names and groups.">RegisterSet</a>. Instances of this class will be owned by a single <a class="el" href="classsparta_1_1RegisterSet.html" title="Holds and can create a set of Register objects having various names and groups.">RegisterSet</a>.  <a href="classsparta_1_1RegisterBankTable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1RegisterBase.html">RegisterBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class to represents an architected register of any size that is a power of 2 and greater than 0 with a ceiling specified.  <a href="classsparta_1_1RegisterBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1RegisterBits.html">RegisterBits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1RegisterProxy.html">RegisterProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an interface to a pseudo-"Register" of a fixed size which indirectly references other registers (having the same group num, group idx, and size) depending on simulator state. Essentially, this hides banking and register aliasing (shared data) information from the client of this interface which is useful for presenting debugginer-visible and software-visible registers without regard for the underlying banking or aliasing.  <a href="classsparta_1_1RegisterProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1RegisterProxyBase.html">RegisterProxyBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1RegisterSet.html">RegisterSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds and can create a set of <a class="el" href="classsparta_1_1Register.html" title="An implementation of a RegisterBase.">Register</a> objects having various names and groups.  <a href="classsparta_1_1RegisterSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Resource.html">Resource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The is the base class for all types of resources used by the SPARTA framework.  <a href="classsparta_1_1Resource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceContainer.html">ResourceContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1PhasedObject.html" title="Object having a specific phase in the sparta construction paradigm.">PhasedObject</a> which can hold 0 or 1 <a class="el" href="classsparta_1_1Resource.html" title="The is the base class for all types of resources used by the SPARTA framework.">Resource</a> pointers to an associatedresource. Contains logic for setting and getting the associated <a class="el" href="classsparta_1_1Resource.html" title="The is the base class for all types of resources used by the SPARTA framework.">Resource</a>.  <a href="classsparta_1_1ResourceContainer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceFactory.html">ResourceFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated <a class="el" href="classsparta_1_1ResourceFactoryBase.html" title="Factory which can create Resources as well as the Parameter sets that can be modified before actually...">ResourceFactoryBase</a> implementation which can be used to trivially define <a class="el" href="classsparta_1_1Resource.html" title="The is the base class for all types of resources used by the SPARTA framework.">Resource</a> Factories.  <a href="classsparta_1_1ResourceFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceFactoryBase.html">ResourceFactoryBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory which can create Resources as well as the <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> sets that can be modified before actually instantiating the resources themselves. Packages providing resources to the simulator implement this interface.  <a href="classsparta_1_1ResourceFactoryBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceSet.html">ResourceSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of published ResourceFactories which can be referenced by name.  <a href="classsparta_1_1ResourceSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ResourceTreeNode.html">ResourceTreeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> subclass representing a node in the device tree which contains a single <a class="el" href="classsparta_1_1ResourceFactory.html" title="Templated ResourceFactoryBase implementation which can be used to trivially define Resource Factories...">ResourceFactory</a> and a <a class="el" href="classsparta_1_1ParameterSet.html" title="Generic container of Parameters.">sparta::ParameterSet</a>. A <a class="el" href="classsparta_1_1ResourceTreeNode.html" title="TreeNode subclass representing a node in the device tree which contains a single ResourceFactory and ...">ResourceTreeNode</a> is also associated with a clock.  <a href="classsparta_1_1ResourceTreeNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ReversedStatisticRange.html">ReversedStatisticRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception indicating that the range of a <a class="el" href="classsparta_1_1StatisticInstance.html" title="Instance of either a StatisticDef or CounterBase or an Expression. Has a sample window (simulator tic...">StatisticInstance</a> was reversed when it was accessed (probably caused by checkpointing)  <a href="classsparta_1_1ReversedStatisticRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1RootTreeNode.html">RootTreeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> which represents the root ("top") of a device tree.  <a href="classsparta_1_1RootTreeNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Scheduleable.html">Scheduleable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that defines the basic scheduling interface to the <a class="el" href="classsparta_1_1Scheduler.html" title="A class that lets you schedule events now and in the future.">Scheduler</a>. Not intended to be used by modelers directly, but certainly can be.  <a href="classsparta_1_1Scheduleable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ScheduleableHandle.html">ScheduleableHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A light-weight reference counting handle for Scheduleables &ndash; DOES NOT delete.  <a href="classsparta_1_1ScheduleableHandle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Scheduler.html">Scheduler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that lets you schedule events now and in the future.  <a href="classsparta_1_1Scheduler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Scoreboard.html">Scoreboard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class used to track operand dependencies (timed) between units.  <a href="classsparta_1_1Scoreboard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ScoreboardView.html">ScoreboardView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classsparta_1_1ScoreboardView.html" title="A ScoreboardView is a view into the master Scoreboard for operand readiness.">ScoreboardView</a> is a view into the master <a class="el" href="classsparta_1_1Scoreboard.html" title="Class used to track operand dependencies (timed) between units.">Scoreboard</a> for operand readiness.  <a href="classsparta_1_1ScoreboardView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1SharedData.html">SharedData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that allows the writing of data <b>this</b> cycle, but not visable until <b>next</b> cycle.  <a href="classsparta_1_1SharedData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1SignalInPort.html">SignalInPort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1SignalInPort.html" title="SignalInPort receives data from sender using a SignalOutPort.">SignalInPort</a> receives data from sender using a <a class="el" href="classsparta_1_1SignalOutPort.html" title="SignalOutPort is used for transferring a simple signal to another module.">SignalOutPort</a>.  <a href="classsparta_1_1SignalInPort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1SignalOutPort.html">SignalOutPort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1SignalOutPort.html" title="SignalOutPort is used for transferring a simple signal to another module.">SignalOutPort</a> is used for transferring a simple signal to another module.  <a href="classsparta_1_1SignalOutPort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1SimulationInfo.html">SimulationInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains information describing the simulation instance for the purpose of identifying the simulation and possible recreating it. This information should be written to all log files, reports, cmdline, etc.  <a href="classsparta_1_1SimulationInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html">SingleCycleUniqueEvent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An event that can only be schedule one cycle into the future.  <a href="classsparta_1_1SingleCycleUniqueEvent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1SpartaCriticalError.html">SpartaCriticalError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates something went seriously wrong and likely indicates corruption in simulator runtime state.  <a href="classsparta_1_1SpartaCriticalError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1SpartaException.html">SpartaException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to construct and throw a standard C++ exception. Inherits from std::exception.  <a href="classsparta_1_1SpartaException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1SpartaFatalError.html">SpartaFatalError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates something went seriously wrong and likely indicates unrecoverable corruption in simulator runtime state or misuse. This is the only exception that should ever be generated by a destructor since its semantics are that the simulation should terminate.  <a href="classsparta_1_1SpartaFatalError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1SpartaSharedPointer.html">SpartaSharedPointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for garbage collection, will delete the object it points to when all objects are finished using it.  <a href="classsparta_1_1SpartaSharedPointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1SpartaSharedPointerAllocator.html">SpartaSharedPointerAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A memory allocator complementing <a class="el" href="classsparta_1_1SpartaSharedPointer.html" title="Used for garbage collection, will delete the object it points to when all objects are finished using ...">SpartaSharedPointer</a> that reuses old memory.  <a href="classsparta_1_1SpartaSharedPointerAllocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1SpartaStaticInitializer.html">SpartaStaticInitializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static-initialization order controller.  <a href="classsparta_1_1SpartaStaticInitializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1SpartaTester.html">SpartaTester</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple testing class.  <a href="classsparta_1_1SpartaTester.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1SpartaWeakPointer.html">SpartaWeakPointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like in STL, create a weak pointer to a <a class="el" href="classsparta_1_1SpartaSharedPointer.html" title="Used for garbage collection, will delete the object it points to when all objects are finished using ...">SpartaSharedPointer</a>.  <a href="classsparta_1_1SpartaWeakPointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1StartupEvent.html">StartupEvent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1StartupEvent.html" title="StartupEvent is a simple class for scheduling a starting event on the Scheduler. It does not support ...">StartupEvent</a> is a simple class for scheduling a starting event on the <a class="el" href="classsparta_1_1Scheduler.html" title="A class that lets you schedule events now and in the future.">Scheduler</a>. It does not support precedence.  <a href="classsparta_1_1StartupEvent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1State.html">State</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classsparta_1_1State.html" title="The State class for watching transition between enum states.">State</a> class for watching transition between enum states.  <a href="classsparta_1_1State.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1State_3_01T_00_01typename_01std_1_1enable__if_3_01std_1_1is__same_3_01T_00_01Phascd75c55a6e869d9876163fe09c3af8e1.html">State&lt; T, typename std::enable_if&lt; std::is_same&lt; T, PhasedObject::TreePhase &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1StateHistogram.html">StateHistogram</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1StateHistogram.html" title="StateHistogram class for uint64_t values.">StateHistogram</a> class for uint64_t values.  <a href="classsparta_1_1StateHistogram.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1StateTimerUnit.html">StateTimerUnit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A high level wrapper contains the StateTimerPool and StateTimerHistogram.  <a href="classsparta_1_1StateTimerUnit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1StatInstCalculator.html">StatInstCalculator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1StatisticDef.html">StatisticDef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains a statistic definition (some useful information which can be computed)  <a href="classsparta_1_1StatisticDef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1StatisticInstance.html">StatisticInstance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instance of either a <a class="el" href="classsparta_1_1StatisticDef.html" title="Contains a statistic definition (some useful information which can be computed)">StatisticDef</a> or <a class="el" href="classsparta_1_1CounterBase.html" title="The base class for all Counters.">CounterBase</a> or an Expression. Has a sample window (simulator ticks) over which it will compute the value of the contained expression/counter for that range.  <a href="classsparta_1_1StatisticInstance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1StatisticSet.html">StatisticSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of <a class="el" href="classsparta_1_1StatisticDef.html" title="Contains a statistic definition (some useful information which can be computed)">StatisticDef</a> and CounterBase-derived objects for visiblility through a sparta Tree.  <a href="classsparta_1_1StatisticSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1StringManager.html">StringManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages string internment for SPARTA. This allows strings to be compared by pointer once interned.  <a href="classsparta_1_1StringManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1SyncInPort.html">SyncInPort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that defines an synchronized input port on modules on two different clocks.  <a href="classsparta_1_1SyncInPort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1SyncOutPort.html">SyncOutPort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that defines a synchronized <a class="el" href="classsparta_1_1SyncOutPort.html" title="Class that defines a synchronized SyncOutPort for data writes on different clocks.">SyncOutPort</a> for data writes on different clocks.  <a href="classsparta_1_1SyncOutPort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1SysCSpartaSchedulerAdapter.html">SysCSpartaSchedulerAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that "connects" Sparta to SystemC.  <a href="classsparta_1_1SysCSpartaSchedulerAdapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Tag.html">Tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1Tag.html#ad7d593862ab37955185d998b1a715a74" title="Tag(): Constructor Construct a new tag, using the internal global sequence number.">Tag()</a>: Simple class to provide nested sequence numbering.  <a href="classsparta_1_1Tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TieredMap.html">TieredMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">N-Tier lookup map for sparse-representation of large memory spaces. This is essentially a M-Tree where the child lookup at each node is a simple offset computed by a rshift and mask.  <a href="classsparta_1_1TieredMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TimeManager.html">TimeManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singleton which manages wall-clock time for simulations in SPARTA This is not a "timer" manager, but rather an information service and could possible become a timing interval manager.  <a href="classsparta_1_1TimeManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNode.html">TreeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node in a composite tree representing a sparta Tree item.  <a href="classsparta_1_1TreeNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1TreeNodePrivateAttorney.html">TreeNodePrivateAttorney</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1UniqueEvent.html">UniqueEvent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type of <a class="el" href="classsparta_1_1Event.html" title="Event is a simple class for scheduling random events on the Scheduler.">Event</a> that uniquely schedules itself on the schedule within a single time quantum. This class is typed on the SchedulingPhase and is the preferred type to use for <a class="el" href="classsparta_1_1UniqueEvent.html" title="A type of Event that uniquely schedules itself on the schedule within a single time quantum....">UniqueEvent</a> use, but the main API is found in <a class="el" href="classsparta_1_1PhasedUniqueEvent.html" title="A type of Event that uniquely schedules itself on the schedule within a single time quantum....">PhasedUniqueEvent</a>.  <a href="classsparta_1_1UniqueEvent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1Unit.html">Unit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The is the base class for user defined blocks in simulation.  <a href="classsparta_1_1Unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1ValidationCheckCallback.html">ValidationCheckCallback</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delegate for <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">Parameter</a> validation.  <a href="classsparta_1_1ValidationCheckCallback.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1VirtualGlobalTreeNode.html">VirtualGlobalTreeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual global node for all device trees in a single simulation. This node acts a potential notification observation point for every node in the simulation regardless hierarchy.  <a href="classsparta_1_1VirtualGlobalTreeNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1WeightedContextCounter.html">WeightedContextCounter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an example context counter subclass used to show how users may supply their own "aggregated value calculation" method via the REGISTER_CONTEXT_COUNTER_AGGREGATE_FCN macro.  <a href="classsparta_1_1WeightedContextCounter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3b31ac5bb01e672a2e86c64e844fc5f0" id="r_a3b31ac5bb01e672a2e86c64e844fc5f0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b31ac5bb01e672a2e86c64e844fc5f0">RegisterDefinitionSet</a></td></tr>
<tr class="separator:a3b31ac5bb01e672a2e86c64e844fc5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46be989638b09a61b66440720d285290" id="r_a46be989638b09a61b66440720d285290"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46be989638b09a61b66440720d285290">ProxyDefinitionSet</a></td></tr>
<tr class="separator:a46be989638b09a61b66440720d285290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f2b856793ff477c6bc5812972dd7e2" id="r_a82f2b856793ff477c6bc5812972dd7e2"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; std::unordered_map&lt; uint32_t, std::vector&lt; sparta::Clock::Cycle &gt; * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82f2b856793ff477c6bc5812972dd7e2">StateTimerDataContainerPtr</a></td></tr>
<tr class="separator:a82f2b856793ff477c6bc5812972dd7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31317083691763b0ea542fe5af014293" id="r_a31317083691763b0ea542fe5af014293"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31317083691763b0ea542fe5af014293">CycleHistogram</a> = <a class="el" href="classsparta_1_1CycleHistogramTreeNode.html">CycleHistogramTreeNode</a></td></tr>
<tr class="separator:a31317083691763b0ea542fe5af014293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc8aa73e74af356fa9ce2071faa5b0e" id="r_abbc8aa73e74af356fa9ce2071faa5b0e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classsparta_1_1HistogramTreeNode.html">HistogramTreeNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbc8aa73e74af356fa9ce2071faa5b0e">Histogram</a></td></tr>
<tr class="separator:abbc8aa73e74af356fa9ce2071faa5b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd097dc2b5ef707ef5837ede254ce24" id="r_a3cd097dc2b5ef707ef5837ede254ce24"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3cd097dc2b5ef707ef5837ede254ce24"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3cd097dc2b5ef707ef5837ede254ce24">HistStatCalcFcn</a> = double (*)(const T*)</td></tr>
<tr class="separator:a3cd097dc2b5ef707ef5837ede254ce24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aeec80d237ace9f07634c3d24c9aed9a0" id="r_aeec80d237ace9f07634c3d24c9aed9a0"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> { <br />
&#160;&#160;<a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0a06933067aafd48425d67bcb01bba5cb6">Update</a>
, <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0a07c70f002c020dbbf271b086039983ee">PortUpdate</a>
, <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0a75f33789f924a80667bcdf8e195c1a1d">Flush</a>
, <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0ad15b505cce09406de9f918cb1f8c641c">Collection</a>
, <br />
&#160;&#160;<a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0a0b3516a5bbb77566f904f9d3877f4710">Tick</a>
, <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0aa98a2c3f64967bd2d16be0f1700e2793">PostTick</a>
<br />
 }</td></tr>
<tr class="memdesc:aeec80d237ace9f07634c3d24c9aed9a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SchedulingPhases used for events (Tick, Update, PortUpdate, etc)  <a href="#aeec80d237ace9f07634c3d24c9aed9a0">More...</a><br /></td></tr>
<tr class="separator:aeec80d237ace9f07634c3d24c9aed9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c04c9473be440ddcb25c2294fe90ec3" id="r_a2c04c9473be440ddcb25c2294fe90ec3"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c04c9473be440ddcb25c2294fe90ec3">ArrayType</a> { <a class="el" href="#a2c04c9473be440ddcb25c2294fe90ec3a1e23852820b9154316c7c06e2b7ba051">NORMAL</a>
, <a class="el" href="#a2c04c9473be440ddcb25c2294fe90ec3a97be62eb080a8b5fcc3f3f06a80a6cc7">AGED</a>
 }</td></tr>
<tr class="memdesc:a2c04c9473be440ddcb25c2294fe90ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines how a <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">sparta::Array</a> should behave. The array will have different features depending on the type.  <a href="#a2c04c9473be440ddcb25c2294fe90ec3">More...</a><br /></td></tr>
<tr class="separator:a2c04c9473be440ddcb25c2294fe90ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3e7ddb8e5c54811105c5ab61112a5b" id="r_afc3e7ddb8e5c54811105c5ab61112a5b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc3e7ddb8e5c54811105c5ab61112a5b">ByteOrder</a> { <b>LE</b> = 0
, <a class="el" href="#afc3e7ddb8e5c54811105c5ab61112a5bae6d6457742b40b16092846e8e785f3ba">BE</a> = 1
 }</td></tr>
<tr class="memdesc:afc3e7ddb8e5c54811105c5ab61112a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte order enum for read/write methods.  <a href="#afc3e7ddb8e5c54811105c5ab61112a5b">More...</a><br /></td></tr>
<tr class="separator:afc3e7ddb8e5c54811105c5ab61112a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1be764ebc8eb8aa6927969df96a8a98b" id="r_a1be764ebc8eb8aa6927969df96a8a98b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1be764ebc8eb8aa6927969df96a8a98b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; T, <a class="el" href="classsparta_1_1app_1_1FeatureConfiguration.html">app::FeatureConfiguration</a> &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1be764ebc8eb8aa6927969df96a8a98b">IsFeatureValueEqualTo</a> (const T &amp;cfg, const std::string &amp;feature_name, const unsigned int feature_value)</td></tr>
<tr class="separator:a1be764ebc8eb8aa6927969df96a8a98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3415f00abe48816ec2f28eb2507539" id="r_a6a3415f00abe48816ec2f28eb2507539"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6a3415f00abe48816ec2f28eb2507539"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structMetaStruct_1_1is__any__pointer.html">MetaStruct::is_any_pointer</a>&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6a3415f00abe48816ec2f28eb2507539">IsFeatureValueEqualTo</a> (const T &amp;cfg, const std::string &amp;feature_name, const unsigned int feature_value)</td></tr>
<tr class="separator:a6a3415f00abe48816ec2f28eb2507539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a63fdacb399754c6ceb02f4273c119" id="r_af5a63fdacb399754c6ceb02f4273c119"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af5a63fdacb399754c6ceb02f4273c119"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; T, <a class="el" href="classsparta_1_1app_1_1FeatureConfiguration.html">app::FeatureConfiguration</a> &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af5a63fdacb399754c6ceb02f4273c119">IsFeatureValueEnabled</a> (const T &amp;cfg, const std::string &amp;feature_name)</td></tr>
<tr class="separator:af5a63fdacb399754c6ceb02f4273c119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61273cc42cec96de6d2bf39a79d96055" id="r_a61273cc42cec96de6d2bf39a79d96055"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a61273cc42cec96de6d2bf39a79d96055"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structMetaStruct_1_1is__any__pointer.html">MetaStruct::is_any_pointer</a>&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a61273cc42cec96de6d2bf39a79d96055">IsFeatureValueEnabled</a> (const T &amp;cfg, const std::string &amp;feature_name)</td></tr>
<tr class="separator:a61273cc42cec96de6d2bf39a79d96055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00e205d913fa86f8cfc54f60819c63b" id="r_aa00e205d913fa86f8cfc54f60819c63b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa00e205d913fa86f8cfc54f60819c63b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; T, <a class="el" href="classsparta_1_1app_1_1FeatureConfiguration.html">app::FeatureConfiguration</a> &gt;::value, constapp::FeatureConfiguration::FeatureOptions * &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa00e205d913fa86f8cfc54f60819c63b">GetFeatureOptions</a> (const T &amp;cfg, const std::string &amp;feature_name)</td></tr>
<tr class="separator:aa00e205d913fa86f8cfc54f60819c63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeffd5171f220fcc45b2c82f8bc498fcd" id="r_aeffd5171f220fcc45b2c82f8bc498fcd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeffd5171f220fcc45b2c82f8bc498fcd"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structMetaStruct_1_1is__any__pointer.html">MetaStruct::is_any_pointer</a>&lt; T &gt;::value, constapp::FeatureConfiguration::FeatureOptions * &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aeffd5171f220fcc45b2c82f8bc498fcd">GetFeatureOptions</a> (const T &amp;cfg, const std::string &amp;feature_name)</td></tr>
<tr class="separator:aeffd5171f220fcc45b2c82f8bc498fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfecbf1a2ff93a528d26a85ec371916d" id="r_abfecbf1a2ff93a528d26a85ec371916d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfecbf1a2ff93a528d26a85ec371916d">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classsparta_1_1SimulationInfo.html">SimulationInfo</a> &amp;info)</td></tr>
<tr class="memdesc:abfecbf1a2ff93a528d26a85ec371916d"><td class="mdescLeft">&#160;</td><td class="mdescRight">ostream insertion operator for <a class="el" href="classsparta_1_1SimulationInfo.html" title="Contains information describing the simulation instance for the purpose of identifying the simulation...">SimulationInfo</a>  <br /></td></tr>
<tr class="separator:abfecbf1a2ff93a528d26a85ec371916d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7059a71a007a55c76350eab5b78e2822" id="r_a7059a71a007a55c76350eab5b78e2822"><td class="memTemplParams" colspan="2">template&lt;class ScheduleableTypeA &gt; </td></tr>
<tr class="memitem:a7059a71a007a55c76350eab5b78e2822"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="classsparta_1_1EventNode.html">EventNode</a>, ScheduleableTypeA &gt;::value, constGlobalOrderingPoint &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7059a71a007a55c76350eab5b78e2822">operator&gt;&gt;</a> (ScheduleableTypeA &amp;producer, const <a class="el" href="classsparta_1_1GlobalOrderingPoint.html">GlobalOrderingPoint</a> &amp;consumer)</td></tr>
<tr class="memdesc:a7059a71a007a55c76350eab5b78e2822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a precedence between a <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">Scheduleable</a> object and a <a class="el" href="classsparta_1_1GlobalOrderingPoint.html" title="Used to set precedence between Scheduleable types across simulation.">GlobalOrderingPoint</a>.  <br /></td></tr>
<tr class="separator:a7059a71a007a55c76350eab5b78e2822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716207ad3fb6cdea775ec5a6b181d0b2" id="r_a716207ad3fb6cdea775ec5a6b181d0b2"><td class="memTemplParams" colspan="2">template&lt;class ScheduleableTypeA &gt; </td></tr>
<tr class="memitem:a716207ad3fb6cdea775ec5a6b181d0b2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="classsparta_1_1EventNode.html">EventNode</a>, ScheduleableTypeA &gt;::value, ScheduleableTypeA &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a716207ad3fb6cdea775ec5a6b181d0b2">operator&gt;&gt;</a> (const <a class="el" href="classsparta_1_1GlobalOrderingPoint.html">GlobalOrderingPoint</a> &amp;producer, ScheduleableTypeA &amp;consumer)</td></tr>
<tr class="memdesc:a716207ad3fb6cdea775ec5a6b181d0b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a precedence between a <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">Scheduleable</a> object and a <a class="el" href="classsparta_1_1GlobalOrderingPoint.html" title="Used to set precedence between Scheduleable types across simulation.">GlobalOrderingPoint</a>.  <br /></td></tr>
<tr class="separator:a716207ad3fb6cdea775ec5a6b181d0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c19896e74f3787f5854d521b69ee3e" id="r_a31c19896e74f3787f5854d521b69ee3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1InPort.html">InPort</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31c19896e74f3787f5854d521b69ee3e">operator&gt;&gt;</a> (const <a class="el" href="classsparta_1_1GlobalOrderingPoint.html">GlobalOrderingPoint</a> &amp;producer, <a class="el" href="classsparta_1_1InPort.html">InPort</a> &amp;consumer)</td></tr>
<tr class="memdesc:a31c19896e74f3787f5854d521b69ee3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a precedence between a <a class="el" href="classsparta_1_1GlobalOrderingPoint.html" title="Used to set precedence between Scheduleable types across simulation.">GlobalOrderingPoint</a> and an <a class="el" href="classsparta_1_1InPort.html" title="Base class for all InPort types.">InPort</a>.  <br /></td></tr>
<tr class="separator:a31c19896e74f3787f5854d521b69ee3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df9e497fcaa24cc149016ded4b9b371" id="r_a4df9e497fcaa24cc149016ded4b9b371"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsparta_1_1GlobalOrderingPoint.html">GlobalOrderingPoint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4df9e497fcaa24cc149016ded4b9b371">operator&gt;&gt;</a> (<a class="el" href="classsparta_1_1InPort.html">InPort</a> &amp;producer, const <a class="el" href="classsparta_1_1GlobalOrderingPoint.html">GlobalOrderingPoint</a> &amp;consumer)</td></tr>
<tr class="memdesc:a4df9e497fcaa24cc149016ded4b9b371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a precedence between a <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">Scheduleable</a> object and a <a class="el" href="classsparta_1_1GlobalOrderingPoint.html" title="Used to set precedence between Scheduleable types across simulation.">GlobalOrderingPoint</a>.  <br /></td></tr>
<tr class="separator:a4df9e497fcaa24cc149016ded4b9b371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88753996384613e1376e772cf78163e7" id="r_a88753996384613e1376e772cf78163e7"><td class="memTemplParams" colspan="2">template&lt;class DataT1 , <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT1, class DataT2 , <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT2&gt; </td></tr>
<tr class="memitem:a88753996384613e1376e772cf78163e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1PayloadEvent.html">PayloadEvent</a>&lt; DataT2, PayloadPhaseT2 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a88753996384613e1376e772cf78163e7">operator&gt;&gt;</a> (<a class="el" href="classsparta_1_1PayloadEvent.html">PayloadEvent</a>&lt; DataT1, PayloadPhaseT1 &gt; &amp;producer, <a class="el" href="classsparta_1_1PayloadEvent.html">PayloadEvent</a>&lt; DataT2, PayloadPhaseT2 &gt; &amp;consumer)</td></tr>
<tr class="memdesc:a88753996384613e1376e772cf78163e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a precedence between a <a class="el" href="classsparta_1_1PayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...">PayloadEvent</a> and another <a class="el" href="classsparta_1_1PayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...">PayloadEvent</a>.  <br /></td></tr>
<tr class="separator:a88753996384613e1376e772cf78163e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8ac305a796c13d990aedbce9c402dc" id="r_adf8ac305a796c13d990aedbce9c402dc"><td class="memTemplParams" colspan="2">template&lt;class DataT1 , <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT1, <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT2&gt; </td></tr>
<tr class="memitem:adf8ac305a796c13d990aedbce9c402dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1UniqueEvent.html">UniqueEvent</a>&lt; PayloadPhaseT2 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adf8ac305a796c13d990aedbce9c402dc">operator&gt;&gt;</a> (<a class="el" href="classsparta_1_1PayloadEvent.html">PayloadEvent</a>&lt; DataT1, PayloadPhaseT1 &gt; &amp;producer, <a class="el" href="classsparta_1_1UniqueEvent.html">UniqueEvent</a>&lt; PayloadPhaseT2 &gt; &amp;consumer)</td></tr>
<tr class="memdesc:adf8ac305a796c13d990aedbce9c402dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a precedence between a <a class="el" href="classsparta_1_1PayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...">PayloadEvent</a> and <a class="el" href="classsparta_1_1UniqueEvent.html" title="A type of Event that uniquely schedules itself on the schedule within a single time quantum....">UniqueEvent</a>.  <br /></td></tr>
<tr class="separator:adf8ac305a796c13d990aedbce9c402dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6813ebf9470d3984edd2686563abc335" id="r_a6813ebf9470d3984edd2686563abc335"><td class="memTemplParams" colspan="2">template&lt;class DataT1 , <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT1, <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT2&gt; </td></tr>
<tr class="memitem:a6813ebf9470d3984edd2686563abc335"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html">SingleCycleUniqueEvent</a>&lt; PayloadPhaseT2 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6813ebf9470d3984edd2686563abc335">operator&gt;&gt;</a> (<a class="el" href="classsparta_1_1PayloadEvent.html">PayloadEvent</a>&lt; DataT1, PayloadPhaseT1 &gt; &amp;producer, <a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html">SingleCycleUniqueEvent</a>&lt; PayloadPhaseT2 &gt; &amp;consumer)</td></tr>
<tr class="memdesc:a6813ebf9470d3984edd2686563abc335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a precedence between a <a class="el" href="classsparta_1_1PayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...">PayloadEvent</a> and <a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html" title="An event that can only be schedule one cycle into the future.">SingleCycleUniqueEvent</a>.  <br /></td></tr>
<tr class="separator:a6813ebf9470d3984edd2686563abc335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a796a23bb60f5e3686ce021d4a0fb84cf" id="r_a796a23bb60f5e3686ce021d4a0fb84cf"><td class="memTemplParams" colspan="2">template&lt;class DataT1 , <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT1, <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT2&gt; </td></tr>
<tr class="memitem:a796a23bb60f5e3686ce021d4a0fb84cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Event.html">Event</a>&lt; PayloadPhaseT2 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a796a23bb60f5e3686ce021d4a0fb84cf">operator&gt;&gt;</a> (<a class="el" href="classsparta_1_1PayloadEvent.html">PayloadEvent</a>&lt; DataT1, PayloadPhaseT1 &gt; &amp;producer, <a class="el" href="classsparta_1_1Event.html">Event</a>&lt; PayloadPhaseT2 &gt; &amp;consumer)</td></tr>
<tr class="memdesc:a796a23bb60f5e3686ce021d4a0fb84cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a precedence between a <a class="el" href="classsparta_1_1PayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...">PayloadEvent</a> and an <a class="el" href="classsparta_1_1Event.html" title="Event is a simple class for scheduling random events on the Scheduler.">Event</a>.  <br /></td></tr>
<tr class="separator:a796a23bb60f5e3686ce021d4a0fb84cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d25aa7a5045f86ad433dd673586dea2" id="r_a4d25aa7a5045f86ad433dd673586dea2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT1, class DataT2 , <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT2&gt; </td></tr>
<tr class="memitem:a4d25aa7a5045f86ad433dd673586dea2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1PayloadEvent.html">PayloadEvent</a>&lt; DataT2, PayloadPhaseT2 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4d25aa7a5045f86ad433dd673586dea2">operator&gt;&gt;</a> (<a class="el" href="classsparta_1_1UniqueEvent.html">UniqueEvent</a>&lt; PayloadPhaseT1 &gt; &amp;producer, <a class="el" href="classsparta_1_1PayloadEvent.html">PayloadEvent</a>&lt; DataT2, PayloadPhaseT2 &gt; &amp;consumer)</td></tr>
<tr class="memdesc:a4d25aa7a5045f86ad433dd673586dea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a precedence between a <a class="el" href="classsparta_1_1PayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...">PayloadEvent</a> and an <a class="el" href="classsparta_1_1UniqueEvent.html" title="A type of Event that uniquely schedules itself on the schedule within a single time quantum....">UniqueEvent</a>.  <br /></td></tr>
<tr class="separator:a4d25aa7a5045f86ad433dd673586dea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf04f92023ad53fa82d126bbe8ed9d4" id="r_a8bf04f92023ad53fa82d126bbe8ed9d4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT1, class DataT2 , <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT2&gt; </td></tr>
<tr class="memitem:a8bf04f92023ad53fa82d126bbe8ed9d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1PayloadEvent.html">PayloadEvent</a>&lt; DataT2, PayloadPhaseT2 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8bf04f92023ad53fa82d126bbe8ed9d4">operator&gt;&gt;</a> (<a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html">SingleCycleUniqueEvent</a>&lt; PayloadPhaseT1 &gt; &amp;producer, <a class="el" href="classsparta_1_1PayloadEvent.html">PayloadEvent</a>&lt; DataT2, PayloadPhaseT2 &gt; &amp;consumer)</td></tr>
<tr class="memdesc:a8bf04f92023ad53fa82d126bbe8ed9d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a precedence between a <a class="el" href="classsparta_1_1PayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...">PayloadEvent</a> and an <a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html" title="An event that can only be schedule one cycle into the future.">SingleCycleUniqueEvent</a>.  <br /></td></tr>
<tr class="separator:a8bf04f92023ad53fa82d126bbe8ed9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9145a844e641be88ec0ef7987294092c" id="r_a9145a844e641be88ec0ef7987294092c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT1, class DataT2 , <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT2&gt; </td></tr>
<tr class="memitem:a9145a844e641be88ec0ef7987294092c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1PayloadEvent.html">PayloadEvent</a>&lt; DataT2, PayloadPhaseT2 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9145a844e641be88ec0ef7987294092c">operator&gt;&gt;</a> (<a class="el" href="classsparta_1_1Event.html">Event</a>&lt; PayloadPhaseT1 &gt; &amp;producer, <a class="el" href="classsparta_1_1PayloadEvent.html">PayloadEvent</a>&lt; DataT2, PayloadPhaseT2 &gt; &amp;consumer)</td></tr>
<tr class="memdesc:a9145a844e641be88ec0ef7987294092c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a precedence between a <a class="el" href="classsparta_1_1Event.html" title="Event is a simple class for scheduling random events on the Scheduler.">Event</a> and an <a class="el" href="classsparta_1_1PayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...">PayloadEvent</a>.  <br /></td></tr>
<tr class="separator:a9145a844e641be88ec0ef7987294092c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02f6b8a64f7b1e8e7ff25f3d78dabd8" id="r_ab02f6b8a64f7b1e8e7ff25f3d78dabd8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT1, <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT2&gt; </td></tr>
<tr class="memitem:ab02f6b8a64f7b1e8e7ff25f3d78dabd8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1UniqueEvent.html">UniqueEvent</a>&lt; PayloadPhaseT2 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab02f6b8a64f7b1e8e7ff25f3d78dabd8">operator&gt;&gt;</a> (<a class="el" href="classsparta_1_1UniqueEvent.html">UniqueEvent</a>&lt; PayloadPhaseT1 &gt; &amp;producer, <a class="el" href="classsparta_1_1UniqueEvent.html">UniqueEvent</a>&lt; PayloadPhaseT2 &gt; &amp;consumer)</td></tr>
<tr class="memdesc:ab02f6b8a64f7b1e8e7ff25f3d78dabd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a precedence between a <a class="el" href="classsparta_1_1UniqueEvent.html" title="A type of Event that uniquely schedules itself on the schedule within a single time quantum....">UniqueEvent</a> and an <a class="el" href="classsparta_1_1UniqueEvent.html" title="A type of Event that uniquely schedules itself on the schedule within a single time quantum....">UniqueEvent</a>.  <br /></td></tr>
<tr class="separator:ab02f6b8a64f7b1e8e7ff25f3d78dabd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f295b2cf0f4cec80b27714ab48be2b7" id="r_a4f295b2cf0f4cec80b27714ab48be2b7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT1, <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT2&gt; </td></tr>
<tr class="memitem:a4f295b2cf0f4cec80b27714ab48be2b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html">SingleCycleUniqueEvent</a>&lt; PayloadPhaseT2 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4f295b2cf0f4cec80b27714ab48be2b7">operator&gt;&gt;</a> (<a class="el" href="classsparta_1_1UniqueEvent.html">UniqueEvent</a>&lt; PayloadPhaseT1 &gt; &amp;producer, <a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html">SingleCycleUniqueEvent</a>&lt; PayloadPhaseT2 &gt; &amp;consumer)</td></tr>
<tr class="memdesc:a4f295b2cf0f4cec80b27714ab48be2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a precedence between a <a class="el" href="classsparta_1_1UniqueEvent.html" title="A type of Event that uniquely schedules itself on the schedule within a single time quantum....">UniqueEvent</a> and an <a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html" title="An event that can only be schedule one cycle into the future.">SingleCycleUniqueEvent</a>.  <br /></td></tr>
<tr class="separator:a4f295b2cf0f4cec80b27714ab48be2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6896b1c71d6ba7dab7dccf7eebc892e6" id="r_a6896b1c71d6ba7dab7dccf7eebc892e6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT1, <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT2&gt; </td></tr>
<tr class="memitem:a6896b1c71d6ba7dab7dccf7eebc892e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1UniqueEvent.html">UniqueEvent</a>&lt; PayloadPhaseT2 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6896b1c71d6ba7dab7dccf7eebc892e6">operator&gt;&gt;</a> (<a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html">SingleCycleUniqueEvent</a>&lt; PayloadPhaseT1 &gt; &amp;producer, <a class="el" href="classsparta_1_1UniqueEvent.html">UniqueEvent</a>&lt; PayloadPhaseT2 &gt; &amp;consumer)</td></tr>
<tr class="memdesc:a6896b1c71d6ba7dab7dccf7eebc892e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a precedence between a <a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html" title="An event that can only be schedule one cycle into the future.">SingleCycleUniqueEvent</a> and an <a class="el" href="classsparta_1_1UniqueEvent.html" title="A type of Event that uniquely schedules itself on the schedule within a single time quantum....">UniqueEvent</a>.  <br /></td></tr>
<tr class="separator:a6896b1c71d6ba7dab7dccf7eebc892e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2830d90f0bbaaa445a29d896e038c0" id="r_a4f2830d90f0bbaaa445a29d896e038c0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PhaseT1, <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PhaseT2&gt; </td></tr>
<tr class="memitem:a4f2830d90f0bbaaa445a29d896e038c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html">SingleCycleUniqueEvent</a>&lt; PhaseT2 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4f2830d90f0bbaaa445a29d896e038c0">operator&gt;&gt;</a> (<a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html">SingleCycleUniqueEvent</a>&lt; PhaseT1 &gt; &amp;producer, <a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html">SingleCycleUniqueEvent</a>&lt; PhaseT2 &gt; &amp;consumer)</td></tr>
<tr class="memdesc:a4f2830d90f0bbaaa445a29d896e038c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a precedence between a <a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html" title="An event that can only be schedule one cycle into the future.">SingleCycleUniqueEvent</a> and a <a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html" title="An event that can only be schedule one cycle into the future.">SingleCycleUniqueEvent</a>.  <br /></td></tr>
<tr class="separator:a4f2830d90f0bbaaa445a29d896e038c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e3c5b2b89f50f7310a24f07b963f47" id="r_a86e3c5b2b89f50f7310a24f07b963f47"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PhaseT1, <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PhaseT2&gt; </td></tr>
<tr class="memitem:a86e3c5b2b89f50f7310a24f07b963f47"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Event.html">Event</a>&lt; PhaseT2 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a86e3c5b2b89f50f7310a24f07b963f47">operator&gt;&gt;</a> (<a class="el" href="classsparta_1_1Event.html">Event</a>&lt; PhaseT1 &gt; &amp;producer, <a class="el" href="classsparta_1_1Event.html">Event</a>&lt; PhaseT2 &gt; &amp;consumer)</td></tr>
<tr class="memdesc:a86e3c5b2b89f50f7310a24f07b963f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a precedence between a <a class="el" href="classsparta_1_1Event.html" title="Event is a simple class for scheduling random events on the Scheduler.">Event</a> and another <a class="el" href="classsparta_1_1Event.html" title="Event is a simple class for scheduling random events on the Scheduler.">Event</a>.  <br /></td></tr>
<tr class="separator:a86e3c5b2b89f50f7310a24f07b963f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a5b4234fbf5e967f7a35488aa25adf" id="r_a73a5b4234fbf5e967f7a35488aa25adf"><td class="memTemplParams" colspan="2">template&lt;class EventT1 , class EventT2 &gt; </td></tr>
<tr class="memitem:a73a5b4234fbf5e967f7a35488aa25adf"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; EventT2 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a73a5b4234fbf5e967f7a35488aa25adf">operator&gt;&gt;</a> (std::unique_ptr&lt; EventT1 &gt; &amp;producer, std::unique_ptr&lt; EventT2 &gt; &amp;consumer)</td></tr>
<tr class="memdesc:a73a5b4234fbf5e967f7a35488aa25adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a precedence between a std::unique_ptr&lt;EventT1&gt; and another std::unique_ptr&lt;EventT2&gt;  <br /></td></tr>
<tr class="separator:a73a5b4234fbf5e967f7a35488aa25adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5707f15f54dd3cf229818c9be003f3f" id="r_ad5707f15f54dd3cf229818c9be003f3f"><td class="memTemplParams" colspan="2">template&lt;class EventT1 , class EventT2 &gt; </td></tr>
<tr class="memitem:ad5707f15f54dd3cf229818c9be003f3f"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; EventT2 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad5707f15f54dd3cf229818c9be003f3f">operator&gt;&gt;</a> (EventT1 &amp;producer, std::unique_ptr&lt; EventT2 &gt; &amp;consumer)</td></tr>
<tr class="memdesc:ad5707f15f54dd3cf229818c9be003f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a precedence between an EventT1 and std::unique_ptr&lt;EventT2&gt;  <br /></td></tr>
<tr class="separator:ad5707f15f54dd3cf229818c9be003f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa802de6b38a77a796ec5c0f03684a6eb" id="r_aa802de6b38a77a796ec5c0f03684a6eb"><td class="memTemplParams" colspan="2">template&lt;class EventT1 , class EventT2 &gt; </td></tr>
<tr class="memitem:aa802de6b38a77a796ec5c0f03684a6eb"><td class="memTemplItemLeft" align="right" valign="top">EventT2 &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa802de6b38a77a796ec5c0f03684a6eb">operator&gt;&gt;</a> (std::unique_ptr&lt; EventT1 &gt; &amp;producer, EventT2 &amp;consumer)</td></tr>
<tr class="memdesc:aa802de6b38a77a796ec5c0f03684a6eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a precedence between a std::unique_ptr&lt;EventT1&gt; and EventT2.  <br /></td></tr>
<tr class="separator:aa802de6b38a77a796ec5c0f03684a6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8220b00fe75a16e8936d6a9d9bb4e2" id="r_acc8220b00fe75a16e8936d6a9d9bb4e2"><td class="memTemplParams" colspan="2">template&lt;class DataT2 , <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> phase&gt; </td></tr>
<tr class="memitem:acc8220b00fe75a16e8936d6a9d9bb4e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1PayloadEvent.html">PayloadEvent</a>&lt; DataT2, phase &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acc8220b00fe75a16e8936d6a9d9bb4e2">operator&gt;&gt;</a> (<a class="el" href="classsparta_1_1Scheduleable.html">Scheduleable</a> &amp;producer, <a class="el" href="classsparta_1_1PayloadEvent.html">PayloadEvent</a>&lt; DataT2, phase &gt; &amp;consumer)</td></tr>
<tr class="memdesc:acc8220b00fe75a16e8936d6a9d9bb4e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a precedence between a <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">Scheduleable</a> and a <a class="el" href="classsparta_1_1PayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...">PayloadEvent</a>.  <br /></td></tr>
<tr class="separator:acc8220b00fe75a16e8936d6a9d9bb4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24cfd795ea9241a7f8b4e500e4cfb9d4" id="r_a24cfd795ea9241a7f8b4e500e4cfb9d4"><td class="memTemplParams" colspan="2">template&lt;class DataT1 , <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> phase&gt; </td></tr>
<tr class="memitem:a24cfd795ea9241a7f8b4e500e4cfb9d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Scheduleable.html">Scheduleable</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a24cfd795ea9241a7f8b4e500e4cfb9d4">operator&gt;&gt;</a> (<a class="el" href="classsparta_1_1PayloadEvent.html">PayloadEvent</a>&lt; DataT1, phase &gt; &amp;producer, <a class="el" href="classsparta_1_1Scheduleable.html">Scheduleable</a> &amp;consumer)</td></tr>
<tr class="memdesc:a24cfd795ea9241a7f8b4e500e4cfb9d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a precedence between a <a class="el" href="classsparta_1_1PayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...">PayloadEvent</a> and a <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">Scheduleable</a>.  <br /></td></tr>
<tr class="separator:a24cfd795ea9241a7f8b4e500e4cfb9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59075953a8f2a9ec7b1a5903c52cb5c" id="r_ad59075953a8f2a9ec7b1a5903c52cb5c"><td class="memTemplParams" colspan="2">template&lt;class ScheduleableType &gt; </td></tr>
<tr class="memitem:ad59075953a8f2a9ec7b1a5903c52cb5c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="classsparta_1_1Scheduleable.html">Scheduleable</a>, ScheduleableType &gt;::value, <a class="el" href="classsparta_1_1Bus.html">Bus</a> &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad59075953a8f2a9ec7b1a5903c52cb5c">operator&gt;&gt;</a> (ScheduleableType &amp;producer, <a class="el" href="classsparta_1_1Bus.html">Bus</a> &amp;consumer)</td></tr>
<tr class="memdesc:ad59075953a8f2a9ec7b1a5903c52cb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a precedence between a <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">Scheduleable</a> and a <a class="el" href="classsparta_1_1Bus.html" title="Class that defines a Bus type.">Bus</a>.  <br /></td></tr>
<tr class="separator:ad59075953a8f2a9ec7b1a5903c52cb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3499289f1cacb032a9421d37f5abd0a7" id="r_a3499289f1cacb032a9421d37f5abd0a7"><td class="memTemplParams" colspan="2">template&lt;class ScheduleableType &gt; </td></tr>
<tr class="memitem:a3499289f1cacb032a9421d37f5abd0a7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="classsparta_1_1Scheduleable.html">Scheduleable</a>, ScheduleableType &gt;::value, ScheduleableType &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3499289f1cacb032a9421d37f5abd0a7">operator&gt;&gt;</a> (<a class="el" href="classsparta_1_1Bus.html">Bus</a> &amp;producer, ScheduleableType &amp;consumer)</td></tr>
<tr class="memdesc:a3499289f1cacb032a9421d37f5abd0a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a precedence between a <a class="el" href="classsparta_1_1Bus.html" title="Class that defines a Bus type.">Bus</a> and a <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">Scheduleable</a>.  <br /></td></tr>
<tr class="separator:a3499289f1cacb032a9421d37f5abd0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9505663d539ce92e684f3973ac983f7" id="r_ab9505663d539ce92e684f3973ac983f7"><td class="memTemplParams" colspan="2">template&lt;class ScheduleableTypeB &gt; </td></tr>
<tr class="memitem:ab9505663d539ce92e684f3973ac983f7"><td class="memTemplItemLeft" align="right" valign="top">ScheduleableTypeB &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab9505663d539ce92e684f3973ac983f7">operator&gt;&gt;</a> (const <a class="el" href="classsparta_1_1EventGroup.html">EventGroup</a> &amp;producers, ScheduleableTypeB &amp;consumer)</td></tr>
<tr class="separator:ab9505663d539ce92e684f3973ac983f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ceed42442bee420e907ad303e3c93b" id="r_a85ceed42442bee420e907ad303e3c93b"><td class="memTemplParams" colspan="2">template&lt;class ScheduleableTypeA &gt; </td></tr>
<tr class="memitem:a85ceed42442bee420e907ad303e3c93b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classsparta_1_1EventGroup.html">EventGroup</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a85ceed42442bee420e907ad303e3c93b">operator&gt;&gt;</a> (ScheduleableTypeA &amp;producer, const <a class="el" href="classsparta_1_1EventGroup.html">EventGroup</a> &amp;consumers)</td></tr>
<tr class="separator:a85ceed42442bee420e907ad303e3c93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c50033c25f275c22b42183c9dc4dde5" id="r_a8c50033c25f275c22b42183c9dc4dde5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsparta_1_1EventGroup.html">EventGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c50033c25f275c22b42183c9dc4dde5">operator&gt;&gt;</a> (const <a class="el" href="classsparta_1_1EventGroup.html">EventGroup</a> &amp;producers, const <a class="el" href="classsparta_1_1EventGroup.html">EventGroup</a> &amp;consumers)</td></tr>
<tr class="separator:a8c50033c25f275c22b42183c9dc4dde5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23625a4707a7d7e65408eff02bbe8a2" id="r_ae23625a4707a7d7e65408eff02bbe8a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Scheduleable.html">Scheduleable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae23625a4707a7d7e65408eff02bbe8a2">operator&gt;&gt;</a> (<a class="el" href="classsparta_1_1Scheduleable.html">Scheduleable</a> &amp;producer, <a class="el" href="classsparta_1_1Scheduleable.html">Scheduleable</a> &amp;consumer)</td></tr>
<tr class="separator:ae23625a4707a7d7e65408eff02bbe8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa148a3ec863b7cec37ff036b6b9ba5ed" id="r_aa148a3ec863b7cec37ff036b6b9ba5ed"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa148a3ec863b7cec37ff036b6b9ba5ed">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> &amp;phase)</td></tr>
<tr class="memdesc:aa148a3ec863b7cec37ff036b6b9ba5ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the SchedulingPhase.  <br /></td></tr>
<tr class="separator:aa148a3ec863b7cec37ff036b6b9ba5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b34eb9804296a39f67ed8800846ded" id="r_a20b34eb9804296a39f67ed8800846ded"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20b34eb9804296a39f67ed8800846ded">operator==</a> (const <a class="el" href="structsparta_1_1RegisterBase_1_1Definition.html">RegisterBase::Definition</a> &amp;a, const <a class="el" href="structsparta_1_1RegisterBase_1_1Definition.html">RegisterBase::Definition</a> &amp;b)</td></tr>
<tr class="separator:a20b34eb9804296a39f67ed8800846ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf34f238fa54ff498b637be43e9f1438" id="r_aaf34f238fa54ff498b637be43e9f1438"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf34f238fa54ff498b637be43e9f1438">operator!=</a> (const <a class="el" href="structsparta_1_1RegisterBase_1_1Definition.html">RegisterBase::Definition</a> &amp;a, const <a class="el" href="structsparta_1_1RegisterBase_1_1Definition.html">RegisterBase::Definition</a> &amp;b)</td></tr>
<tr class="separator:aaf34f238fa54ff498b637be43e9f1438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40529f7a2fe9e82d2cb3a5ec14821259" id="r_a40529f7a2fe9e82d2cb3a5ec14821259"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40529f7a2fe9e82d2cb3a5ec14821259">operator==</a> (const <a class="el" href="structsparta_1_1RegisterProxyBase_1_1Definition.html">RegisterProxyBase::Definition</a> &amp;a, const <a class="el" href="structsparta_1_1RegisterProxyBase_1_1Definition.html">RegisterProxyBase::Definition</a> &amp;b)</td></tr>
<tr class="separator:a40529f7a2fe9e82d2cb3a5ec14821259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0491810de0250f122ec692a261869f26" id="r_a0491810de0250f122ec692a261869f26"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0491810de0250f122ec692a261869f26">operator!=</a> (const <a class="el" href="structsparta_1_1RegisterProxyBase_1_1Definition.html">RegisterProxyBase::Definition</a> &amp;a, const <a class="el" href="structsparta_1_1RegisterProxyBase_1_1Definition.html">RegisterProxyBase::Definition</a> &amp;b)</td></tr>
<tr class="separator:a0491810de0250f122ec692a261869f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc91d8642fd2f22f56b5ccb2cf2b418c" id="r_acc91d8642fd2f22f56b5ccb2cf2b418c"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc91d8642fd2f22f56b5ccb2cf2b418c">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classsparta_1_1DAG.html">DAG</a> &amp;d)</td></tr>
<tr class="separator:acc91d8642fd2f22f56b5ccb2cf2b418c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6f66cd1bcda14b5d8846b094cbdee0" id="r_a8c6f66cd1bcda14b5d8846b094cbdee0"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c6f66cd1bcda14b5d8846b094cbdee0">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classsparta_1_1DAG.html">DAG</a> *d)</td></tr>
<tr class="separator:a8c6f66cd1bcda14b5d8846b094cbdee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5ee9399682eb31f52231079334644f" id="r_a6e5ee9399682eb31f52231079334644f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e5ee9399682eb31f52231079334644f">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classsparta_1_1NotificationSourceBase_1_1ObservationStateCallback.html">NotificationSourceBase::ObservationStateCallback</a> &amp;osc)</td></tr>
<tr class="separator:a6e5ee9399682eb31f52231079334644f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6365394172db580c9620dc3f4e3cbafa" id="r_a6365394172db580c9620dc3f4e3cbafa"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6365394172db580c9620dc3f4e3cbafa">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classsparta_1_1NotificationSourceBase_1_1ObservationStateCallback.html">NotificationSourceBase::ObservationStateCallback</a> *osc)</td></tr>
<tr class="separator:a6365394172db580c9620dc3f4e3cbafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e328d41db963d8fa8d62139d70e960" id="r_ae0e328d41db963d8fa8d62139d70e960"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0e328d41db963d8fa8d62139d70e960">bind</a> (<a class="el" href="classsparta_1_1Bus.html">Bus</a> *p1, <a class="el" href="classsparta_1_1Bus.html">Bus</a> *p2)</td></tr>
<tr class="memdesc:ae0e328d41db963d8fa8d62139d70e960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind two buses together.  <br /></td></tr>
<tr class="separator:ae0e328d41db963d8fa8d62139d70e960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a81d36884c4c054c170a4b707a2b010" id="r_a3a81d36884c4c054c170a4b707a2b010"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a81d36884c4c054c170a4b707a2b010">bind</a> (<a class="el" href="classsparta_1_1Bus.html">Bus</a> &amp;p1, <a class="el" href="classsparta_1_1Bus.html">Bus</a> &amp;p2)</td></tr>
<tr class="memdesc:a3a81d36884c4c054c170a4b707a2b010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind two buses together.  <br /></td></tr>
<tr class="separator:a3a81d36884c4c054c170a4b707a2b010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c17f463617d49a0117e33f5476ebfd" id="r_a60c17f463617d49a0117e33f5476ebfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60c17f463617d49a0117e33f5476ebfd">bind</a> (<a class="el" href="classsparta_1_1Bus.html">Bus</a> *p1, <a class="el" href="classsparta_1_1Bus.html">Bus</a> &amp;p2)</td></tr>
<tr class="memdesc:a60c17f463617d49a0117e33f5476ebfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind two buses together.  <br /></td></tr>
<tr class="separator:a60c17f463617d49a0117e33f5476ebfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d71bce915c66cbed446b388af18273" id="r_a92d71bce915c66cbed446b388af18273"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92d71bce915c66cbed446b388af18273">bind</a> (<a class="el" href="classsparta_1_1Bus.html">Bus</a> &amp;p1, <a class="el" href="classsparta_1_1Bus.html">Bus</a> *p2)</td></tr>
<tr class="memdesc:a92d71bce915c66cbed446b388af18273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind two buses together.  <br /></td></tr>
<tr class="separator:a92d71bce915c66cbed446b388af18273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb3d186a623f8a7169ee63d719652fa" id="r_a0fb3d186a623f8a7169ee63d719652fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fb3d186a623f8a7169ee63d719652fa">bind</a> (<a class="el" href="classsparta_1_1Port.html">Port</a> *p1, <a class="el" href="classsparta_1_1Port.html">Port</a> *p2)</td></tr>
<tr class="memdesc:a0fb3d186a623f8a7169ee63d719652fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind two ports together.  <br /></td></tr>
<tr class="separator:a0fb3d186a623f8a7169ee63d719652fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f43a41f95790c0025c748fbc0970f3" id="r_a69f43a41f95790c0025c748fbc0970f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69f43a41f95790c0025c748fbc0970f3">bind</a> (<a class="el" href="classsparta_1_1Port.html">Port</a> &amp;p1, <a class="el" href="classsparta_1_1Port.html">Port</a> &amp;p2)</td></tr>
<tr class="memdesc:a69f43a41f95790c0025c748fbc0970f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind two ports together.  <br /></td></tr>
<tr class="separator:a69f43a41f95790c0025c748fbc0970f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeea717c5da6fcb0235c750df8756715" id="r_adeea717c5da6fcb0235c750df8756715"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adeea717c5da6fcb0235c750df8756715">bind</a> (<a class="el" href="classsparta_1_1Port.html">Port</a> *p1, <a class="el" href="classsparta_1_1Port.html">Port</a> &amp;p2)</td></tr>
<tr class="memdesc:adeea717c5da6fcb0235c750df8756715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind two ports together.  <br /></td></tr>
<tr class="separator:adeea717c5da6fcb0235c750df8756715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363b92b9d85e2aae9e2b38b5f1b65e2c" id="r_a363b92b9d85e2aae9e2b38b5f1b65e2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a363b92b9d85e2aae9e2b38b5f1b65e2c">bind</a> (<a class="el" href="classsparta_1_1Port.html">Port</a> &amp;p1, <a class="el" href="classsparta_1_1Port.html">Port</a> *p2)</td></tr>
<tr class="memdesc:a363b92b9d85e2aae9e2b38b5f1b65e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind two ports together.  <br /></td></tr>
<tr class="separator:a363b92b9d85e2aae9e2b38b5f1b65e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575213c8022b8456f1a439b8165b30db" id="r_a575213c8022b8456f1a439b8165b30db"><td class="memItemLeft" align="right" valign="top"><a id="a575213c8022b8456f1a439b8165b30db" name="a575213c8022b8456f1a439b8165b30db"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>printBitSet</b> (const Scoreboard::RegisterBitMask &amp;bits)</td></tr>
<tr class="separator:a575213c8022b8456f1a439b8165b30db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8125c727efbed2a4c7ccefc34debe472" id="r_a8125c727efbed2a4c7ccefc34debe472"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8125c727efbed2a4c7ccefc34debe472">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classsparta_1_1Clock.html">sparta::Clock</a> &amp;clk)</td></tr>
<tr class="separator:a8125c727efbed2a4c7ccefc34debe472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3650b902d4a6387060e3944d55c6a788" id="r_a3650b902d4a6387060e3944d55c6a788"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Scheduler.html#a2c6114226a2d41fb22ac0395520b56c3">Scheduler::Tick</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3650b902d4a6387060e3944d55c6a788">calculateClockCrossingDelay</a> (<a class="el" href="classsparta_1_1Scheduler.html#a2c6114226a2d41fb22ac0395520b56c3">Scheduler::Tick</a> src_delay, const <a class="el" href="classsparta_1_1Clock.html">Clock</a> *src_clk, <a class="el" href="classsparta_1_1Scheduler.html#a2c6114226a2d41fb22ac0395520b56c3">Scheduler::Tick</a> dst_delay, const <a class="el" href="classsparta_1_1Clock.html">Clock</a> *dst_clk)</td></tr>
<tr class="separator:a3650b902d4a6387060e3944d55c6a788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b75372dc50607a3217873eecffaa2b1" id="r_a2b75372dc50607a3217873eecffaa2b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1Scheduler.html#a2c6114226a2d41fb22ac0395520b56c3">Scheduler::Tick</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b75372dc50607a3217873eecffaa2b1">calculateReverseClockCrossingDelay</a> (<a class="el" href="classsparta_1_1Scheduler.html#a2c6114226a2d41fb22ac0395520b56c3">Scheduler::Tick</a> dst_arrival_tick, <a class="el" href="classsparta_1_1Scheduler.html#a2c6114226a2d41fb22ac0395520b56c3">Scheduler::Tick</a> src_delay, const <a class="el" href="classsparta_1_1Clock.html">Clock</a> *src_clk, <a class="el" href="classsparta_1_1Scheduler.html#a2c6114226a2d41fb22ac0395520b56c3">Scheduler::Tick</a> dst_delay, const <a class="el" href="classsparta_1_1Clock.html">Clock</a> *dst_clk)</td></tr>
<tr class="separator:a2b75372dc50607a3217873eecffaa2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e0d03f3a672b76c34b27ed95987b8c" id="r_a24e0d03f3a672b76c34b27ed95987b8c"><td class="memItemLeft" align="right" valign="top"><a id="a24e0d03f3a672b76c34b27ed95987b8c" name="a24e0d03f3a672b76c34b27ed95987b8c"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classsparta_1_1ClockManager.html">ClockManager</a> &amp;m)</td></tr>
<tr class="separator:a24e0d03f3a672b76c34b27ed95987b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3daa869502f6ee8730edca1f3b60733f" id="r_a3daa869502f6ee8730edca1f3b60733f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3daa869502f6ee8730edca1f3b60733f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3daa869502f6ee8730edca1f3b60733f">smartLexicalCast</a> (const <a class="el" href="classsparta_1_1ParameterBase.html">ParameterBase</a> *p, const std::string &amp;s, size_t &amp;end_pos, bool allow_recursion=true, bool allow_prefix=true)</td></tr>
<tr class="memdesc:a3daa869502f6ee8730edca1f3b60733f"><td class="mdescLeft">&#160;</td><td class="mdescRight">smartLexicalCast wrapper with parameter information added to exceptions  <br /></td></tr>
<tr class="separator:a3daa869502f6ee8730edca1f3b60733f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac766be8c0bc2a6829736d6408a47f94c" id="r_ac766be8c0bc2a6829736d6408a47f94c"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac766be8c0bc2a6829736d6408a47f94c">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classsparta_1_1ParameterTree_1_1Node.html">ParameterTree::Node</a> &amp;n)</td></tr>
<tr class="separator:ac766be8c0bc2a6829736d6408a47f94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44eb91b66a9ed919b7b76e8be330cee1" id="r_a44eb91b66a9ed919b7b76e8be330cee1"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44eb91b66a9ed919b7b76e8be330cee1">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classsparta_1_1ParameterTree_1_1Node.html">ParameterTree::Node</a> *n)</td></tr>
<tr class="separator:a44eb91b66a9ed919b7b76e8be330cee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed30fb441ce7c7e9dc71a10db268f0f" id="r_a1ed30fb441ce7c7e9dc71a10db268f0f"><td class="memTemplParams" colspan="2">template&lt;class Ch , class Tr &gt; </td></tr>
<tr class="memitem:a1ed30fb441ce7c7e9dc71a10db268f0f"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; Ch, Tr &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1ed30fb441ce7c7e9dc71a10db268f0f">operator&lt;&lt;</a> (std::basic_ostream&lt; Ch, Tr &gt; &amp;out, <a class="el" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a> const &amp;tn)</td></tr>
<tr class="memdesc:a1ed30fb441ce7c7e9dc71a10db268f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> stream operator.  <br /></td></tr>
<tr class="separator:a1ed30fb441ce7c7e9dc71a10db268f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6105eb11e517ad2e76bcc530591cd11" id="r_aa6105eb11e517ad2e76bcc530591cd11"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6105eb11e517ad2e76bcc530591cd11">operator&lt;&lt;</a> (std::ostream &amp;out, <a class="el" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a> const *tn)</td></tr>
<tr class="memdesc:aa6105eb11e517ad2e76bcc530591cd11"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> stream operator.  <br /></td></tr>
<tr class="separator:aa6105eb11e517ad2e76bcc530591cd11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6379e6669e33ed5fe30711ca4a75f539" id="r_a6379e6669e33ed5fe30711ca4a75f539"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a6379e6669e33ed5fe30711ca4a75f539"><td class="memTemplItemLeft" align="right" valign="top">MetaStruct::enable_if_t&lt; not <a class="el" href="structsparta_1_1is__sparta__enum.html">sparta::is_sparta_enum</a>&lt; U &gt;::value and <a class="el" href="structsparta_1_1utils_1_1has__ostream__operator.html">sparta::utils::has_ostream_operator</a>&lt; U &gt;::value, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6379e6669e33ed5fe30711ca4a75f539">getHumanReadableHistogramBinNames</a> (std::vector&lt; std::string &gt; &amp;enum_name_strings)</td></tr>
<tr class="memdesc:a6379e6669e33ed5fe30711ca4a75f539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an enum class type, this method figures out the string.  <br /></td></tr>
<tr class="separator:a6379e6669e33ed5fe30711ca4a75f539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88bd65ffebee073443491fd711ae7f5" id="r_aa88bd65ffebee073443491fd711ae7f5"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:aa88bd65ffebee073443491fd711ae7f5"><td class="memTemplItemLeft" align="right" valign="top">MetaStruct::enable_if_t&lt; not <a class="el" href="structsparta_1_1is__sparta__enum.html">sparta::is_sparta_enum</a>&lt; U &gt;::value and not <a class="el" href="structsparta_1_1utils_1_1has__ostream__operator.html">sparta::utils::has_ostream_operator</a>&lt; U &gt;::value, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa88bd65ffebee073443491fd711ae7f5">getHumanReadableHistogramBinNames</a> (std::vector&lt; std::string &gt; &amp;)</td></tr>
<tr class="memdesc:aa88bd65ffebee073443491fd711ae7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an enum class type, this method figures out the string.  <br /></td></tr>
<tr class="separator:aa88bd65ffebee073443491fd711ae7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa418c36248e0d9c823fddb6ae03eeec0" id="r_aa418c36248e0d9c823fddb6ae03eeec0"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:aa418c36248e0d9c823fddb6ae03eeec0"><td class="memTemplItemLeft" align="right" valign="top">MetaStruct::enable_if_t&lt; <a class="el" href="structsparta_1_1is__sparta__enum.html">sparta::is_sparta_enum</a>&lt; U &gt;::value, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa418c36248e0d9c823fddb6ae03eeec0">getHumanReadableHistogramBinNames</a> (std::vector&lt; std::string &gt; &amp;enum_name_strings)</td></tr>
<tr class="memdesc:aa418c36248e0d9c823fddb6ae03eeec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an enum class type, this method figures out the string.  <br /></td></tr>
<tr class="separator:aa418c36248e0d9c823fddb6ae03eeec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ee46795c63d58510a9cea78d0ec7bf" id="r_a43ee46795c63d58510a9cea78d0ec7bf"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43ee46795c63d58510a9cea78d0ec7bf">operator&lt;&lt;</a> (std::ostream &amp;out, <a class="el" href="classsparta_1_1StatisticInstance.html">sparta::StatisticInstance</a> const &amp;si)</td></tr>
<tr class="memdesc:a43ee46795c63d58510a9cea78d0ec7bf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1StatisticInstance.html" title="Instance of either a StatisticDef or CounterBase or an Expression. Has a sample window (simulator tic...">StatisticInstance</a> stream operator.  <br /></td></tr>
<tr class="separator:a43ee46795c63d58510a9cea78d0ec7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd73b6c947c5df447187e7b05e92c1e4" id="r_acd73b6c947c5df447187e7b05e92c1e4"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd73b6c947c5df447187e7b05e92c1e4">operator&lt;&lt;</a> (std::ostream &amp;out, <a class="el" href="classsparta_1_1StatisticInstance.html">sparta::StatisticInstance</a> const *si)</td></tr>
<tr class="memdesc:acd73b6c947c5df447187e7b05e92c1e4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> stream operator.  <br /></td></tr>
<tr class="separator:acd73b6c947c5df447187e7b05e92c1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17970a38d3054bdd50ce337e22a35679" id="r_a17970a38d3054bdd50ce337e22a35679"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a17970a38d3054bdd50ce337e22a35679"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a17970a38d3054bdd50ce337e22a35679">byte_swap</a> (T val)</td></tr>
<tr class="memdesc:a17970a38d3054bdd50ce337e22a35679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the order of bytes for various types.  <br /></td></tr>
<tr class="separator:a17970a38d3054bdd50ce337e22a35679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a1cd4b597a68600a258747569d784c" id="r_ae7a1cd4b597a68600a258747569d784c"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ae7a1cd4b597a68600a258747569d784c"><td class="memTemplItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae7a1cd4b597a68600a258747569d784c">byte_swap</a> (uint8_t val)</td></tr>
<tr class="separator:ae7a1cd4b597a68600a258747569d784c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af414ec44370bc7ba08017d820f8e5eeb" id="r_af414ec44370bc7ba08017d820f8e5eeb"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:af414ec44370bc7ba08017d820f8e5eeb"><td class="memTemplItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af414ec44370bc7ba08017d820f8e5eeb">byte_swap</a> (int8_t val)</td></tr>
<tr class="separator:af414ec44370bc7ba08017d820f8e5eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2f845f27a62283b1be039369b7ff03" id="r_a8e2f845f27a62283b1be039369b7ff03"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a8e2f845f27a62283b1be039369b7ff03"><td class="memTemplItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8e2f845f27a62283b1be039369b7ff03">byte_swap</a> (uint16_t val)</td></tr>
<tr class="separator:a8e2f845f27a62283b1be039369b7ff03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8ded913a7bae431e53cfe61ccd02c5" id="r_acf8ded913a7bae431e53cfe61ccd02c5"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:acf8ded913a7bae431e53cfe61ccd02c5"><td class="memTemplItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acf8ded913a7bae431e53cfe61ccd02c5">byte_swap</a> (int16_t val)</td></tr>
<tr class="separator:acf8ded913a7bae431e53cfe61ccd02c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a987e3429a78cd6229a3972a351e2c1" id="r_a3a987e3429a78cd6229a3972a351e2c1"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a3a987e3429a78cd6229a3972a351e2c1"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3a987e3429a78cd6229a3972a351e2c1">byte_swap</a> (uint32_t val)</td></tr>
<tr class="separator:a3a987e3429a78cd6229a3972a351e2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa636c5313d0dc8a45c6b31a67d62a7" id="r_a3aa636c5313d0dc8a45c6b31a67d62a7"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a3aa636c5313d0dc8a45c6b31a67d62a7"><td class="memTemplItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3aa636c5313d0dc8a45c6b31a67d62a7">byte_swap</a> (int32_t val)</td></tr>
<tr class="separator:a3aa636c5313d0dc8a45c6b31a67d62a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e68957a8846e82ff315cd3d5e1ee9e" id="r_ae4e68957a8846e82ff315cd3d5e1ee9e"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ae4e68957a8846e82ff315cd3d5e1ee9e"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae4e68957a8846e82ff315cd3d5e1ee9e">byte_swap</a> (uint64_t val)</td></tr>
<tr class="separator:ae4e68957a8846e82ff315cd3d5e1ee9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc08de39a273bd675704153aff49cd1" id="r_a7cc08de39a273bd675704153aff49cd1"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a7cc08de39a273bd675704153aff49cd1"><td class="memTemplItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7cc08de39a273bd675704153aff49cd1">byte_swap</a> (int64_t val)</td></tr>
<tr class="separator:a7cc08de39a273bd675704153aff49cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57002ba92c08d4a3abb4acb2824bc6d3" id="r_a57002ba92c08d4a3abb4acb2824bc6d3"><td class="memTemplParams" colspan="2">template&lt;typename T , enum <a class="el" href="#afc3e7ddb8e5c54811105c5ab61112a5b">ByteOrder</a> BO&gt; </td></tr>
<tr class="memitem:a57002ba92c08d4a3abb4acb2824bc6d3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; boost::mpl::int_&lt; BO &gt;, boost::mpl::int_&lt; <a class="el" href="#afc3e7ddb8e5c54811105c5ab61112a5bae6d6457742b40b16092846e8e785f3ba">BE</a> &gt; &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a57002ba92c08d4a3abb4acb2824bc6d3">reorder</a> (const T &amp;t)</td></tr>
<tr class="separator:a57002ba92c08d4a3abb4acb2824bc6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42744ae87cf1b049252fc73de5ece03" id="r_ae42744ae87cf1b049252fc73de5ece03"><td class="memTemplParams" colspan="2">template&lt;typename T , enum <a class="el" href="#afc3e7ddb8e5c54811105c5ab61112a5b">ByteOrder</a> BO&gt; </td></tr>
<tr class="memitem:ae42744ae87cf1b049252fc73de5ece03"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; boost::mpl::int_&lt; BO &gt;, boost::mpl::int_&lt; LE &gt; &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae42744ae87cf1b049252fc73de5ece03">reorder</a> (const T &amp;t)</td></tr>
<tr class="separator:ae42744ae87cf1b049252fc73de5ece03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3349bd0261eafc0405eca4437e5296" id="r_a9e3349bd0261eafc0405eca4437e5296"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9e3349bd0261eafc0405eca4437e5296"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9e3349bd0261eafc0405eca4437e5296">lexicalCast</a> (const std::string &amp;str, uint32_t base=10)</td></tr>
<tr class="separator:a9e3349bd0261eafc0405eca4437e5296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0aa7dffa010a4ea365cbc3292862b05" id="r_ac0aa7dffa010a4ea365cbc3292862b05"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac0aa7dffa010a4ea365cbc3292862b05"><td class="memTemplItemLeft" align="right" valign="top">MetaStruct::enable_if_t&lt; <a class="el" href="structMetaStruct_1_1is__stl.html">MetaStruct::is_stl</a>&lt; T &gt;::value and std::is_same&lt; typename T::value_type, bool &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac0aa7dffa010a4ea365cbc3292862b05">lexicalCast</a> (const std::string &amp;str, uint32_t base=10)=delete</td></tr>
<tr class="separator:ac0aa7dffa010a4ea365cbc3292862b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa849f3d6b47a500f3c110e6b33849c" id="r_a1aa849f3d6b47a500f3c110e6b33849c"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a1aa849f3d6b47a500f3c110e6b33849c"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1aa849f3d6b47a500f3c110e6b33849c">lexicalCast</a> (const std::string &amp;str, uint32_t base)</td></tr>
<tr class="separator:a1aa849f3d6b47a500f3c110e6b33849c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf3eceb958516aee139b92f44dbaad8" id="r_a1cf3eceb958516aee139b92f44dbaad8"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a1cf3eceb958516aee139b92f44dbaad8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1cf3eceb958516aee139b92f44dbaad8">lexicalCast</a> (const std::string &amp;str, uint32_t base)</td></tr>
<tr class="separator:a1cf3eceb958516aee139b92f44dbaad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9662fa9521b5b0a77276dd54cbe98b4a" id="r_a9662fa9521b5b0a77276dd54cbe98b4a"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a9662fa9521b5b0a77276dd54cbe98b4a"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9662fa9521b5b0a77276dd54cbe98b4a">lexicalCast</a> (const std::string &amp;str, uint32_t base)</td></tr>
<tr class="separator:a9662fa9521b5b0a77276dd54cbe98b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9608e0cb0d8d4fb8c2d2ef2996e29ede" id="r_a9608e0cb0d8d4fb8c2d2ef2996e29ede"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a9608e0cb0d8d4fb8c2d2ef2996e29ede"><td class="memTemplItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9608e0cb0d8d4fb8c2d2ef2996e29ede">lexicalCast</a> (const std::string &amp;str, uint32_t base)</td></tr>
<tr class="separator:a9608e0cb0d8d4fb8c2d2ef2996e29ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b6c08989d9e77a8ddbd05ef263ac2b" id="r_a03b6c08989d9e77a8ddbd05ef263ac2b"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a03b6c08989d9e77a8ddbd05ef263ac2b"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a03b6c08989d9e77a8ddbd05ef263ac2b">lexicalCast</a> (const std::string &amp;str, uint32_t base)</td></tr>
<tr class="separator:a03b6c08989d9e77a8ddbd05ef263ac2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a494f59e2ad2807b56495452f4ff550ea" id="r_a494f59e2ad2807b56495452f4ff550ea"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a494f59e2ad2807b56495452f4ff550ea"><td class="memTemplItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a494f59e2ad2807b56495452f4ff550ea">lexicalCast</a> (const std::string &amp;str, uint32_t base)</td></tr>
<tr class="separator:a494f59e2ad2807b56495452f4ff550ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686b73cac0940a378e3dba4bcdcac07b" id="r_a686b73cac0940a378e3dba4bcdcac07b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a686b73cac0940a378e3dba4bcdcac07b">numDecDigits</a> (uint32_t val)</td></tr>
<tr class="memdesc:a686b73cac0940a378e3dba4bcdcac07b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets number of decimal digits in a uint32_t.  <br /></td></tr>
<tr class="separator:a686b73cac0940a378e3dba4bcdcac07b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad12364f9dbfae24ee6655d907032e28" id="r_aad12364f9dbfae24ee6655d907032e28"><td class="memTemplParams" colspan="2">template&lt;typename PtrT , typename Ptr2 &gt; </td></tr>
<tr class="memitem:aad12364f9dbfae24ee6655d907032e28"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aad12364f9dbfae24ee6655d907032e28">operator==</a> (const <a class="el" href="classsparta_1_1SpartaSharedPointer.html">SpartaSharedPointer</a>&lt; PtrT &gt; &amp;ptr1, const <a class="el" href="classsparta_1_1SpartaSharedPointer.html">SpartaSharedPointer</a>&lt; Ptr2 &gt; &amp;ptr2) noexcept</td></tr>
<tr class="separator:aad12364f9dbfae24ee6655d907032e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4cc5a6070e35d538a462c09d0360aa9" id="r_ac4cc5a6070e35d538a462c09d0360aa9"><td class="memTemplParams" colspan="2">template&lt;typename PtrT &gt; </td></tr>
<tr class="memitem:ac4cc5a6070e35d538a462c09d0360aa9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac4cc5a6070e35d538a462c09d0360aa9">operator==</a> (const <a class="el" href="classsparta_1_1SpartaSharedPointer.html">SpartaSharedPointer</a>&lt; PtrT &gt; &amp;ptr1, std::nullptr_t) noexcept</td></tr>
<tr class="separator:ac4cc5a6070e35d538a462c09d0360aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e4a4d86dcec7a702e975cc429ba731" id="r_ae2e4a4d86dcec7a702e975cc429ba731"><td class="memTemplParams" colspan="2">template&lt;typename PtrT &gt; </td></tr>
<tr class="memitem:ae2e4a4d86dcec7a702e975cc429ba731"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae2e4a4d86dcec7a702e975cc429ba731">operator==</a> (std::nullptr_t, const <a class="el" href="classsparta_1_1SpartaSharedPointer.html">SpartaSharedPointer</a>&lt; PtrT &gt; &amp;ptr1) noexcept</td></tr>
<tr class="separator:ae2e4a4d86dcec7a702e975cc429ba731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f48238763469a49de618f0d5045af0b" id="r_a9f48238763469a49de618f0d5045af0b"><td class="memTemplParams" colspan="2">template&lt;typename PtrT , typename Ptr2 &gt; </td></tr>
<tr class="memitem:a9f48238763469a49de618f0d5045af0b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9f48238763469a49de618f0d5045af0b">operator!=</a> (const <a class="el" href="classsparta_1_1SpartaSharedPointer.html">SpartaSharedPointer</a>&lt; PtrT &gt; &amp;ptr1, const <a class="el" href="classsparta_1_1SpartaSharedPointer.html">SpartaSharedPointer</a>&lt; Ptr2 &gt; &amp;ptr2) noexcept</td></tr>
<tr class="separator:a9f48238763469a49de618f0d5045af0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae6fc3fbc564353b07015fb251c3849" id="r_a0ae6fc3fbc564353b07015fb251c3849"><td class="memTemplParams" colspan="2">template&lt;typename PtrT &gt; </td></tr>
<tr class="memitem:a0ae6fc3fbc564353b07015fb251c3849"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0ae6fc3fbc564353b07015fb251c3849">operator!=</a> (const <a class="el" href="classsparta_1_1SpartaSharedPointer.html">SpartaSharedPointer</a>&lt; PtrT &gt; &amp;ptr1, std::nullptr_t) noexcept</td></tr>
<tr class="separator:a0ae6fc3fbc564353b07015fb251c3849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e24d39dd1012a3ac845130f7ccf553" id="r_ae2e24d39dd1012a3ac845130f7ccf553"><td class="memTemplParams" colspan="2">template&lt;typename PtrT &gt; </td></tr>
<tr class="memitem:ae2e24d39dd1012a3ac845130f7ccf553"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae2e24d39dd1012a3ac845130f7ccf553">operator!=</a> (std::nullptr_t, const <a class="el" href="classsparta_1_1SpartaSharedPointer.html">SpartaSharedPointer</a>&lt; PtrT &gt; &amp;ptr1) noexcept</td></tr>
<tr class="separator:ae2e24d39dd1012a3ac845130f7ccf553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d3f531a3a29e7010e3b72b21f5bc1c" id="r_a26d3f531a3a29e7010e3b72b21f5bc1c"><td class="memTemplParams" colspan="2">template&lt;typename PtrT &gt; </td></tr>
<tr class="memitem:a26d3f531a3a29e7010e3b72b21f5bc1c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a26d3f531a3a29e7010e3b72b21f5bc1c">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classsparta_1_1SpartaSharedPointer.html">SpartaSharedPointer</a>&lt; PtrT &gt; &amp;p)</td></tr>
<tr class="separator:a26d3f531a3a29e7010e3b72b21f5bc1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461a77508c6d89191e6b6149bf9c88f8" id="r_a461a77508c6d89191e6b6149bf9c88f8"><td class="memTemplParams" colspan="2">template&lt;typename PointerT , typename... Args&gt; </td></tr>
<tr class="memitem:a461a77508c6d89191e6b6149bf9c88f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1SpartaSharedPointer.html">SpartaSharedPointer</a>&lt; PointerT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a461a77508c6d89191e6b6149bf9c88f8">allocate_sparta_shared_pointer</a> (<a class="el" href="classsparta_1_1SpartaSharedPointerAllocator.html">SpartaSharedPointerAllocator</a>&lt; PointerT &gt; &amp;alloc, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a461a77508c6d89191e6b6149bf9c88f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a <a class="el" href="classsparta_1_1SpartaSharedPointer.html" title="Used for garbage collection, will delete the object it points to when all objects are finished using ...">SpartaSharedPointer</a>.  <br /></td></tr>
<tr class="separator:a461a77508c6d89191e6b6149bf9c88f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ec057e36ea2e9a4685e5b937bf4a7c" id="r_a97ec057e36ea2e9a4685e5b937bf4a7c"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97ec057e36ea2e9a4685e5b937bf4a7c">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classsparta_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a97ec057e36ea2e9a4685e5b937bf4a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt;&lt;(): Stream insertion operator  <br /></td></tr>
<tr class="separator:a97ec057e36ea2e9a4685e5b937bf4a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f357b5e4e0fc3586e7de50aee3cc0b" id="r_a96f357b5e4e0fc3586e7de50aee3cc0b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96f357b5e4e0fc3586e7de50aee3cc0b">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classsparta_1_1Tag.html">Tag</a> *tag)</td></tr>
<tr class="memdesc:a96f357b5e4e0fc3586e7de50aee3cc0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt;&lt;(): Stream insertion operator (for <a class="el" href="classsparta_1_1Tag.html" title="Tag(): Simple class to provide nested sequence numbering.">Tag</a> pointers)  <br /></td></tr>
<tr class="separator:a96f357b5e4e0fc3586e7de50aee3cc0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d13fe4f5988a5abaea1f1819f335be" id="r_aa4d13fe4f5988a5abaea1f1819f335be"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4d13fe4f5988a5abaea1f1819f335be">generateUUID</a> ()</td></tr>
<tr class="separator:aa4d13fe4f5988a5abaea1f1819f335be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ee498c9959a2ac816b0e5e15b5c790" id="r_ac6ee498c9959a2ac816b0e5e15b5c790"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , typename... Args, template&lt; typename... &gt; class MapType&gt; </td></tr>
<tr class="memitem:ac6ee498c9959a2ac816b0e5e15b5c790"><td class="memTemplItemLeft" align="right" valign="top">MapType&lt; V, K &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac6ee498c9959a2ac816b0e5e15b5c790">flipMap</a> (const MapType&lt; K, V, Args... &gt; &amp;map)</td></tr>
<tr class="memdesc:ac6ee498c9959a2ac816b0e5e15b5c790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to invert a maps or an unordered_map, or any type of class that has key/value semantics. The variadic template argument is necessary 'cause map/unordered_map don't have just two template parameters.  <br /></td></tr>
<tr class="separator:ac6ee498c9959a2ac816b0e5e15b5c790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed83fab41761c39068128f061bd02007" id="r_aed83fab41761c39068128f061bd02007"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed83fab41761c39068128f061bd02007">isPowerOf2</a> (uint64_t x)</td></tr>
<tr class="memdesc:aed83fab41761c39068128f061bd02007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if input is 0 or a power of 2.  <br /></td></tr>
<tr class="separator:aed83fab41761c39068128f061bd02007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f60aeec01dacb8926a44e7b20203ab" id="r_ac5f60aeec01dacb8926a44e7b20203ab"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac5f60aeec01dacb8926a44e7b20203ab"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac5f60aeec01dacb8926a44e7b20203ab">computeMask</a> (T size, T &amp;lsb_pos)</td></tr>
<tr class="memdesc:ac5f60aeec01dacb8926a44e7b20203ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a maks and the lsb-position given a block size. The mask generated can be AND-ed with any number to get a value rounded down to the nearest multiple of <em>size</em>.  <br /></td></tr>
<tr class="separator:ac5f60aeec01dacb8926a44e7b20203ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92c09501cc8c45c0098a1db8f773073" id="r_ad92c09501cc8c45c0098a1db8f773073"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad92c09501cc8c45c0098a1db8f773073"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad92c09501cc8c45c0098a1db8f773073">computeMaskShift</a> (T size)</td></tr>
<tr class="memdesc:ad92c09501cc8c45c0098a1db8f773073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper around computeMask to get the shift value.  <br /></td></tr>
<tr class="separator:ad92c09501cc8c45c0098a1db8f773073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a2df7a7ca53b2fc0384476286b95ec" id="r_ac0a2df7a7ca53b2fc0384476286b95ec"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0a2df7a7ca53b2fc0384476286b95ec">demangle</a> (const std::string &amp;name) noexcept</td></tr>
<tr class="memdesc:ac0a2df7a7ca53b2fc0384476286b95ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Demangles a C++ symbol.  <br /></td></tr>
<tr class="separator:ac0a2df7a7ca53b2fc0384476286b95ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bc9340188818892abcbd141b40fa50" id="r_a57bc9340188818892abcbd141b40fa50"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a57bc9340188818892abcbd141b40fa50"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a57bc9340188818892abcbd141b40fa50">notNull</a> (T *p)</td></tr>
<tr class="memdesc:a57bc9340188818892abcbd141b40fa50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that a pointer is not null.  <br /></td></tr>
<tr class="separator:a57bc9340188818892abcbd141b40fa50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43ec25e72735ede6e889caf6714ddff" id="r_ab43ec25e72735ede6e889caf6714ddff"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab43ec25e72735ede6e889caf6714ddff">replaceSubstring</a> (std::string &amp;s, const std::string &amp;from, const std::string &amp;to)</td></tr>
<tr class="memdesc:ab43ec25e72735ede6e889caf6714ddff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces within a string 's' all instances of some string 'from' with 'to'.  <br /></td></tr>
<tr class="separator:ab43ec25e72735ede6e889caf6714ddff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5b32e157a4e4df15f8e524bf141008" id="r_a4d5b32e157a4e4df15f8e524bf141008"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d5b32e157a4e4df15f8e524bf141008">copyWithReplace</a> (const std::string &amp;s, char from, const std::string &amp;to)</td></tr>
<tr class="memdesc:a4d5b32e157a4e4df15f8e524bf141008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies from 1 string to another with replacement of a single character with a string.  <br /></td></tr>
<tr class="separator:a4d5b32e157a4e4df15f8e524bf141008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09dd2417814e3e8c904e8375851ee365" id="r_a09dd2417814e3e8c904e8375851ee365"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09dd2417814e3e8c904e8375851ee365">convertCPPStringToPython</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a09dd2417814e3e8c904e8375851ee365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take all of the C++-isms out of a string (like parens, angle brackets, colons, etc) and replace them with an '_'.  <br /></td></tr>
<tr class="separator:a09dd2417814e3e8c904e8375851ee365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b6a7e7f071080f91d35b6625afa0d3" id="r_aa8b6a7e7f071080f91d35b6625afa0d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8b6a7e7f071080f91d35b6625afa0d3">writeNChars</a> (std::ostream &amp;out, uint32_t num, char chr=' ')</td></tr>
<tr class="memdesc:aa8b6a7e7f071080f91d35b6625afa0d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a number of some character into an ostream.  <br /></td></tr>
<tr class="separator:aa8b6a7e7f071080f91d35b6625afa0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51fd0296b8a1f9bc5e6a4ddb69bef69" id="r_ad51fd0296b8a1f9bc5e6a4ddb69bef69"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad51fd0296b8a1f9bc5e6a4ddb69bef69">toLower</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:ad51fd0296b8a1f9bc5e6a4ddb69bef69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a copy of an input string s in lower-case.  <br /></td></tr>
<tr class="separator:ad51fd0296b8a1f9bc5e6a4ddb69bef69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0844196dcdf8258ded48a3c9c334a6d4" id="r_a0844196dcdf8258ded48a3c9c334a6d4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0844196dcdf8258ded48a3c9c334a6d4"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0844196dcdf8258ded48a3c9c334a6d4">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classsparta_1_1AssignOnceObject.html">AssignOnceObject</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:a0844196dcdf8258ded48a3c9c334a6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7b1d29b159e4430934f6d9694d76c51d" id="r_a7b1d29b159e4430934f6d9694d76c51d"><td class="memItemLeft" align="right" valign="top">const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b1d29b159e4430934f6d9694d76c51d">NUM_SCHEDULING_PHASES</a></td></tr>
<tr class="memdesc:a7b1d29b159e4430934f6d9694d76c51d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of phases.  <br /></td></tr>
<tr class="separator:a7b1d29b159e4430934f6d9694d76c51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d79d03050f11d8218ea5365fcefaf6" id="r_a68d79d03050f11d8218ea5365fcefaf6"><td class="memItemLeft" align="right" valign="top"><a id="a68d79d03050f11d8218ea5365fcefaf6" name="a68d79d03050f11d8218ea5365fcefaf6"></a>
static class <a class="el" href="classsparta_1_1SpartaStaticInitializer.html">sparta::SpartaStaticInitializer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_SpartaStaticInitializer</b></td></tr>
<tr class="separator:a68d79d03050f11d8218ea5365fcefaf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Macros for handling exponential backoff. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a31317083691763b0ea542fe5af014293" name="a31317083691763b0ea542fe5af014293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31317083691763b0ea542fe5af014293">&#9670;&#160;</a></span>CycleHistogram</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classsparta_1_1CycleHistogramTreeNode.html">sparta::CycleHistogram</a> = <a class="el" href="classsparta_1_1CycleHistogramTreeNode.html">CycleHistogramTreeNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CycleHistogram_8hpp_source.html#l00796">796</a> of file <a class="el" href="CycleHistogram_8hpp_source.html">CycleHistogram.hpp</a>.</p>

</div>
</div>
<a id="abbc8aa73e74af356fa9ce2071faa5b0e" name="abbc8aa73e74af356fa9ce2071faa5b0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc8aa73e74af356fa9ce2071faa5b0e">&#9670;&#160;</a></span>Histogram</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classsparta_1_1HistogramTreeNode.html">HistogramTreeNode</a> <a class="el" href="classsparta_1_1HistogramTreeNode.html">sparta::Histogram</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Histogram_8hpp_source.html#l00526">526</a> of file <a class="el" href="Histogram_8hpp_source.html">Histogram.hpp</a>.</p>

</div>
</div>
<a id="a3cd097dc2b5ef707ef5837ede254ce24" name="a3cd097dc2b5ef707ef5837ede254ce24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd097dc2b5ef707ef5837ede254ce24">&#9670;&#160;</a></span>HistStatCalcFcn</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using sparta::HistStatCalcFcn = double (*)(const T*)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="HistogramFunctionManager_8hpp_source.html#l00075">75</a> of file <a class="el" href="HistogramFunctionManager_8hpp_source.html">HistogramFunctionManager.hpp</a>.</p>

</div>
</div>
<a id="a46be989638b09a61b66440720d285290" name="a46be989638b09a61b66440720d285290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46be989638b09a61b66440720d285290">&#9670;&#160;</a></span>ProxyDefinitionSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classsparta_1_1____RegisterDefintionSet.html">sparta::ProxyDefinitionSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    __RegisterDefintionSet&lt;sparta::RegisterProxyBase&gt;</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="RegisterDefinitionSet_8hpp_source.html#l00064">64</a> of file <a class="el" href="RegisterDefinitionSet_8hpp_source.html">RegisterDefinitionSet.hpp</a>.</p>

</div>
</div>
<a id="a3b31ac5bb01e672a2e86c64e844fc5f0" name="a3b31ac5bb01e672a2e86c64e844fc5f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b31ac5bb01e672a2e86c64e844fc5f0">&#9670;&#160;</a></span>RegisterDefinitionSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classsparta_1_1____RegisterDefintionSet.html">sparta::RegisterDefinitionSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    __RegisterDefintionSet&lt;sparta::RegisterBase&gt;</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="RegisterDefinitionSet_8hpp_source.html#l00061">61</a> of file <a class="el" href="RegisterDefinitionSet_8hpp_source.html">RegisterDefinitionSet.hpp</a>.</p>

</div>
</div>
<a id="a82f2b856793ff477c6bc5812972dd7e2" name="a82f2b856793ff477c6bc5812972dd7e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f2b856793ff477c6bc5812972dd7e2">&#9670;&#160;</a></span>StateTimerDataContainerPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;std::unordered_map&lt;uint32_t, std::vector&lt;sparta::Clock::Cycle&gt; *&gt; &gt; sparta::StateTimerDataContainerPtr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StateTimerUnit_8hpp_source.html#l00024">24</a> of file <a class="el" href="StateTimerUnit_8hpp_source.html">StateTimerUnit.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a2c04c9473be440ddcb25c2294fe90ec3" name="a2c04c9473be440ddcb25c2294fe90ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c04c9473be440ddcb25c2294fe90ec3">&#9670;&#160;</a></span>ArrayType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a2c04c9473be440ddcb25c2294fe90ec3">sparta::ArrayType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines how a <a class="el" href="classsparta_1_1Array.html" title="Array is essentially a fixed size vector, maintains a concept of validity of its indexes,...">sparta::Array</a> should behave. The array will have different features depending on the type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2c04c9473be440ddcb25c2294fe90ec3a1e23852820b9154316c7c06e2b7ba051" name="a2c04c9473be440ddcb25c2294fe90ec3a1e23852820b9154316c7c06e2b7ba051"></a>NORMAL&#160;</td><td class="fielddoc"><p>The array does NOT allow access or maintain information about age. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2c04c9473be440ddcb25c2294fe90ec3a97be62eb080a8b5fcc3f3f06a80a6cc7" name="a2c04c9473be440ddcb25c2294fe90ec3a97be62eb080a8b5fcc3f3f06a80a6cc7"></a>AGED&#160;</td><td class="fielddoc"><p>The array allows fuctions that require a concept of age in each entry </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00027">27</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="afc3e7ddb8e5c54811105c5ab61112a5b" name="afc3e7ddb8e5c54811105c5ab61112a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc3e7ddb8e5c54811105c5ab61112a5b">&#9670;&#160;</a></span>ByteOrder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#afc3e7ddb8e5c54811105c5ab61112a5b">sparta::ByteOrder</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Byte order enum for read/write methods. </p>
<p>Example 32 Byte register layout which can be accessed as smaller types by index. Layout in memory is unaware of byte-order. Read/Write methods dictate the storage.</p>
<p>The following shows how the value index offset and access sizes map to some data in memory. </p><pre class="fragment">* MEMORY   addr: 0x 0     2     4     6     8     a     c     e     10    12    14    16    18    1a    1c    1e    20
*                   [- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 32 -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- )
*                   [- -- -- -- -- -- -- -- 16 -- -- -- -- -- -- -- )                       ,                       ,
*                   [- -- -- -- 8- -- -- -- )                                                                       ,
*                   [- -- 4- -- )           ,                       ,                       ,                       ,
*                   [- 2- )                                                                                         ,
*                   [- )        .           ,           .           ,           .           ,           .           ,
*          val: 0x  00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f ,
*
* Little (LE)       ,                                               ,                                               ,
*                   LSB                                             ,                                            MSB,
*  type      idx    ,                                               ,                                               ,
*  uint64_t  0      [- -- -- -- -- -- -- -]                         ,                                               , =&gt; 0x0706050403020100
*  uint64_t  3      ,                                               ,                       [- -- -- -- -- -- -- -] , =&gt; 0x1f1e1d1c1b1a1918
*  uint32_t  0      [- -- -- -]                                     ,                                               , =&gt; 0x03020100
*  uint32_t  1      ,           [- -- -- -]                         ,                                               , =&gt; 0x07060504
*  uint8_t   1      ,  []                                           ,                                               , =&gt; 0x01
*
* Big (BE)          ,                                               ,                                               ,
*                   MSB                                             ,                                            LSB,
*  uint64_t  0      [- -- -- -- -- -- -- -]                         ,                                               , =&gt; 0x0001020304050607
*  uint64_t  3      ,                                               ,                       [- -- -- -- -- -- -- -] m =&gt; 0x18191a1b1c1d1e1f
*  uint8_t   1      ,  []                                           ,                                               , =&gt; 0x01
*
* Bitfield (LE)     ,                                               ,                                               ,
*  07-00            []                                              ,                                               , =&gt; 0x00
*  15-08            ,  []                                           ,                                               , =&gt; 0x01
*  23-16            ,     []                                        ,                                               , =&gt; 0x02
*  31-24            ,        []                                     ,                                               , =&gt; 0x03
*
* </pre> <table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afc3e7ddb8e5c54811105c5ab61112a5bae6d6457742b40b16092846e8e785f3ba" name="afc3e7ddb8e5c54811105c5ab61112a5bae6d6457742b40b16092846e8e785f3ba"></a>BE&#160;</td><td class="fielddoc"><p>Little endian. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ByteOrder_8hpp_source.html#l00073">73</a> of file <a class="el" href="ByteOrder_8hpp_source.html">ByteOrder.hpp</a>.</p>

</div>
</div>
<a id="aeec80d237ace9f07634c3d24c9aed9a0" name="aeec80d237ace9f07634c3d24c9aed9a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec80d237ace9f07634c3d24c9aed9a0">&#9670;&#160;</a></span>SchedulingPhase</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">sparta::SchedulingPhase</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The SchedulingPhases used for events (Tick, Update, PortUpdate, etc) </p>
<p>SchedulingPhase are phases within the SPARTA framework that allow a user to "categorize" events, ports, collection, and updatables into groups for auto-precedence establishment.</p>
<p>The current organization of this framework is UPCaT (Updateables, Ports, Collection, and Tick [incl PostTick]) or more specifically:</p>
<ol type="1">
<li>Updatables are ordered first (<a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0a06933067aafd48425d67bcb01bba5cb6" title="Resources are updated in this phase.">sparta::SchedulingPhase::Update</a>)</li>
<li>Ports, N-Cycle where N &gt; 0, that transfer/append to resources (like pipes, buffers) are updated next (specifically, registered handlers are called) (<a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0a07c70f002c020dbbf271b086039983ee" title="N-cycle Ports are updated in this phase.">sparta::SchedulingPhase::PortUpdate</a>)</li>
<li>Collection for pipeline viewing (<a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0ad15b505cce09406de9f918cb1f8c641c" title="Pipeline collection occurs here.">sparta::SchedulingPhase::Collection</a>)</li>
<li>Tickables, or simulation components that operate on data from updatables and ports. (<a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0a0b3516a5bbb77566f904f9d3877f4710" title="Most operations (combinational logic) occurs in this phase.">sparta::SchedulingPhase::Tick</a>)</li>
<li>Post-tickables, or events fired after all Tick events (<a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0aa98a2c3f64967bd2d16be0f1700e2793" title="Operations such as post-tick pipeline collection occur here.">sparta::SchedulingPhase::PostTick</a>)</li>
</ol>
<p>What happens in the framework is that all <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">Scheduleable</a> objects that are in the <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0a06933067aafd48425d67bcb01bba5cb6" title="Resources are updated in this phase.">SchedulingPhase::Update</a> phase will be organized on the <a class="el" href="classsparta_1_1Scheduler.html" title="A class that lets you schedule events now and in the future.">Scheduler</a> before <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0a07c70f002c020dbbf271b086039983ee" title="N-cycle Ports are updated in this phase.">SchedulingPhase::PortUpdate</a> <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">Scheduleable</a> events, which are before <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0ad15b505cce09406de9f918cb1f8c641c" title="Pipeline collection occurs here.">SchedulingPhase::Collection</a> <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">Scheduleable</a> objects, and so on. Within a specific phase, a modeler can order events as well. For example, two events in the <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0a0b3516a5bbb77566f904f9d3877f4710" title="Most operations (combinational logic) occurs in this phase.">SchedulingPhase::Tick</a> can be ordered using the "&gt;&gt;" operator. See Precedence.h for more information.</p>
<p>For 0-cycle Ports, <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0a07c70f002c020dbbf271b086039983ee" title="N-cycle Ports are updated in this phase.">SchedulingPhase::PortUpdate</a> events occur in the <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0a0b3516a5bbb77566f904f9d3877f4710" title="Most operations (combinational logic) occurs in this phase.">SchedulingPhase::Tick</a> scheduling phase and are ordered with other events also in the <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0a0b3516a5bbb77566f904f9d3877f4710" title="Most operations (combinational logic) occurs in this phase.">SchedulingPhase::Tick</a> scheduling phase. This only happens, however, when precedence is established between the <a class="el" href="classsparta_1_1Port.html" title="The port interface used to bind port types together and defines a port behavior.">Port</a> and that subsequent events. This precedence is established by calling Port::registerConsumerEvent or Port::registerProducingEvent (depending on the <a class="el" href="classsparta_1_1Port.html#a99401d822eb596806a4e431e123fd308" title="The direction of this port.">sparta::Port::Direction</a>). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aeec80d237ace9f07634c3d24c9aed9a0a06933067aafd48425d67bcb01bba5cb6" name="aeec80d237ace9f07634c3d24c9aed9a0a06933067aafd48425d67bcb01bba5cb6"></a>Update&#160;</td><td class="fielddoc"><p>Resources are updated in this phase. </p>
</td></tr>
<tr><td class="fieldname"><a id="aeec80d237ace9f07634c3d24c9aed9a0a07c70f002c020dbbf271b086039983ee" name="aeec80d237ace9f07634c3d24c9aed9a0a07c70f002c020dbbf271b086039983ee"></a>PortUpdate&#160;</td><td class="fielddoc"><p>N-cycle Ports are updated in this phase. </p>
</td></tr>
<tr><td class="fieldname"><a id="aeec80d237ace9f07634c3d24c9aed9a0a75f33789f924a80667bcdf8e195c1a1d" name="aeec80d237ace9f07634c3d24c9aed9a0a75f33789f924a80667bcdf8e195c1a1d"></a>Flush&#160;</td><td class="fielddoc"><p>Phase where flushing of pipelines, etc can occur. </p>
</td></tr>
<tr><td class="fieldname"><a id="aeec80d237ace9f07634c3d24c9aed9a0ad15b505cce09406de9f918cb1f8c641c" name="aeec80d237ace9f07634c3d24c9aed9a0ad15b505cce09406de9f918cb1f8c641c"></a>Collection&#160;</td><td class="fielddoc"><p><a class="el" href="classsparta_1_1Pipeline.html" title="A simple pipeline.">Pipeline</a> collection occurs here. </p>
</td></tr>
<tr><td class="fieldname"><a id="aeec80d237ace9f07634c3d24c9aed9a0a0b3516a5bbb77566f904f9d3877f4710" name="aeec80d237ace9f07634c3d24c9aed9a0a0b3516a5bbb77566f904f9d3877f4710"></a>Tick&#160;</td><td class="fielddoc"><p>Most operations (combinational logic) occurs in this phase. </p>
</td></tr>
<tr><td class="fieldname"><a id="aeec80d237ace9f07634c3d24c9aed9a0aa98a2c3f64967bd2d16be0f1700e2793" name="aeec80d237ace9f07634c3d24c9aed9a0aa98a2c3f64967bd2d16be0f1700e2793"></a>PostTick&#160;</td><td class="fielddoc"><p>Operations such as post-tick pipeline collection occur here. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="SchedulingPhases_8hpp_source.html#l00057">57</a> of file <a class="el" href="SchedulingPhases_8hpp_source.html">SchedulingPhases.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a461a77508c6d89191e6b6149bf9c88f8" name="a461a77508c6d89191e6b6149bf9c88f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a461a77508c6d89191e6b6149bf9c88f8">&#9670;&#160;</a></span>allocate_sparta_shared_pointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointerT , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1SpartaSharedPointer.html">SpartaSharedPointer</a>&lt; PointerT &gt; sparta::allocate_sparta_shared_pointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1SpartaSharedPointerAllocator.html">SpartaSharedPointerAllocator</a>&lt; PointerT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a <a class="el" href="classsparta_1_1SpartaSharedPointer.html" title="Used for garbage collection, will delete the object it points to when all objects are finished using ...">SpartaSharedPointer</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointerT</td><td>The pointer type to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments to the class being instantiated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classsparta_1_1SpartaSharedPointer.html" title="Used for garbage collection, will delete the object it points to when all objects are finished using ...">sparta::SpartaSharedPointer</a> type</dd></dl>
<p>Allocate a <a class="el" href="classsparta_1_1SpartaSharedPointer.html" title="Used for garbage collection, will delete the object it points to when all objects are finished using ...">SpartaSharedPointer</a> using the <a class="el" href="classsparta_1_1SpartaSharedPointerAllocator.html" title="A memory allocator complementing SpartaSharedPointer that reuses old memory.">SpartaSharedPointerAllocator</a> instance found in the PointerT.</p>
<p>See <a class="el" href="classsparta_1_1SpartaSharedPointerAllocator.html" title="A memory allocator complementing SpartaSharedPointer that reuses old memory.">SpartaSharedPointerAllocator</a> for example usage </p>

<p class="definition">Definition at line <a class="el" href="SpartaSharedPointerAllocator_8hpp_source.html#l00488">488</a> of file <a class="el" href="SpartaSharedPointerAllocator_8hpp_source.html">SpartaSharedPointerAllocator.hpp</a>.</p>

</div>
</div>
<a id="a3a81d36884c4c054c170a4b707a2b010" name="a3a81d36884c4c054c170a4b707a2b010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a81d36884c4c054c170a4b707a2b010">&#9670;&#160;</a></span>bind() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Bus.html">Bus</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Bus.html">Bus</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind two buses together. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>First bus to bind to </td></tr>
    <tr><td class="paramname">p2</td><td>Second bus to bind to</td></tr>
  </table>
  </dd>
</dl>
<p>This method will bi-directionally bind two buses together </p>

<p class="definition">Definition at line <a class="el" href="Bus_8hpp_source.html#l00346">346</a> of file <a class="el" href="Bus_8hpp_source.html">Bus.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_a3a81d36884c4c054c170a4b707a2b010_cgraph.png" border="0" usemap="#anamespacesparta_a3a81d36884c4c054c170a4b707a2b010_cgraph" alt=""/></div>
<map name="anamespacesparta_a3a81d36884c4c054c170a4b707a2b010_cgraph" id="anamespacesparta_a3a81d36884c4c054c170a4b707a2b010_cgraph">
<area shape="rect" title="Bind two buses together." alt="" coords="5,31,93,56"/>
<area shape="rect" href="namespacesparta.html#ae0e328d41db963d8fa8d62139d70e960" title="Bind two buses together." alt="" coords="141,31,228,56"/>
<area shape="poly" title=" " alt="" coords="93,41,125,41,125,46,93,46"/>
<area shape="rect" href="classsparta_1_1Bus.html#a87e2bcf029a5ec143359b569bab943e7" title="Bind bus1 to bus2." alt="" coords="276,31,392,56"/>
<area shape="poly" title=" " alt="" coords="229,41,261,41,261,46,229,46"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#abfa3602a9ab827b1351ef8f518c32576" title="Gets the name of this node." alt="" coords="440,5,620,31"/>
<area shape="poly" title=" " alt="" coords="393,33,425,29,425,34,393,39"/>
<area shape="rect" href="classsparta_1_1Bus.html#a4f2d0c49bb361b96024d3bb0ef3ada65" title="Get the ports in this PortSet for the given direction." alt="" coords="459,55,601,80"/>
<area shape="poly" title=" " alt="" coords="393,48,444,54,444,60,393,53"/>
<area shape="rect" href="classsparta_1_1PortSet.html#a5c61be847db017f48430c57c7e7967dc" title="Get the ports in this PortSet for the given direction." alt="" coords="668,55,830,80"/>
<area shape="poly" title=" " alt="" coords="601,65,652,65,652,70,601,70"/>
</map>
</div>

</div>
</div>
<a id="a92d71bce915c66cbed446b388af18273" name="a92d71bce915c66cbed446b388af18273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d71bce915c66cbed446b388af18273">&#9670;&#160;</a></span>bind() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Bus.html">Bus</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Bus.html">Bus</a> *</td>          <td class="paramname"><span class="paramname"><em>p2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind two buses together. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>First bus to bind to </td></tr>
    <tr><td class="paramname">p2</td><td>Second bus to bind to</td></tr>
  </table>
  </dd>
</dl>
<p>This method will bi-directionally bind two buses together </p>

<p class="definition">Definition at line <a class="el" href="Bus_8hpp_source.html#l00369">369</a> of file <a class="el" href="Bus_8hpp_source.html">Bus.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_a92d71bce915c66cbed446b388af18273_cgraph.png" border="0" usemap="#anamespacesparta_a92d71bce915c66cbed446b388af18273_cgraph" alt=""/></div>
<map name="anamespacesparta_a92d71bce915c66cbed446b388af18273_cgraph" id="anamespacesparta_a92d71bce915c66cbed446b388af18273_cgraph">
<area shape="rect" title="Bind two buses together." alt="" coords="5,31,93,56"/>
<area shape="rect" href="namespacesparta.html#ae0e328d41db963d8fa8d62139d70e960" title="Bind two buses together." alt="" coords="141,31,228,56"/>
<area shape="poly" title=" " alt="" coords="93,41,125,41,125,46,93,46"/>
<area shape="rect" href="classsparta_1_1Bus.html#a87e2bcf029a5ec143359b569bab943e7" title="Bind bus1 to bus2." alt="" coords="276,31,392,56"/>
<area shape="poly" title=" " alt="" coords="229,41,261,41,261,46,229,46"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#abfa3602a9ab827b1351ef8f518c32576" title="Gets the name of this node." alt="" coords="440,5,620,31"/>
<area shape="poly" title=" " alt="" coords="393,33,425,29,425,34,393,39"/>
<area shape="rect" href="classsparta_1_1Bus.html#a4f2d0c49bb361b96024d3bb0ef3ada65" title="Get the ports in this PortSet for the given direction." alt="" coords="459,55,601,80"/>
<area shape="poly" title=" " alt="" coords="393,48,444,54,444,60,393,53"/>
<area shape="rect" href="classsparta_1_1PortSet.html#a5c61be847db017f48430c57c7e7967dc" title="Get the ports in this PortSet for the given direction." alt="" coords="668,55,830,80"/>
<area shape="poly" title=" " alt="" coords="601,65,652,65,652,70,601,70"/>
</map>
</div>

</div>
</div>
<a id="a60c17f463617d49a0117e33f5476ebfd" name="a60c17f463617d49a0117e33f5476ebfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c17f463617d49a0117e33f5476ebfd">&#9670;&#160;</a></span>bind() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Bus.html">Bus</a> *</td>          <td class="paramname"><span class="paramname"><em>p1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Bus.html">Bus</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind two buses together. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>First bus to bind to </td></tr>
    <tr><td class="paramname">p2</td><td>Second bus to bind to</td></tr>
  </table>
  </dd>
</dl>
<p>This method will bi-directionally bind two buses together </p>

<p class="definition">Definition at line <a class="el" href="Bus_8hpp_source.html#l00357">357</a> of file <a class="el" href="Bus_8hpp_source.html">Bus.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_a60c17f463617d49a0117e33f5476ebfd_cgraph.png" border="0" usemap="#anamespacesparta_a60c17f463617d49a0117e33f5476ebfd_cgraph" alt=""/></div>
<map name="anamespacesparta_a60c17f463617d49a0117e33f5476ebfd_cgraph" id="anamespacesparta_a60c17f463617d49a0117e33f5476ebfd_cgraph">
<area shape="rect" title="Bind two buses together." alt="" coords="5,31,93,56"/>
<area shape="rect" href="namespacesparta.html#ae0e328d41db963d8fa8d62139d70e960" title="Bind two buses together." alt="" coords="141,31,228,56"/>
<area shape="poly" title=" " alt="" coords="93,41,125,41,125,46,93,46"/>
<area shape="rect" href="classsparta_1_1Bus.html#a87e2bcf029a5ec143359b569bab943e7" title="Bind bus1 to bus2." alt="" coords="276,31,392,56"/>
<area shape="poly" title=" " alt="" coords="229,41,261,41,261,46,229,46"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#abfa3602a9ab827b1351ef8f518c32576" title="Gets the name of this node." alt="" coords="440,5,620,31"/>
<area shape="poly" title=" " alt="" coords="393,33,425,29,425,34,393,39"/>
<area shape="rect" href="classsparta_1_1Bus.html#a4f2d0c49bb361b96024d3bb0ef3ada65" title="Get the ports in this PortSet for the given direction." alt="" coords="459,55,601,80"/>
<area shape="poly" title=" " alt="" coords="393,48,444,54,444,60,393,53"/>
<area shape="rect" href="classsparta_1_1PortSet.html#a5c61be847db017f48430c57c7e7967dc" title="Get the ports in this PortSet for the given direction." alt="" coords="668,55,830,80"/>
<area shape="poly" title=" " alt="" coords="601,65,652,65,652,70,601,70"/>
</map>
</div>

</div>
</div>
<a id="ae0e328d41db963d8fa8d62139d70e960" name="ae0e328d41db963d8fa8d62139d70e960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e328d41db963d8fa8d62139d70e960">&#9670;&#160;</a></span>bind() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Bus.html">Bus</a> *</td>          <td class="paramname"><span class="paramname"><em>p1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Bus.html">Bus</a> *</td>          <td class="paramname"><span class="paramname"><em>p2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind two buses together. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>First bus to bind to </td></tr>
    <tr><td class="paramname">p2</td><td>Second bus to bind to</td></tr>
  </table>
  </dd>
</dl>
<p>This method will bi-directionally bind two buses together </p>

<p class="definition">Definition at line <a class="el" href="Bus_8hpp_source.html#l00333">333</a> of file <a class="el" href="Bus_8hpp_source.html">Bus.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_ae0e328d41db963d8fa8d62139d70e960_cgraph.png" border="0" usemap="#anamespacesparta_ae0e328d41db963d8fa8d62139d70e960_cgraph" alt=""/></div>
<map name="anamespacesparta_ae0e328d41db963d8fa8d62139d70e960_cgraph" id="anamespacesparta_ae0e328d41db963d8fa8d62139d70e960_cgraph">
<area shape="rect" title="Bind two buses together." alt="" coords="5,31,93,56"/>
<area shape="rect" href="classsparta_1_1Bus.html#a87e2bcf029a5ec143359b569bab943e7" title="Bind bus1 to bus2." alt="" coords="141,31,257,56"/>
<area shape="poly" title=" " alt="" coords="93,41,125,41,125,46,93,46"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#abfa3602a9ab827b1351ef8f518c32576" title="Gets the name of this node." alt="" coords="305,5,484,31"/>
<area shape="poly" title=" " alt="" coords="257,33,289,29,290,34,258,39"/>
<area shape="rect" href="classsparta_1_1Bus.html#a4f2d0c49bb361b96024d3bb0ef3ada65" title="Get the ports in this PortSet for the given direction." alt="" coords="324,55,465,80"/>
<area shape="poly" title=" " alt="" coords="258,48,309,54,308,60,257,53"/>
<area shape="rect" href="classsparta_1_1PortSet.html#a5c61be847db017f48430c57c7e7967dc" title="Get the ports in this PortSet for the given direction." alt="" coords="532,55,695,80"/>
<area shape="poly" title=" " alt="" coords="466,65,517,65,517,70,466,70"/>
</map>
</div>

</div>
</div>
<a id="a69f43a41f95790c0025c748fbc0970f3" name="a69f43a41f95790c0025c748fbc0970f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f43a41f95790c0025c748fbc0970f3">&#9670;&#160;</a></span>bind() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Port.html">Port</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Port.html">Port</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind two ports together. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>First port to bind to </td></tr>
    <tr><td class="paramname">p2</td><td>Second port to bind to</td></tr>
  </table>
  </dd>
</dl>
<p>This method will bi-directionally bind two ports together </p>

<p class="definition">Definition at line <a class="el" href="Port_8hpp_source.html#l00680">680</a> of file <a class="el" href="Port_8hpp_source.html">Port.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_a69f43a41f95790c0025c748fbc0970f3_cgraph.png" border="0" usemap="#anamespacesparta_a69f43a41f95790c0025c748fbc0970f3_cgraph" alt=""/></div>
<map name="anamespacesparta_a69f43a41f95790c0025c748fbc0970f3_cgraph" id="anamespacesparta_a69f43a41f95790c0025c748fbc0970f3_cgraph">
<area shape="rect" title="Bind two ports together." alt="" coords="5,31,93,56"/>
<area shape="rect" href="namespacesparta.html#ae0e328d41db963d8fa8d62139d70e960" title="Bind two buses together." alt="" coords="141,31,228,56"/>
<area shape="poly" title=" " alt="" coords="93,41,125,41,125,46,93,46"/>
<area shape="rect" href="classsparta_1_1Bus.html#a87e2bcf029a5ec143359b569bab943e7" title="Bind bus1 to bus2." alt="" coords="276,31,392,56"/>
<area shape="poly" title=" " alt="" coords="229,41,261,41,261,46,229,46"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#abfa3602a9ab827b1351ef8f518c32576" title="Gets the name of this node." alt="" coords="440,5,620,31"/>
<area shape="poly" title=" " alt="" coords="393,33,425,29,425,34,393,39"/>
<area shape="rect" href="classsparta_1_1Bus.html#a4f2d0c49bb361b96024d3bb0ef3ada65" title="Get the ports in this PortSet for the given direction." alt="" coords="459,55,601,80"/>
<area shape="poly" title=" " alt="" coords="393,48,444,54,444,60,393,53"/>
<area shape="rect" href="classsparta_1_1PortSet.html#a5c61be847db017f48430c57c7e7967dc" title="Get the ports in this PortSet for the given direction." alt="" coords="668,55,830,80"/>
<area shape="poly" title=" " alt="" coords="601,65,652,65,652,70,601,70"/>
</map>
</div>

</div>
</div>
<a id="a363b92b9d85e2aae9e2b38b5f1b65e2c" name="a363b92b9d85e2aae9e2b38b5f1b65e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a363b92b9d85e2aae9e2b38b5f1b65e2c">&#9670;&#160;</a></span>bind() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Port.html">Port</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Port.html">Port</a> *</td>          <td class="paramname"><span class="paramname"><em>p2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind two ports together. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>First port to bind to </td></tr>
    <tr><td class="paramname">p2</td><td>Second port to bind to</td></tr>
  </table>
  </dd>
</dl>
<p>This method will bi-directionally bind two ports together </p>

<p class="definition">Definition at line <a class="el" href="Port_8hpp_source.html#l00703">703</a> of file <a class="el" href="Port_8hpp_source.html">Port.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_a363b92b9d85e2aae9e2b38b5f1b65e2c_cgraph.png" border="0" usemap="#anamespacesparta_a363b92b9d85e2aae9e2b38b5f1b65e2c_cgraph" alt=""/></div>
<map name="anamespacesparta_a363b92b9d85e2aae9e2b38b5f1b65e2c_cgraph" id="anamespacesparta_a363b92b9d85e2aae9e2b38b5f1b65e2c_cgraph">
<area shape="rect" title="Bind two ports together." alt="" coords="5,31,93,56"/>
<area shape="rect" href="namespacesparta.html#ae0e328d41db963d8fa8d62139d70e960" title="Bind two buses together." alt="" coords="141,31,228,56"/>
<area shape="poly" title=" " alt="" coords="93,41,125,41,125,46,93,46"/>
<area shape="rect" href="classsparta_1_1Bus.html#a87e2bcf029a5ec143359b569bab943e7" title="Bind bus1 to bus2." alt="" coords="276,31,392,56"/>
<area shape="poly" title=" " alt="" coords="229,41,261,41,261,46,229,46"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#abfa3602a9ab827b1351ef8f518c32576" title="Gets the name of this node." alt="" coords="440,5,620,31"/>
<area shape="poly" title=" " alt="" coords="393,33,425,29,425,34,393,39"/>
<area shape="rect" href="classsparta_1_1Bus.html#a4f2d0c49bb361b96024d3bb0ef3ada65" title="Get the ports in this PortSet for the given direction." alt="" coords="459,55,601,80"/>
<area shape="poly" title=" " alt="" coords="393,48,444,54,444,60,393,53"/>
<area shape="rect" href="classsparta_1_1PortSet.html#a5c61be847db017f48430c57c7e7967dc" title="Get the ports in this PortSet for the given direction." alt="" coords="668,55,830,80"/>
<area shape="poly" title=" " alt="" coords="601,65,652,65,652,70,601,70"/>
</map>
</div>

</div>
</div>
<a id="adeea717c5da6fcb0235c750df8756715" name="adeea717c5da6fcb0235c750df8756715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeea717c5da6fcb0235c750df8756715">&#9670;&#160;</a></span>bind() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Port.html">Port</a> *</td>          <td class="paramname"><span class="paramname"><em>p1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Port.html">Port</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind two ports together. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>First port to bind to </td></tr>
    <tr><td class="paramname">p2</td><td>Second port to bind to</td></tr>
  </table>
  </dd>
</dl>
<p>This method will bi-directionally bind two ports together </p>

<p class="definition">Definition at line <a class="el" href="Port_8hpp_source.html#l00691">691</a> of file <a class="el" href="Port_8hpp_source.html">Port.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_adeea717c5da6fcb0235c750df8756715_cgraph.png" border="0" usemap="#anamespacesparta_adeea717c5da6fcb0235c750df8756715_cgraph" alt=""/></div>
<map name="anamespacesparta_adeea717c5da6fcb0235c750df8756715_cgraph" id="anamespacesparta_adeea717c5da6fcb0235c750df8756715_cgraph">
<area shape="rect" title="Bind two ports together." alt="" coords="5,31,93,56"/>
<area shape="rect" href="namespacesparta.html#ae0e328d41db963d8fa8d62139d70e960" title="Bind two buses together." alt="" coords="141,31,228,56"/>
<area shape="poly" title=" " alt="" coords="93,41,125,41,125,46,93,46"/>
<area shape="rect" href="classsparta_1_1Bus.html#a87e2bcf029a5ec143359b569bab943e7" title="Bind bus1 to bus2." alt="" coords="276,31,392,56"/>
<area shape="poly" title=" " alt="" coords="229,41,261,41,261,46,229,46"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#abfa3602a9ab827b1351ef8f518c32576" title="Gets the name of this node." alt="" coords="440,5,620,31"/>
<area shape="poly" title=" " alt="" coords="393,33,425,29,425,34,393,39"/>
<area shape="rect" href="classsparta_1_1Bus.html#a4f2d0c49bb361b96024d3bb0ef3ada65" title="Get the ports in this PortSet for the given direction." alt="" coords="459,55,601,80"/>
<area shape="poly" title=" " alt="" coords="393,48,444,54,444,60,393,53"/>
<area shape="rect" href="classsparta_1_1PortSet.html#a5c61be847db017f48430c57c7e7967dc" title="Get the ports in this PortSet for the given direction." alt="" coords="668,55,830,80"/>
<area shape="poly" title=" " alt="" coords="601,65,652,65,652,70,601,70"/>
</map>
</div>

</div>
</div>
<a id="a0fb3d186a623f8a7169ee63d719652fa" name="a0fb3d186a623f8a7169ee63d719652fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fb3d186a623f8a7169ee63d719652fa">&#9670;&#160;</a></span>bind() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Port.html">Port</a> *</td>          <td class="paramname"><span class="paramname"><em>p1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Port.html">Port</a> *</td>          <td class="paramname"><span class="paramname"><em>p2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind two ports together. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>First port to bind to </td></tr>
    <tr><td class="paramname">p2</td><td>Second port to bind to</td></tr>
  </table>
  </dd>
</dl>
<p>This method will bi-directionally bind two ports together </p>

<p class="definition">Definition at line <a class="el" href="Port_8hpp_source.html#l00667">667</a> of file <a class="el" href="Port_8hpp_source.html">Port.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_a0fb3d186a623f8a7169ee63d719652fa_cgraph.png" border="0" usemap="#anamespacesparta_a0fb3d186a623f8a7169ee63d719652fa_cgraph" alt=""/></div>
<map name="anamespacesparta_a0fb3d186a623f8a7169ee63d719652fa_cgraph" id="anamespacesparta_a0fb3d186a623f8a7169ee63d719652fa_cgraph">
<area shape="rect" title="Bind two ports together." alt="" coords="5,5,93,31"/>
<area shape="rect" href="classsparta_1_1Port.html#a92472c136101d56f2773a3c03689e25f" title="Method to bind this Port to another, pointer style." alt="" coords="141,5,258,31"/>
<area shape="poly" title=" " alt="" coords="93,16,125,16,125,21,93,21"/>
</map>
</div>

</div>
</div>
<a id="acf8ded913a7bae431e53cfe61ccd02c5" name="acf8ded913a7bae431e53cfe61ccd02c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf8ded913a7bae431e53cfe61ccd02c5">&#9670;&#160;</a></span>byte_swap() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t sparta::byte_swap </td>
          <td>(</td>
          <td class="paramtype">int16_t</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ByteOrder_8hpp_source.html#l00109">109</a> of file <a class="el" href="ByteOrder_8hpp_source.html">ByteOrder.hpp</a>.</p>

</div>
</div>
<a id="a3aa636c5313d0dc8a45c6b31a67d62a7" name="a3aa636c5313d0dc8a45c6b31a67d62a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa636c5313d0dc8a45c6b31a67d62a7">&#9670;&#160;</a></span>byte_swap() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t sparta::byte_swap </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ByteOrder_8hpp_source.html#l00121">121</a> of file <a class="el" href="ByteOrder_8hpp_source.html">ByteOrder.hpp</a>.</p>

</div>
</div>
<a id="a7cc08de39a273bd675704153aff49cd1" name="a7cc08de39a273bd675704153aff49cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc08de39a273bd675704153aff49cd1">&#9670;&#160;</a></span>byte_swap() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t sparta::byte_swap </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ByteOrder_8hpp_source.html#l00133">133</a> of file <a class="el" href="ByteOrder_8hpp_source.html">ByteOrder.hpp</a>.</p>

</div>
</div>
<a id="af414ec44370bc7ba08017d820f8e5eeb" name="af414ec44370bc7ba08017d820f8e5eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af414ec44370bc7ba08017d820f8e5eeb">&#9670;&#160;</a></span>byte_swap() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int8_t sparta::byte_swap </td>
          <td>(</td>
          <td class="paramtype">int8_t</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ByteOrder_8hpp_source.html#l00097">97</a> of file <a class="el" href="ByteOrder_8hpp_source.html">ByteOrder.hpp</a>.</p>

</div>
</div>
<a id="a17970a38d3054bdd50ce337e22a35679" name="a17970a38d3054bdd50ce337e22a35679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17970a38d3054bdd50ce337e22a35679">&#9670;&#160;</a></span>byte_swap() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_integral&lt; T &gt;::value, T &gt;::type sparta::byte_swap </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the order of bytes for various types. </p>

<p class="definition">Definition at line <a class="el" href="ByteOrder_8hpp_source.html#l00083">83</a> of file <a class="el" href="ByteOrder_8hpp_source.html">ByteOrder.hpp</a>.</p>

</div>
</div>
<a id="a8e2f845f27a62283b1be039369b7ff03" name="a8e2f845f27a62283b1be039369b7ff03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2f845f27a62283b1be039369b7ff03">&#9670;&#160;</a></span>byte_swap() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t sparta::byte_swap </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ByteOrder_8hpp_source.html#l00103">103</a> of file <a class="el" href="ByteOrder_8hpp_source.html">ByteOrder.hpp</a>.</p>

</div>
</div>
<a id="a3a987e3429a78cd6229a3972a351e2c1" name="a3a987e3429a78cd6229a3972a351e2c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a987e3429a78cd6229a3972a351e2c1">&#9670;&#160;</a></span>byte_swap() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sparta::byte_swap </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ByteOrder_8hpp_source.html#l00115">115</a> of file <a class="el" href="ByteOrder_8hpp_source.html">ByteOrder.hpp</a>.</p>

</div>
</div>
<a id="ae4e68957a8846e82ff315cd3d5e1ee9e" name="ae4e68957a8846e82ff315cd3d5e1ee9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e68957a8846e82ff315cd3d5e1ee9e">&#9670;&#160;</a></span>byte_swap() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t sparta::byte_swap </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ByteOrder_8hpp_source.html#l00127">127</a> of file <a class="el" href="ByteOrder_8hpp_source.html">ByteOrder.hpp</a>.</p>

</div>
</div>
<a id="ae7a1cd4b597a68600a258747569d784c" name="ae7a1cd4b597a68600a258747569d784c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7a1cd4b597a68600a258747569d784c">&#9670;&#160;</a></span>byte_swap() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t sparta::byte_swap </td>
          <td>(</td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ByteOrder_8hpp_source.html#l00091">91</a> of file <a class="el" href="ByteOrder_8hpp_source.html">ByteOrder.hpp</a>.</p>

</div>
</div>
<a id="a3650b902d4a6387060e3944d55c6a788" name="a3650b902d4a6387060e3944d55c6a788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3650b902d4a6387060e3944d55c6a788">&#9670;&#160;</a></span>calculateClockCrossingDelay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Scheduler.html#a2c6114226a2d41fb22ac0395520b56c3">Scheduler::Tick</a> sparta::calculateClockCrossingDelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Scheduler.html#a2c6114226a2d41fb22ac0395520b56c3">Scheduler::Tick</a></td>          <td class="paramname"><span class="paramname"><em>src_delay</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1Clock.html">Clock</a> *</td>          <td class="paramname"><span class="paramname"><em>src_clk</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Scheduler.html#a2c6114226a2d41fb22ac0395520b56c3">Scheduler::Tick</a></td>          <td class="paramname"><span class="paramname"><em>dst_delay</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1Clock.html">Clock</a> *</td>          <td class="paramname"><span class="paramname"><em>dst_clk</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Clock_8hpp_source.html#l00371">371</a> of file <a class="el" href="Clock_8hpp_source.html">Clock.hpp</a>.</p>

</div>
</div>
<a id="a2b75372dc50607a3217873eecffaa2b1" name="a2b75372dc50607a3217873eecffaa2b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b75372dc50607a3217873eecffaa2b1">&#9670;&#160;</a></span>calculateReverseClockCrossingDelay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Scheduler.html#a2c6114226a2d41fb22ac0395520b56c3">Scheduler::Tick</a> sparta::calculateReverseClockCrossingDelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Scheduler.html#a2c6114226a2d41fb22ac0395520b56c3">Scheduler::Tick</a></td>          <td class="paramname"><span class="paramname"><em>dst_arrival_tick</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Scheduler.html#a2c6114226a2d41fb22ac0395520b56c3">Scheduler::Tick</a></td>          <td class="paramname"><span class="paramname"><em>src_delay</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1Clock.html">Clock</a> *</td>          <td class="paramname"><span class="paramname"><em>src_clk</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Scheduler.html#a2c6114226a2d41fb22ac0395520b56c3">Scheduler::Tick</a></td>          <td class="paramname"><span class="paramname"><em>dst_delay</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1Clock.html">Clock</a> *</td>          <td class="paramname"><span class="paramname"><em>dst_clk</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Clock_8hpp_source.html#l00430">430</a> of file <a class="el" href="Clock_8hpp_source.html">Clock.hpp</a>.</p>

</div>
</div>
<a id="ac5f60aeec01dacb8926a44e7b20203ab" name="ac5f60aeec01dacb8926a44e7b20203ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f60aeec01dacb8926a44e7b20203ab">&#9670;&#160;</a></span>computeMask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T sparta::computeMask </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>lsb_pos</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a maks and the lsb-position given a block size. The mask generated can be AND-ed with any number to get a value rounded down to the nearest multiple of <em>size</em>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of value to compute mask for. Expected to be uint[XX]_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size for which the mask and lsbshould be computed. </td></tr>
    <tr><td class="paramname">lsb_pos</td><td>Bit position of lsb in mask. A value can be shifted right by this amount to effectively get a "block index" which is the <em>mask</em> / <em>size</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mask computed as described</dd></dl>
<p>If size = 0, lsb_pos is number of bits in <em>T</em> and mask returned is 0. </p>

<p class="definition">Definition at line <a class="el" href="Utils_8hpp_source.html#l00171">171</a> of file <a class="el" href="Utils_8hpp_source.html">Utils.hpp</a>.</p>

</div>
</div>
<a id="ad92c09501cc8c45c0098a1db8f773073" name="ad92c09501cc8c45c0098a1db8f773073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad92c09501cc8c45c0098a1db8f773073">&#9670;&#160;</a></span>computeMaskShift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T sparta::computeMaskShift </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience wrapper around computeMask to get the shift value. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac5f60aeec01dacb8926a44e7b20203ab" title="Computes a maks and the lsb-position given a block size. The mask generated can be AND-ed with any nu...">computeMask</a></dd></dl>
<p>This exists so that the shift can be computed in a constructor initialization list. </p>

<p class="definition">Definition at line <a class="el" href="Utils_8hpp_source.html#l00198">198</a> of file <a class="el" href="Utils_8hpp_source.html">Utils.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_ad92c09501cc8c45c0098a1db8f773073_cgraph.png" border="0" usemap="#anamespacesparta_ad92c09501cc8c45c0098a1db8f773073_cgraph" alt=""/></div>
<map name="anamespacesparta_ad92c09501cc8c45c0098a1db8f773073_cgraph" id="anamespacesparta_ad92c09501cc8c45c0098a1db8f773073_cgraph">
<area shape="rect" title="Convenience wrapper around computeMask to get the shift value." alt="" coords="5,5,178,31"/>
<area shape="rect" href="namespacesparta.html#ac5f60aeec01dacb8926a44e7b20203ab" title="Computes a maks and the lsb&#45;position given a block size. The mask generated can be AND&#45;ed with any nu..." alt="" coords="226,5,371,31"/>
<area shape="poly" title=" " alt="" coords="178,16,210,16,210,21,178,21"/>
</map>
</div>

</div>
</div>
<a id="a09dd2417814e3e8c904e8375851ee365" name="a09dd2417814e3e8c904e8375851ee365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09dd2417814e3e8c904e8375851ee365">&#9670;&#160;</a></span>convertCPPStringToPython()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string sparta::convertCPPStringToPython </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take all of the C++-isms out of a string (like parens, angle brackets, colons, etc) and replace them with an '_'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string to clean up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cleaned up string </dd></dl>

<p class="definition">Definition at line <a class="el" href="Utils_8hpp_source.html#l00318">318</a> of file <a class="el" href="Utils_8hpp_source.html">Utils.hpp</a>.</p>

</div>
</div>
<a id="a4d5b32e157a4e4df15f8e524bf141008" name="a4d5b32e157a4e4df15f8e524bf141008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5b32e157a4e4df15f8e524bf141008">&#9670;&#160;</a></span>copyWithReplace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string sparta::copyWithReplace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>to</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies from 1 string to another with replacement of a single character with a string. </p>
<p>Result should be moved if possible </p>

<p class="definition">Definition at line <a class="el" href="Utils_8hpp_source.html#l00293">293</a> of file <a class="el" href="Utils_8hpp_source.html">Utils.hpp</a>.</p>

</div>
</div>
<a id="ac0a2df7a7ca53b2fc0384476286b95ec" name="ac0a2df7a7ca53b2fc0384476286b95ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a2df7a7ca53b2fc0384476286b95ec">&#9670;&#160;</a></span>demangle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string sparta::demangle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Demangles a C++ symbol. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Name</td><td>Symbol name to demangle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Demangled name if successful. If failed, returns the input name. Note that demangled names may match input name. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Demangling is limited by DEMANGLE_BUF_LENGTH. results may be truncated or fail for very symbols. Change this value to support longer symbol names. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Utils_8hpp_source.html#l00214">214</a> of file <a class="el" href="Utils_8hpp_source.html">Utils.hpp</a>.</p>

</div>
</div>
<a id="ac6ee498c9959a2ac816b0e5e15b5c790" name="ac6ee498c9959a2ac816b0e5e15b5c790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ee498c9959a2ac816b0e5e15b5c790">&#9670;&#160;</a></span>flipMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , typename... Args, template&lt; typename... &gt; class MapType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MapType&lt; V, K &gt; sparta::flipMap </td>
          <td>(</td>
          <td class="paramtype">const MapType&lt; K, V, Args... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>map</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to invert a maps or an unordered_map, or any type of class that has key/value semantics. The variadic template argument is necessary 'cause map/unordered_map don't have just two template parameters. </p>

<p class="definition">Definition at line <a class="el" href="Utils_8hpp_source.html#l00104">104</a> of file <a class="el" href="Utils_8hpp_source.html">Utils.hpp</a>.</p>

</div>
</div>
<a id="aa4d13fe4f5988a5abaea1f1819f335be" name="aa4d13fe4f5988a5abaea1f1819f335be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d13fe4f5988a5abaea1f1819f335be">&#9670;&#160;</a></span>generateUUID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string sparta::generateUUID </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Utils_8hpp_source.html#l00090">90</a> of file <a class="el" href="Utils_8hpp_source.html">Utils.hpp</a>.</p>

</div>
</div>
<a id="aa00e205d913fa86f8cfc54f60819c63b" name="aa00e205d913fa86f8cfc54f60819c63b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa00e205d913fa86f8cfc54f60819c63b">&#9670;&#160;</a></span>GetFeatureOptions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; T, <a class="el" href="classsparta_1_1app_1_1FeatureConfiguration.html">app::FeatureConfiguration</a> &gt;::value, constapp::FeatureConfiguration::FeatureOptions * &gt;::type sparta::GetFeatureOptions </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>cfg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>feature_name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility in the sparta namespace that gets the named FeatureOptions object from a FeatureConfiguration set </p>

<p class="definition">Definition at line <a class="el" href="FeatureConfiguration_8hpp_source.html#l00308">308</a> of file <a class="el" href="FeatureConfiguration_8hpp_source.html">FeatureConfiguration.hpp</a>.</p>

</div>
</div>
<a id="aeffd5171f220fcc45b2c82f8bc498fcd" name="aeffd5171f220fcc45b2c82f8bc498fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeffd5171f220fcc45b2c82f8bc498fcd">&#9670;&#160;</a></span>GetFeatureOptions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structMetaStruct_1_1is__any__pointer.html">MetaStruct::is_any_pointer</a>&lt; T &gt;::value, constapp::FeatureConfiguration::FeatureOptions * &gt;::type sparta::GetFeatureOptions </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>cfg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>feature_name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility in the sparta namespace which gets the named FeatureOptions object from a FeatureConfiguration which may be null </p>

<p class="definition">Definition at line <a class="el" href="FeatureConfiguration_8hpp_source.html#l00320">320</a> of file <a class="el" href="FeatureConfiguration_8hpp_source.html">FeatureConfiguration.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_aeffd5171f220fcc45b2c82f8bc498fcd_cgraph.png" border="0" usemap="#anamespacesparta_aeffd5171f220fcc45b2c82f8bc498fcd_cgraph" alt=""/></div>
<map name="anamespacesparta_aeffd5171f220fcc45b2c82f8bc498fcd_cgraph" id="anamespacesparta_aeffd5171f220fcc45b2c82f8bc498fcd_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,179,31"/>
<area shape="rect" href="namespacesparta.html#aa00e205d913fa86f8cfc54f60819c63b" title=" " alt="" coords="227,5,400,31"/>
<area shape="poly" title=" " alt="" coords="179,16,211,16,211,21,179,21"/>
</map>
</div>

</div>
</div>
<a id="aa88bd65ffebee073443491fd711ae7f5" name="aa88bd65ffebee073443491fd711ae7f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa88bd65ffebee073443491fd711ae7f5">&#9670;&#160;</a></span>getHumanReadableHistogramBinNames() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MetaStruct::enable_if_t&lt; not <a class="el" href="structsparta_1_1is__sparta__enum.html">sparta::is_sparta_enum</a>&lt; U &gt;::value and not <a class="el" href="structsparta_1_1utils_1_1has__ostream__operator.html">sparta::utils::has_ostream_operator</a>&lt; U &gt;::value, void &gt; sparta::getHumanReadableHistogramBinNames </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an enum class type, this method figures out the string. </p>

<p class="definition">Definition at line <a class="el" href="EnumCycleHistogram_8hpp_source.html#l00072">72</a> of file <a class="el" href="EnumCycleHistogram_8hpp_source.html">EnumCycleHistogram.hpp</a>.</p>

</div>
</div>
<a id="a6379e6669e33ed5fe30711ca4a75f539" name="a6379e6669e33ed5fe30711ca4a75f539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6379e6669e33ed5fe30711ca4a75f539">&#9670;&#160;</a></span>getHumanReadableHistogramBinNames() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MetaStruct::enable_if_t&lt; not <a class="el" href="structsparta_1_1is__sparta__enum.html">sparta::is_sparta_enum</a>&lt; U &gt;::value and <a class="el" href="structsparta_1_1utils_1_1has__ostream__operator.html">sparta::utils::has_ostream_operator</a>&lt; U &gt;::value, void &gt; sparta::getHumanReadableHistogramBinNames </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>enum_name_strings</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an enum class type, this method figures out the string. </p>

<p class="definition">Definition at line <a class="el" href="EnumCycleHistogram_8hpp_source.html#l00049">49</a> of file <a class="el" href="EnumCycleHistogram_8hpp_source.html">EnumCycleHistogram.hpp</a>.</p>

</div>
</div>
<a id="aa418c36248e0d9c823fddb6ae03eeec0" name="aa418c36248e0d9c823fddb6ae03eeec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa418c36248e0d9c823fddb6ae03eeec0">&#9670;&#160;</a></span>getHumanReadableHistogramBinNames() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MetaStruct::enable_if_t&lt; <a class="el" href="structsparta_1_1is__sparta__enum.html">sparta::is_sparta_enum</a>&lt; U &gt;::value, void &gt; sparta::getHumanReadableHistogramBinNames </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>enum_name_strings</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an enum class type, this method figures out the string. </p>

<p class="definition">Definition at line <a class="el" href="EnumCycleHistogram_8hpp_source.html#l00079">79</a> of file <a class="el" href="EnumCycleHistogram_8hpp_source.html">EnumCycleHistogram.hpp</a>.</p>

</div>
</div>
<a id="af5a63fdacb399754c6ceb02f4273c119" name="af5a63fdacb399754c6ceb02f4273c119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a63fdacb399754c6ceb02f4273c119">&#9670;&#160;</a></span>IsFeatureValueEnabled() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; T, <a class="el" href="classsparta_1_1app_1_1FeatureConfiguration.html">app::FeatureConfiguration</a> &gt;::value, bool &gt;::type sparta::IsFeatureValueEnabled </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>cfg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>feature_name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility in the sparta namespace that checks if a feature value has been set to any positive number (0=disabled, &gt;0=enabled) </p>

<p class="definition">Definition at line <a class="el" href="FeatureConfiguration_8hpp_source.html#l00281">281</a> of file <a class="el" href="FeatureConfiguration_8hpp_source.html">FeatureConfiguration.hpp</a>.</p>

</div>
</div>
<a id="a61273cc42cec96de6d2bf39a79d96055" name="a61273cc42cec96de6d2bf39a79d96055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61273cc42cec96de6d2bf39a79d96055">&#9670;&#160;</a></span>IsFeatureValueEnabled() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structMetaStruct_1_1is__any__pointer.html">MetaStruct::is_any_pointer</a>&lt; T &gt;::value, bool &gt;::type sparta::IsFeatureValueEnabled </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>cfg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>feature_name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility in the sparta namespace that asks a FeatureConfiguration if the provided feature is enabled, for a FeatureConfiguration that may be null </p>

<p class="definition">Definition at line <a class="el" href="FeatureConfiguration_8hpp_source.html#l00295">295</a> of file <a class="el" href="FeatureConfiguration_8hpp_source.html">FeatureConfiguration.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_a61273cc42cec96de6d2bf39a79d96055_cgraph.png" border="0" usemap="#anamespacesparta_a61273cc42cec96de6d2bf39a79d96055_cgraph" alt=""/></div>
<map name="anamespacesparta_a61273cc42cec96de6d2bf39a79d96055_cgraph" id="anamespacesparta_a61273cc42cec96de6d2bf39a79d96055_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,203,31"/>
<area shape="rect" href="namespacesparta.html#af5a63fdacb399754c6ceb02f4273c119" title=" " alt="" coords="251,5,448,31"/>
<area shape="poly" title=" " alt="" coords="203,16,235,16,235,21,203,21"/>
</map>
</div>

</div>
</div>
<a id="a1be764ebc8eb8aa6927969df96a8a98b" name="a1be764ebc8eb8aa6927969df96a8a98b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1be764ebc8eb8aa6927969df96a8a98b">&#9670;&#160;</a></span>IsFeatureValueEqualTo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; T, <a class="el" href="classsparta_1_1app_1_1FeatureConfiguration.html">app::FeatureConfiguration</a> &gt;::value, bool &gt;::type sparta::IsFeatureValueEqualTo </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>cfg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>feature_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int</td>          <td class="paramname"><span class="paramname"><em>feature_value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility in the sparta namespace that checks a FeatureConfiguration for a specific feature's current value (typically 1=enabled, and 0=disabled, but there could be more feature values too) </p>

<p class="definition">Definition at line <a class="el" href="FeatureConfiguration_8hpp_source.html#l00253">253</a> of file <a class="el" href="FeatureConfiguration_8hpp_source.html">FeatureConfiguration.hpp</a>.</p>

</div>
</div>
<a id="a6a3415f00abe48816ec2f28eb2507539" name="a6a3415f00abe48816ec2f28eb2507539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a3415f00abe48816ec2f28eb2507539">&#9670;&#160;</a></span>IsFeatureValueEqualTo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structMetaStruct_1_1is__any__pointer.html">MetaStruct::is_any_pointer</a>&lt; T &gt;::value, bool &gt;::type sparta::IsFeatureValueEqualTo </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>cfg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>feature_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int</td>          <td class="paramname"><span class="paramname"><em>feature_value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility in the sparta namespace that checks for a FeatureConfiguration value, with a FeatureConfiguration that may be null </p>

<p class="definition">Definition at line <a class="el" href="FeatureConfiguration_8hpp_source.html#l00267">267</a> of file <a class="el" href="FeatureConfiguration_8hpp_source.html">FeatureConfiguration.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_a6a3415f00abe48816ec2f28eb2507539_cgraph.png" border="0" usemap="#anamespacesparta_a6a3415f00abe48816ec2f28eb2507539_cgraph" alt=""/></div>
<map name="anamespacesparta_a6a3415f00abe48816ec2f28eb2507539_cgraph" id="anamespacesparta_a6a3415f00abe48816ec2f28eb2507539_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,204,31"/>
<area shape="rect" href="namespacesparta.html#a1be764ebc8eb8aa6927969df96a8a98b" title=" " alt="" coords="252,5,450,31"/>
<area shape="poly" title=" " alt="" coords="204,16,236,16,236,21,204,21"/>
</map>
</div>

</div>
</div>
<a id="aed83fab41761c39068128f061bd02007" name="aed83fab41761c39068128f061bd02007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed83fab41761c39068128f061bd02007">&#9670;&#160;</a></span>isPowerOf2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::isPowerOf2 </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if input is 0 or a power of 2. </p>
<dl class="section return"><dt>Returns</dt><dd>true if number is 0 or a power of 2 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Counting set bits is likely the fastest way to do this, though it probably doesn't make a difference if this is just used for checking register sizes during initialization. \warn Do not use this method in performance-critical code until it is faster. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Utils_8hpp_source.html#l00153">153</a> of file <a class="el" href="Utils_8hpp_source.html">Utils.hpp</a>.</p>

</div>
</div>
<a id="a1aa849f3d6b47a500f3c110e6b33849c" name="a1aa849f3d6b47a500f3c110e6b33849c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa849f3d6b47a500f3c110e6b33849c">&#9670;&#160;</a></span>lexicalCast() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string sparta::lexicalCast </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LexicalCast_8hpp_source.html#l00100">100</a> of file <a class="el" href="LexicalCast_8hpp_source.html">LexicalCast.hpp</a>.</p>

</div>
</div>
<a id="a1cf3eceb958516aee139b92f44dbaad8" name="a1cf3eceb958516aee139b92f44dbaad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf3eceb958516aee139b92f44dbaad8">&#9670;&#160;</a></span>lexicalCast() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::lexicalCast </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LexicalCast_8hpp_source.html#l00106">106</a> of file <a class="el" href="LexicalCast_8hpp_source.html">LexicalCast.hpp</a>.</p>

</div>
</div>
<a id="a9662fa9521b5b0a77276dd54cbe98b4a" name="a9662fa9521b5b0a77276dd54cbe98b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9662fa9521b5b0a77276dd54cbe98b4a">&#9670;&#160;</a></span>lexicalCast() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t sparta::lexicalCast </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LexicalCast_8hpp_source.html#l00130">130</a> of file <a class="el" href="LexicalCast_8hpp_source.html">LexicalCast.hpp</a>.</p>

</div>
</div>
<a id="a9608e0cb0d8d4fb8c2d2ef2996e29ede" name="a9608e0cb0d8d4fb8c2d2ef2996e29ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9608e0cb0d8d4fb8c2d2ef2996e29ede">&#9670;&#160;</a></span>lexicalCast() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t sparta::lexicalCast </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LexicalCast_8hpp_source.html#l00144">144</a> of file <a class="el" href="LexicalCast_8hpp_source.html">LexicalCast.hpp</a>.</p>

</div>
</div>
<a id="a03b6c08989d9e77a8ddbd05ef263ac2b" name="a03b6c08989d9e77a8ddbd05ef263ac2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03b6c08989d9e77a8ddbd05ef263ac2b">&#9670;&#160;</a></span>lexicalCast() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sparta::lexicalCast </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LexicalCast_8hpp_source.html#l00158">158</a> of file <a class="el" href="LexicalCast_8hpp_source.html">LexicalCast.hpp</a>.</p>

</div>
</div>
<a id="a494f59e2ad2807b56495452f4ff550ea" name="a494f59e2ad2807b56495452f4ff550ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a494f59e2ad2807b56495452f4ff550ea">&#9670;&#160;</a></span>lexicalCast() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t sparta::lexicalCast </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LexicalCast_8hpp_source.html#l00176">176</a> of file <a class="el" href="LexicalCast_8hpp_source.html">LexicalCast.hpp</a>.</p>

</div>
</div>
<a id="a9e3349bd0261eafc0405eca4437e5296" name="a9e3349bd0261eafc0405eca4437e5296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e3349bd0261eafc0405eca4437e5296">&#9670;&#160;</a></span>lexicalCast() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T sparta::lexicalCast </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>base</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cast string to T where T is either ValueType or (if ValueType is a vector) a vector's value_type.</p>
<p>boost::lexical_cast and ios_base::operator&gt;&gt; fail to determine type of an integer literal. For example, 0xdeadbeef is blindly interpreted as 0 with leftover characters. 070 is interpreted as decimal 70.</p>
<p>This attempts to interpret hex and octal in addition to decimal, and string values. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a></td><td>if cast fails. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="LexicalCast_8hpp_source.html#l00079">79</a> of file <a class="el" href="LexicalCast_8hpp_source.html">LexicalCast.hpp</a>.</p>

</div>
</div>
<a id="ac0aa7dffa010a4ea365cbc3292862b05" name="ac0aa7dffa010a4ea365cbc3292862b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0aa7dffa010a4ea365cbc3292862b05">&#9670;&#160;</a></span>lexicalCast() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MetaStruct::enable_if_t&lt; <a class="el" href="structMetaStruct_1_1is__stl.html">MetaStruct::is_stl</a>&lt; T &gt;::value and std::is_same&lt; typename T::value_type, bool &gt;::value, T &gt; sparta::lexicalCast </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>base</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cast string to T where T is either ValueType or (if ValueType is a vector) a vector's value_type.</p>
<p>boost::lexical_cast and ios_base::operator&gt;&gt; fail to determine type of an integer literal. For example, 0xdeadbeef is blindly interpreted as 0 with leftover characters. 070 is interpreted as decimal 70.</p>
<p>This attempts to interpret hex and octal in addition to decimal, and string values. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a></td><td>if cast fails. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="LexicalCast_8hpp_source.html#l00079">79</a> of file <a class="el" href="LexicalCast_8hpp_source.html">LexicalCast.hpp</a>.</p>

</div>
</div>
<a id="a57bc9340188818892abcbd141b40fa50" name="a57bc9340188818892abcbd141b40fa50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57bc9340188818892abcbd141b40fa50">&#9670;&#160;</a></span>notNull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * sparta::notNull </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that a pointer is not null. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>p unless exception is thrown </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a></td><td>if pointer is null.</td></tr>
  </table>
  </dd>
</dl>
<p>Useful for checking for null in constructor initializer lists which refer to members through object pointers. </p>

<p class="definition">Definition at line <a class="el" href="Utils_8hpp_source.html#l00235">235</a> of file <a class="el" href="Utils_8hpp_source.html">Utils.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_a57bc9340188818892abcbd141b40fa50_cgraph.png" border="0" usemap="#anamespacesparta_a57bc9340188818892abcbd141b40fa50_cgraph" alt=""/></div>
<map name="anamespacesparta_a57bc9340188818892abcbd141b40fa50_cgraph" id="anamespacesparta_a57bc9340188818892abcbd141b40fa50_cgraph">
<area shape="rect" title="Ensures that a pointer is not null." alt="" coords="5,5,110,31"/>
<area shape="rect" href="namespacesparta.html#ac0a2df7a7ca53b2fc0384476286b95ec" title="Demangles a C++ symbol." alt="" coords="158,5,277,31"/>
<area shape="poly" title=" " alt="" coords="110,16,142,16,142,21,110,21"/>
</map>
</div>

</div>
</div>
<a id="a686b73cac0940a378e3dba4bcdcac07b" name="a686b73cac0940a378e3dba4bcdcac07b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a686b73cac0940a378e3dba4bcdcac07b">&#9670;&#160;</a></span>numDecDigits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sparta::numDecDigits </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets number of decimal digits in a uint32_t. </p>

<p class="definition">Definition at line <a class="el" href="LexicalCast_8hpp_source.html#l00190">190</a> of file <a class="el" href="LexicalCast_8hpp_source.html">LexicalCast.hpp</a>.</p>

</div>
</div>
<a id="aaf34f238fa54ff498b637be43e9f1438" name="aaf34f238fa54ff498b637be43e9f1438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf34f238fa54ff498b637be43e9f1438">&#9670;&#160;</a></span>operator!=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsparta_1_1RegisterBase_1_1Definition.html">RegisterBase::Definition</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsparta_1_1RegisterBase_1_1Definition.html">RegisterBase::Definition</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Register_8hpp_source.html#l01492">1492</a> of file <a class="el" href="Register_8hpp_source.html">Register.hpp</a>.</p>

</div>
</div>
<a id="a0491810de0250f122ec692a261869f26" name="a0491810de0250f122ec692a261869f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0491810de0250f122ec692a261869f26">&#9670;&#160;</a></span>operator!=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsparta_1_1RegisterProxyBase_1_1Definition.html">RegisterProxyBase::Definition</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsparta_1_1RegisterProxyBase_1_1Definition.html">RegisterProxyBase::Definition</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RegisterSet_8hpp_source.html#l00126">126</a> of file <a class="el" href="RegisterSet_8hpp_source.html">RegisterSet.hpp</a>.</p>

</div>
</div>
<a id="a9f48238763469a49de618f0d5045af0b" name="a9f48238763469a49de618f0d5045af0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f48238763469a49de618f0d5045af0b">&#9670;&#160;</a></span>operator!=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PtrT , typename Ptr2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1SpartaSharedPointer.html">SpartaSharedPointer</a>&lt; PtrT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1SpartaSharedPointer.html">SpartaSharedPointer</a>&lt; Ptr2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SpartaSharedPointer_8hpp_source.html#l00539">539</a> of file <a class="el" href="SpartaSharedPointer_8hpp_source.html">SpartaSharedPointer.hpp</a>.</p>

</div>
</div>
<a id="a0ae6fc3fbc564353b07015fb251c3849" name="a0ae6fc3fbc564353b07015fb251c3849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ae6fc3fbc564353b07015fb251c3849">&#9670;&#160;</a></span>operator!=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PtrT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1SpartaSharedPointer.html">SpartaSharedPointer</a>&lt; PtrT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SpartaSharedPointer_8hpp_source.html#l00543">543</a> of file <a class="el" href="SpartaSharedPointer_8hpp_source.html">SpartaSharedPointer.hpp</a>.</p>

</div>
</div>
<a id="ae2e24d39dd1012a3ac845130f7ccf553" name="ae2e24d39dd1012a3ac845130f7ccf553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e24d39dd1012a3ac845130f7ccf553">&#9670;&#160;</a></span>operator!=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PtrT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::operator!= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1SpartaSharedPointer.html">SpartaSharedPointer</a>&lt; PtrT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr1</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SpartaSharedPointer_8hpp_source.html#l00547">547</a> of file <a class="el" href="SpartaSharedPointer_8hpp_source.html">SpartaSharedPointer.hpp</a>.</p>

</div>
</div>
<a id="a1ed30fb441ce7c7e9dc71a10db268f0f" name="a1ed30fb441ce7c7e9dc71a10db268f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ed30fb441ce7c7e9dc71a10db268f0f">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Ch , class Tr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt; Ch, Tr &gt; &amp; sparta::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; Ch, Tr &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>tn</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> stream operator. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l00001">1</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>

</div>
</div>
<a id="a0844196dcdf8258ded48a3c9c334a6d4" name="a0844196dcdf8258ded48a3c9c334a6d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0844196dcdf8258ded48a3c9c334a6d4">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; sparta::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>o</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1AssignOnceObject.html">AssignOnceObject</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Utils_8hpp_source.html#l00578">578</a> of file <a class="el" href="Utils_8hpp_source.html">Utils.hpp</a>.</p>

</div>
</div>
<a id="a6e5ee9399682eb31f52231079334644f" name="a6e5ee9399682eb31f52231079334644f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e5ee9399682eb31f52231079334644f">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[3/17]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; sparta::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>o</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1NotificationSourceBase_1_1ObservationStateCallback.html">NotificationSourceBase::ObservationStateCallback</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>osc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NotificationSource_8hpp_source.html#l01216">1216</a> of file <a class="el" href="NotificationSource_8hpp_source.html">NotificationSource.hpp</a>.</p>

</div>
</div>
<a id="a6365394172db580c9620dc3f4e3cbafa" name="a6365394172db580c9620dc3f4e3cbafa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6365394172db580c9620dc3f4e3cbafa">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[4/17]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; sparta::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>o</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1NotificationSourceBase_1_1ObservationStateCallback.html">NotificationSourceBase::ObservationStateCallback</a> *</td>          <td class="paramname"><span class="paramname"><em>osc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NotificationSource_8hpp_source.html#l01222">1222</a> of file <a class="el" href="NotificationSource_8hpp_source.html">NotificationSource.hpp</a>.</p>

</div>
</div>
<a id="ac766be8c0bc2a6829736d6408a47f94c" name="ac766be8c0bc2a6829736d6408a47f94c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac766be8c0bc2a6829736d6408a47f94c">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[5/17]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; sparta::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>o</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1ParameterTree_1_1Node.html">ParameterTree::Node</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ParameterTree_8hpp_source.html#l01602">1602</a> of file <a class="el" href="ParameterTree_8hpp_source.html">ParameterTree.hpp</a>.</p>

</div>
</div>
<a id="a44eb91b66a9ed919b7b76e8be330cee1" name="a44eb91b66a9ed919b7b76e8be330cee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44eb91b66a9ed919b7b76e8be330cee1">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[6/17]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; sparta::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>o</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1ParameterTree_1_1Node.html">ParameterTree::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ParameterTree_8hpp_source.html#l01607">1607</a> of file <a class="el" href="ParameterTree_8hpp_source.html">ParameterTree.hpp</a>.</p>

</div>
</div>
<a id="abfecbf1a2ff93a528d26a85ec371916d" name="abfecbf1a2ff93a528d26a85ec371916d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfecbf1a2ff93a528d26a85ec371916d">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[7/17]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; sparta::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>o</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1SimulationInfo.html">SimulationInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>info</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ostream insertion operator for <a class="el" href="classsparta_1_1SimulationInfo.html" title="Contains information describing the simulation instance for the purpose of identifying the simulation...">SimulationInfo</a> </p>

<p class="definition">Definition at line <a class="el" href="SimulationInfo_8hpp_source.html#l00442">442</a> of file <a class="el" href="SimulationInfo_8hpp_source.html">SimulationInfo.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_abfecbf1a2ff93a528d26a85ec371916d_cgraph.png" border="0" usemap="#anamespacesparta_abfecbf1a2ff93a528d26a85ec371916d_cgraph" alt=""/></div>
<map name="anamespacesparta_abfecbf1a2ff93a528d26a85ec371916d_cgraph" id="anamespacesparta_abfecbf1a2ff93a528d26a85ec371916d_cgraph">
<area shape="rect" title="ostream insertion operator for SimulationInfo" alt="" coords="5,112,132,137"/>
<area shape="rect" href="classsparta_1_1SimulationInfo.html#ab6df1c6f149c18a0ddba301086ca1288" title="Write this information to an ostream." alt="" coords="180,104,326,145"/>
<area shape="poly" title=" " alt="" coords="132,122,164,122,164,127,132,127"/>
<area shape="rect" href="classsparta_1_1SimulationInfo.html#aaaf9c8cf6dd90544da19ef002a47275c" title="Gets (name, value) pairs for each header entry." alt="" coords="374,104,520,145"/>
<area shape="poly" title=" " alt="" coords="327,122,359,122,359,127,327,127"/>
<area shape="rect" href="classsparta_1_1TimeManager.html#a6728b6d1e95b60a1c6f21321491b37e6" title="Gets the number of seconds elapsed since the instantiation of SPARTA static and global vars." alt="" coords="575,5,717,46"/>
<area shape="poly" title=" " alt="" coords="484,101,567,57,580,50,582,55,570,61,486,106"/>
<area shape="rect" href="classsparta_1_1TimeManager.html#af030bd86de09c6db4e481d66fe77afb7" title="Returns the TimeManager singleton." alt="" coords="575,71,717,111"/>
<area shape="poly" title=" " alt="" coords="521,109,559,103,560,108,521,115"/>
<area shape="rect" href="classsparta_1_1utils_1_1ValidValue.html#aca75dab39668be5fb02f4e2bb8d5019c" title="Get the value &#45; const version." alt="" coords="568,136,724,177"/>
<area shape="poly" title=" " alt="" coords="521,134,553,139,552,144,521,139"/>
<area shape="rect" href="classsparta_1_1utils_1_1ValidValue.html#ae3676d510018298bdc57028aca4efaff" title="Is this value valid." alt="" coords="568,201,724,242"/>
<area shape="poly" title=" " alt="" coords="487,143,570,186,582,192,580,197,567,191,485,148"/>
</map>
</div>

</div>
</div>
<a id="acc91d8642fd2f22f56b5ccb2cf2b418c" name="acc91d8642fd2f22f56b5ccb2cf2b418c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc91d8642fd2f22f56b5ccb2cf2b418c">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[8/17]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; sparta::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1DAG.html">DAG</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DAG_8hpp_source.html#l00228">228</a> of file <a class="el" href="DAG_8hpp_source.html">DAG.hpp</a>.</p>

</div>
</div>
<a id="a8c6f66cd1bcda14b5d8846b094cbdee0" name="a8c6f66cd1bcda14b5d8846b094cbdee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c6f66cd1bcda14b5d8846b094cbdee0">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[9/17]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; sparta::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1DAG.html">DAG</a> *</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DAG_8hpp_source.html#l00234">234</a> of file <a class="el" href="DAG_8hpp_source.html">DAG.hpp</a>.</p>

</div>
</div>
<a id="aa148a3ec863b7cec37ff036b6b9ba5ed" name="aa148a3ec863b7cec37ff036b6b9ba5ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa148a3ec863b7cec37ff036b6b9ba5ed">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[10/17]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; sparta::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>phase</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the SchedulingPhase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>ostream to print to </td></tr>
    <tr><td class="paramname">phase</td><td>The SchedulingPhase to print out </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ostream </dd></dl>

<p class="definition">Definition at line <a class="el" href="SchedulingPhases_8hpp_source.html#l00084">84</a> of file <a class="el" href="SchedulingPhases_8hpp_source.html">SchedulingPhases.hpp</a>.</p>

</div>
</div>
<a id="a8125c727efbed2a4c7ccefc34debe472" name="a8125c727efbed2a4c7ccefc34debe472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8125c727efbed2a4c7ccefc34debe472">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[11/17]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; sparta::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1Clock.html">sparta::Clock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>clk</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Clock_8hpp_source.html#l00348">348</a> of file <a class="el" href="Clock_8hpp_source.html">Clock.hpp</a>.</p>

</div>
</div>
<a id="a26d3f531a3a29e7010e3b72b21f5bc1c" name="a26d3f531a3a29e7010e3b72b21f5bc1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26d3f531a3a29e7010e3b72b21f5bc1c">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[12/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PtrT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; sparta::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1SpartaSharedPointer.html">SpartaSharedPointer</a>&lt; PtrT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SpartaSharedPointer_8hpp_source.html#l00551">551</a> of file <a class="el" href="SpartaSharedPointer_8hpp_source.html">SpartaSharedPointer.hpp</a>.</p>

</div>
</div>
<a id="a97ec057e36ea2e9a4685e5b937bf4a7c" name="a97ec057e36ea2e9a4685e5b937bf4a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ec057e36ea2e9a4685e5b937bf4a7c">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[13/17]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; sparta::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1Tag.html">Tag</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tag</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>&lt;&lt;(): Stream insertion operator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream </td></tr>
    <tr><td class="paramname">tag</td><td><a class="el" href="classsparta_1_1Tag.html" title="Tag(): Simple class to provide nested sequence numbering.">Tag</a> to output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::ostream&amp; </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tag_8hpp_source.html#l00166">166</a> of file <a class="el" href="Tag_8hpp_source.html">Tag.hpp</a>.</p>

</div>
</div>
<a id="a96f357b5e4e0fc3586e7de50aee3cc0b" name="a96f357b5e4e0fc3586e7de50aee3cc0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f357b5e4e0fc3586e7de50aee3cc0b">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[14/17]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; sparta::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1Tag.html">Tag</a> *</td>          <td class="paramname"><span class="paramname"><em>tag</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>&lt;&lt;(): Stream insertion operator (for <a class="el" href="classsparta_1_1Tag.html" title="Tag(): Simple class to provide nested sequence numbering.">Tag</a> pointers) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream </td></tr>
    <tr><td class="paramname">tag</td><td><a class="el" href="classsparta_1_1Tag.html" title="Tag(): Simple class to provide nested sequence numbering.">Tag</a> pointer to de-reference and output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::ostream&amp; </dd></dl>

<p class="definition">Definition at line <a class="el" href="Tag_8hpp_source.html#l00180">180</a> of file <a class="el" href="Tag_8hpp_source.html">Tag.hpp</a>.</p>

</div>
</div>
<a id="a43ee46795c63d58510a9cea78d0ec7bf" name="a43ee46795c63d58510a9cea78d0ec7bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ee46795c63d58510a9cea78d0ec7bf">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[15/17]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; sparta::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1StatisticInstance.html">sparta::StatisticInstance</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>si</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classsparta_1_1StatisticInstance.html" title="Instance of either a StatisticDef or CounterBase or an Expression. Has a sample window (simulator tic...">StatisticInstance</a> stream operator. </p>

<p class="definition">Definition at line <a class="el" href="StatisticInstance_8hpp_source.html#l00604">604</a> of file <a class="el" href="StatisticInstance_8hpp_source.html">StatisticInstance.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_a43ee46795c63d58510a9cea78d0ec7bf_cgraph.png" border="0" usemap="#anamespacesparta_a43ee46795c63d58510a9cea78d0ec7bf_cgraph" alt=""/></div>
<map name="anamespacesparta_a43ee46795c63d58510a9cea78d0ec7bf_cgraph" id="anamespacesparta_a43ee46795c63d58510a9cea78d0ec7bf_cgraph">
<area shape="rect" title="StatisticInstance stream operator." alt="" coords="5,13,132,38"/>
<area shape="rect" href="classsparta_1_1StatisticInstance.html#a4851caf23ee639b43f081f5b9c37ceee" title="Renders this StatisticInstance to a string containing computation window, source, and current value." alt="" coords="180,5,341,46"/>
<area shape="poly" title=" " alt="" coords="132,23,164,23,164,28,132,28"/>
</map>
</div>

</div>
</div>
<a id="acd73b6c947c5df447187e7b05e92c1e4" name="acd73b6c947c5df447187e7b05e92c1e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd73b6c947c5df447187e7b05e92c1e4">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[16/17]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; sparta::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1StatisticInstance.html">sparta::StatisticInstance</a> const *</td>          <td class="paramname"><span class="paramname"><em>si</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> stream operator. </p>

<p class="definition">Definition at line <a class="el" href="StatisticInstance_8hpp_source.html#l00611">611</a> of file <a class="el" href="StatisticInstance_8hpp_source.html">StatisticInstance.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_acd73b6c947c5df447187e7b05e92c1e4_cgraph.png" border="0" usemap="#anamespacesparta_acd73b6c947c5df447187e7b05e92c1e4_cgraph" alt=""/></div>
<map name="anamespacesparta_acd73b6c947c5df447187e7b05e92c1e4_cgraph" id="anamespacesparta_acd73b6c947c5df447187e7b05e92c1e4_cgraph">
<area shape="rect" title="TreeNode stream operator." alt="" coords="5,13,132,38"/>
<area shape="rect" href="classsparta_1_1StatisticInstance.html#a4851caf23ee639b43f081f5b9c37ceee" title="Renders this StatisticInstance to a string containing computation window, source, and current value." alt="" coords="180,5,341,46"/>
<area shape="poly" title=" " alt="" coords="132,23,164,23,164,28,132,28"/>
</map>
</div>

</div>
</div>
<a id="aa6105eb11e517ad2e76bcc530591cd11" name="aa6105eb11e517ad2e76bcc530591cd11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6105eb11e517ad2e76bcc530591cd11">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[17/17]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; sparta::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a> const *</td>          <td class="paramname"><span class="paramname"><em>tn</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> stream operator. </p>

<p class="definition">Definition at line <a class="el" href="TreeNode_8hpp_source.html#l04760">4760</a> of file <a class="el" href="TreeNode_8hpp_source.html">TreeNode.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_aa6105eb11e517ad2e76bcc530591cd11_cgraph.png" border="0" usemap="#anamespacesparta_aa6105eb11e517ad2e76bcc530591cd11_cgraph" alt=""/></div>
<map name="anamespacesparta_aa6105eb11e517ad2e76bcc530591cd11_cgraph" id="anamespacesparta_aa6105eb11e517ad2e76bcc530591cd11_cgraph">
<area shape="rect" title="TreeNode stream operator." alt="" coords="5,31,132,56"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#ab76a73f2f862a47e969c212f2ac16d85" title="Create a string representation of this node." alt="" coords="180,31,354,56"/>
<area shape="poly" title=" " alt="" coords="132,41,164,41,164,46,132,46"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a1a6d4aac10bfa5345b587d84170441de" title=" " alt="" coords="406,5,601,31"/>
<area shape="poly" title=" " alt="" coords="354,32,391,28,391,33,354,37"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#abeb9301d222aa616093a280921f65d4a" title="Render tags to a string in the form: &quot; tags:[tag0, tag1]&quot; If there are any tags. The leading space ma..." alt="" coords="402,55,605,80"/>
<area shape="poly" title=" " alt="" coords="354,50,386,53,386,58,354,55"/>
</map>
</div>

</div>
</div>
<a id="a20b34eb9804296a39f67ed8800846ded" name="a20b34eb9804296a39f67ed8800846ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b34eb9804296a39f67ed8800846ded">&#9670;&#160;</a></span>operator==() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsparta_1_1RegisterBase_1_1Definition.html">RegisterBase::Definition</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsparta_1_1RegisterBase_1_1Definition.html">RegisterBase::Definition</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Register_8hpp_source.html#l01433">1433</a> of file <a class="el" href="Register_8hpp_source.html">Register.hpp</a>.</p>

</div>
</div>
<a id="a40529f7a2fe9e82d2cb3a5ec14821259" name="a40529f7a2fe9e82d2cb3a5ec14821259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40529f7a2fe9e82d2cb3a5ec14821259">&#9670;&#160;</a></span>operator==() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsparta_1_1RegisterProxyBase_1_1Definition.html">RegisterProxyBase::Definition</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsparta_1_1RegisterProxyBase_1_1Definition.html">RegisterProxyBase::Definition</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RegisterSet_8hpp_source.html#l00101">101</a> of file <a class="el" href="RegisterSet_8hpp_source.html">RegisterSet.hpp</a>.</p>

</div>
</div>
<a id="aad12364f9dbfae24ee6655d907032e28" name="aad12364f9dbfae24ee6655d907032e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad12364f9dbfae24ee6655d907032e28">&#9670;&#160;</a></span>operator==() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PtrT , typename Ptr2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1SpartaSharedPointer.html">SpartaSharedPointer</a>&lt; PtrT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1SpartaSharedPointer.html">SpartaSharedPointer</a>&lt; Ptr2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SpartaSharedPointer_8hpp_source.html#l00527">527</a> of file <a class="el" href="SpartaSharedPointer_8hpp_source.html">SpartaSharedPointer.hpp</a>.</p>

</div>
</div>
<a id="ac4cc5a6070e35d538a462c09d0360aa9" name="ac4cc5a6070e35d538a462c09d0360aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4cc5a6070e35d538a462c09d0360aa9">&#9670;&#160;</a></span>operator==() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PtrT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1SpartaSharedPointer.html">SpartaSharedPointer</a>&lt; PtrT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SpartaSharedPointer_8hpp_source.html#l00531">531</a> of file <a class="el" href="SpartaSharedPointer_8hpp_source.html">SpartaSharedPointer.hpp</a>.</p>

</div>
</div>
<a id="ae2e4a4d86dcec7a702e975cc429ba731" name="ae2e4a4d86dcec7a702e975cc429ba731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e4a4d86dcec7a702e975cc429ba731">&#9670;&#160;</a></span>operator==() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PtrT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::operator== </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1SpartaSharedPointer.html">SpartaSharedPointer</a>&lt; PtrT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr1</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SpartaSharedPointer_8hpp_source.html#l00535">535</a> of file <a class="el" href="SpartaSharedPointer_8hpp_source.html">SpartaSharedPointer.hpp</a>.</p>

</div>
</div>
<a id="a3499289f1cacb032a9421d37f5abd0a7" name="a3499289f1cacb032a9421d37f5abd0a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3499289f1cacb032a9421d37f5abd0a7">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[1/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ScheduleableType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="classsparta_1_1Scheduleable.html">Scheduleable</a>, ScheduleableType &gt;::value, ScheduleableType &gt;::type &amp; sparta::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Bus.html">Bus</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>producer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScheduleableType &amp;</td>          <td class="paramname"><span class="paramname"><em>consumer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place a precedence between a <a class="el" href="classsparta_1_1Bus.html" title="Class that defines a Bus type.">Bus</a> and a <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">Scheduleable</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">producer</td><td>The <a class="el" href="classsparta_1_1Bus.html" title="Class that defines a Bus type.">Bus</a> to succeed a <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">Scheduleable</a> </td></tr>
    <tr><td class="paramname">consumer</td><td>The producer (LHS) must come before consumer (RHS)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The consumer</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function returns the consumer (RHS) of the operation instead of the producer (LHS). This is opposite of typical behavior of &gt;&gt; operators.</dd></dl>
<p>Place a precedence on a producer to the consumer. The consumer is returned, <b>not</b> the producer. This is to allow chaining:</p>
<div class="fragment"><div class="line">my_producer_event_ &gt;&gt; my_consumer_event_ &gt;&gt; my_event_following_consumption_;</div>
</div><!-- fragment --><p>This implementation of the precedence operator catches a Scheduleable/EventNode on the LHS preceding another and ensures the two events are within the same phase.</p>
<div class="fragment"><div class="line">my_outgoing_bus &gt;&gt; ev_tick;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Precedence_8hpp_source.html#l00995">995</a> of file <a class="el" href="Precedence_8hpp_source.html">Precedence.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_a3499289f1cacb032a9421d37f5abd0a7_cgraph.png" border="0" usemap="#anamespacesparta_a3499289f1cacb032a9421d37f5abd0a7_cgraph" alt=""/></div>
<map name="anamespacesparta_a3499289f1cacb032a9421d37f5abd0a7_cgraph" id="anamespacesparta_a3499289f1cacb032a9421d37f5abd0a7_cgraph">
<area shape="rect" title="Place a precedence between a Bus and a Scheduleable." alt="" coords="5,56,132,82"/>
<area shape="rect" href="classsparta_1_1Bus.html#a16cc5eff60d0e358a06db2ca757a98c5" title="Make all inports precede the given event." alt="" coords="180,56,359,82"/>
<area shape="poly" title=" " alt="" coords="132,66,164,66,164,72,132,72"/>
<area shape="rect" href="classsparta_1_1Bus.html#a4f2d0c49bb361b96024d3bb0ef3ada65" title="Get the ports in this PortSet for the given direction." alt="" coords="410,16,551,42"/>
<area shape="poly" title=" " alt="" coords="340,53,394,42,395,48,341,58"/>
<area shape="rect" href="classsparta_1_1InPort.html#a1a7e27e872e1e73ce02aa320a0973346" title="Add an event &quot;listener&quot; to this port." alt="" coords="407,76,554,117"/>
<area shape="poly" title=" " alt="" coords="360,78,392,82,391,88,359,83"/>
<area shape="rect" href="classsparta_1_1PortSet.html#a5c61be847db017f48430c57c7e7967dc" title="Get the ports in this PortSet for the given direction." alt="" coords="611,5,773,31"/>
<area shape="poly" title=" " alt="" coords="551,23,595,20,595,26,552,28"/>
<area shape="rect" href="classsparta_1_1Port.html#afb0fd7ccb38114dd5aaaf4dc69f03e39" title="The direction of the port." alt="" coords="611,55,773,80"/>
<area shape="poly" title=" " alt="" coords="555,84,595,78,596,84,555,89"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#abfa3602a9ab827b1351ef8f518c32576" title="Gets the name of this node." alt="" coords="602,104,782,130"/>
<area shape="poly" title=" " alt="" coords="555,101,587,104,587,110,555,106"/>
<area shape="rect" href="classsparta_1_1Port.html#a8d71612c1256b048b9ec52d06fe2ba2f" title="Is this port bound to another port?" alt="" coords="622,153,762,179"/>
<area shape="poly" title=" " alt="" coords="535,115,603,140,624,146,623,151,601,145,533,120"/>
</map>
</div>

</div>
</div>
<a id="a8c50033c25f275c22b42183c9dc4dde5" name="a8c50033c25f275c22b42183c9dc4dde5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c50033c25f275c22b42183c9dc4dde5">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[2/27]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsparta_1_1EventGroup.html">EventGroup</a> &amp; sparta::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1EventGroup.html">EventGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>producers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1EventGroup.html">EventGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>consumers</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This template supports the following: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">producers</td><td>Group of Scheduleables that must come before each of the consumers in the <a class="el" href="classsparta_1_1EventGroup.html" title="Group a series of events together for precedence establishment.">EventGroup</a> </td></tr>
    <tr><td class="paramname">consumers</td><td>Group of Scheduleables that must come after each of the producers in the <a class="el" href="classsparta_1_1EventGroup.html" title="Group a series of events together for precedence establishment.">EventGroup</a> <div class="fragment"><div class="line"><a class="code hl_class" href="classsparta_1_1EventGroup.html">sparta::EventGroup</a>( ProdEvent1, ProdEvent2, ProdEvent3, ... )</div>
<div class="line">    &gt;&gt; <a class="code hl_class" href="classsparta_1_1EventGroup.html">sparta::EventGroup</a>( ConsEvent1, ConsEvent2, ConsEvent3, ... );</div>
<div class="ttc" id="aclasssparta_1_1EventGroup_html"><div class="ttname"><a href="classsparta_1_1EventGroup.html">sparta::EventGroup</a></div><div class="ttdoc">Group a series of events together for precedence establishment.</div><div class="ttdef"><b>Definition</b> <a href="Precedence_8hpp_source.html#l01041">Precedence.hpp:1042</a></div></div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<p>Where each consuming event is preceded by each producing event. The consuming and producing events are still independent of each other. </p>

<p class="definition">Definition at line <a class="el" href="Precedence_8hpp_source.html#l01188">1188</a> of file <a class="el" href="Precedence_8hpp_source.html">Precedence.hpp</a>.</p>

</div>
</div>
<a id="ab9505663d539ce92e684f3973ac983f7" name="ab9505663d539ce92e684f3973ac983f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9505663d539ce92e684f3973ac983f7">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[3/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ScheduleableTypeB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ScheduleableTypeB &amp; sparta::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1EventGroup.html">EventGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>producers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScheduleableTypeB &amp;</td>          <td class="paramname"><span class="paramname"><em>consumer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This template supports the following: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">producers</td><td>Group of Scheduleables that must come before the given consumer </td></tr>
    <tr><td class="paramname">consumer</td><td>The <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">Scheduleable</a> that succeed each of the Scheduleables in the <a class="el" href="classsparta_1_1EventGroup.html" title="Group a series of events together for precedence establishment.">EventGroup</a></td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsparta_1_1EventGroup.html">sparta::EventGroup</a>(ProEvent1, ProEvent2, ProEvent3, ...) &gt;&gt; ConsEvent;</div>
</div><!-- fragment --><p>Where the consuming event is preceded by each producing event. The producing events are still independent. </p>

<p class="definition">Definition at line <a class="el" href="Precedence_8hpp_source.html#l01144">1144</a> of file <a class="el" href="Precedence_8hpp_source.html">Precedence.hpp</a>.</p>

</div>
</div>
<a id="a31c19896e74f3787f5854d521b69ee3e" name="a31c19896e74f3787f5854d521b69ee3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31c19896e74f3787f5854d521b69ee3e">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[4/27]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1InPort.html">InPort</a> &amp; sparta::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1GlobalOrderingPoint.html">GlobalOrderingPoint</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>producer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1InPort.html">InPort</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>consumer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Place a precedence between a <a class="el" href="classsparta_1_1GlobalOrderingPoint.html" title="Used to set precedence between Scheduleable types across simulation.">GlobalOrderingPoint</a> and an <a class="el" href="classsparta_1_1InPort.html" title="Base class for all InPort types.">InPort</a>. </p>
<p>Methods used for precedence have access to the internal scheduleable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">producer</td><td>The <a class="el" href="classsparta_1_1GlobalOrderingPoint.html" title="Used to set precedence between Scheduleable types across simulation.">GlobalOrderingPoint</a> to succeed the ScheduleableType </td></tr>
    <tr><td class="paramname">consumer</td><td>The producer (LHS) must come before consumer (RHS)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The consumer</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function returns the consumer (RHS) of the operation instead of the producer (LHS). This is opposite of typical behavior of &gt;&gt; operators.</dd></dl>
<p>Place a precedence on a producer to the consumer. The consumer is returned, <b>not</b> the producer. This is to allow chaining:</p>
<div class="fragment"><div class="line">my_producer_event_ &gt;&gt; my_consumer_event_ &gt;&gt; my_event_following_consumption_;</div>
</div><!-- fragment --><p>This implementation of the precedence operator catches a <a class="el" href="classsparta_1_1GlobalOrderingPoint.html" title="Used to set precedence between Scheduleable types across simulation.">GlobalOrderingPoint</a> on the LHS preceding a <a class="el" href="classsparta_1_1InPort.html" title="Base class for all InPort types.">InPort</a> and ensures the two events are within the same phase.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsparta_1_1GlobalOrderingPoint.html">GlobalOrderingPoint</a>(node, <span class="stringliteral">&quot;gop&quot;</span>) &gt;&gt; <a class="code hl_class" href="classsparta_1_1InPort.html">InPort</a></div>
<div class="ttc" id="aclasssparta_1_1GlobalOrderingPoint_html"><div class="ttname"><a href="classsparta_1_1GlobalOrderingPoint.html">sparta::GlobalOrderingPoint</a></div><div class="ttdoc">Used to set precedence between Scheduleable types across simulation.</div><div class="ttdef"><b>Definition</b> <a href="GlobalOrderingPoint_8hpp_source.html#l00060">GlobalOrderingPoint.hpp:61</a></div></div>
<div class="ttc" id="aclasssparta_1_1InPort_html"><div class="ttname"><a href="classsparta_1_1InPort.html">sparta::InPort</a></div><div class="ttdoc">Base class for all InPort types.</div><div class="ttdef"><b>Definition</b> <a href="Port_8hpp_source.html#l00296">Port.hpp:297</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Precedence_8hpp_source.html#l00206">206</a> of file <a class="el" href="Precedence_8hpp_source.html">Precedence.hpp</a>.</p>

</div>
</div>
<a id="a716207ad3fb6cdea775ec5a6b181d0b2" name="a716207ad3fb6cdea775ec5a6b181d0b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716207ad3fb6cdea775ec5a6b181d0b2">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[5/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ScheduleableTypeA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="classsparta_1_1EventNode.html">EventNode</a>, ScheduleableTypeA &gt;::value, ScheduleableTypeA &gt;::type &amp; sparta::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1GlobalOrderingPoint.html">GlobalOrderingPoint</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>producer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScheduleableTypeA &amp;</td>          <td class="paramname"><span class="paramname"><em>consumer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place a precedence between a <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">Scheduleable</a> object and a <a class="el" href="classsparta_1_1GlobalOrderingPoint.html" title="Used to set precedence between Scheduleable types across simulation.">GlobalOrderingPoint</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">producer</td><td>The <a class="el" href="classsparta_1_1GlobalOrderingPoint.html" title="Used to set precedence between Scheduleable types across simulation.">GlobalOrderingPoint</a> to succeed the ScheduleableType </td></tr>
    <tr><td class="paramname">consumer</td><td>The producer (LHS) must come before consumer (RHS)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The consumer</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function returns the consumer (RHS) of the operation instead of the producer (LHS). This is opposite of typical behavior of &gt;&gt; operators.</dd></dl>
<p>Place a precedence on a producer to the consumer. The consumer is returned, <b>not</b> the producer. This is to allow chaining:</p>
<div class="fragment"><div class="line">my_producer_event_ &gt;&gt; my_consumer_event_ &gt;&gt; my_event_following_consumption_;</div>
</div><!-- fragment --><p>This implementation of the precedence operator catches a <a class="el" href="classsparta_1_1GlobalOrderingPoint.html" title="Used to set precedence between Scheduleable types across simulation.">GlobalOrderingPoint</a> on the LHS preceding a <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">Scheduleable</a> type and ensures the two events are within the same phase.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsparta_1_1GlobalOrderingPoint.html">GlobalOrderingPoint</a>(node, <span class="stringliteral">&quot;gop&quot;</span>) &gt;&gt; (<a class="code hl_class" href="classsparta_1_1UniqueEvent.html">UniqueEvent</a>, <a class="code hl_class" href="classsparta_1_1PayloadEvent.html">PayloadEvent</a>, <a class="code hl_class" href="classsparta_1_1SingleCycleUniqueEvent.html">SingleCycleUniqueEvent</a>, <a class="code hl_class" href="classsparta_1_1Event.html">Event</a>);</div>
<div class="ttc" id="aclasssparta_1_1Event_html"><div class="ttname"><a href="classsparta_1_1Event.html">sparta::Event</a></div><div class="ttdoc">Event is a simple class for scheduling random events on the Scheduler.</div><div class="ttdef"><b>Definition</b> <a href="Event_8hpp_source.html#l00041">Event.hpp:42</a></div></div>
<div class="ttc" id="aclasssparta_1_1PayloadEvent_html"><div class="ttname"><a href="classsparta_1_1PayloadEvent.html">sparta::PayloadEvent</a></div><div class="ttdoc">Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...</div><div class="ttdef"><b>Definition</b> <a href="PayloadEvent_8hpp_source.html#l00086">PayloadEvent.hpp:87</a></div></div>
<div class="ttc" id="aclasssparta_1_1SingleCycleUniqueEvent_html"><div class="ttname"><a href="classsparta_1_1SingleCycleUniqueEvent.html">sparta::SingleCycleUniqueEvent</a></div><div class="ttdoc">An event that can only be schedule one cycle into the future.</div><div class="ttdef"><b>Definition</b> <a href="SingleCycleUniqueEvent_8hpp_source.html#l00074">SingleCycleUniqueEvent.hpp:75</a></div></div>
<div class="ttc" id="aclasssparta_1_1UniqueEvent_html"><div class="ttname"><a href="classsparta_1_1UniqueEvent.html">sparta::UniqueEvent</a></div><div class="ttdoc">A type of Event that uniquely schedules itself on the schedule within a single time quantum....</div><div class="ttdef"><b>Definition</b> <a href="UniqueEvent_8hpp_source.html#l00072">UniqueEvent.hpp:73</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Precedence_8hpp_source.html#l00173">173</a> of file <a class="el" href="Precedence_8hpp_source.html">Precedence.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_a716207ad3fb6cdea775ec5a6b181d0b2_cgraph.png" border="0" usemap="#anamespacesparta_a716207ad3fb6cdea775ec5a6b181d0b2_cgraph" alt=""/></div>
<map name="anamespacesparta_a716207ad3fb6cdea775ec5a6b181d0b2_cgraph" id="anamespacesparta_a716207ad3fb6cdea775ec5a6b181d0b2_cgraph">
<area shape="rect" title="Place a precedence between a Scheduleable object and a GlobalOrderingPoint." alt="" coords="5,13,132,38"/>
<area shape="rect" href="classsparta_1_1GlobalOrderingPoint.html#afc48fcdbb8b5c72d1d45ba95da84ba86" title="Used by the precedence rules." alt="" coords="180,5,359,46"/>
<area shape="poly" title=" " alt="" coords="132,23,164,23,164,28,132,28"/>
</map>
</div>

</div>
</div>
<a id="a9145a844e641be88ec0ef7987294092c" name="a9145a844e641be88ec0ef7987294092c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9145a844e641be88ec0ef7987294092c">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[6/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT1, class DataT2 , <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1PayloadEvent.html">PayloadEvent</a>&lt; DataT2, PayloadPhaseT2 &gt; &amp; sparta::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Event.html">Event</a>&lt; PayloadPhaseT1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>producer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1PayloadEvent.html">PayloadEvent</a>&lt; DataT2, PayloadPhaseT2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>consumer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place a precedence between a <a class="el" href="classsparta_1_1Event.html" title="Event is a simple class for scheduling random events on the Scheduler.">Event</a> and an <a class="el" href="classsparta_1_1PayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...">PayloadEvent</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">producer</td><td>The <a class="el" href="classsparta_1_1Event.html" title="Event is a simple class for scheduling random events on the Scheduler.">Event</a> to succeed a <a class="el" href="classsparta_1_1PayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...">PayloadEvent</a> </td></tr>
    <tr><td class="paramname">consumer</td><td>The producer (LHS) must come before consumer (RHS)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The consumer</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function returns the consumer (RHS) of the operation instead of the producer (LHS). This is opposite of typical behavior of &gt;&gt; operators.</dd></dl>
<p>Place a precedence on a producer to the consumer. The consumer is returned, <b>not</b> the producer. This is to allow chaining:</p>
<div class="fragment"><div class="line">my_producer_event_ &gt;&gt; my_consumer_event_ &gt;&gt; my_event_following_consumption_;</div>
</div><!-- fragment --><p>This implementation of the precedence operator catches a Scheduleable/EventNode on the LHS preceding another and ensures the two events are within the same phase.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsparta_1_1Event.html">Event&lt;P&gt;</a> &gt;&gt; <a class="code hl_class" href="classsparta_1_1PayloadEvent.html">PayloadEvent&lt;T, P&gt;</a>;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Precedence_8hpp_source.html#l00523">523</a> of file <a class="el" href="Precedence_8hpp_source.html">Precedence.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_a9145a844e641be88ec0ef7987294092c_cgraph.png" border="0" usemap="#anamespacesparta_a9145a844e641be88ec0ef7987294092c_cgraph" alt=""/></div>
<map name="anamespacesparta_a9145a844e641be88ec0ef7987294092c_cgraph" id="anamespacesparta_a9145a844e641be88ec0ef7987294092c_cgraph">
<area shape="rect" title="Place a precedence between a Event and an PayloadEvent." alt="" coords="5,46,132,72"/>
<area shape="rect" href="classsparta_1_1PhasedPayloadEvent.html#ae4b329988917863c31f03a3764323a01" title="Get the scheduleable associated with this event node." alt="" coords="180,5,366,46"/>
<area shape="poly" title=" " alt="" coords="132,46,164,41,165,46,132,51"/>
<area shape="rect" href="classsparta_1_1Scheduleable.html#a697e61ff71726cc21d7e8eebe1ce83d2" title="Have this Scheduleable precede another." alt="" coords="202,71,344,111"/>
<area shape="poly" title=" " alt="" coords="132,66,188,75,187,80,132,71"/>
</map>
</div>

</div>
</div>
<a id="a86e3c5b2b89f50f7310a24f07b963f47" name="a86e3c5b2b89f50f7310a24f07b963f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86e3c5b2b89f50f7310a24f07b963f47">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[7/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PhaseT1, <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PhaseT2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Event.html">Event</a>&lt; PhaseT2 &gt; &amp; sparta::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Event.html">Event</a>&lt; PhaseT1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>producer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Event.html">Event</a>&lt; PhaseT2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>consumer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place a precedence between a <a class="el" href="classsparta_1_1Event.html" title="Event is a simple class for scheduling random events on the Scheduler.">Event</a> and another <a class="el" href="classsparta_1_1Event.html" title="Event is a simple class for scheduling random events on the Scheduler.">Event</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">producer</td><td>The <a class="el" href="classsparta_1_1Event.html" title="Event is a simple class for scheduling random events on the Scheduler.">Event</a> to succeed a <a class="el" href="classsparta_1_1Event.html" title="Event is a simple class for scheduling random events on the Scheduler.">Event</a> </td></tr>
    <tr><td class="paramname">consumer</td><td>The producer (LHS) must come before consumer (RHS)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The consumer</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function returns the consumer (RHS) of the operation instead of the producer (LHS). This is opposite of typical behavior of &gt;&gt; operators.</dd></dl>
<p>Place a precedence on a producer to the consumer. The consumer is returned, <b>not</b> the producer. This is to allow chaining:</p>
<div class="fragment"><div class="line">my_producer_event_ &gt;&gt; my_consumer_event_ &gt;&gt; my_event_following_consumption_;</div>
</div><!-- fragment --><p>This implementation of the precedence operator catches a Scheduleable/EventNode on the LHS preceding another and ensures the two events are within the same phase.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsparta_1_1Event.html">Event&lt;P&gt;</a> &gt;&gt; <a class="code hl_class" href="classsparta_1_1Event.html">Event&lt;P&gt;</a>;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Precedence_8hpp_source.html#l00720">720</a> of file <a class="el" href="Precedence_8hpp_source.html">Precedence.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_a86e3c5b2b89f50f7310a24f07b963f47_cgraph.png" border="0" usemap="#anamespacesparta_a86e3c5b2b89f50f7310a24f07b963f47_cgraph" alt=""/></div>
<map name="anamespacesparta_a86e3c5b2b89f50f7310a24f07b963f47_cgraph" id="anamespacesparta_a86e3c5b2b89f50f7310a24f07b963f47_cgraph">
<area shape="rect" title="Place a precedence between a Event and another Event." alt="" coords="5,35,132,60"/>
<area shape="rect" href="classsparta_1_1Event.html#afc3baf550a28f8b0291ca3aa9632e417" title="Get the scheduleable associated with this event node." alt="" coords="180,5,378,31"/>
<area shape="poly" title=" " alt="" coords="132,36,167,31,167,36,133,41"/>
<area shape="rect" href="classsparta_1_1Scheduleable.html#a697e61ff71726cc21d7e8eebe1ce83d2" title="Have this Scheduleable precede another." alt="" coords="208,55,350,96"/>
<area shape="poly" title=" " alt="" coords="132,53,193,61,192,67,132,59"/>
</map>
</div>

</div>
</div>
<a id="ad5707f15f54dd3cf229818c9be003f3f" name="ad5707f15f54dd3cf229818c9be003f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5707f15f54dd3cf229818c9be003f3f">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[8/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class EventT1 , class EventT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; EventT2 &gt; &amp; sparta::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">EventT1 &amp;</td>          <td class="paramname"><span class="paramname"><em>producer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; EventT2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>consumer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place a precedence between an EventT1 and std::unique_ptr&lt;EventT2&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">producer</td><td>The EventT1 to succeed a EventT2 </td></tr>
    <tr><td class="paramname">consumer</td><td>The producer (LHS) must come before consumer (RHS)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The consumer</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function returns the consumer (RHS) of the operation instead of the producer (LHS). This is opposite of typical behavior of &gt;&gt; operators.</dd></dl>
<p>Place a precedence on a producer to the consumer. The consumer is returned, <b>not</b> the producer. This is to allow chaining:</p>
<div class="fragment"><div class="line">my_producer_event_ &gt;&gt; my_consumer_event_ &gt;&gt; my_event_following_consumption_;</div>
</div><!-- fragment --><p>This implementation of the precedence operator catches a Scheduleable/EventNode on the LHS preceding another and ensures the two events are within the same phase.</p>
<div class="fragment"><div class="line">EventT1 &gt;&gt; std::unique_ptr&lt;EventT2&gt;;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Precedence_8hpp_source.html#l00798">798</a> of file <a class="el" href="Precedence_8hpp_source.html">Precedence.hpp</a>.</p>

</div>
</div>
<a id="a4df9e497fcaa24cc149016ded4b9b371" name="a4df9e497fcaa24cc149016ded4b9b371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df9e497fcaa24cc149016ded4b9b371">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[9/27]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsparta_1_1GlobalOrderingPoint.html">GlobalOrderingPoint</a> &amp; sparta::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1InPort.html">InPort</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>producer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1GlobalOrderingPoint.html">GlobalOrderingPoint</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>consumer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Place a precedence between a <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">Scheduleable</a> object and a <a class="el" href="classsparta_1_1GlobalOrderingPoint.html" title="Used to set precedence between Scheduleable types across simulation.">GlobalOrderingPoint</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">producer</td><td>The <a class="el" href="classsparta_1_1GlobalOrderingPoint.html" title="Used to set precedence between Scheduleable types across simulation.">GlobalOrderingPoint</a> to succeed the ScheduleableType </td></tr>
    <tr><td class="paramname">consumer</td><td>The producer (LHS) must come before consumer (RHS)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The consumer</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function returns the consumer (RHS) of the operation instead of the producer (LHS). This is opposite of typical behavior of &gt;&gt; operators.</dd></dl>
<p>Place a precedence on a producer to the consumer. The consumer is returned, <b>not</b> the producer. This is to allow chaining:</p>
<div class="fragment"><div class="line">my_producer_event_ &gt;&gt; my_consumer_event_ &gt;&gt; my_event_following_consumption_;</div>
</div><!-- fragment --><p>This implementation of the precedence operator catches a <a class="el" href="classsparta_1_1InPort.html" title="Base class for all InPort types.">InPort</a> on the LHS preceding a <a class="el" href="classsparta_1_1GlobalOrderingPoint.html" title="Used to set precedence between Scheduleable types across simulation.">GlobalOrderingPoint</a> (which is a Vertex type) and ensures the two events are within the same phase.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsparta_1_1InPort.html">InPort</a> &gt;&gt; <a class="code hl_class" href="classsparta_1_1GlobalOrderingPoint.html">GlobalOrderingPoint</a>(node, <span class="stringliteral">&quot;gop&quot;</span>);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Precedence_8hpp_source.html#l00238">238</a> of file <a class="el" href="Precedence_8hpp_source.html">Precedence.hpp</a>.</p>

</div>
</div>
<a id="a796a23bb60f5e3686ce021d4a0fb84cf" name="a796a23bb60f5e3686ce021d4a0fb84cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a796a23bb60f5e3686ce021d4a0fb84cf">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[10/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT1 , <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT1, <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Event.html">Event</a>&lt; PayloadPhaseT2 &gt; &amp; sparta::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1PayloadEvent.html">PayloadEvent</a>&lt; DataT1, PayloadPhaseT1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>producer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Event.html">Event</a>&lt; PayloadPhaseT2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>consumer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place a precedence between a <a class="el" href="classsparta_1_1PayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...">PayloadEvent</a> and an <a class="el" href="classsparta_1_1Event.html" title="Event is a simple class for scheduling random events on the Scheduler.">Event</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">producer</td><td>The <a class="el" href="classsparta_1_1PayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...">PayloadEvent</a> to succeed an <a class="el" href="classsparta_1_1Event.html" title="Event is a simple class for scheduling random events on the Scheduler.">Event</a> </td></tr>
    <tr><td class="paramname">consumer</td><td>The producer (LHS) must come before consumer (RHS)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The consumer</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function returns the consumer (RHS) of the operation instead of the producer (LHS). This is opposite of typical behavior of &gt;&gt; operators.</dd></dl>
<p>Place a precedence on a producer to the consumer. The consumer is returned, <b>not</b> the producer. This is to allow chaining:</p>
<div class="fragment"><div class="line">my_producer_event_ &gt;&gt; my_consumer_event_ &gt;&gt; my_event_following_consumption_;</div>
</div><!-- fragment --><p>This implementation of the precedence operator catches a Scheduleable/EventNode on the LHS preceding another and ensures the two events are within the same phase.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsparta_1_1PayloadEvent.html">PayloadEvent&lt;T, P&gt;</a> &gt;&gt; <a class="code hl_class" href="classsparta_1_1Event.html">Event&lt;P&gt;</a>;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Precedence_8hpp_source.html#l00409">409</a> of file <a class="el" href="Precedence_8hpp_source.html">Precedence.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_a796a23bb60f5e3686ce021d4a0fb84cf_cgraph.png" border="0" usemap="#anamespacesparta_a796a23bb60f5e3686ce021d4a0fb84cf_cgraph" alt=""/></div>
<map name="anamespacesparta_a796a23bb60f5e3686ce021d4a0fb84cf_cgraph" id="anamespacesparta_a796a23bb60f5e3686ce021d4a0fb84cf_cgraph">
<area shape="rect" title="Place a precedence between a PayloadEvent and an Event." alt="" coords="5,63,132,88"/>
<area shape="rect" href="classsparta_1_1Event.html#afc3baf550a28f8b0291ca3aa9632e417" title="Get the scheduleable associated with this event node." alt="" coords="180,5,378,31"/>
<area shape="poly" title=" " alt="" coords="114,60,179,41,209,33,211,38,180,46,115,65"/>
<area shape="rect" href="classsparta_1_1PhasedPayloadEvent.html#ae4b329988917863c31f03a3764323a01" title="Get the scheduleable associated with this event node." alt="" coords="186,55,372,96"/>
<area shape="poly" title=" " alt="" coords="132,73,170,73,170,78,132,78"/>
<area shape="rect" href="classsparta_1_1Scheduleable.html#a697e61ff71726cc21d7e8eebe1ce83d2" title="Have this Scheduleable precede another." alt="" coords="208,120,350,161"/>
<area shape="poly" title=" " alt="" coords="113,86,197,113,196,118,112,91"/>
</map>
</div>

</div>
</div>
<a id="a88753996384613e1376e772cf78163e7" name="a88753996384613e1376e772cf78163e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88753996384613e1376e772cf78163e7">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[11/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT1 , <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT1, class DataT2 , <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1PayloadEvent.html">PayloadEvent</a>&lt; DataT2, PayloadPhaseT2 &gt; &amp; sparta::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1PayloadEvent.html">PayloadEvent</a>&lt; DataT1, PayloadPhaseT1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>producer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1PayloadEvent.html">PayloadEvent</a>&lt; DataT2, PayloadPhaseT2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>consumer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place a precedence between a <a class="el" href="classsparta_1_1PayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...">PayloadEvent</a> and another <a class="el" href="classsparta_1_1PayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...">PayloadEvent</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">producer</td><td>The <a class="el" href="classsparta_1_1PayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...">PayloadEvent</a> to succeed another <a class="el" href="classsparta_1_1PayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...">PayloadEvent</a> </td></tr>
    <tr><td class="paramname">consumer</td><td>The producer (LHS) must come before consumer (RHS)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The consumer</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function returns the consumer (RHS) of the operation instead of the producer (LHS). This is opposite of typical behavior of &gt;&gt; operators.</dd></dl>
<p>Place a precedence on a producer to the consumer. The consumer is returned, <b>not</b> the producer. This is to allow chaining:</p>
<div class="fragment"><div class="line">my_producer_event_ &gt;&gt; my_consumer_event_ &gt;&gt; my_event_following_consumption_;</div>
</div><!-- fragment --><p>This implementation of the precedence operator catches a Scheduleable/EventNode on the LHS preceding another and ensures the two events are within the same phase.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsparta_1_1PayloadEvent.html">PayloadEvent&lt;T, P&gt;</a> &gt;&gt; <a class="code hl_class" href="classsparta_1_1PayloadEvent.html">PayloadEvent&lt;T, P&gt;</a>;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Precedence_8hpp_source.html#l00295">295</a> of file <a class="el" href="Precedence_8hpp_source.html">Precedence.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_a88753996384613e1376e772cf78163e7_cgraph.png" border="0" usemap="#anamespacesparta_a88753996384613e1376e772cf78163e7_cgraph" alt=""/></div>
<map name="anamespacesparta_a88753996384613e1376e772cf78163e7_cgraph" id="anamespacesparta_a88753996384613e1376e772cf78163e7_cgraph">
<area shape="rect" title="Place a precedence between a PayloadEvent and another PayloadEvent." alt="" coords="5,46,132,72"/>
<area shape="rect" href="classsparta_1_1PhasedPayloadEvent.html#ae4b329988917863c31f03a3764323a01" title="Get the scheduleable associated with this event node." alt="" coords="180,5,366,46"/>
<area shape="poly" title=" " alt="" coords="132,46,164,41,165,46,132,51"/>
<area shape="rect" href="classsparta_1_1Scheduleable.html#a697e61ff71726cc21d7e8eebe1ce83d2" title="Have this Scheduleable precede another." alt="" coords="202,71,344,111"/>
<area shape="poly" title=" " alt="" coords="132,66,188,75,187,80,132,71"/>
</map>
</div>

</div>
</div>
<a id="a6813ebf9470d3984edd2686563abc335" name="a6813ebf9470d3984edd2686563abc335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6813ebf9470d3984edd2686563abc335">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[12/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT1 , <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT1, <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html">SingleCycleUniqueEvent</a>&lt; PayloadPhaseT2 &gt; &amp; sparta::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1PayloadEvent.html">PayloadEvent</a>&lt; DataT1, PayloadPhaseT1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>producer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html">SingleCycleUniqueEvent</a>&lt; PayloadPhaseT2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>consumer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place a precedence between a <a class="el" href="classsparta_1_1PayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...">PayloadEvent</a> and <a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html" title="An event that can only be schedule one cycle into the future.">SingleCycleUniqueEvent</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">producer</td><td>The <a class="el" href="classsparta_1_1PayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...">PayloadEvent</a> to succeed <a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html" title="An event that can only be schedule one cycle into the future.">SingleCycleUniqueEvent</a> </td></tr>
    <tr><td class="paramname">consumer</td><td>The producer (LHS) must come before consumer (RHS)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The consumer</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function returns the consumer (RHS) of the operation instead of the producer (LHS). This is opposite of typical behavior of &gt;&gt; operators.</dd></dl>
<p>Place a precedence on a producer to the consumer. The consumer is returned, <b>not</b> the producer. This is to allow chaining:</p>
<div class="fragment"><div class="line">my_producer_event_ &gt;&gt; my_consumer_event_ &gt;&gt; my_event_following_consumption_;</div>
</div><!-- fragment --><p>This implementation of the precedence operator catches a Scheduleable/EventNode on the LHS preceding another and ensures the two events are within the same phase.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsparta_1_1PayloadEvent.html">PayloadEvent&lt;T, P&gt;</a> &gt;&gt; <a class="code hl_class" href="classsparta_1_1SingleCycleUniqueEvent.html">SingleCycleUniqueEvent&lt;P&gt;</a>;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Precedence_8hpp_source.html#l00371">371</a> of file <a class="el" href="Precedence_8hpp_source.html">Precedence.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_a6813ebf9470d3984edd2686563abc335_cgraph.png" border="0" usemap="#anamespacesparta_a6813ebf9470d3984edd2686563abc335_cgraph" alt=""/></div>
<map name="anamespacesparta_a6813ebf9470d3984edd2686563abc335_cgraph" id="anamespacesparta_a6813ebf9470d3984edd2686563abc335_cgraph">
<area shape="rect" title="Place a precedence between a PayloadEvent and SingleCycleUniqueEvent." alt="" coords="5,78,132,104"/>
<area shape="rect" href="classsparta_1_1EventNode.html#ade2ce9e1d898e826493a600eefebd6bf" title="Get the scheduleable associated with this event node." alt="" coords="206,5,340,46"/>
<area shape="poly" title=" " alt="" coords="110,75,192,49,193,54,112,80"/>
<area shape="rect" href="classsparta_1_1PhasedPayloadEvent.html#ae4b329988917863c31f03a3764323a01" title="Get the scheduleable associated with this event node." alt="" coords="180,71,366,111"/>
<area shape="poly" title=" " alt="" coords="132,88,164,88,164,94,132,94"/>
<area shape="rect" href="classsparta_1_1Scheduleable.html#a697e61ff71726cc21d7e8eebe1ce83d2" title="Have this Scheduleable precede another." alt="" coords="202,136,344,177"/>
<area shape="poly" title=" " alt="" coords="112,102,193,128,192,133,110,107"/>
</map>
</div>

</div>
</div>
<a id="adf8ac305a796c13d990aedbce9c402dc" name="adf8ac305a796c13d990aedbce9c402dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf8ac305a796c13d990aedbce9c402dc">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[13/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT1 , <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT1, <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1UniqueEvent.html">UniqueEvent</a>&lt; PayloadPhaseT2 &gt; &amp; sparta::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1PayloadEvent.html">PayloadEvent</a>&lt; DataT1, PayloadPhaseT1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>producer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1UniqueEvent.html">UniqueEvent</a>&lt; PayloadPhaseT2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>consumer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place a precedence between a <a class="el" href="classsparta_1_1PayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...">PayloadEvent</a> and <a class="el" href="classsparta_1_1UniqueEvent.html" title="A type of Event that uniquely schedules itself on the schedule within a single time quantum....">UniqueEvent</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">producer</td><td>The <a class="el" href="classsparta_1_1PayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...">PayloadEvent</a> to succeed <a class="el" href="classsparta_1_1UniqueEvent.html" title="A type of Event that uniquely schedules itself on the schedule within a single time quantum....">UniqueEvent</a> </td></tr>
    <tr><td class="paramname">consumer</td><td>The producer (LHS) must come before consumer (RHS)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The consumer</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function returns the consumer (RHS) of the operation instead of the producer (LHS). This is opposite of typical behavior of &gt;&gt; operators.</dd></dl>
<p>Place a precedence on a producer to the consumer. The consumer is returned, <b>not</b> the producer. This is to allow chaining:</p>
<div class="fragment"><div class="line">my_producer_event_ &gt;&gt; my_consumer_event_ &gt;&gt; my_event_following_consumption_;</div>
</div><!-- fragment --><p>This implementation of the precedence operator catches a Scheduleable/EventNode on the LHS preceding another and ensures the two events are within the same phase.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsparta_1_1PayloadEvent.html">PayloadEvent&lt;T, P&gt;</a> &gt;&gt; <a class="code hl_class" href="classsparta_1_1UniqueEvent.html">UniqueEvent&lt;P&gt;</a>;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Precedence_8hpp_source.html#l00333">333</a> of file <a class="el" href="Precedence_8hpp_source.html">Precedence.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_adf8ac305a796c13d990aedbce9c402dc_cgraph.png" border="0" usemap="#anamespacesparta_adf8ac305a796c13d990aedbce9c402dc_cgraph" alt=""/></div>
<map name="anamespacesparta_adf8ac305a796c13d990aedbce9c402dc_cgraph" id="anamespacesparta_adf8ac305a796c13d990aedbce9c402dc_cgraph">
<area shape="rect" title="Place a precedence between a PayloadEvent and UniqueEvent." alt="" coords="5,78,132,104"/>
<area shape="rect" href="classsparta_1_1EventNode.html#ade2ce9e1d898e826493a600eefebd6bf" title="Get the scheduleable associated with this event node." alt="" coords="206,5,340,46"/>
<area shape="poly" title=" " alt="" coords="110,75,192,49,193,54,112,80"/>
<area shape="rect" href="classsparta_1_1PhasedPayloadEvent.html#ae4b329988917863c31f03a3764323a01" title="Get the scheduleable associated with this event node." alt="" coords="180,71,366,111"/>
<area shape="poly" title=" " alt="" coords="132,88,164,88,164,94,132,94"/>
<area shape="rect" href="classsparta_1_1Scheduleable.html#a697e61ff71726cc21d7e8eebe1ce83d2" title="Have this Scheduleable precede another." alt="" coords="202,136,344,177"/>
<area shape="poly" title=" " alt="" coords="112,102,193,128,192,133,110,107"/>
</map>
</div>

</div>
</div>
<a id="a24cfd795ea9241a7f8b4e500e4cfb9d4" name="a24cfd795ea9241a7f8b4e500e4cfb9d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24cfd795ea9241a7f8b4e500e4cfb9d4">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[14/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT1 , <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> phase&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Scheduleable.html">Scheduleable</a> &amp; sparta::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1PayloadEvent.html">PayloadEvent</a>&lt; DataT1, phase &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>producer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Scheduleable.html">Scheduleable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>consumer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place a precedence between a <a class="el" href="classsparta_1_1PayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...">PayloadEvent</a> and a <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">Scheduleable</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">producer</td><td>The <a class="el" href="classsparta_1_1PayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...">PayloadEvent</a> to succeed a <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">Scheduleable</a> </td></tr>
    <tr><td class="paramname">consumer</td><td>The producer (LHS) must come before consumer (RHS)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The consumer</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function returns the consumer (RHS) of the operation instead of the producer (LHS). This is opposite of typical behavior of &gt;&gt; operators.</dd></dl>
<p>Place a precedence on a producer to the consumer. The consumer is returned, <b>not</b> the producer. This is to allow chaining:</p>
<div class="fragment"><div class="line">my_producer_event_ &gt;&gt; my_consumer_event_ &gt;&gt; my_event_following_consumption_;</div>
</div><!-- fragment --><p>This implementation of the precedence operator catches a Scheduleable/EventNode on the LHS preceding another and ensures the two events are within the same phase.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsparta_1_1PayloadEvent.html">PayloadEvent&lt;DataT, PhaseT&gt;</a> &gt;&gt; <a class="code hl_class" href="classsparta_1_1Scheduleable.html">Scheduleable</a>;</div>
<div class="ttc" id="aclasssparta_1_1Scheduleable_html"><div class="ttname"><a href="classsparta_1_1Scheduleable.html">sparta::Scheduleable</a></div><div class="ttdoc">A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...</div><div class="ttdef"><b>Definition</b> <a href="Scheduleable_8hpp_source.html#l00037">Scheduleable.hpp:38</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Precedence_8hpp_source.html#l00907">907</a> of file <a class="el" href="Precedence_8hpp_source.html">Precedence.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_a24cfd795ea9241a7f8b4e500e4cfb9d4_cgraph.png" border="0" usemap="#anamespacesparta_a24cfd795ea9241a7f8b4e500e4cfb9d4_cgraph" alt=""/></div>
<map name="anamespacesparta_a24cfd795ea9241a7f8b4e500e4cfb9d4_cgraph" id="anamespacesparta_a24cfd795ea9241a7f8b4e500e4cfb9d4_cgraph">
<area shape="rect" title="Place a precedence between a PayloadEvent and a Scheduleable." alt="" coords="5,112,132,137"/>
<area shape="rect" href="classsparta_1_1PhasedPayloadEvent.html#ae4b329988917863c31f03a3764323a01" title="Get the scheduleable associated with this event node." alt="" coords="180,5,366,46"/>
<area shape="poly" title=" " alt="" coords="88,109,129,83,178,57,194,50,196,55,181,61,132,88,91,113"/>
<area shape="rect" href="classsparta_1_1EventNode.html#a973b084a7f33fdabcc2fb8a09148fc71" title="Get the scheduling phase of this event node." alt="" coords="203,71,343,111"/>
<area shape="poly" title=" " alt="" coords="132,111,187,102,188,108,132,117"/>
<area shape="rect" href="classsparta_1_1Scheduleable.html#ac375a291bc8e1c782e20108e75598faa" title="Get the internal phase number." alt="" coords="200,136,346,177"/>
<area shape="poly" title=" " alt="" coords="132,132,185,140,184,145,132,137"/>
<area shape="rect" href="classsparta_1_1Scheduleable.html#a697e61ff71726cc21d7e8eebe1ce83d2" title="Have this Scheduleable precede another." alt="" coords="202,201,344,242"/>
<area shape="poly" title=" " alt="" coords="92,135,132,160,181,186,196,193,194,198,179,191,130,165,89,140"/>
</map>
</div>

</div>
</div>
<a id="acc8220b00fe75a16e8936d6a9d9bb4e2" name="acc8220b00fe75a16e8936d6a9d9bb4e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc8220b00fe75a16e8936d6a9d9bb4e2">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[15/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataT2 , <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> phase&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1PayloadEvent.html">PayloadEvent</a>&lt; DataT2, phase &gt; &amp; sparta::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Scheduleable.html">Scheduleable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>producer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1PayloadEvent.html">PayloadEvent</a>&lt; DataT2, phase &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>consumer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place a precedence between a <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">Scheduleable</a> and a <a class="el" href="classsparta_1_1PayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...">PayloadEvent</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">producer</td><td>The <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">Scheduleable</a> to succeed the <a class="el" href="classsparta_1_1PayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...">PayloadEvent</a> </td></tr>
    <tr><td class="paramname">consumer</td><td>The producer (LHS) must come before consumer (RHS)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The consumer</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function returns the consumer (RHS) of the operation instead of the producer (LHS). This is opposite of typical behavior of &gt;&gt; operators.</dd></dl>
<p>Place a precedence on a producer to the consumer. The consumer is returned, <b>not</b> the producer. This is to allow chaining:</p>
<div class="fragment"><div class="line">my_producer_event_ &gt;&gt; my_consumer_event_ &gt;&gt; my_event_following_consumption_;</div>
</div><!-- fragment --><p>This implementation of the precedence operator catches a Scheduleable/EventNode on the LHS preceding another and ensures the two events are within the same phase.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsparta_1_1Scheduleable.html">Scheduleable</a> &gt;&gt; <a class="code hl_class" href="classsparta_1_1PayloadEvent.html">PayloadEvent&lt;DataT, PhaseT&gt;</a>;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Precedence_8hpp_source.html#l00870">870</a> of file <a class="el" href="Precedence_8hpp_source.html">Precedence.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_acc8220b00fe75a16e8936d6a9d9bb4e2_cgraph.png" border="0" usemap="#anamespacesparta_acc8220b00fe75a16e8936d6a9d9bb4e2_cgraph" alt=""/></div>
<map name="anamespacesparta_acc8220b00fe75a16e8936d6a9d9bb4e2_cgraph" id="anamespacesparta_acc8220b00fe75a16e8936d6a9d9bb4e2_cgraph">
<area shape="rect" title="Place a precedence between a Scheduleable and a PayloadEvent." alt="" coords="5,112,132,137"/>
<area shape="rect" href="classsparta_1_1PhasedPayloadEvent.html#ae4b329988917863c31f03a3764323a01" title="Get the scheduleable associated with this event node." alt="" coords="180,5,366,46"/>
<area shape="poly" title=" " alt="" coords="88,109,129,83,178,57,194,50,196,55,181,61,132,88,91,113"/>
<area shape="rect" href="classsparta_1_1EventNode.html#a973b084a7f33fdabcc2fb8a09148fc71" title="Get the scheduling phase of this event node." alt="" coords="203,71,343,111"/>
<area shape="poly" title=" " alt="" coords="132,111,187,102,188,108,132,117"/>
<area shape="rect" href="classsparta_1_1Scheduleable.html#ac375a291bc8e1c782e20108e75598faa" title="Get the internal phase number." alt="" coords="200,136,346,177"/>
<area shape="poly" title=" " alt="" coords="132,132,185,140,184,145,132,137"/>
<area shape="rect" href="classsparta_1_1Scheduleable.html#a697e61ff71726cc21d7e8eebe1ce83d2" title="Have this Scheduleable precede another." alt="" coords="202,201,344,242"/>
<area shape="poly" title=" " alt="" coords="92,135,132,160,181,186,196,193,194,198,179,191,130,165,89,140"/>
</map>
</div>

</div>
</div>
<a id="ae23625a4707a7d7e65408eff02bbe8a2" name="ae23625a4707a7d7e65408eff02bbe8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae23625a4707a7d7e65408eff02bbe8a2">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[16/27]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1Scheduleable.html">Scheduleable</a> &amp; sparta::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Scheduleable.html">Scheduleable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>producer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Scheduleable.html">Scheduleable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>consumer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Scheduleable_8hpp_source.html#l00625">625</a> of file <a class="el" href="Scheduleable_8hpp_source.html">Scheduleable.hpp</a>.</p>

</div>
</div>
<a id="ad59075953a8f2a9ec7b1a5903c52cb5c" name="ad59075953a8f2a9ec7b1a5903c52cb5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59075953a8f2a9ec7b1a5903c52cb5c">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[17/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ScheduleableType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="classsparta_1_1Scheduleable.html">Scheduleable</a>, ScheduleableType &gt;::value, <a class="el" href="classsparta_1_1Bus.html">Bus</a> &gt;::type &amp; sparta::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">ScheduleableType &amp;</td>          <td class="paramname"><span class="paramname"><em>producer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1Bus.html">Bus</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>consumer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place a precedence between a <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">Scheduleable</a> and a <a class="el" href="classsparta_1_1Bus.html" title="Class that defines a Bus type.">Bus</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">producer</td><td>The <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">Scheduleable</a> to succeed a <a class="el" href="classsparta_1_1Bus.html" title="Class that defines a Bus type.">Bus</a> </td></tr>
    <tr><td class="paramname">consumer</td><td>The producer (LHS) must come before consumer (RHS)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The consumer</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function returns the consumer (RHS) of the operation instead of the producer (LHS). This is opposite of typical behavior of &gt;&gt; operators.</dd></dl>
<p>Place a precedence on a producer to the consumer. The consumer is returned, <b>not</b> the producer. This is to allow chaining:</p>
<div class="fragment"><div class="line">my_producer_event_ &gt;&gt; my_consumer_event_ &gt;&gt; my_event_following_consumption_;</div>
</div><!-- fragment --><p>This implementation of the precedence operator catches a Scheduleable/EventNode on the LHS preceding another and ensures the two events are within the same phase.</p>
<div class="fragment"><div class="line">ev_tick &gt;&gt; my_outgoing_bus;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Precedence_8hpp_source.html#l00953">953</a> of file <a class="el" href="Precedence_8hpp_source.html">Precedence.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_ad59075953a8f2a9ec7b1a5903c52cb5c_cgraph.png" border="0" usemap="#anamespacesparta_ad59075953a8f2a9ec7b1a5903c52cb5c_cgraph" alt=""/></div>
<map name="anamespacesparta_ad59075953a8f2a9ec7b1a5903c52cb5c_cgraph" id="anamespacesparta_ad59075953a8f2a9ec7b1a5903c52cb5c_cgraph">
<area shape="rect" title="Place a precedence between a Scheduleable and a Bus." alt="" coords="5,56,132,82"/>
<area shape="rect" href="classsparta_1_1Bus.html#aaa21e7e76aa07cf62654c38578c3c8e8" title="Make all outports succeed the given event." alt="" coords="180,56,370,82"/>
<area shape="poly" title=" " alt="" coords="132,66,164,66,164,72,132,72"/>
<area shape="rect" href="classsparta_1_1Bus.html#a4f2d0c49bb361b96024d3bb0ef3ada65" title="Get the ports in this PortSet for the given direction." alt="" coords="426,16,567,42"/>
<area shape="poly" title=" " alt="" coords="349,53,410,42,411,47,350,58"/>
<area shape="rect" href="classsparta_1_1OutPort.html#a6a9af2af9223255b8b1fc4877e5893d5" title="Add an event &quot;producer&quot; to this port." alt="" coords="418,76,575,117"/>
<area shape="poly" title=" " alt="" coords="371,78,402,82,402,88,370,84"/>
<area shape="rect" href="classsparta_1_1PortSet.html#a5c61be847db017f48430c57c7e7967dc" title="Get the ports in this PortSet for the given direction." alt="" coords="632,5,794,31"/>
<area shape="poly" title=" " alt="" coords="568,23,617,20,617,26,568,28"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#abfa3602a9ab827b1351ef8f518c32576" title="Gets the name of this node." alt="" coords="623,55,803,80"/>
<area shape="poly" title=" " alt="" coords="575,84,607,79,608,84,576,89"/>
<area shape="rect" href="classsparta_1_1Port.html#a8d71612c1256b048b9ec52d06fe2ba2f" title="Is this port bound to another port?" alt="" coords="643,104,783,130"/>
<area shape="poly" title=" " alt="" coords="576,101,628,106,627,112,575,107"/>
<area shape="rect" href="classsparta_1_1OutPort.html#a08bfa7d5cc8c5bc6961cd8fda5f72b7f" title=" " alt="" coords="634,154,792,194"/>
<area shape="poly" title=" " alt="" coords="557,115,640,146,639,151,555,120"/>
</map>
</div>

</div>
</div>
<a id="a85ceed42442bee420e907ad303e3c93b" name="a85ceed42442bee420e907ad303e3c93b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ceed42442bee420e907ad303e3c93b">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[18/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ScheduleableTypeA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsparta_1_1EventGroup.html">EventGroup</a> &amp; sparta::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">ScheduleableTypeA &amp;</td>          <td class="paramname"><span class="paramname"><em>producer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1EventGroup.html">EventGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>consumers</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This template supports the following: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">producer</td><td>The <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">Scheduleable</a> that precedes each of the Scheduleables in the <a class="el" href="classsparta_1_1EventGroup.html" title="Group a series of events together for precedence establishment.">EventGroup</a> </td></tr>
    <tr><td class="paramname">consumer</td><td>Group of Scheduleables that must come after the given producer <div class="fragment"><div class="line">ProEvent1 &gt;&gt; <a class="code hl_class" href="classsparta_1_1EventGroup.html">sparta::EventGroup</a>(ConsEvent1, ConsEvent2, ConsEvent3, ... );</div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<p>Where each consuming event is preceded by the single producing event. The consuming events are still independent. </p>

<p class="definition">Definition at line <a class="el" href="Precedence_8hpp_source.html#l01165">1165</a> of file <a class="el" href="Precedence_8hpp_source.html">Precedence.hpp</a>.</p>

</div>
</div>
<a id="a7059a71a007a55c76350eab5b78e2822" name="a7059a71a007a55c76350eab5b78e2822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7059a71a007a55c76350eab5b78e2822">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[19/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ScheduleableTypeA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="classsparta_1_1EventNode.html">EventNode</a>, ScheduleableTypeA &gt;::value, constGlobalOrderingPoint &gt;::type &amp; sparta::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">ScheduleableTypeA &amp;</td>          <td class="paramname"><span class="paramname"><em>producer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1GlobalOrderingPoint.html">GlobalOrderingPoint</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>consumer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place a precedence between a <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">Scheduleable</a> object and a <a class="el" href="classsparta_1_1GlobalOrderingPoint.html" title="Used to set precedence between Scheduleable types across simulation.">GlobalOrderingPoint</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">producer</td><td>The producer (LHS) must come before consumer (RHS) </td></tr>
    <tr><td class="paramname">consumer</td><td>The <a class="el" href="classsparta_1_1GlobalOrderingPoint.html" title="Used to set precedence between Scheduleable types across simulation.">GlobalOrderingPoint</a> (Vertex type) to succeed the ScheduleableType</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The consumer</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function returns the consumer (RHS) of the operation instead of the producer (LHS). This is opposite of typical behavior of &gt;&gt; operators.</dd></dl>
<p>Place a precedence on a producer to the consumer. The consumer is returned, <b>not</b> the producer. This is to allow chaining:</p>
<div class="fragment"><div class="line">my_producer_event_ &gt;&gt; my_consumer_event_ &gt;&gt; my_event_following_consumption_;</div>
</div><!-- fragment --><p>This implementation of the precedence operator catches a <a class="el" href="classsparta_1_1Scheduleable.html" title="A class that defines the basic scheduling interface to the Scheduler. Not intended to be used by mode...">Scheduleable</a> on the LHS preceding a <a class="el" href="classsparta_1_1GlobalOrderingPoint.html" title="Used to set precedence between Scheduleable types across simulation.">GlobalOrderingPoint</a> point and ensures the two events are within the same phase.</p>
<div class="fragment"><div class="line">(<a class="code hl_class" href="classsparta_1_1UniqueEvent.html">UniqueEvent</a>, <a class="code hl_class" href="classsparta_1_1PayloadEvent.html">PayloadEvent</a>, <a class="code hl_class" href="classsparta_1_1SingleCycleUniqueEvent.html">SingleCycleUniqueEvent</a>, <a class="code hl_class" href="classsparta_1_1Event.html">Event</a>) &gt;&gt; <a class="code hl_class" href="classsparta_1_1GlobalOrderingPoint.html">GlobalOrderingPoint</a>(node, <span class="stringliteral">&quot;gop&quot;</span>);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Precedence_8hpp_source.html#l00138">138</a> of file <a class="el" href="Precedence_8hpp_source.html">Precedence.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_a7059a71a007a55c76350eab5b78e2822_cgraph.png" border="0" usemap="#anamespacesparta_a7059a71a007a55c76350eab5b78e2822_cgraph" alt=""/></div>
<map name="anamespacesparta_a7059a71a007a55c76350eab5b78e2822_cgraph" id="anamespacesparta_a7059a71a007a55c76350eab5b78e2822_cgraph">
<area shape="rect" title="Place a precedence between a Scheduleable object and a GlobalOrderingPoint." alt="" coords="5,13,132,38"/>
<area shape="rect" href="classsparta_1_1GlobalOrderingPoint.html#afc48fcdbb8b5c72d1d45ba95da84ba86" title="Used by the precedence rules." alt="" coords="180,5,359,46"/>
<area shape="poly" title=" " alt="" coords="132,23,164,23,164,28,132,28"/>
</map>
</div>

</div>
</div>
<a id="a8bf04f92023ad53fa82d126bbe8ed9d4" name="a8bf04f92023ad53fa82d126bbe8ed9d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf04f92023ad53fa82d126bbe8ed9d4">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[20/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT1, class DataT2 , <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1PayloadEvent.html">PayloadEvent</a>&lt; DataT2, PayloadPhaseT2 &gt; &amp; sparta::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html">SingleCycleUniqueEvent</a>&lt; PayloadPhaseT1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>producer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1PayloadEvent.html">PayloadEvent</a>&lt; DataT2, PayloadPhaseT2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>consumer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place a precedence between a <a class="el" href="classsparta_1_1PayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...">PayloadEvent</a> and an <a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html" title="An event that can only be schedule one cycle into the future.">SingleCycleUniqueEvent</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">producer</td><td>The <a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html" title="An event that can only be schedule one cycle into the future.">SingleCycleUniqueEvent</a> to succeed a <a class="el" href="classsparta_1_1PayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...">PayloadEvent</a> </td></tr>
    <tr><td class="paramname">consumer</td><td>The producer (LHS) must come before consumer (RHS)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The consumer</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function returns the consumer (RHS) of the operation instead of the producer (LHS). This is opposite of typical behavior of &gt;&gt; operators.</dd></dl>
<p>Place a precedence on a producer to the consumer. The consumer is returned, <b>not</b> the producer. This is to allow chaining:</p>
<div class="fragment"><div class="line">my_producer_event_ &gt;&gt; my_consumer_event_ &gt;&gt; my_event_following_consumption_;</div>
</div><!-- fragment --><p>This implementation of the precedence operator catches a Scheduleable/EventNode on the LHS preceding another and ensures the two events are within the same phase.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsparta_1_1SingleCycleUniqueEvent.html">SingleCycleUniqueEvent&lt;P&gt;</a> &gt;&gt; <a class="code hl_class" href="classsparta_1_1PayloadEvent.html">PayloadEvent&lt;T, P&gt;</a>;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Precedence_8hpp_source.html#l00485">485</a> of file <a class="el" href="Precedence_8hpp_source.html">Precedence.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_a8bf04f92023ad53fa82d126bbe8ed9d4_cgraph.png" border="0" usemap="#anamespacesparta_a8bf04f92023ad53fa82d126bbe8ed9d4_cgraph" alt=""/></div>
<map name="anamespacesparta_a8bf04f92023ad53fa82d126bbe8ed9d4_cgraph" id="anamespacesparta_a8bf04f92023ad53fa82d126bbe8ed9d4_cgraph">
<area shape="rect" title="Place a precedence between a PayloadEvent and an SingleCycleUniqueEvent." alt="" coords="5,46,132,72"/>
<area shape="rect" href="classsparta_1_1PhasedPayloadEvent.html#ae4b329988917863c31f03a3764323a01" title="Get the scheduleable associated with this event node." alt="" coords="180,5,366,46"/>
<area shape="poly" title=" " alt="" coords="132,46,164,41,165,46,132,51"/>
<area shape="rect" href="classsparta_1_1PhasedSingleCycleUniqueEvent.html#a2fbbce0bf73293a1f7cbd0120bea3f12" title="Have this SingleCycleUniqueEvent precede another." alt="" coords="185,71,360,111"/>
<area shape="poly" title=" " alt="" coords="132,66,170,72,169,77,132,71"/>
<area shape="rect" href="classsparta_1_1Scheduleable.html#a697e61ff71726cc21d7e8eebe1ce83d2" title="Have this Scheduleable precede another." alt="" coords="414,71,555,111"/>
<area shape="poly" title=" " alt="" coords="361,88,398,88,398,94,361,94"/>
</map>
</div>

</div>
</div>
<a id="a6896b1c71d6ba7dab7dccf7eebc892e6" name="a6896b1c71d6ba7dab7dccf7eebc892e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6896b1c71d6ba7dab7dccf7eebc892e6">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[21/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT1, <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1UniqueEvent.html">UniqueEvent</a>&lt; PayloadPhaseT2 &gt; &amp; sparta::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html">SingleCycleUniqueEvent</a>&lt; PayloadPhaseT1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>producer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1UniqueEvent.html">UniqueEvent</a>&lt; PayloadPhaseT2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>consumer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place a precedence between a <a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html" title="An event that can only be schedule one cycle into the future.">SingleCycleUniqueEvent</a> and an <a class="el" href="classsparta_1_1UniqueEvent.html" title="A type of Event that uniquely schedules itself on the schedule within a single time quantum....">UniqueEvent</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">producer</td><td>The <a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html" title="An event that can only be schedule one cycle into the future.">SingleCycleUniqueEvent</a> to succeed an <a class="el" href="classsparta_1_1UniqueEvent.html" title="A type of Event that uniquely schedules itself on the schedule within a single time quantum....">UniqueEvent</a> </td></tr>
    <tr><td class="paramname">consumer</td><td>The producer (LHS) must come before consumer (RHS)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The consumer</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function returns the consumer (RHS) of the operation instead of the producer (LHS). This is opposite of typical behavior of &gt;&gt; operators.</dd></dl>
<p>Place a precedence on a producer to the consumer. The consumer is returned, <b>not</b> the producer. This is to allow chaining:</p>
<div class="fragment"><div class="line">my_producer_event_ &gt;&gt; my_consumer_event_ &gt;&gt; my_event_following_consumption_;</div>
</div><!-- fragment --><p>This implementation of the precedence operator catches a Scheduleable/EventNode on the LHS preceding another and ensures the two events are within the same phase.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsparta_1_1SingleCycleUniqueEvent.html">SingleCycleUniqueEvent&lt;P&gt;</a> &gt;&gt; <a class="code hl_class" href="classsparta_1_1UniqueEvent.html">UniqueEvent&lt;P&gt;</a>;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Precedence_8hpp_source.html#l00642">642</a> of file <a class="el" href="Precedence_8hpp_source.html">Precedence.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_a6896b1c71d6ba7dab7dccf7eebc892e6_cgraph.png" border="0" usemap="#anamespacesparta_a6896b1c71d6ba7dab7dccf7eebc892e6_cgraph" alt=""/></div>
<map name="anamespacesparta_a6896b1c71d6ba7dab7dccf7eebc892e6_cgraph" id="anamespacesparta_a6896b1c71d6ba7dab7dccf7eebc892e6_cgraph">
<area shape="rect" title="Place a precedence between a SingleCycleUniqueEvent and an UniqueEvent." alt="" coords="5,46,132,72"/>
<area shape="rect" href="classsparta_1_1EventNode.html#ade2ce9e1d898e826493a600eefebd6bf" title="Get the scheduleable associated with this event node." alt="" coords="201,5,334,46"/>
<area shape="poly" title=" " alt="" coords="131,46,185,37,186,42,132,51"/>
<area shape="rect" href="classsparta_1_1PhasedSingleCycleUniqueEvent.html#a2fbbce0bf73293a1f7cbd0120bea3f12" title="Have this SingleCycleUniqueEvent precede another." alt="" coords="180,71,355,111"/>
<area shape="poly" title=" " alt="" coords="132,66,165,72,164,77,131,72"/>
<area shape="rect" href="classsparta_1_1Scheduleable.html#a697e61ff71726cc21d7e8eebe1ce83d2" title="Have this Scheduleable precede another." alt="" coords="403,71,544,111"/>
<area shape="poly" title=" " alt="" coords="356,88,388,88,388,94,356,94"/>
</map>
</div>

</div>
</div>
<a id="a4f2830d90f0bbaaa445a29d896e038c0" name="a4f2830d90f0bbaaa445a29d896e038c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f2830d90f0bbaaa445a29d896e038c0">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[22/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PhaseT1, <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PhaseT2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html">SingleCycleUniqueEvent</a>&lt; PhaseT2 &gt; &amp; sparta::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html">SingleCycleUniqueEvent</a>&lt; PhaseT1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>producer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html">SingleCycleUniqueEvent</a>&lt; PhaseT2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>consumer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place a precedence between a <a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html" title="An event that can only be schedule one cycle into the future.">SingleCycleUniqueEvent</a> and a <a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html" title="An event that can only be schedule one cycle into the future.">SingleCycleUniqueEvent</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">producer</td><td>The <a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html" title="An event that can only be schedule one cycle into the future.">SingleCycleUniqueEvent</a> to succeed a <a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html" title="An event that can only be schedule one cycle into the future.">SingleCycleUniqueEvent</a> </td></tr>
    <tr><td class="paramname">consumer</td><td>The producer (LHS) must come before consumer (RHS)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The consumer</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function returns the consumer (RHS) of the operation instead of the producer (LHS). This is opposite of typical behavior of &gt;&gt; operators.</dd></dl>
<p>Place a precedence on a producer to the consumer. The consumer is returned, <b>not</b> the producer. This is to allow chaining:</p>
<div class="fragment"><div class="line">my_producer_event_ &gt;&gt; my_consumer_event_ &gt;&gt; my_event_following_consumption_;</div>
</div><!-- fragment --><p>This implementation of the precedence operator catches a Scheduleable/EventNode on the LHS preceding another and ensures the two events are within the same phase.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsparta_1_1SingleCycleUniqueEvent.html">SingleCycleUniqueEvent&lt;P&gt;</a> &gt;&gt; <a class="code hl_class" href="classsparta_1_1SingleCycleUniqueEvent.html">SingleCycleUniqueEvent&lt;P&gt;</a>;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Precedence_8hpp_source.html#l00681">681</a> of file <a class="el" href="Precedence_8hpp_source.html">Precedence.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_a4f2830d90f0bbaaa445a29d896e038c0_cgraph.png" border="0" usemap="#anamespacesparta_a4f2830d90f0bbaaa445a29d896e038c0_cgraph" alt=""/></div>
<map name="anamespacesparta_a4f2830d90f0bbaaa445a29d896e038c0_cgraph" id="anamespacesparta_a4f2830d90f0bbaaa445a29d896e038c0_cgraph">
<area shape="rect" title="Place a precedence between a SingleCycleUniqueEvent and a SingleCycleUniqueEvent." alt="" coords="5,46,132,72"/>
<area shape="rect" href="classsparta_1_1EventNode.html#ade2ce9e1d898e826493a600eefebd6bf" title="Get the scheduleable associated with this event node." alt="" coords="184,5,317,46"/>
<area shape="poly" title=" " alt="" coords="132,45,168,38,169,43,132,50"/>
<area shape="rect" href="classsparta_1_1Scheduleable.html#a697e61ff71726cc21d7e8eebe1ce83d2" title="Have this Scheduleable precede another." alt="" coords="180,71,321,111"/>
<area shape="poly" title=" " alt="" coords="132,67,165,73,164,79,132,73"/>
</map>
</div>

</div>
</div>
<a id="aa802de6b38a77a796ec5c0f03684a6eb" name="aa802de6b38a77a796ec5c0f03684a6eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa802de6b38a77a796ec5c0f03684a6eb">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[23/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class EventT1 , class EventT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EventT2 &amp; sparta::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; EventT1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>producer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EventT2 &amp;</td>          <td class="paramname"><span class="paramname"><em>consumer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place a precedence between a std::unique_ptr&lt;EventT1&gt; and EventT2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">producer</td><td>The EventT1 to succeed a EventT2 </td></tr>
    <tr><td class="paramname">consumer</td><td>The producer (LHS) must come before consumer (RHS)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The consumer</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function returns the consumer (RHS) of the operation instead of the producer (LHS). This is opposite of typical behavior of &gt;&gt; operators.</dd></dl>
<p>Place a precedence on a producer to the consumer. The consumer is returned, <b>not</b> the producer. This is to allow chaining:</p>
<div class="fragment"><div class="line">my_producer_event_ &gt;&gt; my_consumer_event_ &gt;&gt; my_event_following_consumption_;</div>
</div><!-- fragment --><p>This implementation of the precedence operator catches a Scheduleable/EventNode on the LHS preceding another and ensures the two events are within the same phase.</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;EventT1&gt; &gt;&gt; EventT2;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Precedence_8hpp_source.html#l00832">832</a> of file <a class="el" href="Precedence_8hpp_source.html">Precedence.hpp</a>.</p>

</div>
</div>
<a id="a73a5b4234fbf5e967f7a35488aa25adf" name="a73a5b4234fbf5e967f7a35488aa25adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73a5b4234fbf5e967f7a35488aa25adf">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[24/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class EventT1 , class EventT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; EventT2 &gt; &amp; sparta::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; EventT1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>producer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; EventT2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>consumer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place a precedence between a std::unique_ptr&lt;EventT1&gt; and another std::unique_ptr&lt;EventT2&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">producer</td><td>The EventT1 to succeed a EventT2 </td></tr>
    <tr><td class="paramname">consumer</td><td>The producer (LHS) must come before consumer (RHS)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The consumer</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function returns the consumer (RHS) of the operation instead of the producer (LHS). This is opposite of typical behavior of &gt;&gt; operators.</dd></dl>
<p>Place a precedence on a producer to the consumer. The consumer is returned, <b>not</b> the producer. This is to allow chaining:</p>
<div class="fragment"><div class="line">my_producer_event_ &gt;&gt; my_consumer_event_ &gt;&gt; my_event_following_consumption_;</div>
</div><!-- fragment --><p>This implementation of the precedence operator catches a Scheduleable/EventNode on the LHS preceding another and ensures the two events are within the same phase.</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;EventT1&gt; &gt;&gt; std::unique_ptr&lt;EventT2&gt;;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Precedence_8hpp_source.html#l00763">763</a> of file <a class="el" href="Precedence_8hpp_source.html">Precedence.hpp</a>.</p>

</div>
</div>
<a id="a4d25aa7a5045f86ad433dd673586dea2" name="a4d25aa7a5045f86ad433dd673586dea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d25aa7a5045f86ad433dd673586dea2">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[25/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT1, class DataT2 , <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1PayloadEvent.html">PayloadEvent</a>&lt; DataT2, PayloadPhaseT2 &gt; &amp; sparta::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1UniqueEvent.html">UniqueEvent</a>&lt; PayloadPhaseT1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>producer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1PayloadEvent.html">PayloadEvent</a>&lt; DataT2, PayloadPhaseT2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>consumer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place a precedence between a <a class="el" href="classsparta_1_1PayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...">PayloadEvent</a> and an <a class="el" href="classsparta_1_1UniqueEvent.html" title="A type of Event that uniquely schedules itself on the schedule within a single time quantum....">UniqueEvent</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">producer</td><td>The <a class="el" href="classsparta_1_1UniqueEvent.html" title="A type of Event that uniquely schedules itself on the schedule within a single time quantum....">UniqueEvent</a> to succeed a <a class="el" href="classsparta_1_1PayloadEvent.html" title="Class to schedule a Scheduleable in the future with a payload, typed on both the data type and the sc...">PayloadEvent</a> </td></tr>
    <tr><td class="paramname">consumer</td><td>The producer (LHS) must come before consumer (RHS)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The consumer</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function returns the consumer (RHS) of the operation instead of the producer (LHS). This is opposite of typical behavior of &gt;&gt; operators.</dd></dl>
<p>Place a precedence on a producer to the consumer. The consumer is returned, <b>not</b> the producer. This is to allow chaining:</p>
<div class="fragment"><div class="line">my_producer_event_ &gt;&gt; my_consumer_event_ &gt;&gt; my_event_following_consumption_;</div>
</div><!-- fragment --><p>This implementation of the precedence operator catches a Scheduleable/EventNode on the LHS preceding another and ensures the two events are within the same phase.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsparta_1_1UniqueEvent.html">UniqueEvent&lt;P&gt;</a> &gt;&gt; <a class="code hl_class" href="classsparta_1_1PayloadEvent.html">PayloadEvent&lt;T, P&gt;</a>;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Precedence_8hpp_source.html#l00447">447</a> of file <a class="el" href="Precedence_8hpp_source.html">Precedence.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_a4d25aa7a5045f86ad433dd673586dea2_cgraph.png" border="0" usemap="#anamespacesparta_a4d25aa7a5045f86ad433dd673586dea2_cgraph" alt=""/></div>
<map name="anamespacesparta_a4d25aa7a5045f86ad433dd673586dea2_cgraph" id="anamespacesparta_a4d25aa7a5045f86ad433dd673586dea2_cgraph">
<area shape="rect" title="Place a precedence between a PayloadEvent and an UniqueEvent." alt="" coords="5,46,132,72"/>
<area shape="rect" href="classsparta_1_1PhasedPayloadEvent.html#ae4b329988917863c31f03a3764323a01" title="Get the scheduleable associated with this event node." alt="" coords="180,5,366,46"/>
<area shape="poly" title=" " alt="" coords="132,46,164,41,165,46,132,51"/>
<area shape="rect" href="classsparta_1_1Scheduleable.html#a697e61ff71726cc21d7e8eebe1ce83d2" title="Have this Scheduleable precede another." alt="" coords="202,71,344,111"/>
<area shape="poly" title=" " alt="" coords="132,66,188,75,187,80,132,71"/>
</map>
</div>

</div>
</div>
<a id="a4f295b2cf0f4cec80b27714ab48be2b7" name="a4f295b2cf0f4cec80b27714ab48be2b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f295b2cf0f4cec80b27714ab48be2b7">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[26/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT1, <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html">SingleCycleUniqueEvent</a>&lt; PayloadPhaseT2 &gt; &amp; sparta::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1UniqueEvent.html">UniqueEvent</a>&lt; PayloadPhaseT1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>producer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html">SingleCycleUniqueEvent</a>&lt; PayloadPhaseT2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>consumer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place a precedence between a <a class="el" href="classsparta_1_1UniqueEvent.html" title="A type of Event that uniquely schedules itself on the schedule within a single time quantum....">UniqueEvent</a> and an <a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html" title="An event that can only be schedule one cycle into the future.">SingleCycleUniqueEvent</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">producer</td><td>The <a class="el" href="classsparta_1_1UniqueEvent.html" title="A type of Event that uniquely schedules itself on the schedule within a single time quantum....">UniqueEvent</a> to succeed a <a class="el" href="classsparta_1_1SingleCycleUniqueEvent.html" title="An event that can only be schedule one cycle into the future.">SingleCycleUniqueEvent</a> </td></tr>
    <tr><td class="paramname">consumer</td><td>The producer (LHS) must come before consumer (RHS)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The consumer</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function returns the consumer (RHS) of the operation instead of the producer (LHS). This is opposite of typical behavior of &gt;&gt; operators.</dd></dl>
<p>Place a precedence on a producer to the consumer. The consumer is returned, <b>not</b> the producer. This is to allow chaining:</p>
<div class="fragment"><div class="line">my_producer_event_ &gt;&gt; my_consumer_event_ &gt;&gt; my_event_following_consumption_;</div>
</div><!-- fragment --><p>This implementation of the precedence operator catches a Scheduleable/EventNode on the LHS preceding another and ensures the two events are within the same phase.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsparta_1_1UniqueEvent.html">UniqueEvent&lt;P&gt;</a> &gt;&gt; <a class="code hl_class" href="classsparta_1_1SingleCycleUniqueEvent.html">SingleCycleUniqueEvent&lt;P&gt;</a>;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Precedence_8hpp_source.html#l00605">605</a> of file <a class="el" href="Precedence_8hpp_source.html">Precedence.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_a4f295b2cf0f4cec80b27714ab48be2b7_cgraph.png" border="0" usemap="#anamespacesparta_a4f295b2cf0f4cec80b27714ab48be2b7_cgraph" alt=""/></div>
<map name="anamespacesparta_a4f295b2cf0f4cec80b27714ab48be2b7_cgraph" id="anamespacesparta_a4f295b2cf0f4cec80b27714ab48be2b7_cgraph">
<area shape="rect" title="Place a precedence between a UniqueEvent and an SingleCycleUniqueEvent." alt="" coords="5,46,132,72"/>
<area shape="rect" href="classsparta_1_1EventNode.html#ade2ce9e1d898e826493a600eefebd6bf" title="Get the scheduleable associated with this event node." alt="" coords="184,5,317,46"/>
<area shape="poly" title=" " alt="" coords="132,45,168,38,169,43,132,50"/>
<area shape="rect" href="classsparta_1_1Scheduleable.html#a697e61ff71726cc21d7e8eebe1ce83d2" title="Have this Scheduleable precede another." alt="" coords="180,71,321,111"/>
<area shape="poly" title=" " alt="" coords="132,67,165,73,164,79,132,73"/>
</map>
</div>

</div>
</div>
<a id="ab02f6b8a64f7b1e8e7ff25f3d78dabd8" name="ab02f6b8a64f7b1e8e7ff25f3d78dabd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab02f6b8a64f7b1e8e7ff25f3d78dabd8">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[27/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT1, <a class="el" href="#aeec80d237ace9f07634c3d24c9aed9a0">SchedulingPhase</a> PayloadPhaseT2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1UniqueEvent.html">UniqueEvent</a>&lt; PayloadPhaseT2 &gt; &amp; sparta::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsparta_1_1UniqueEvent.html">UniqueEvent</a>&lt; PayloadPhaseT1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>producer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1UniqueEvent.html">UniqueEvent</a>&lt; PayloadPhaseT2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>consumer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place a precedence between a <a class="el" href="classsparta_1_1UniqueEvent.html" title="A type of Event that uniquely schedules itself on the schedule within a single time quantum....">UniqueEvent</a> and an <a class="el" href="classsparta_1_1UniqueEvent.html" title="A type of Event that uniquely schedules itself on the schedule within a single time quantum....">UniqueEvent</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">producer</td><td>The <a class="el" href="classsparta_1_1UniqueEvent.html" title="A type of Event that uniquely schedules itself on the schedule within a single time quantum....">UniqueEvent</a> to succeed a <a class="el" href="classsparta_1_1UniqueEvent.html" title="A type of Event that uniquely schedules itself on the schedule within a single time quantum....">UniqueEvent</a> </td></tr>
    <tr><td class="paramname">consumer</td><td>The producer (LHS) must come before consumer (RHS)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The consumer</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function returns the consumer (RHS) of the operation instead of the producer (LHS). This is opposite of typical behavior of &gt;&gt; operators.</dd></dl>
<p>Place a precedence on a producer to the consumer. The consumer is returned, <b>not</b> the producer. This is to allow chaining:</p>
<div class="fragment"><div class="line">my_producer_event_ &gt;&gt; my_consumer_event_ &gt;&gt; my_event_following_consumption_;</div>
</div><!-- fragment --><p>This implementation of the precedence operator catches a Scheduleable/EventNode on the LHS preceding another and ensures the two events are within the same phase.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsparta_1_1UniqueEvent.html">UniqueEvent&lt;P&gt;</a> &gt;&gt; <a class="code hl_class" href="classsparta_1_1UniqueEvent.html">UniqueEvent&lt;P&gt;</a>;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Precedence_8hpp_source.html#l00568">568</a> of file <a class="el" href="Precedence_8hpp_source.html">Precedence.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_ab02f6b8a64f7b1e8e7ff25f3d78dabd8_cgraph.png" border="0" usemap="#anamespacesparta_ab02f6b8a64f7b1e8e7ff25f3d78dabd8_cgraph" alt=""/></div>
<map name="anamespacesparta_ab02f6b8a64f7b1e8e7ff25f3d78dabd8_cgraph" id="anamespacesparta_ab02f6b8a64f7b1e8e7ff25f3d78dabd8_cgraph">
<area shape="rect" title="Place a precedence between a UniqueEvent and an UniqueEvent." alt="" coords="5,46,132,72"/>
<area shape="rect" href="classsparta_1_1EventNode.html#ade2ce9e1d898e826493a600eefebd6bf" title="Get the scheduleable associated with this event node." alt="" coords="184,5,317,46"/>
<area shape="poly" title=" " alt="" coords="132,45,168,38,169,43,132,50"/>
<area shape="rect" href="classsparta_1_1Scheduleable.html#a697e61ff71726cc21d7e8eebe1ce83d2" title="Have this Scheduleable precede another." alt="" coords="180,71,321,111"/>
<area shape="poly" title=" " alt="" coords="132,67,165,73,164,79,132,73"/>
</map>
</div>

</div>
</div>
<a id="a57002ba92c08d4a3abb4acb2824bc6d3" name="a57002ba92c08d4a3abb4acb2824bc6d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57002ba92c08d4a3abb4acb2824bc6d3">&#9670;&#160;</a></span>reorder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enum <a class="el" href="#afc3e7ddb8e5c54811105c5ab61112a5b">ByteOrder</a> BO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; boost::mpl::int_&lt; BO &gt;, boost::mpl::int_&lt; <a class="el" href="#afc3e7ddb8e5c54811105c5ab61112a5bae6d6457742b40b16092846e8e785f3ba">BE</a> &gt; &gt;::value, T &gt;::type sparta::reorder </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Takes a value of type T from native byte order to the designed byte order Specialization for Big-Endian </p>

<p class="definition">Definition at line <a class="el" href="ByteOrder_8hpp_source.html#l00143">143</a> of file <a class="el" href="ByteOrder_8hpp_source.html">ByteOrder.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_a57002ba92c08d4a3abb4acb2824bc6d3_cgraph.png" border="0" usemap="#anamespacesparta_a57002ba92c08d4a3abb4acb2824bc6d3_cgraph" alt=""/></div>
<map name="anamespacesparta_a57002ba92c08d4a3abb4acb2824bc6d3_cgraph" id="anamespacesparta_a57002ba92c08d4a3abb4acb2824bc6d3_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,109,31"/>
<area shape="rect" href="namespacesparta.html#a17970a38d3054bdd50ce337e22a35679" title="Swaps the order of bytes for various types." alt="" coords="157,5,282,31"/>
<area shape="poly" title=" " alt="" coords="109,16,141,16,141,21,109,21"/>
</map>
</div>

</div>
</div>
<a id="ae42744ae87cf1b049252fc73de5ece03" name="ae42744ae87cf1b049252fc73de5ece03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae42744ae87cf1b049252fc73de5ece03">&#9670;&#160;</a></span>reorder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enum <a class="el" href="#afc3e7ddb8e5c54811105c5ab61112a5b">ByteOrder</a> BO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; boost::mpl::int_&lt; BO &gt;, boost::mpl::int_&lt; LE &gt; &gt;::value, T &gt;::type sparta::reorder </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Takes a value of type T from native byte order to the designed byte order Specialization for Little-Endian </p>

<p class="definition">Definition at line <a class="el" href="ByteOrder_8hpp_source.html#l00152">152</a> of file <a class="el" href="ByteOrder_8hpp_source.html">ByteOrder.hpp</a>.</p>

</div>
</div>
<a id="ab43ec25e72735ede6e889caf6714ddff" name="ab43ec25e72735ede6e889caf6714ddff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43ec25e72735ede6e889caf6714ddff">&#9670;&#160;</a></span>replaceSubstring()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sparta::replaceSubstring </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>to</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces within a string 's' all instances of some string 'from' with 'to'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>String to perform replacement on </td></tr>
    <tr><td class="paramname">from</td><td>String to replace with &lt;to&gt; </td></tr>
    <tr><td class="paramname">to</td><td>String to replace all instances of &lt;from&gt; with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of replacements </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This can resize the string <s> if from and to are different lengths.</s></dd></dl>
<p>Replaces based on found instances of &lt;from&gt; starting from position 0. After replacing, the loop advances to the end of the replaced text and continues there. Characters inserted from &lt;to&gt; will never be matched as part of a &lt;from&gt; </p>

<p class="definition">Definition at line <a class="el" href="Utils_8hpp_source.html#l00276">276</a> of file <a class="el" href="Utils_8hpp_source.html">Utils.hpp</a>.</p>

</div>
</div>
<a id="a3daa869502f6ee8730edca1f3b60733f" name="a3daa869502f6ee8730edca1f3b60733f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3daa869502f6ee8730edca1f3b60733f">&#9670;&#160;</a></span>smartLexicalCast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T sparta::smartLexicalCast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsparta_1_1ParameterBase.html">ParameterBase</a> *</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>end_pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allow_recursion</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allow_prefix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>smartLexicalCast wrapper with parameter information added to exceptions </p>

<p class="definition">Definition at line <a class="el" href="Parameter_8hpp_source.html#l02558">2558</a> of file <a class="el" href="Parameter_8hpp_source.html">Parameter.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacesparta_a3daa869502f6ee8730edca1f3b60733f_cgraph.png" border="0" usemap="#anamespacesparta_a3daa869502f6ee8730edca1f3b60733f_cgraph" alt=""/></div>
<map name="anamespacesparta_a3daa869502f6ee8730edca1f3b60733f_cgraph" id="anamespacesparta_a3daa869502f6ee8730edca1f3b60733f_cgraph">
<area shape="rect" title="smartLexicalCast wrapper with parameter information added to exceptions" alt="" coords="5,5,170,31"/>
<area shape="rect" href="classsparta_1_1TreeNode.html#a1a6d4aac10bfa5345b587d84170441de" title=" " alt="" coords="218,5,412,31"/>
<area shape="poly" title=" " alt="" coords="170,16,202,16,202,21,170,21"/>
</map>
</div>

</div>
</div>
<a id="ad51fd0296b8a1f9bc5e6a4ddb69bef69" name="ad51fd0296b8a1f9bc5e6a4ddb69bef69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad51fd0296b8a1f9bc5e6a4ddb69bef69">&#9670;&#160;</a></span>toLower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string sparta::toLower </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a copy of an input string s in lower-case. </p>

<p class="definition">Definition at line <a class="el" href="Utils_8hpp_source.html#l00352">352</a> of file <a class="el" href="Utils_8hpp_source.html">Utils.hpp</a>.</p>

</div>
</div>
<a id="aa8b6a7e7f071080f91d35b6625afa0d3" name="aa8b6a7e7f071080f91d35b6625afa0d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b6a7e7f071080f91d35b6625afa0d3">&#9670;&#160;</a></span>writeNChars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::writeNChars </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>num</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>chr</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'&#160;'</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a number of some character into an ostream. </p>

<p class="definition">Definition at line <a class="el" href="Utils_8hpp_source.html#l00343">343</a> of file <a class="el" href="Utils_8hpp_source.html">Utils.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a7b1d29b159e4430934f6d9694d76c51d" name="a7b1d29b159e4430934f6d9694d76c51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1d29b159e4430934f6d9694d76c51d">&#9670;&#160;</a></span>NUM_SCHEDULING_PHASES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t sparta::NUM_SCHEDULING_PHASES</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">        <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(SchedulingPhase::__last_scheduling_phase)</div>
</div><!-- fragment -->
<p>The number of phases. </p>

<p class="definition">Definition at line <a class="el" href="SchedulingPhases_8hpp_source.html#l00075">75</a> of file <a class="el" href="SchedulingPhases_8hpp_source.html">SchedulingPhases.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesparta.html">sparta</a></li>
    <li class="footer">Generated on Mon Feb 9 2026 03:27:55 for The Sparta Modeling Framework by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
