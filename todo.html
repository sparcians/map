<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Sparta Modeling Framework: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">The Sparta Modeling Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('todo.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Todo List</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt>Page <a class="el" href="log_out_format.html">Logging Output formats (.log, .log.raw, .log.basic, log.verbose)</a>  </dt>
<dd><a class="anchor" id="_todo000007"></a>Write this page  </dd>
<dt>Page <a class="el" href="end_user.html">Sparta Command Line Interface End-User Guide</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000001"></a>Write this section</p>
<p class="interdd"><a class="anchor" id="_todo000002"></a>Write this section</p><ol type="1">
<li>Configuration</li>
<li>Traces</li>
<li>Run Control</li>
<li>Notifications</li>
<li>Inspecting configuration</li>
<li>Showing the tree</li>
<li>Writing configuration</li>
</ol>
<p class="interdd"><a class="anchor" id="_todo000003"></a>Complete this section</p>
<p class="interdd"><a class="anchor" id="_todo000004"></a>Complete this section</p><ol type="1">
<li>Parsing</li>
<li>Formats/extending</li>
</ol>
<p class="interdd"><a class="anchor" id="_todo000005"></a>Write this section</p>
<p class="enddd"><a class="anchor" id="_todo000006"></a>Write this section </p>
</dd>
<dt>Member <a class="el" href="classsparta_1_1app_1_1NodeConfigFileApplicator.html#a0e4c4359d54edc3d4cc4a8bf528688bd">sparta::app::NodeConfigFileApplicator::tryApply</a>  (<a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">sparta::TreeNode</a> *root, ApplySuccessCondition asc, ApplyFilter filter=ApplyFilter(), bool verbose=false) const override</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000010"></a>Allow meta-data attached to virtual parameter trees </p>
<p class="interdd"><a class="anchor" id="_todo000011"></a></p>
<p class="enddd"><a class="anchor" id="_todo000012"></a>Support tracking of set parameters and error on 0-paramerters set based on ASC_ policy.  </p>
</dd>
<dt>Member <a class="el" href="classsparta_1_1app_1_1ParameterApplicator.html#a5f577160c2f4417013a75b1c78f417d5">sparta::app::ParameterApplicator::tryApply</a>  (<a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">sparta::TreeNode</a> *root, ApplySuccessCondition required, ApplyFilter filter, bool verbose) const override</dt>
<dd><a class="anchor" id="_todo000008"></a>Allow meta-data attached to virtual parameter trees  </dd>
<dt>Member <a class="el" href="classsparta_1_1app_1_1ParameterDefaultApplicator.html#a4d1fba374944910d440cf01657275e99">sparta::app::ParameterDefaultApplicator::tryApply</a>  (<a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">sparta::TreeNode</a> *root, ApplySuccessCondition required, ApplyFilter filter=ApplyFilter(), bool verbose=false) const override</dt>
<dd><a class="anchor" id="_todo000009"></a>Allow meta-data attached to virtual parameter trees  </dd>
<dt>Member <a class="el" href="classsparta_1_1bounded__int.html#a2a7d921409ce49db15310aea13716ce2">sparta::bounded_int&lt; T, min_bound, max_bound &gt;::operator T</a>  () const</dt>
<dd><a class="anchor" id="_todo000093"></a>Add static methods to convert a value using additional bounds. A new bounded value can be constructed to achieve this as well.  </dd>
<dt>Member <a class="el" href="classsparta_1_1ClockManager.html#ab8957cecec6faa5fb61fd7d08b6fbbd7">sparta::ClockManager::makeRoot</a>  (<a class="el" href="classsparta_1_1RootTreeNode.html" title="TreeNode which represents the root (&quot;top&quot;) of a device tree.">RootTreeNode</a> *parent=nullptr, const std::string &amp;name="Root")</dt>
<dd><a class="anchor" id="_todo000048"></a>Implement special case for RootClock that avoids this extra level  </dd>
<dt>Member <a class="el" href="classsparta_1_1collection_1_1PipelineCollector.html#a30ffe36a80b193beba0da60a8c64ac7c">sparta::collection::PipelineCollector::PipelineCollector</a>  (const std::string &amp;filepath, <a class="el" href="classsparta_1_1Scheduler.html#a2c6114226a2d41fb22ac0395520b56c3" title="Typedef for our unit of time.">Scheduler::Tick</a> heartbeat_interval, const <a class="el" href="classsparta_1_1Clock.html" title="A representation of simulated time.">sparta::Clock</a> *root_clk, const <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">sparta::TreeNode</a> *root, <a class="el" href="classsparta_1_1Scheduler.html" title="A class that lets you schedule events now and in the future.">Scheduler</a> *scheduler=nullptr)</dt>
<dd><a class="anchor" id="_todo000014"></a>The multiplier should also be scaled slightly by the number of locations registered in order to better estimate the ideal heartbeat size.  </dd>
<dt>Member <a class="el" href="classsparta_1_1Counter.html#a6ddd114c70b29a8ed9001635ba6d79a7">sparta::Counter::get</a>  () const override</dt>
<dd><a class="anchor" id="_todo000084"></a>Allow indexed accesses if larger counters are supported.  </dd>
<dt>Member <a class="el" href="classsparta_1_1Counter.html#a2018763d34404360c22704dadcd7f8e3">sparta::Counter::increment</a>  (counter_type add)</dt>
<dd><a class="anchor" id="_todo000081"></a>Allow indexed accesses if larger counters are supported  </dd>
<dt>Member <a class="el" href="classsparta_1_1Counter.html#a7525fb79899ba1f369ae66b6334e7286">sparta::Counter::operator++</a>  ()</dt>
<dd><a class="anchor" id="_todo000082"></a>Allow indexed accesses if larger counters are supported  </dd>
<dt>Member <a class="el" href="classsparta_1_1Counter.html#af900d4e3e6903e889d1e49e7352bc15a">sparta::Counter::operator++</a>  (int)</dt>
<dd><a class="anchor" id="_todo000083"></a>Allow indexed accesses if larger counters are supported  </dd>
<dt>Member <a class="el" href="classsparta_1_1Counter.html#a79e138c4e54f9793cb3f671022535f1b">sparta::Counter::set</a>  (counter_type val)</dt>
<dd><a class="anchor" id="_todo000080"></a>Allow indexed accesses if larger counters are supported </dd>
<dt>Member <a class="el" href="classsparta_1_1CounterBase.html#a31d36b265b2bc10db58b1461cd63c516">sparta::CounterBase::get</a>  () const =0</dt>
<dd><a class="anchor" id="_todo000085"></a>Allow indexed accesses if larger counters are supported.  </dd>
<dt>Member <a class="el" href="classsparta_1_1CycleCounter.html#a88fd7c307e15277ef72eef42aa3446d6">sparta::CycleCounter::get</a>  () const override</dt>
<dd><a class="anchor" id="_todo000086"></a>Allow indexed accesses if larger counters are supported.  </dd>
<dt>Class <a class="el" href="classsparta_1_1DataOutPort.html">sparta::DataOutPort&lt; DataT &gt;</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000046"></a>Add support for requiring bounded ports </p>
<p class="interdd"></p>
<p class="enddd">Add support for automatic collection  </p>
</dd>
<dt>Member <a class="el" href="classsparta_1_1DataView.html#a7905ffabe69032fefc40522de224b9cd">sparta::DataView::place_</a>  (offset_type offset) override</dt>
<dd><a class="anchor" id="_todo000017"></a>Store pointer directly to value to save an add in offset  </dd>
<dt>Class <a class="el" href="classsparta_1_1log_1_1MessageSource.html">sparta::log::MessageSource</a>  </dt>
<dd><a class="anchor" id="_todo000036"></a>Must understand current thread + sequence within that thread  </dd>
<dt>Member <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html#a9a8c5d968f26baac8aee245f69e629e2">sparta::memory::BlockingMemoryIF::BlockingMemoryIF</a>  (const std::string &amp;desc, addr_t block_size, const <a class="el" href="structsparta_1_1memory_1_1DebugMemoryIF_1_1AccessWindow.html" title="Defines an access window within this interface. Accesses through a memory interface are constrained t...">DebugMemoryIF::AccessWindow</a> &amp;window, <a class="el" href="classsparta_1_1memory_1_1TranslationIF.html" title="Blocking translation interface with 1:1 translation unless subclassed.">TranslationIF</a> *transif=nullptr)</dt>
<dd><a class="anchor" id="_todo000040"></a>Support vectors of windows with holes  </dd>
<dt>Member <a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a216bb8e3ff6974157a2a792408bc4314">sparta::memory::DebugMemoryIF::DebugMemoryIF</a>  (const std::string &amp;desc, addr_t block_size, const <a class="el" href="structsparta_1_1memory_1_1DebugMemoryIF_1_1AccessWindow.html" title="Defines an access window within this interface. Accesses through a memory interface are constrained t...">AccessWindow</a> &amp;window, <a class="el" href="classsparta_1_1memory_1_1TranslationIF.html" title="Blocking translation interface with 1:1 translation unless subclassed.">TranslationIF</a> *transif=nullptr)</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000041"></a>Support vectors of windows with holes </p>
<p class="interdd"><a class="anchor" id="_todo000042"></a>Check for access window overlaps (once multiple windows are supported) </p>
<p class="enddd"><a class="anchor" id="_todo000043"></a>Create lookup map for identifying holes if more than 1 window is allowed  </p>
</dd>
<dt>Member <a class="el" href="classsparta_1_1memory_1_1TranslationIF.html#a5698d7fddec3b91b6b280e8a79e832de">sparta::memory::TranslationIF::translate</a>  (const addr_t &amp;addr, <a class="el" href="classsparta_1_1memory_1_1Translation.html" title="An older class used to help in encapsulate read/virtual addresses.">Translation</a> *trans=nullptr) const</dt>
<dd><a class="anchor" id="_todo000044"></a>Determine failure cause.  </dd>
<dt>Class <a class="el" href="classsparta_1_1memory_1_1TranslationIFNode.html">sparta::memory::TranslationIFNode</a>  </dt>
<dd><a class="anchor" id="_todo000045"></a>Add sparta Notification support  </dd>
<dt>Class <a class="el" href="classsparta_1_1NotificationSourceBase_1_1ObservationStateCallback.html">sparta::NotificationSourceBase::ObservationStateCallback</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000038"></a>Add a multi-callback version of this class that handles both sole-[de]registering functions and both any-[de]registering functions</p>
<p class="enddd"><a class="anchor" id="_todo000039"></a>Aoply this pattern (with code re-use) to <a class="el" href="classsparta_1_1Counter.html" title="Represents a counter of type counter_type (uint64_t). 2 and greater than 0 with a ceiling specified....">Counter</a> types as well so that Counter-incrementing code can change it's behavior and granularity to better support counter-based SPARTA tirggers  </p>
</dd>
<dt>Member <a class="el" href="classsparta_1_1Parameter.html#a1f23570d658ad7780ce5a88472ab7efb">sparta::Parameter&lt; ValueType &gt;::operator=</a>  (const ValueType &amp;v)</dt>
<dd><a class="anchor" id="_todo000051"></a>Perform independent parameter validation and throw exception if failed.  </dd>
<dt>Member <a class="el" href="classsparta_1_1ParameterBase.html#a9fe793772a1fadb6966cde1e10d578b2">sparta::ParameterBase::ParameterBase</a>  (const std::string &amp;name, const std::string &amp;desc)</dt>
<dd><a class="anchor" id="_todo000050"></a>Check that parent is a <a class="el" href="classsparta_1_1ParameterSet.html" title="Generic container of Parameters.">ParameterSet</a>  </dd>
<dt>Class <a class="el" href="classsparta_1_1ParameterSet.html">sparta::ParameterSet</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000052"></a>Deduce set of fields using boost::fusion or other instrospection fields instead of the current __collect method. </p>
<p class="enddd"><a class="anchor" id="_todo000053"></a>Allow defaulting the numeric display base for entire set (like <a class="el" href="classsparta_1_1Parameter.html#ac27173c5407e013cb0a8631d34e5a66f" title="Set the numeric base for displaying the value of this parameter.">sparta::Parameter::setNumericDisplayBase</a>)  </p>
</dd>
<dt>Member <a class="el" href="classsparta_1_1ParameterSet.html#a3c08f873f659b0f9c6f1c9aaf865b6e6">sparta::ParameterSet::addParameter_</a>  (<a class="el" href="classsparta_1_1ParameterBase.html" title="Non-templated base class for generic parameter access and iteration.">sparta::ParameterBase</a> *p)</dt>
<dd><a class="anchor" id="_todo000055"></a>This must be done automatically by onAddingChild_ and not explicitly by anyone except ParametersThemselves  </dd>
<dt>Member <a class="el" href="classsparta_1_1ParameterSet.html#a74d9a1f0ef3531b92a854efedfd9ee8e">sparta::ParameterSet::dumpList</a>  () const</dt>
<dd><a class="anchor" id="_todo000054"></a>This should be optimized to store fields in a matrix such that each string isn't rendered twice  </dd>
<dt>Member <a class="el" href="classsparta_1_1ParameterSet.html#a547d778bdcf40db2d8d4683f6f73030e">sparta::ParameterSet::readValueFromVirtualTree_</a>  (const <a class="el" href="classsparta_1_1ParameterTree.html" title="Virtual Parameter Tree. This represents a tree of parameters read from some source but does not neces...">ParameterTree</a> *arch_pt, const <a class="el" href="classsparta_1_1ParameterTree.html" title="Virtual Parameter Tree. This represents a tree of parameters read from some source but does not neces...">ParameterTree</a> *pt, <a class="el" href="classsparta_1_1ParameterBase.html" title="Non-templated base class for generic parameter access and iteration.">sparta::ParameterBase</a> *p)</dt>
<dd><a class="anchor" id="_todo000056"></a>Merge this into <a class="el" href="classsparta_1_1ParameterBase.html" title="Non-templated base class for generic parameter access and iteration.">ParameterBase</a> construction if possible  </dd>
<dt>Member <a class="el" href="classsparta_1_1PhasedObject.html#a59b0c6f93493d362a720a665ce443ccd">sparta::PhasedObject::setPhase_</a>  (TreePhase phase)</dt>
<dd><a class="anchor" id="_todo000034"></a>Enforce phas ordering here  </dd>
<dt>Member <a class="el" href="classsparta_1_1ReadOnlyCounter.html#a896a11e20c3fe95e1cd727d9f123e821">sparta::ReadOnlyCounter::get</a>  () const override</dt>
<dd><a class="anchor" id="_todo000087"></a>Allow indexed accesses if larger counters are supported.  </dd>
<dt>Member <a class="el" href="classsparta_1_1RegisterBankTable.html#a22e986c08ad33c791be5aa3333daa949">sparta::RegisterBankTable&lt; RegisterT &gt;::addRegister</a>  (RegisterT *r)</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000025"></a>Use logger </p>
<p class="interdd"><a class="anchor" id="_todo000026"></a>Use logger </p>
<p class="enddd"><a class="anchor" id="_todo000027"></a>Use logger  </p>
</dd>
<dt>Class <a class="el" href="classsparta_1_1RegisterBase.html">sparta::RegisterBase</a>  </dt>
<dd><a class="anchor" id="_todo000018"></a>Add register notifications between compound registers  </dd>
<dt>Struct <a class="el" href="structsparta_1_1RegisterBase_1_1Definition.html">sparta::RegisterBase::Definition</a>  </dt>
<dd><a class="anchor" id="_todo000019"></a>Add omitted fields:  </dd>
<dt>Struct <a class="el" href="structsparta_1_1RegisterBase_1_1Field_1_1Definition.html">sparta::RegisterBase::Field::Definition</a>  </dt>
<dd><a class="anchor" id="_todo000020"></a>Add reserved field (or other missing attributes)  </dd>
<dt>Member <a class="el" href="classsparta_1_1RegisterBase_1_1Field.html#a843ee03e72ef14e03dd249cee23e8402">sparta::RegisterBase::Field::peek</a>  () const</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000022"></a>Support indexes for reading more than <em>access_type</em> elements </p>
<p class="interdd"></p>
<p class="enddd">Support reading with different integer sizes  </p>
</dd>
<dt>Member <a class="el" href="classsparta_1_1RegisterBase_1_1Field.html#af0316bcb5b02307c6a8015837048afa6">sparta::RegisterBase::Field::poke</a>  (access_type t)</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000024"></a>Support indexes for reading more than <em>access_type</em> elements </p>
<p class="interdd"></p>
<p class="enddd">Support reading with different integer sizes  </p>
</dd>
<dt>Member <a class="el" href="classsparta_1_1RegisterBase_1_1Field.html#ad931b093a47c64ab8a5c6405936cb0d9">sparta::RegisterBase::Field::read</a>  ()</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000021"></a>Support indexes for reading more than <em>access_type</em> elements </p>
<p class="interdd"></p>
<p class="enddd">Support reading with different integer sizes  </p>
</dd>
<dt>Member <a class="el" href="classsparta_1_1RegisterBase_1_1Field.html#a1a47abafccd9d4a644b88a3fb1810372">sparta::RegisterBase::Field::write</a>  (access_type t)</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000023"></a>Support indexes for reading more than <em>access_type</em> elements </p>
<p class="interdd"></p>
<p class="enddd">Support reading with different integer sizes  </p>
</dd>
<dt>Class <a class="el" href="classsparta_1_1RegisterProxy.html">sparta::RegisterProxy</a>  </dt>
<dd><a class="anchor" id="_todo000028"></a>Access a register  </dd>
<dt>Member <a class="el" href="classsparta_1_1ResourceTreeNode.html#a264559c1652e4b47d0b94185e9ca6ae8">sparta::ResourceTreeNode::createResource_</a>  () override</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000059"></a>Check for orphaned trees (no common parent). Defining nodes with "top" semantics would simplify this. </p>
<p class="enddd"><a class="anchor" id="_todo000060"></a>Move this check to the actual setting of the resources. <a class="el" href="classsparta_1_1ResourceTreeNode.html" title="TreeNode subclass representing a node in the device tree which contains a single ResourceFactory and ...">ResourceTreeNode</a> should hook into <a class="el" href="classsparta_1_1ResourceContainer.html" title="PhasedObject which can hold 0 or 1 Resource pointers to an associatedresource. Contains logic for set...">ResourceContainer</a>'s method to prevent setting of a resource externally  </p>
</dd>
<dt>Member <a class="el" href="classsparta_1_1ResourceTreeNode.html#aa7d9556c06575a321b3fc6633f604065">sparta::ResourceTreeNode::ResourceTreeNode</a>  (<a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a> *parent, const std::string &amp;name, const std::string &amp;group, group_idx_type group_idx, const std::string &amp;desc, <a class="el" href="classsparta_1_1ResourceFactoryBase.html" title="Factory which can create Resources as well as the Parameter sets that can be modified before actually...">ResourceFactoryBase</a> *res_fact)</dt>
<dd><a class="anchor" id="_todo000058"></a>desc should come from the resource factory as a common const char*.  </dd>
<dt>Member <a class="el" href="classsparta_1_1RootTreeNode.html#a431fba8d4494832a06e7449ff61b3052">sparta::RootTreeNode::bindTreeEarly</a>  ()</dt>
<dd><a class="anchor" id="_todo000061"></a>Prevent this from being called when the simulation is running  </dd>
<dt>Member <a class="el" href="classsparta_1_1RootTreeNode.html#a72f9e3deac598ac9f4ace7fede01f21c">sparta::RootTreeNode::dumpDebugContent</a>  (std::ostream &amp;out) noexcept</dt>
<dd><a class="anchor" id="_todo000062"></a>Replace this method with a method that places all output into different files within a subfolder  </dd>
<dt>Member <a class="el" href="classsparta_1_1Scheduler.html#a8e8c093347b2bf30c47640a88fef20d5">sparta::Scheduler::stopRunning</a>  ()</dt>
<dd><a class="anchor" id="_todo000035"></a>Change the granularity of when the scheduler stops running so that it must finish the tick. </dd>
<dt>Member <a class="el" href="classsparta_1_1serialization_1_1checkpoint_1_1Checkpointer.html#a8cad3235e58b52835ca5fd78be96460b">sparta::serialization::checkpoint::Checkpointer::dumpBranch</a>  (std::ostream &amp;o, const <a class="el" href="classsparta_1_1serialization_1_1checkpoint_1_1Checkpoint.html" title="Single checkpoint object interface with a tick number and an ID unique to the owning Checkpointer ins...">Checkpoint</a> *chkpt, uint32_t indent, uint32_t pos, std::deque&lt; uint32_t &gt; &amp;continues) const</dt>
<dd><a class="anchor" id="_todo000072"></a>Move the constants somewhere static outside this function (especially the assert)  </dd>
<dt>Member <a class="el" href="classsparta_1_1serialization_1_1checkpoint_1_1Checkpointer.html#a2ebfa4a91724facc17177407e5231ffc">sparta::serialization::checkpoint::Checkpointer::findCheckpoint_</a>  (chkpt_id_t id) noexcept=0</dt>
<dd><a class="anchor" id="_todo000073"></a>Faster lookup?  </dd>
<dt>Class <a class="el" href="classsparta_1_1serialization_1_1checkpoint_1_1DeltaCheckpoint.html">sparta::serialization::checkpoint::DeltaCheckpoint&lt; StorageT &gt;</a>  </dt>
<dd><a class="anchor" id="_todo000074"></a>Store reverse deltas additional (or maybe instead) so that rewind is quicker  </dd>
<dt>Class <a class="el" href="classsparta_1_1serialization_1_1checkpoint_1_1FastCheckpointer.html">sparta::serialization::checkpoint::FastCheckpointer</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000076"></a>Implement reverse delta storage for backward checkpoint loading </p>
<p class="interdd"></p>
<p class="interdd">Tune <a class="el" href="classsparta_1_1ArchData.html" title="Contains a set of contiguous line of architectural data which can be referred to by any architected o...">ArchData</a> line size based on checkpointer performance </p>
<p class="interdd"></p>
<p class="interdd">More profiling </p>
<p class="interdd"></p>
<p class="interdd">Compression </p>
<p class="interdd"></p>
<p class="enddd">Saving to disk using a templated checkpoint object storage class (allowing for non-binary)  </p>
</dd>
<dt>Member <a class="el" href="classsparta_1_1serialization_1_1checkpoint_1_1FastCheckpointer.html#a46f4bf524ed6c274be858397a61c3dcb">sparta::serialization::checkpoint::FastCheckpointer::cleanupChain_</a>  (checkpoint_type *d)</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000077"></a>Support compression </p>
<p class="enddd"><a class="anchor" id="_todo000078"></a>canDelete is recursive at worst and might benefit from optimization  </p>
</dd>
<dt>Member <a class="el" href="classsparta_1_1serialization_1_1checkpoint_1_1FastCheckpointer.html#ac148071f4baed77d65246f9a9fb6da12">sparta::serialization::checkpoint::FastCheckpointer::findCheckpoint_</a>  (chkpt_id_t id) noexcept override</dt>
<dd><a class="anchor" id="_todo000079"></a>Faster lookup?  </dd>
<dt>Member <a class="el" href="classsparta_1_1SimulationInfo.html#a35c12f12e0942d02767f0a7decf60fab">sparta::SimulationInfo::setCommandLine</a>  (int argc, char **argv)</dt>
<dd><a class="anchor" id="_todo000013"></a>Re-escape quotes or remove need for quotes by escaping everything  </dd>
<dt>Class <a class="el" href="classsparta_1_1SysCSpartaSchedulerAdapter.html">sparta::SysCSpartaSchedulerAdapter</a>  </dt>
<dd><a class="anchor" id="_todo000090"></a>The Sparta scheduler is on its own SC_THREAD and is put to sleep between scheduled events. For example, if the Sparta scheduler has an event scheduled @ tick 1000, and time is currently 500, the Sparta scheduler thread will wait() for 500 ticks. However, if a SystemC component puts an event on the Sparta scheduler during this sleep window (say at 750 ticks), we do not have a mechanism to wake this thread early.  </dd>
<dt>Class <a class="el" href="classsparta_1_1TieredMap.html">sparta::TieredMap&lt; KeyT, ValT &gt;</a>  </dt>
<dd><a class="anchor" id="_todo000091"></a>Improve iteration to reduce memory use. Instead of maintaining a separate list of pairs, walk the tree itself. However, reasonably fast iteration is needed for checkpointing, so the extra memory use may be somewhat justified  </dd>
<dt>Member <a class="el" href="classsparta_1_1TieredMap.html#a6f96a9b194a629cdb35651bd64befdc6">sparta::TieredMap&lt; KeyT, ValT &gt;::node_t</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000092"></a>Memory can be further saved by making this sparse itself. Most easily, a start index can be stored in addition to the vector's size. </p>
<p class="interdd"></p>
<p class="enddd">More memory might be saved by making this a simple array instead of a vector. Performance in debug mode would definitely increase because of the removed bounds checking  </p>
</dd>
<dt>Member <a class="el" href="classsparta_1_1TreeNode.html#adfb91033f1351c5dc6b31c35d4c2ae9a">sparta::TreeNode::CHILD_FIND_THRESHOLD</a>  </dt>
<dd><a class="anchor" id="_todo000063"></a>getChild/findChildren should know the difference between report-based accesses and model-based accesses so that this can be conditionally incremented  </dd>
<dt>Member <a class="el" href="classsparta_1_1TreeNode.html#ae53352d950db4b085566de453e0d2e00">sparta::TreeNode::getChildrenIdentifiers</a>  (std::vector&lt; std::string &gt; &amp;idents, bool ignore_builtin_group=true) const</dt>
<dd><a class="anchor" id="_todo000064"></a>Allow groups to be retrieved witih getChild  </dd>
<dt>Member <a class="el" href="classsparta_1_1TreeNode.html#a28436401cbe813f5ea99f4c09615fef4">sparta::TreeNode::getGroup</a>  (const std::string &amp;group, std::vector&lt; TreeNode * &gt; &amp;results)</dt>
<dd><a class="anchor" id="_todo000067"></a>Optimize lookup by group using mappings </dd>
<dt>Member <a class="el" href="classsparta_1_1TreeNode.html#a6a8509bfb982375b090e6e2d280bc0dd">sparta::TreeNode::getGroupIndexMax</a>  (const std::string &amp;group)</dt>
<dd><a class="anchor" id="_todo000066"></a>Optimize this count by storing group mappings  </dd>
<dt>Member <a class="el" href="classsparta_1_1TreeNode.html#ace29f38285cf6318c8c2973e028c1588">sparta::TreeNode::getGroupSize</a>  (const std::string &amp;group)</dt>
<dd><a class="anchor" id="_todo000065"></a>Optimize this count by storing group sizes (or group vectors) in <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">TreeNode</a>. </dd>
<dt>Member <a class="el" href="classsparta_1_1TreeNode.html#a6260f885d559f61593a2158545d275fb">sparta::TreeNode::registerForNotification</a>  (T *obj, const std::string &amp;name, bool ensure_possible=true)</dt>
<dd><a class="anchor" id="_todo000069"></a>Faster attachment of delegates to children. There is notable performance impact today, however.  </dd>
<dt>Member <a class="el" href="File_8hpp.html#a39a599c3419ec268ffa492f0bb91133c">sparta::utils::computeOutputFilename</a>  (const std::string &amp;name, const std::string &amp;location, uint32_t idx, const std::string &amp;sim_name)</dt>
<dd><a class="anchor" id="_todo000088"></a>Create a file manager  </dd>
<dt>Member <a class="el" href="SmartLexicalCast_8hpp.html#ad18bb5e352194bae30db075d3c661958">sparta::utils::smartLexicalCast</a>  (const std::string &amp;s, size_t &amp;end_pos, bool allow_recursion=true, bool allow_prefix=true)</dt>
<dd><a class="anchor" id="_todo000089"></a>To resolve prefix/suffix ambiguity and allow stringing together multiple value with prefixes support could be added for '+' as a disamgiuator (e.g. 50+0b111) </dd>
</dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Aug 22 2025 17:16:12 for The Sparta Modeling Framework by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
