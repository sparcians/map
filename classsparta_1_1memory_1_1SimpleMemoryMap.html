<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Sparta Modeling Framework: sparta::memory::SimpleMemoryMap Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">The Sparta Modeling Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classsparta_1_1memory_1_1SimpleMemoryMap.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsparta_1_1memory_1_1SimpleMemoryMap-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">sparta::memory::SimpleMemoryMap Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Memory mapping object which maps addresses onto block-aligned destinations, each of which is a <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html" title="Pure-virtual memory interface which represents a simple, immediately accessible (blocking) address-sp...">BlockingMemoryIF</a> object. This method does not actually support memory accesses, only mapping and querying.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SimpleMemoryMap_8hpp_source.html">SimpleMemoryMap.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sparta::memory::SimpleMemoryMap:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1memory_1_1SimpleMemoryMap__inherit__graph.png" border="0" usemap="#asparta_1_1memory_1_1SimpleMemoryMap_inherit__map" alt="Inheritance graph"/></div>
<map name="asparta_1_1memory_1_1SimpleMemoryMap_inherit__map" id="asparta_1_1memory_1_1SimpleMemoryMap_inherit__map">
<area shape="rect" title="Memory mapping object which maps addresses onto block&#45;aligned destinations, each of which is a Blocki..." alt="" coords="5,5,232,31"/>
<area shape="rect" href="classsparta_1_1memory_1_1SimpleMemoryMapNode.html" title="Memory mapping object which implements BlockingMemoryIFNode. Supports a simple mapping of incoming ad..." alt="" coords="18,79,219,120"/>
<area shape="poly" title=" " alt="" coords="121,46,121,79,116,79,116,46"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsparta_1_1memory_1_1SimpleMemoryMap_1_1Mapping.html">Mapping</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a mapping between an input address and output address for use in a destination <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html" title="Pure-virtual memory interface which represents a simple, immediately accessible (blocking) address-sp...">BlockingMemoryIF</a>.  <a href="structsparta_1_1memory_1_1SimpleMemoryMap_1_1Mapping.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af899abd659c5ebdb868341ddb369964d" id="r_af899abd659c5ebdb868341ddb369964d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af899abd659c5ebdb868341ddb369964d">stringize</a> (bool pretty=false) const</td></tr>
<tr class="memdesc:af899abd659c5ebdb868341ddb369964d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render description of this <a class="el" href="classsparta_1_1memory_1_1SimpleMemoryMap.html" title="Memory mapping object which maps addresses onto block-aligned destinations, each of which is a Blocki...">SimpleMemoryMap</a> as a string.  <br /></td></tr>
<tr class="separator:af899abd659c5ebdb868341ddb369964d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction</div></td></tr>
<tr class="memitem:a74d42a1f93e674d68d94cee714f36bd6" id="r_a74d42a1f93e674d68d94cee714f36bd6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74d42a1f93e674d68d94cee714f36bd6">SimpleMemoryMap</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> block_size)</td></tr>
<tr class="memdesc:a74d42a1f93e674d68d94cee714f36bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classsparta_1_1memory_1_1SimpleMemoryMap.html" title="Memory mapping object which maps addresses onto block-aligned destinations, each of which is a Blocki...">SimpleMemoryMap</a>.  <br /></td></tr>
<tr class="separator:a74d42a1f93e674d68d94cee714f36bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f90ba67f0977609683790d698387bde" id="r_a8f90ba67f0977609683790d698387bde"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f90ba67f0977609683790d698387bde">~SimpleMemoryMap</a> ()</td></tr>
<tr class="memdesc:a8f90ba67f0977609683790d698387bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a8f90ba67f0977609683790d698387bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mapping Interface</div></td></tr>
<tr class="memitem:a9d9f4d0e68fba7f4bb96e763e468c4eb" id="r_a9d9f4d0e68fba7f4bb96e763e468c4eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d9f4d0e68fba7f4bb96e763e468c4eb">addMapping</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> start, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> end, <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html">BlockingMemoryIF</a> *memif, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> dest_start)</td></tr>
<tr class="memdesc:a9d9f4d0e68fba7f4bb96e763e468c4eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mapping from addresses entering this object to a destination memory interface.  <br /></td></tr>
<tr class="separator:a9d9f4d0e68fba7f4bb96e763e468c4eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243251a8f8343aea54d2412e9267d032" id="r_a243251a8f8343aea54d2412e9267d032"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a243251a8f8343aea54d2412e9267d032">dumpTree</a> (std::ostream &amp;o) const</td></tr>
<tr class="memdesc:a243251a8f8343aea54d2412e9267d032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps the tree to an ostream like a directory listing.  <br /></td></tr>
<tr class="separator:a243251a8f8343aea54d2412e9267d032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8018c73a24f34bc73000ef89edabe529" id="r_a8018c73a24f34bc73000ef89edabe529"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8018c73a24f34bc73000ef89edabe529">dumpMappings</a> (std::ostream &amp;o) const</td></tr>
<tr class="memdesc:a8018c73a24f34bc73000ef89edabe529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps a list of mappings to an ostream with a newline after each mapping entry.  <br /></td></tr>
<tr class="separator:a8018c73a24f34bc73000ef89edabe529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714742bbde799e5a47a85fbd39006cd7" id="r_a714742bbde799e5a47a85fbd39006cd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html">BlockingMemoryIF</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a714742bbde799e5a47a85fbd39006cd7">findInterface</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr)</td></tr>
<tr class="memdesc:a714742bbde799e5a47a85fbd39006cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the destination memory interface associated with a mapping containing an address.  <br /></td></tr>
<tr class="separator:a714742bbde799e5a47a85fbd39006cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef58f4130935e3a0a5af7c6125312a0" id="r_a5ef58f4130935e3a0a5af7c6125312a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsparta_1_1memory_1_1SimpleMemoryMap_1_1Mapping.html">Mapping</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ef58f4130935e3a0a5af7c6125312a0">findMapping</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr)</td></tr>
<tr class="memdesc:a5ef58f4130935e3a0a5af7c6125312a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the <a class="el" href="structsparta_1_1memory_1_1SimpleMemoryMap_1_1Mapping.html" title="Represents a mapping between an input address and output address for use in a destination BlockingMem...">Mapping</a> object associated with an address.  <br /></td></tr>
<tr class="separator:a5ef58f4130935e3a0a5af7c6125312a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c89ba9b88339a059f7e56630646174" id="r_a44c89ba9b88339a059f7e56630646174"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structsparta_1_1memory_1_1SimpleMemoryMap_1_1Mapping.html">Mapping</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44c89ba9b88339a059f7e56630646174">findMapping</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr) const</td></tr>
<tr class="separator:a44c89ba9b88339a059f7e56630646174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03897cc554d3c815b6dfea485c1d67c1" id="r_a03897cc554d3c815b6dfea485c1d67c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03897cc554d3c815b6dfea485c1d67c1">verifyHasMapping</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size) const</td></tr>
<tr class="memdesc:a03897cc554d3c815b6dfea485c1d67c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a mapping is valid or not.  <br /></td></tr>
<tr class="separator:a03897cc554d3c815b6dfea485c1d67c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514630d883de5cbb34021243d772eafc" id="r_a514630d883de5cbb34021243d772eafc"><td class="memItemLeft" align="right" valign="top">std::pair&lt; const <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html">BlockingMemoryIF</a> *, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a514630d883de5cbb34021243d772eafc">mapAddress</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr) const noexcept</td></tr>
<tr class="memdesc:a514630d883de5cbb34021243d772eafc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps an input address to a destination interface and address within that destination interface.  <br /></td></tr>
<tr class="separator:a514630d883de5cbb34021243d772eafc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b63f780974a7487f622d8963c6e22b4" id="r_a7b63f780974a7487f622d8963c6e22b4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b63f780974a7487f622d8963c6e22b4">getNumMappings</a> () const</td></tr>
<tr class="memdesc:a7b63f780974a7487f622d8963c6e22b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of mappings successfully added to this map.  <br /></td></tr>
<tr class="separator:a7b63f780974a7487f622d8963c6e22b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78987b147cfe2045ded86befb78d8eb2" id="r_a78987b147cfe2045ded86befb78d8eb2"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; const <a class="el" href="structsparta_1_1memory_1_1SimpleMemoryMap_1_1Mapping.html">Mapping</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78987b147cfe2045ded86befb78d8eb2">getMappings</a> () const</td></tr>
<tr class="memdesc:a78987b147cfe2045ded86befb78d8eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vector of current mappings in the order added.  <br /></td></tr>
<tr class="separator:a78987b147cfe2045ded86befb78d8eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Attributes</div></td></tr>
<tr class="memitem:a3e4e5899aba28cdd39d026ad59b18aab" id="r_a3e4e5899aba28cdd39d026ad59b18aab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e4e5899aba28cdd39d026ad59b18aab">getBlockSize</a> () const</td></tr>
<tr class="memdesc:a3e4e5899aba28cdd39d026ad59b18aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the block size of memory represented by this interface. Read and write accesses must not span block boundaries (where addr % block_size == 0).  <br /></td></tr>
<tr class="separator:a3e4e5899aba28cdd39d026ad59b18aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Memory mapping object which maps addresses onto block-aligned destinations, each of which is a <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html" title="Pure-virtual memory interface which represents a simple, immediately accessible (blocking) address-sp...">BlockingMemoryIF</a> object. This method does not actually support memory accesses, only mapping and querying. </p>
<p><a class="el" href="structsparta_1_1memory_1_1SimpleMemoryMap_1_1Mapping.html" title="Represents a mapping between an input address and output address for use in a destination BlockingMem...">Mapping</a> is performed within this map and is invisible to clients of this class. Internal mapping is not considered a translation and there is no <a class="el" href="classsparta_1_1memory_1_1TranslationIF.html" title="Blocking translation interface with 1:1 translation unless subclassed.">TranslationIF</a> associated with the internals mapping of this class.</p>
<p>Mapped ranges can be added only (not removed), cannot overlap, can, however, map to overlapping ranges on the same destination memory.</p>
<p>All mappings are Affine and contiguous. For mapping multiple regions to the same object or mapping one range to discontinuous or overlapping ranges in a destination memory object, use separate mappings.</p>
<p>Implemented as a red-black tree to balance the tree and make lookups more consistently log(n).</p>
<p>Example </p><div class="fragment"><div class="line"><span class="keyword">using </span><a class="code hl_namespace" href="namespacesparta_1_1memory.html">sparta::memory</a>;</div>
<div class="line"><span class="comment">// SimpleMemoryMap* smm;</span></div>
<div class="line"><span class="comment">// BlockingMemoryIF* mem1;</span></div>
<div class="line"><span class="comment">// BlockingMemoryIF* mem2;</span></div>
<div class="line">smm-&gt;addMapping(0x200,0x240,mem1,0);</div>
<div class="line">smm-&gt;addMapping(0x240,0x280,mem2,0);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsparta_1_1memory_1_1BlockingMemoryIF.html">BlockingMemoryIF</a>* bmi = smm-&gt;findInterface(paddr);</div>
<div class="line">assert(bmi == mem1);</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Addr 0x&quot;</span> &lt;&lt; paddr &lt;&lt; std::dec &lt;&lt; <span class="stringliteral">&quot; went to: &quot;</span> &lt;&lt; bmi-&gt;<a class="code hl_function" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a2ff33a34afa19cb71943d7f12102d2b2">getDescription</a>();</div>
<div class="ttc" id="aclasssparta_1_1memory_1_1BlockingMemoryIF_html"><div class="ttname"><a href="classsparta_1_1memory_1_1BlockingMemoryIF.html">sparta::memory::BlockingMemoryIF</a></div><div class="ttdoc">Pure-virtual memory interface which represents a simple, immediately accessible (blocking) address-sp...</div><div class="ttdef"><b>Definition</b> <a href="BlockingMemoryIF_8hpp_source.html#l00059">BlockingMemoryIF.hpp:60</a></div></div>
<div class="ttc" id="aclasssparta_1_1memory_1_1DebugMemoryIF_html_a2ff33a34afa19cb71943d7f12102d2b2"><div class="ttname"><a href="classsparta_1_1memory_1_1DebugMemoryIF.html#a2ff33a34afa19cb71943d7f12102d2b2">sparta::memory::DebugMemoryIF::getDescription</a></div><div class="ttdeci">const std::string &amp; getDescription()</div><div class="ttdoc">Returns the description specified at construction.</div><div class="ttdef"><b>Definition</b> <a href="DebugMemoryIF_8hpp_source.html#l00267">DebugMemoryIF.hpp:267</a></div></div>
<div class="ttc" id="anamespacesparta_1_1memory_html"><div class="ttname"><a href="namespacesparta_1_1memory.html">sparta::memory</a></div><div class="ttdoc">Namespace containing memory interfaces, types, and storage objects.</div><div class="ttdef"><b>Definition</b> <a href="AddressTypes_8hpp_source.html#l00018">AddressTypes.hpp:19</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="SimpleMemoryMap_8hpp_source.html#l00053">53</a> of file <a class="el" href="SimpleMemoryMap_8hpp_source.html">SimpleMemoryMap.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a74d42a1f93e674d68d94cee714f36bd6" name="a74d42a1f93e674d68d94cee714f36bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74d42a1f93e674d68d94cee714f36bd6">&#9670;&#160;</a></span>SimpleMemoryMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sparta::memory::SimpleMemoryMap::SimpleMemoryMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>block_size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classsparta_1_1memory_1_1SimpleMemoryMap.html" title="Memory mapping object which maps addresses onto block-aligned destinations, each of which is a Blocki...">SimpleMemoryMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_size</td><td>Size of blocks in mapping. Must match or be smaller than all <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html" title="Pure-virtual memory interface which represents a simple, immediately accessible (blocking) address-sp...">BlockingMemoryIF</a> instances to which this object will maps. Must be a power of 2 and greater than 0 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SimpleMemoryMap_8hpp_source.html#l00149">149</a> of file <a class="el" href="SimpleMemoryMap_8hpp_source.html">SimpleMemoryMap.hpp</a>.</p>

</div>
</div>
<a id="a8f90ba67f0977609683790d698387bde" name="a8f90ba67f0977609683790d698387bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f90ba67f0977609683790d698387bde">&#9670;&#160;</a></span>~SimpleMemoryMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual sparta::memory::SimpleMemoryMap::~SimpleMemoryMap </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

<p class="definition">Definition at line <a class="el" href="SimpleMemoryMap_8hpp_source.html#l00162">162</a> of file <a class="el" href="SimpleMemoryMap_8hpp_source.html">SimpleMemoryMap.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9d9f4d0e68fba7f4bb96e763e468c4eb" name="a9d9f4d0e68fba7f4bb96e763e468c4eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d9f4d0e68fba7f4bb96e763e468c4eb">&#9670;&#160;</a></span>addMapping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::memory::SimpleMemoryMap::addMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html">BlockingMemoryIF</a> *</td>          <td class="paramname"><span class="paramname"><em>memif</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>dest_start</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a mapping from addresses entering this object to a destination memory interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Start address of mapping region. Must be block-aligned </td></tr>
    <tr><td class="paramname">end</td><td>End address (exclusive) of mapping region. Must be block-aligned. Must be &gt; <em>start</em> (mapping must be 1 or more bytes). The range defined by [start,end) cannot overlap any other mapping range already added to this object. Edges may be shared though (e.g. range 1 end can equal range 2 start). </td></tr>
    <tr><td class="paramname">memif</td><td>Memory interface to which accesses in the range defined by [start,end) will be forwarded with the new address of: <em>address</em> - <em>start</em> + <em>dest_start</em>. The block size (<a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#afec5c7bd3d39673eacfea9c54341d768" title="Returns the block size of memory represented by this interface. Read and write accesses must not span...">BlockingMemoryIF::getBlockSize</a>) of this interface must be exactly the size of this <a class="el" href="classsparta_1_1memory_1_1SimpleMemoryMap.html" title="Memory mapping object which maps addresses onto block-aligned destinations, each of which is a Blocki...">SimpleMemoryMap</a> block size. Requiring the block size to be equal means that no legal accesses can be made through this interface which span blocks in destination memory interfaces. This allows this class to avoid testing for mapping-spanning accesses because the destination interfaces are expected to reject them. If a destination <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html" title="Pure-virtual memory interface which represents a simple, immediately accessible (blocking) address-sp...">BlockingMemoryIF</a> were to violate this assumption, an access could be made through this map which spanned blocks and thus spanned mapping ranges - this would be undesirable behavior. </td></tr>
    <tr><td class="paramname">dest_start</td><td>Added address offset at destination. Must be a multiple of block_size - effectively limits granulariry of any mapping to whole-block-to-whole-block. If dest_start were 0, accesses with an address equal to <em>start</em> to be forwarded to <em>memif</em> with an address of 0. Accesses with address = <em>start+4</em> would be forwarded with an address of 4. <em>dest_start</em> allows this to be adjusted by adding an offset to the destination address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Validates memif to ensure that the entire range specified by [ <em>start</em>, <em>end</em> ) can actually be mapped to accessible values within </dd>
<dd>
Mappings are allowed to span blocks, but endpoints must be block-aligned. By requiring this alignment, and forwarding accesses onto BlockingMemoryIFs which require non-block-spanning accesses, it is guaranteed that accesses will not span mappings in this map. This is also why dest_start must be a block multiple. </dd>
<dd>
Accesses will be allowed to span blocks within this interface. It is the responsibility of the recieving <em>memif</em> to check accesses for block-spanning. </dd>
<dd>
The minimum address that will be accessed in the destination <em>memif</em> is <em>dest_start</em>. The maximum address that will be accessed in the destination <em>memif</em> is <em>dest_start</em> + (end-start) - 1 <em>memif</em> <b>must</b> support this range of accesses </dd></dl>

<p class="definition">Definition at line <a class="el" href="SimpleMemoryMap_8hpp_source.html#l00222">222</a> of file <a class="el" href="SimpleMemoryMap_8hpp_source.html">SimpleMemoryMap.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1memory_1_1SimpleMemoryMap_a9d9f4d0e68fba7f4bb96e763e468c4eb_cgraph.png" border="0" usemap="#aclasssparta_1_1memory_1_1SimpleMemoryMap_a9d9f4d0e68fba7f4bb96e763e468c4eb_cgraph" alt=""/></div>
<map name="aclasssparta_1_1memory_1_1SimpleMemoryMap_a9d9f4d0e68fba7f4bb96e763e468c4eb_cgraph" id="aclasssparta_1_1memory_1_1SimpleMemoryMap_a9d9f4d0e68fba7f4bb96e763e468c4eb_cgraph">
<area shape="rect" title="Create a mapping from addresses entering this object to a destination memory interface." alt="" coords="5,39,207,79"/>
<area shape="rect" href="classsparta_1_1memory_1_1DebugMemoryIF.html#afec5c7bd3d39673eacfea9c54341d768" title="Returns the block size of memory represented by this interface. Read and write accesses must not span..." alt="" coords="255,5,453,46"/>
<area shape="poly" title=" " alt="" coords="207,43,239,38,239,44,207,48"/>
<area shape="rect" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a88eaaf49740910933179b3b489e10c41" title="Gets the total span of this interface&#39;s valid address range." alt="" coords="255,71,453,111"/>
<area shape="poly" title=" " alt="" coords="207,69,239,74,239,79,207,75"/>
</map>
</div>

</div>
</div>
<a id="a8018c73a24f34bc73000ef89edabe529" name="a8018c73a24f34bc73000ef89edabe529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8018c73a24f34bc73000ef89edabe529">&#9670;&#160;</a></span>dumpMappings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::memory::SimpleMemoryMap::dumpMappings </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>o</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps a list of mappings to an ostream with a newline after each mapping entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>ostream to which mappings will be printed </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SimpleMemoryMap_8hpp_source.html#l00443">443</a> of file <a class="el" href="SimpleMemoryMap_8hpp_source.html">SimpleMemoryMap.hpp</a>.</p>

</div>
</div>
<a id="a243251a8f8343aea54d2412e9267d032" name="a243251a8f8343aea54d2412e9267d032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a243251a8f8343aea54d2412e9267d032">&#9670;&#160;</a></span>dumpTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::memory::SimpleMemoryMap::dumpTree </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>o</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps the tree to an ostream like a directory listing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>ostream to which tree will be printed </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SimpleMemoryMap_8hpp_source.html#l00432">432</a> of file <a class="el" href="SimpleMemoryMap_8hpp_source.html">SimpleMemoryMap.hpp</a>.</p>

</div>
</div>
<a id="a714742bbde799e5a47a85fbd39006cd7" name="a714742bbde799e5a47a85fbd39006cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714742bbde799e5a47a85fbd39006cd7">&#9670;&#160;</a></span>findInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html">BlockingMemoryIF</a> * sparta::memory::SimpleMemoryMap::findInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>addr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the destination memory interface associated with a mapping containing an address. </p>
<dl class="section return"><dt>Returns</dt><dd>Memory interface for the mapping containing this address. If not found, returns nullptr. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SimpleMemoryMap_8hpp_source.html#l00479">479</a> of file <a class="el" href="SimpleMemoryMap_8hpp_source.html">SimpleMemoryMap.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1memory_1_1SimpleMemoryMap_a714742bbde799e5a47a85fbd39006cd7_cgraph.png" border="0" usemap="#aclasssparta_1_1memory_1_1SimpleMemoryMap_a714742bbde799e5a47a85fbd39006cd7_cgraph" alt=""/></div>
<map name="aclasssparta_1_1memory_1_1SimpleMemoryMap_a714742bbde799e5a47a85fbd39006cd7_cgraph" id="aclasssparta_1_1memory_1_1SimpleMemoryMap_a714742bbde799e5a47a85fbd39006cd7_cgraph">
<area shape="rect" title="Returns the destination memory interface associated with a mapping containing an address." alt="" coords="5,5,207,46"/>
<area shape="rect" href="classsparta_1_1memory_1_1SimpleMemoryMap.html#a5ef58f4130935e3a0a5af7c6125312a0" title="Finds the Mapping object associated with an address." alt="" coords="255,5,456,46"/>
<area shape="poly" title=" " alt="" coords="207,23,239,23,239,28,207,28"/>
</map>
</div>

</div>
</div>
<a id="a5ef58f4130935e3a0a5af7c6125312a0" name="a5ef58f4130935e3a0a5af7c6125312a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef58f4130935e3a0a5af7c6125312a0">&#9670;&#160;</a></span>findMapping() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsparta_1_1memory_1_1SimpleMemoryMap_1_1Mapping.html">Mapping</a> * sparta::memory::SimpleMemoryMap::findMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>addr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the <a class="el" href="structsparta_1_1memory_1_1SimpleMemoryMap_1_1Mapping.html" title="Represents a mapping between an input address and output address for use in a destination BlockingMem...">Mapping</a> object associated with an address. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structsparta_1_1memory_1_1SimpleMemoryMap_1_1Mapping.html" title="Represents a mapping between an input address and output address for use in a destination BlockingMem...">Mapping</a> associated with an address if address is contained in a mapping. If not found, returns nullptr. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SimpleMemoryMap_8hpp_source.html#l00492">492</a> of file <a class="el" href="SimpleMemoryMap_8hpp_source.html">SimpleMemoryMap.hpp</a>.</p>

</div>
</div>
<a id="a44c89ba9b88339a059f7e56630646174" name="a44c89ba9b88339a059f7e56630646174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c89ba9b88339a059f7e56630646174">&#9670;&#160;</a></span>findMapping() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structsparta_1_1memory_1_1SimpleMemoryMap_1_1Mapping.html">Mapping</a> * sparta::memory::SimpleMemoryMap::findMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>addr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>const-qualified version of findMapping </p>

<p class="definition">Definition at line <a class="el" href="SimpleMemoryMap_8hpp_source.html#l00524">524</a> of file <a class="el" href="SimpleMemoryMap_8hpp_source.html">SimpleMemoryMap.hpp</a>.</p>

</div>
</div>
<a id="a3e4e5899aba28cdd39d026ad59b18aab" name="a3e4e5899aba28cdd39d026ad59b18aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e4e5899aba28cdd39d026ad59b18aab">&#9670;&#160;</a></span>getBlockSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> sparta::memory::SimpleMemoryMap::getBlockSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the block size of memory represented by this interface. Read and write accesses must not span block boundaries (where addr % block_size == 0). </p>

<p class="definition">Definition at line <a class="el" href="SimpleMemoryMap_8hpp_source.html#l00644">644</a> of file <a class="el" href="SimpleMemoryMap_8hpp_source.html">SimpleMemoryMap.hpp</a>.</p>

</div>
</div>
<a id="a78987b147cfe2045ded86befb78d8eb2" name="a78987b147cfe2045ded86befb78d8eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78987b147cfe2045ded86befb78d8eb2">&#9670;&#160;</a></span>getMappings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; const <a class="el" href="structsparta_1_1memory_1_1SimpleMemoryMap_1_1Mapping.html">Mapping</a> * &gt; &amp; sparta::memory::SimpleMemoryMap::getMappings </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the vector of current mappings in the order added. </p>

<p class="definition">Definition at line <a class="el" href="SimpleMemoryMap_8hpp_source.html#l00628">628</a> of file <a class="el" href="SimpleMemoryMap_8hpp_source.html">SimpleMemoryMap.hpp</a>.</p>

</div>
</div>
<a id="a7b63f780974a7487f622d8963c6e22b4" name="a7b63f780974a7487f622d8963c6e22b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b63f780974a7487f622d8963c6e22b4">&#9670;&#160;</a></span>getNumMappings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sparta::memory::SimpleMemoryMap::getNumMappings </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of mappings successfully added to this map. </p>

<p class="definition">Definition at line <a class="el" href="SimpleMemoryMap_8hpp_source.html#l00621">621</a> of file <a class="el" href="SimpleMemoryMap_8hpp_source.html">SimpleMemoryMap.hpp</a>.</p>

</div>
</div>
<a id="a514630d883de5cbb34021243d772eafc" name="a514630d883de5cbb34021243d772eafc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a514630d883de5cbb34021243d772eafc">&#9670;&#160;</a></span>mapAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; const <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html">BlockingMemoryIF</a> *, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> &gt; sparta::memory::SimpleMemoryMap::mapAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>addr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps an input address to a destination interface and address within that destination interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">add</td><td>Input address to map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair containing destination <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html" title="Pure-virtual memory interface which represents a simple, immediately accessible (blocking) address-sp...">BlockingMemoryIF</a> and an address within that interface If no mapping is found for the given address, the memory interface (first) will be nullptr</dd></dl>
<dl class="section note"><dt>Note</dt><dd>As long as accesses to the resulting destination are constrained to blocks, the result can be cached for future accesses of any size provided that they are within the same block as the resulting address</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// uint8_t data[12];</span></div>
<div class="line"><span class="keyword">auto</span> mapping = map.mapAddress(0xf3);</div>
<div class="line"><span class="keywordflow">if</span>(mapping.first != <span class="keyword">nullptr</span>){</div>
<div class="line">  mapping.first.write(mapping.second, 12, data);</div>
<div class="line">}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="SimpleMemoryMap_8hpp_source.html#l00609">609</a> of file <a class="el" href="SimpleMemoryMap_8hpp_source.html">SimpleMemoryMap.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1memory_1_1SimpleMemoryMap_a514630d883de5cbb34021243d772eafc_cgraph.png" border="0" usemap="#aclasssparta_1_1memory_1_1SimpleMemoryMap_a514630d883de5cbb34021243d772eafc_cgraph" alt=""/></div>
<map name="aclasssparta_1_1memory_1_1SimpleMemoryMap_a514630d883de5cbb34021243d772eafc_cgraph" id="aclasssparta_1_1memory_1_1SimpleMemoryMap_a514630d883de5cbb34021243d772eafc_cgraph">
<area shape="rect" title="Maps an input address to a destination interface and address within that destination interface." alt="" coords="5,39,207,79"/>
<area shape="rect" href="classsparta_1_1memory_1_1SimpleMemoryMap.html#a5ef58f4130935e3a0a5af7c6125312a0" title="Finds the Mapping object associated with an address." alt="" coords="255,5,456,46"/>
<area shape="poly" title=" " alt="" coords="207,43,239,39,240,44,208,48"/>
<area shape="rect" href="structsparta_1_1memory_1_1SimpleMemoryMap_1_1Mapping.html#a7b36d343646b9626487a0ab8c8adc934" title="Maps an input address to the address&#45;space for the destination memory interface." alt="" coords="255,71,456,111"/>
<area shape="poly" title=" " alt="" coords="208,69,240,73,239,79,207,75"/>
</map>
</div>

</div>
</div>
<a id="af899abd659c5ebdb868341ddb369964d" name="af899abd659c5ebdb868341ddb369964d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af899abd659c5ebdb868341ddb369964d">&#9670;&#160;</a></span>stringize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string sparta::memory::SimpleMemoryMap::stringize </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>pretty</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Render description of this <a class="el" href="classsparta_1_1memory_1_1SimpleMemoryMap.html" title="Memory mapping object which maps addresses onto block-aligned destinations, each of which is a Blocki...">SimpleMemoryMap</a> as a string. </p>

<p class="definition">Definition at line <a class="el" href="SimpleMemoryMap_8hpp_source.html#l00652">652</a> of file <a class="el" href="SimpleMemoryMap_8hpp_source.html">SimpleMemoryMap.hpp</a>.</p>

</div>
</div>
<a id="a03897cc554d3c815b6dfea485c1d67c1" name="a03897cc554d3c815b6dfea485c1d67c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03897cc554d3c815b6dfea485c1d67c1">&#9670;&#160;</a></span>verifyHasMapping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::memory::SimpleMemoryMap::verifyHasMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a mapping is valid or not. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1memory_1_1MemoryAccessError.html" title="Indicates that there was an issue accessing a SPARTA memory object or interface.">MemoryAccessError</a></td><td>if mapping is not valid</td></tr>
  </table>
  </dd>
</dl>
<p>Note that normal read/write paths may not perform a check this careful for performance reasons </p>

<p class="definition">Definition at line <a class="el" href="SimpleMemoryMap_8hpp_source.html#l00559">559</a> of file <a class="el" href="SimpleMemoryMap_8hpp_source.html">SimpleMemoryMap.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/github/workspace/sparta/sparta/memory/<a class="el" href="SimpleMemoryMap_8hpp_source.html">SimpleMemoryMap.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesparta.html">sparta</a></li><li class="navelem"><a class="el" href="namespacesparta_1_1memory.html">memory</a></li><li class="navelem"><a class="el" href="classsparta_1_1memory_1_1SimpleMemoryMap.html">SimpleMemoryMap</a></li>
    <li class="footer">Generated on Fri Aug 22 2025 17:16:16 for The Sparta Modeling Framework by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
