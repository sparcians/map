<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Sparta Modeling Framework: sparta::memory::DMIBlockingMemoryIF Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">The Sparta Modeling Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classsparta_1_1memory_1_1DMIBlockingMemoryIF.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsparta_1_1memory_1_1DMIBlockingMemoryIF-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">sparta::memory::DMIBlockingMemoryIF Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Class that provides a <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html" title="Pure-virtual memory interface which represents a simple, immediately accessible (blocking) address-sp...">BlockingMemoryIF</a> over a raw pointer.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="DMIBlockingMemoryIF_8hpp_source.html">DMIBlockingMemoryIF.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sparta::memory::DMIBlockingMemoryIF:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1memory_1_1DMIBlockingMemoryIF__inherit__graph.png" border="0" usemap="#asparta_1_1memory_1_1DMIBlockingMemoryIF_inherit__map" alt="Inheritance graph"/></div>
<map name="asparta_1_1memory_1_1DMIBlockingMemoryIF_inherit__map" id="asparta_1_1memory_1_1DMIBlockingMemoryIF_inherit__map">
<area shape="rect" title="Class that provides a BlockingMemoryIF over a raw pointer." alt="" coords="16,168,205,208"/>
<area shape="rect" href="classsparta_1_1memory_1_1BlockingMemoryIF.html" title="Pure&#45;virtual memory interface which represents a simple, immediately accessible (blocking) address&#45;sp..." alt="" coords="28,79,193,120"/>
<area shape="poly" title=" " alt="" coords="113,135,113,167,108,167,108,135"/>
<area shape="rect" href="classsparta_1_1memory_1_1DebugMemoryIF.html" title="Memory interface which represents a simple, immediately accessible (blocking) address&#45;space with supp..." alt="" coords="5,5,216,31"/>
<area shape="poly" title=" " alt="" coords="113,46,113,79,108,79,108,46"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for sparta::memory::DMIBlockingMemoryIF:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1memory_1_1DMIBlockingMemoryIF__coll__graph.png" border="0" usemap="#asparta_1_1memory_1_1DMIBlockingMemoryIF_coll__map" alt="Collaboration graph"/></div>
<map name="asparta_1_1memory_1_1DMIBlockingMemoryIF_coll__map" id="asparta_1_1memory_1_1DMIBlockingMemoryIF_coll__map">
<area shape="rect" title="Class that provides a BlockingMemoryIF over a raw pointer." alt="" coords="16,259,205,300"/>
<area shape="rect" href="classsparta_1_1memory_1_1BlockingMemoryIF.html" title="Pure&#45;virtual memory interface which represents a simple, immediately accessible (blocking) address&#45;sp..." alt="" coords="28,169,193,210"/>
<area shape="poly" title=" " alt="" coords="113,225,113,259,108,259,108,225"/>
<area shape="rect" href="classsparta_1_1memory_1_1DebugMemoryIF.html" title="Memory interface which represents a simple, immediately accessible (blocking) address&#45;space with supp..." alt="" coords="5,94,216,120"/>
<area shape="poly" title=" " alt="" coords="113,135,113,169,108,169,108,135"/>
<area shape="rect" href="classsparta_1_1memory_1_1TranslationIF.html" title="Blocking translation interface with 1:1 translation unless subclassed." alt="" coords="15,5,206,31"/>
<area shape="poly" title=" " alt="" coords="113,47,113,94,108,94,108,47"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae003ba4006ceaeb129dc4f1204ec9baf" id="r_ae003ba4006ceaeb129dc4f1204ec9baf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae003ba4006ceaeb129dc4f1204ec9baf">DMIBlockingMemoryIF</a> (void *raw_pointer, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> start_addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size)</td></tr>
<tr class="memdesc:ae003ba4006ceaeb129dc4f1204ec9baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a raw pointer and provides <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html" title="Pure-virtual memory interface which represents a simple, immediately accessible (blocking) address-sp...">BlockingMemoryIF</a> to it.  <br /></td></tr>
<tr class="separator:ae003ba4006ceaeb129dc4f1204ec9baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefda738b44527e1a9a5883ed0f4b141e" id="r_aefda738b44527e1a9a5883ed0f4b141e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefda738b44527e1a9a5883ed0f4b141e">getRawDataPtr</a> ()</td></tr>
<tr class="memdesc:aefda738b44527e1a9a5883ed0f4b141e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a raw pointer to the memory held (dangerous)  <br /></td></tr>
<tr class="separator:aefda738b44527e1a9a5883ed0f4b141e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f22b56513195bde837c1ee9b1a333c" id="r_ad2f22b56513195bde837c1ee9b1a333c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2f22b56513195bde837c1ee9b1a333c">isValid</a> () const</td></tr>
<tr class="separator:ad2f22b56513195bde837c1ee9b1a333c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf641eb73d7e3b622f821a3ff899dc70" id="r_abf641eb73d7e3b622f821a3ff899dc70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf641eb73d7e3b622f821a3ff899dc70">clearValid</a> ()</td></tr>
<tr class="memdesc:abf641eb73d7e3b622f821a3ff899dc70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typically called by the creator of the DMI Mem IF.  <br /></td></tr>
<tr class="separator:abf641eb73d7e3b622f821a3ff899dc70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92eada4b892613dbd4f93a15234b0d58" id="r_a92eada4b892613dbd4f93a15234b0d58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92eada4b892613dbd4f93a15234b0d58">tryRead</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size, uint8_t *buf, const void *in_supplement=nullptr, void *out_supplement=nullptr) override final</td></tr>
<tr class="memdesc:a92eada4b892613dbd4f93a15234b0d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override of sparta::BlockingMemoryIF::tryRead.  <br /></td></tr>
<tr class="separator:a92eada4b892613dbd4f93a15234b0d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6050ca36f7253e0eb1009f0d28b488f7" id="r_a6050ca36f7253e0eb1009f0d28b488f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6050ca36f7253e0eb1009f0d28b488f7">tryWrite</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size, const uint8_t *buf, const void *in_supplement=nullptr, void *out_supplement=nullptr) override final</td></tr>
<tr class="memdesc:a6050ca36f7253e0eb1009f0d28b488f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override of sparta::BlockingMemoryIF::tryWrite.  <br /></td></tr>
<tr class="separator:a6050ca36f7253e0eb1009f0d28b488f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html">sparta::memory::BlockingMemoryIF</a></td></tr>
<tr class="memitem:a27d1b36cb9fc030de5880fcad11a551e inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF" id="r_a27d1b36cb9fc030de5880fcad11a551e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html#a27d1b36cb9fc030de5880fcad11a551e">stringize</a> (bool pretty=false) const</td></tr>
<tr class="memdesc:a27d1b36cb9fc030de5880fcad11a551e inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render description of this <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html" title="Pure-virtual memory interface which represents a simple, immediately accessible (blocking) address-sp...">BlockingMemoryIF</a> as a string.  <br /></td></tr>
<tr class="separator:a27d1b36cb9fc030de5880fcad11a551e inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8c5d968f26baac8aee245f69e629e2 inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF" id="r_a9a8c5d968f26baac8aee245f69e629e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html#a9a8c5d968f26baac8aee245f69e629e2">BlockingMemoryIF</a> (const std::string &amp;desc, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> block_size, const <a class="el" href="structsparta_1_1memory_1_1DebugMemoryIF_1_1AccessWindow.html">DebugMemoryIF::AccessWindow</a> &amp;window, <a class="el" href="classsparta_1_1memory_1_1TranslationIF.html">TranslationIF</a> *transif=nullptr)</td></tr>
<tr class="memdesc:a9a8c5d968f26baac8aee245f69e629e2 inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a blocking memory interface.  <br /></td></tr>
<tr class="separator:a9a8c5d968f26baac8aee245f69e629e2 inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc22520a86cc03110b62033f325e45c0 inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF" id="r_acc22520a86cc03110b62033f325e45c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html#acc22520a86cc03110b62033f325e45c0">read</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size, uint8_t *buf, const void *in_supplement=nullptr, void *out_supplement=nullptr)</td></tr>
<tr class="memdesc:acc22520a86cc03110b62033f325e45c0 inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to read memory.  <br /></td></tr>
<tr class="separator:acc22520a86cc03110b62033f325e45c0 inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabcf3f10b82cd9130538164358074d7 inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF" id="r_afabcf3f10b82cd9130538164358074d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html#afabcf3f10b82cd9130538164358074d7">write</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size, const uint8_t *buf, const void *in_supplement=nullptr, void *out_supplement=nullptr)</td></tr>
<tr class="memdesc:afabcf3f10b82cd9130538164358074d7 inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to write memory.  <br /></td></tr>
<tr class="separator:afabcf3f10b82cd9130538164358074d7 inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e02e6da4f120023cf4728b2b6b7f7cb inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF" id="r_a6e02e6da4f120023cf4728b2b6b7f7cb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html#a6e02e6da4f120023cf4728b2b6b7f7cb">invalidateAllDMI</a> ()</td></tr>
<tr class="memdesc:a6e02e6da4f120023cf4728b2b6b7f7cb inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate all DMI's.  <br /></td></tr>
<tr class="separator:a6e02e6da4f120023cf4728b2b6b7f7cb inherit pub_methods_classsparta_1_1memory_1_1BlockingMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classsparta_1_1memory_1_1DebugMemoryIF')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html">sparta::memory::DebugMemoryIF</a></td></tr>
<tr class="memitem:ae47924af1683c0df0d0521b661c051a6 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_ae47924af1683c0df0d0521b661c051a6"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>DebugMemoryIF</b> ()=delete</td></tr>
<tr class="memdesc:ae47924af1683c0df0d0521b661c051a6 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constuctor. <br /></td></tr>
<tr class="separator:ae47924af1683c0df0d0521b661c051a6 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216bb8e3ff6974157a2a792408bc4314 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a216bb8e3ff6974157a2a792408bc4314"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a216bb8e3ff6974157a2a792408bc4314">DebugMemoryIF</a> (const std::string &amp;desc, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> block_size, const <a class="el" href="structsparta_1_1memory_1_1DebugMemoryIF_1_1AccessWindow.html">AccessWindow</a> &amp;window, <a class="el" href="classsparta_1_1memory_1_1TranslationIF.html">TranslationIF</a> *transif=nullptr)</td></tr>
<tr class="memdesc:a216bb8e3ff6974157a2a792408bc4314 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a DebugMemoryInterface.  <br /></td></tr>
<tr class="separator:a216bb8e3ff6974157a2a792408bc4314 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc718c72432a36e9271ca56511f911c inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a0bc718c72432a36e9271ca56511f911c"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a0bc718c72432a36e9271ca56511f911c">~DebugMemoryIF</a> ()</td></tr>
<tr class="memdesc:a0bc718c72432a36e9271ca56511f911c inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virutal destructor.  <br /></td></tr>
<tr class="separator:a0bc718c72432a36e9271ca56511f911c inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff89438e6b7853ae0ea0fd43372dc2f inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a2ff89438e6b7853ae0ea0fd43372dc2f"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classsparta_1_1memory_1_1TranslationIF.html">TranslationIF</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a2ff89438e6b7853ae0ea0fd43372dc2f">getTranslationIF</a> ()</td></tr>
<tr class="memdesc:a2ff89438e6b7853ae0ea0fd43372dc2f inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the translation interface associated with this Debug memory interface (if any).  <br /></td></tr>
<tr class="separator:a2ff89438e6b7853ae0ea0fd43372dc2f inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff33a34afa19cb71943d7f12102d2b2 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a2ff33a34afa19cb71943d7f12102d2b2"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a2ff33a34afa19cb71943d7f12102d2b2">getDescription</a> ()</td></tr>
<tr class="memdesc:a2ff33a34afa19cb71943d7f12102d2b2 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the description specified at construction.  <br /></td></tr>
<tr class="separator:a2ff33a34afa19cb71943d7f12102d2b2 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec5c7bd3d39673eacfea9c54341d768 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_afec5c7bd3d39673eacfea9c54341d768"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#afec5c7bd3d39673eacfea9c54341d768">getBlockSize</a> () const</td></tr>
<tr class="memdesc:afec5c7bd3d39673eacfea9c54341d768 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the block size of memory represented by this interface. Read and write accesses must not span block boundaries (where addr % block_size == 0).  <br /></td></tr>
<tr class="separator:afec5c7bd3d39673eacfea9c54341d768 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88eaaf49740910933179b3b489e10c41 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a88eaaf49740910933179b3b489e10c41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a88eaaf49740910933179b3b489e10c41">getRange</a> () const</td></tr>
<tr class="memdesc:a88eaaf49740910933179b3b489e10c41 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total span of this interface's valid address range.  <br /></td></tr>
<tr class="separator:a88eaaf49740910933179b3b489e10c41 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813c0abcfcf0f1da307c0fe66eaead12 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a813c0abcfcf0f1da307c0fe66eaead12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a813c0abcfcf0f1da307c0fe66eaead12">getLowEnd</a> () const</td></tr>
<tr class="memdesc:a813c0abcfcf0f1da307c0fe66eaead12 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the lowest address accessible.  <br /></td></tr>
<tr class="separator:a813c0abcfcf0f1da307c0fe66eaead12 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619defc758b28691ce97c4e37f8d232d inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a619defc758b28691ce97c4e37f8d232d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a619defc758b28691ce97c4e37f8d232d">getHighEnd</a> () const</td></tr>
<tr class="memdesc:a619defc758b28691ce97c4e37f8d232d inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the highest address accessible + 1.  <br /></td></tr>
<tr class="separator:a619defc758b28691ce97c4e37f8d232d inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bafb07c039aab8148305aefc68c578 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a60bafb07c039aab8148305aefc68c578"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a60bafb07c039aab8148305aefc68c578">getAccessibleSize</a> () const</td></tr>
<tr class="memdesc:a60bafb07c039aab8148305aefc68c578 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total accessible size of this interface's valid addresses within the total size (getRange) excluding holes between access windows.  <br /></td></tr>
<tr class="separator:a60bafb07c039aab8148305aefc68c578 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c3357ec5fd3e290636854b46b7719d inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_ad5c3357ec5fd3e290636854b46b7719d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structsparta_1_1memory_1_1DebugMemoryIF_1_1AccessWindow.html">AccessWindow</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#ad5c3357ec5fd3e290636854b46b7719d">getWindows</a> () const</td></tr>
<tr class="memdesc:ad5c3357ec5fd3e290636854b46b7719d inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the vector of windows representing this interface.  <br /></td></tr>
<tr class="separator:ad5c3357ec5fd3e290636854b46b7719d inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1237a04a9fdfb296be4dc712fddbd0e inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_ab1237a04a9fdfb296be4dc712fddbd0e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#ab1237a04a9fdfb296be4dc712fddbd0e">isAddressInWindows</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr) const noexcept</td></tr>
<tr class="memdesc:ab1237a04a9fdfb296be4dc712fddbd0e inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given address is in an access window defined for this interface.  <br /></td></tr>
<tr class="separator:ab1237a04a9fdfb296be4dc712fddbd0e inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35fa48697f197f9357be0d6c5fae0c6 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_ae35fa48697f197f9357be0d6c5fae0c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#ae35fa48697f197f9357be0d6c5fae0c6">verifyInAccessWindows</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size) const</td></tr>
<tr class="memdesc:ae35fa48697f197f9357be0d6c5fae0c6 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies that the range [addr, addr+size) is within the access windows for this interface.  <br /></td></tr>
<tr class="separator:ae35fa48697f197f9357be0d6c5fae0c6 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56bff166f0c2e250be9450a8a152becc inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a56bff166f0c2e250be9450a8a152becc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a56bff166f0c2e250be9450a8a152becc">isInAccessWindows</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size) const</td></tr>
<tr class="memdesc:a56bff166f0c2e250be9450a8a152becc inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the range [addr, addr+size) is within the access windows for this interface.  <br /></td></tr>
<tr class="separator:a56bff166f0c2e250be9450a8a152becc inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb92bd2905d208cab60935b46dcd67a9 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_acb92bd2905d208cab60935b46dcd67a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#acb92bd2905d208cab60935b46dcd67a9">verifyNoBlockSpan</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size) const</td></tr>
<tr class="memdesc:acb92bd2905d208cab60935b46dcd67a9 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies that the given address does not span block boundaries defined for this interface.  <br /></td></tr>
<tr class="separator:acb92bd2905d208cab60935b46dcd67a9 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4efd1a8b860fd5224a78b4f17f06853d inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a4efd1a8b860fd5224a78b4f17f06853d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a4efd1a8b860fd5224a78b4f17f06853d">doesAccessSpan</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size) const noexcept</td></tr>
<tr class="memdesc:a4efd1a8b860fd5224a78b4f17f06853d inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given address spans block boundaries defined for this interface. Accesses which span blocks are illegal for read/write accesses, but allowed for peak/poke debug accesses.  <br /></td></tr>
<tr class="separator:a4efd1a8b860fd5224a78b4f17f06853d inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d460c6428bfcb6d1e37b3b908f17eef inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a1d460c6428bfcb6d1e37b3b908f17eef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a1d460c6428bfcb6d1e37b3b908f17eef">tryPeek</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size, uint8_t *buf) const</td></tr>
<tr class="memdesc:a1d460c6428bfcb6d1e37b3b908f17eef inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to 'peek' memory without having any side effects, size-limitations, alignment constraints except that all bytes peeked are inside an access window for this interface.  <br /></td></tr>
<tr class="separator:a1d460c6428bfcb6d1e37b3b908f17eef inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af806a7b9bf291eb5e1ae1311e70398f2 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_af806a7b9bf291eb5e1ae1311e70398f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#af806a7b9bf291eb5e1ae1311e70398f2">peek</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size, uint8_t *buf) const</td></tr>
<tr class="memdesc:af806a7b9bf291eb5e1ae1311e70398f2 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper on tryPeek which throws a <a class="el" href="classsparta_1_1memory_1_1MemoryAccessError.html" title="Indicates that there was an issue accessing a SPARTA memory object or interface.">MemoryAccessError</a> if the peek is not legal.  <br /></td></tr>
<tr class="separator:af806a7b9bf291eb5e1ae1311e70398f2 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca95f6e332e2c05d78fa5c08ff73965 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_afca95f6e332e2c05d78fa5c08ff73965"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#afca95f6e332e2c05d78fa5c08ff73965">tryPoke</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size, const uint8_t *buf)</td></tr>
<tr class="memdesc:afca95f6e332e2c05d78fa5c08ff73965 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to 'poke' memory without having any side effects other than changing the bytes within the range [ <em>addr</em> , <em>addr</em> + <em>size</em> ). Poke has no size-limitations or alignment constraints except that all bytes peeked are inside an access window for this interface.  <br /></td></tr>
<tr class="separator:afca95f6e332e2c05d78fa5c08ff73965 inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5d6378acc3c8737db0f6416b8082df inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF" id="r_abb5d6378acc3c8737db0f6416b8082df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#abb5d6378acc3c8737db0f6416b8082df">poke</a> (<a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> addr, <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a> size, const uint8_t *buf)</td></tr>
<tr class="memdesc:abb5d6378acc3c8737db0f6416b8082df inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper on tryPoke which throws a <a class="el" href="classsparta_1_1memory_1_1MemoryAccessError.html" title="Indicates that there was an issue accessing a SPARTA memory object or interface.">MemoryAccessError</a> if the poke is not legal.  <br /></td></tr>
<tr class="separator:abb5d6378acc3c8737db0f6416b8082df inherit pub_methods_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classsparta_1_1memory_1_1BlockingMemoryIF"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classsparta_1_1memory_1_1BlockingMemoryIF')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html">sparta::memory::BlockingMemoryIF</a></td></tr>
<tr class="inherit_header pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html">sparta::memory::DebugMemoryIF</a></td></tr>
<tr class="memitem:a65c02153d3a5600ccd331c8888aa99b5 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a65c02153d3a5600ccd331c8888aa99b5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a65c02153d3a5600ccd331c8888aa99b5">block_size_</a></td></tr>
<tr class="memdesc:a65c02153d3a5600ccd331c8888aa99b5 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of a block accessed through this interface.  <br /></td></tr>
<tr class="separator:a65c02153d3a5600ccd331c8888aa99b5 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3017884c6a75c3c142c996bc621e68 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a7a3017884c6a75c3c142c996bc621e68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a7a3017884c6a75c3c142c996bc621e68">block_mask_</a></td></tr>
<tr class="memdesc:a7a3017884c6a75c3c142c996bc621e68 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask applied to an address to get only bits representing the block ID.  <br /></td></tr>
<tr class="separator:a7a3017884c6a75c3c142c996bc621e68 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ca96578aee4568ca9f7f65d97f8622 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF" id="r_ac8ca96578aee4568ca9f7f65d97f8622"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#ac8ca96578aee4568ca9f7f65d97f8622">block_idx_lsb_</a></td></tr>
<tr class="memdesc:ac8ca96578aee4568ca9f7f65d97f8622 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">rshift applied to an address to get the block ID  <br /></td></tr>
<tr class="separator:ac8ca96578aee4568ca9f7f65d97f8622 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3ebb4e5d6568ef4cf7ed73c4b3efb5 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF" id="r_aed3ebb4e5d6568ef4cf7ed73c4b3efb5"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structsparta_1_1memory_1_1DebugMemoryIF_1_1AccessWindow.html">AccessWindow</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#aed3ebb4e5d6568ef4cf7ed73c4b3efb5">acc_windows_</a></td></tr>
<tr class="memdesc:aed3ebb4e5d6568ef4cf7ed73c4b3efb5 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of access windows representing this memory.  <br /></td></tr>
<tr class="separator:aed3ebb4e5d6568ef4cf7ed73c4b3efb5 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76ed77db27ed4a7c3c08d75a965faf6 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF" id="r_aa76ed77db27ed4a7c3c08d75a965faf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsparta_1_1memory_1_1TranslationIF.html">TranslationIF</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#aa76ed77db27ed4a7c3c08d75a965faf6">trans_</a></td></tr>
<tr class="memdesc:aa76ed77db27ed4a7c3c08d75a965faf6 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsparta_1_1memory_1_1Translation.html" title="An older class used to help in encapsulate read/virtual addresses.">Translation</a> interface created for this interface. Externally owned.  <br /></td></tr>
<tr class="separator:aa76ed77db27ed4a7c3c08d75a965faf6 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2182d932a817fceab277b60492a5203 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF" id="r_ad2182d932a817fceab277b60492a5203"><td class="memItemLeft" align="right" valign="top">const std::string *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#ad2182d932a817fceab277b60492a5203">desc_ptr_</a></td></tr>
<tr class="memdesc:ad2182d932a817fceab277b60492a5203 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description pointer.  <br /></td></tr>
<tr class="separator:ad2182d932a817fceab277b60492a5203 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c0a329c864f37b5021277ce4349dc0 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a64c0a329c864f37b5021277ce4349dc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a64c0a329c864f37b5021277ce4349dc0">total_range_</a></td></tr>
<tr class="memdesc:a64c0a329c864f37b5021277ce4349dc0 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range of addresses from highest accessible to lowest.  <br /></td></tr>
<tr class="separator:a64c0a329c864f37b5021277ce4349dc0 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece4fca05034cac697a447f391027fbf inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF" id="r_aece4fca05034cac697a447f391027fbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#aece4fca05034cac697a447f391027fbf">low_end_</a></td></tr>
<tr class="memdesc:aece4fca05034cac697a447f391027fbf inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowest accessible address.  <br /></td></tr>
<tr class="separator:aece4fca05034cac697a447f391027fbf inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11cbfa9ae6babb7e56cdc56366a3ae33 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a11cbfa9ae6babb7e56cdc56366a3ae33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a11cbfa9ae6babb7e56cdc56366a3ae33">high_end_</a></td></tr>
<tr class="memdesc:a11cbfa9ae6babb7e56cdc56366a3ae33 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Highest accessible address + 1.  <br /></td></tr>
<tr class="separator:a11cbfa9ae6babb7e56cdc56366a3ae33 inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616fca295fada16fa14ec939588265be inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF" id="r_a616fca295fada16fa14ec939588265be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a616fca295fada16fa14ec939588265be">accessible_size_</a></td></tr>
<tr class="memdesc:a616fca295fada16fa14ec939588265be inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes accessible through this interface.  <br /></td></tr>
<tr class="separator:a616fca295fada16fa14ec939588265be inherit pro_attribs_classsparta_1_1memory_1_1DebugMemoryIF"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class that provides a <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html" title="Pure-virtual memory interface which represents a simple, immediately accessible (blocking) address-sp...">BlockingMemoryIF</a> over a raw pointer. </p>
<p>Instances of this class are returned from <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html#ab879c2cb4b5a6e0e0a16516235d024e1" title="Get a DMI blocking interface to access the given address/size.">BlockingMemoryIFNode::getDMI</a> which allows a user to gain "backdoor" access to memory in the <a class="el" href="classsparta_1_1ArchData.html" title="Contains a set of contiguous line of architectural data which can be referred to by any architected o...">sparta::ArchData</a> memory pool. Think of a <a class="el" href="classsparta_1_1memory_1_1DMIBlockingMemoryIF.html" title="Class that provides a BlockingMemoryIF over a raw pointer.">DMIBlockingMemoryIF</a> instance as a "view" into a segment of memory between <code>start_addr</code> and (<code>start_addr</code> + <code>size</code>)</p>
<p>The user of this class should be aware of the following caveats:</p>
<ol type="1">
<li>The <a class="el" href="classsparta_1_1memory_1_1DMIBlockingMemoryIF.html" title="Class that provides a BlockingMemoryIF over a raw pointer.">DMIBlockingMemoryIF</a> can be invalidated at any time. Invalidations could result from changes in mappings, permissions, etc. Users that derive from <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIFNode.html" title="Pure-virtual memory interface that builds on the BlockingMemoryIF, acting as a TreeNode in the SPARTA...">BlockingMemoryIFNode</a> and provide their own DMI memory access can invalidate at any time.</li>
<li>Using the method <code>getRawDataPtr</code> is a means to improve simulation speed, but overruns are possible and not checked. The suggestion to use read/write methods is strongly encouraged.</li>
<li>The DMI's access window, if returned from <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIFNode.html" title="Pure-virtual memory interface that builds on the BlockingMemoryIF, acting as a TreeNode in the SPARTA...">BlockingMemoryIFNode</a>, is soley based on the size of the <a class="el" href="classsparta_1_1memory_1_1MemoryObject.html" title="Memory object with sparse storage for large memory representations. Has direct read/write interface w...">sparta::memory::MemoryObject</a> originally programmed in <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIFNode.html" title="Pure-virtual memory interface that builds on the BlockingMemoryIF, acting as a TreeNode in the SPARTA...">BlockingMemoryIFNode</a> and not total memory. For example, if the user creates <a class="el" href="classsparta_1_1memory_1_1MemoryObject.html" title="Memory object with sparse storage for large memory representations. Has direct read/write interface w...">sparta::memory::MemoryObject</a> with block size of 64 bytes and a total of 1024 bytes of memory, a DMI object can <em>only</em> access 64 bytes of memory at a time.</li>
<li>Using a DMI will bypass read/write counts in <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIFNode.html" title="Pure-virtual memory interface that builds on the BlockingMemoryIF, acting as a TreeNode in the SPARTA...">BlockingMemoryIFNode</a> showing fewer reads/writes than actually occurred</li>
<li>Using a DMI will bypass pre/post read/write notifications. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="DMIBlockingMemoryIF_8hpp_source.html#l00050">50</a> of file <a class="el" href="DMIBlockingMemoryIF_8hpp_source.html">DMIBlockingMemoryIF.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae003ba4006ceaeb129dc4f1204ec9baf" name="ae003ba4006ceaeb129dc4f1204ec9baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae003ba4006ceaeb129dc4f1204ec9baf">&#9670;&#160;</a></span>DMIBlockingMemoryIF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sparta::memory::DMIBlockingMemoryIF::DMIBlockingMemoryIF </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>raw_pointer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>start_addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps a raw pointer and provides <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html" title="Pure-virtual memory interface which represents a simple, immediately accessible (blocking) address-sp...">BlockingMemoryIF</a> to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_pointer</td><td>The raw data pointer with memory to access </td></tr>
    <tr><td class="paramname">start_addr</td><td>The expected "start address" of this raw pointer </td></tr>
    <tr><td class="paramname">size</td><td>The expected size of the data</td></tr>
  </table>
  </dd>
</dl>
<p>Typically created by <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryObjectIFNode.html" title="BlockingMemoryIFNode implementation with binding to a MemoryObject instantiated separately and specif...">BlockingMemoryObjectIFNode</a> when DMI request is made, this class will wrap a raw data pointer and provide the functionality of the <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html" title="Pure-virtual memory interface which represents a simple, immediately accessible (blocking) address-sp...">BlockingMemoryIF</a>. This includes window access checking and bounds checking for the raw pointer.</p>
<p>Note that memory observeration is <em>completely bypassed</em> when using a DMI interface. </p>

<p class="definition">Definition at line <a class="el" href="DMIBlockingMemoryIF_8hpp_source.html#l00068">68</a> of file <a class="el" href="DMIBlockingMemoryIF_8hpp_source.html">DMIBlockingMemoryIF.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abf641eb73d7e3b622f821a3ff899dc70" name="abf641eb73d7e3b622f821a3ff899dc70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf641eb73d7e3b622f821a3ff899dc70">&#9670;&#160;</a></span>clearValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparta::memory::DMIBlockingMemoryIF::clearValid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Typically called by the creator of the DMI Mem IF. </p>

<p class="definition">Definition at line <a class="el" href="DMIBlockingMemoryIF_8hpp_source.html#l00093">93</a> of file <a class="el" href="DMIBlockingMemoryIF_8hpp_source.html">DMIBlockingMemoryIF.hpp</a>.</p>

</div>
</div>
<a id="aefda738b44527e1a9a5883ed0f4b141e" name="aefda738b44527e1a9a5883ed0f4b141e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefda738b44527e1a9a5883ed0f4b141e">&#9670;&#160;</a></span>getRawDataPtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * sparta::memory::DMIBlockingMemoryIF::getRawDataPtr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a raw pointer to the memory held (dangerous) </p>
<dl class="section return"><dt>Returns</dt><dd>The internal raw pointer. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">SpartaException</a></td><td>if the pointer is not valid</td></tr>
  </table>
  </dd>
</dl>
<p>This is dangerous to use directly as memory bounds checking can easily be bypassed </p>

<p class="definition">Definition at line <a class="el" href="DMIBlockingMemoryIF_8hpp_source.html#l00084">84</a> of file <a class="el" href="DMIBlockingMemoryIF_8hpp_source.html">DMIBlockingMemoryIF.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1memory_1_1DMIBlockingMemoryIF_aefda738b44527e1a9a5883ed0f4b141e_cgraph.png" border="0" usemap="#aclasssparta_1_1memory_1_1DMIBlockingMemoryIF_aefda738b44527e1a9a5883ed0f4b141e_cgraph" alt=""/></div>
<map name="aclasssparta_1_1memory_1_1DMIBlockingMemoryIF_aefda738b44527e1a9a5883ed0f4b141e_cgraph" id="aclasssparta_1_1memory_1_1DMIBlockingMemoryIF_aefda738b44527e1a9a5883ed0f4b141e_cgraph">
<area shape="rect" title="Get a raw pointer to the memory held (dangerous)" alt="" coords="5,5,195,46"/>
<area shape="rect" href="classsparta_1_1memory_1_1DMIBlockingMemoryIF.html#ad2f22b56513195bde837c1ee9b1a333c" title=" " alt="" coords="243,5,432,46"/>
<area shape="poly" title=" " alt="" coords="195,23,227,23,227,28,195,28"/>
</map>
</div>

</div>
</div>
<a id="ad2f22b56513195bde837c1ee9b1a333c" name="ad2f22b56513195bde837c1ee9b1a333c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f22b56513195bde837c1ee9b1a333c">&#9670;&#160;</a></span>isValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::memory::DMIBlockingMemoryIF::isValid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the DMI is still valid to use </dd></dl>

<p class="definition">Definition at line <a class="el" href="DMIBlockingMemoryIF_8hpp_source.html#l00090">90</a> of file <a class="el" href="DMIBlockingMemoryIF_8hpp_source.html">DMIBlockingMemoryIF.hpp</a>.</p>

</div>
</div>
<a id="a92eada4b892613dbd4f93a15234b0d58" name="a92eada4b892613dbd4f93a15234b0d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92eada4b892613dbd4f93a15234b0d58">&#9670;&#160;</a></span>tryRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::memory::DMIBlockingMemoryIF::tryRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>in_supplement</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>out_supplement</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override of sparta::BlockingMemoryIF::tryRead. </p>
<dl class="section return"><dt>Returns</dt><dd>false if the DMI is not valid </dd></dl>

<p>Reimplemented from <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html#a5b4101acaca8b05c104178ed095d1a80">sparta::memory::BlockingMemoryIF</a>.</p>

<p class="definition">Definition at line <a class="el" href="DMIBlockingMemoryIF_8hpp_source.html#l00099">99</a> of file <a class="el" href="DMIBlockingMemoryIF_8hpp_source.html">DMIBlockingMemoryIF.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1memory_1_1DMIBlockingMemoryIF_a92eada4b892613dbd4f93a15234b0d58_cgraph.png" border="0" usemap="#aclasssparta_1_1memory_1_1DMIBlockingMemoryIF_a92eada4b892613dbd4f93a15234b0d58_cgraph" alt=""/></div>
<map name="aclasssparta_1_1memory_1_1DMIBlockingMemoryIF_a92eada4b892613dbd4f93a15234b0d58_cgraph" id="aclasssparta_1_1memory_1_1DMIBlockingMemoryIF_a92eada4b892613dbd4f93a15234b0d58_cgraph">
<area shape="rect" title="Override of sparta::BlockingMemoryIF::tryRead." alt="" coords="5,39,195,79"/>
<area shape="rect" href="classsparta_1_1memory_1_1DMIBlockingMemoryIF.html#ad2f22b56513195bde837c1ee9b1a333c" title=" " alt="" coords="243,5,432,46"/>
<area shape="poly" title=" " alt="" coords="195,43,227,39,227,44,195,48"/>
<area shape="rect" href="classsparta_1_1memory_1_1BlockingMemoryIF.html#a5b4101acaca8b05c104178ed095d1a80" title="Attempt to read memory of size size at address addr." alt="" coords="255,71,420,111"/>
<area shape="poly" title=" " alt="" coords="195,69,240,75,239,80,195,74"/>
<area shape="rect" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a4efd1a8b860fd5224a78b4f17f06853d" title="Determines if the given address spans block boundaries defined for this interface...." alt="" coords="480,5,678,46"/>
<area shape="poly" title=" " alt="" coords="414,68,485,48,487,53,416,73"/>
<area shape="rect" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a56bff166f0c2e250be9450a8a152becc" title="Determines if the range [addr, addr+size) is within the access windows for this interface." alt="" coords="480,71,678,111"/>
<area shape="poly" title=" " alt="" coords="421,88,464,88,464,94,421,94"/>
<area shape="rect" href="classsparta_1_1memory_1_1BlockingMemoryIF.html#a2c04f71050bbda78ff6bbf87a57fbc01" title="Implements tryRead." alt="" coords="496,136,662,177"/>
<area shape="poly" title=" " alt="" coords="416,109,487,129,485,134,414,114"/>
</map>
</div>

</div>
</div>
<a id="a6050ca36f7253e0eb1009f0d28b488f7" name="a6050ca36f7253e0eb1009f0d28b488f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6050ca36f7253e0eb1009f0d28b488f7">&#9670;&#160;</a></span>tryWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sparta::memory::DMIBlockingMemoryIF::tryWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesparta_1_1memory.html#abf087efa080d7cc51647e4920b42a401">addr_t</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>in_supplement</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>out_supplement</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override of sparta::BlockingMemoryIF::tryWrite. </p>
<dl class="section return"><dt>Returns</dt><dd>false if the DMI is not valid </dd></dl>

<p>Reimplemented from <a class="el" href="classsparta_1_1memory_1_1BlockingMemoryIF.html#ae85336d877e0227b567f05f901c0e782">sparta::memory::BlockingMemoryIF</a>.</p>

<p class="definition">Definition at line <a class="el" href="DMIBlockingMemoryIF_8hpp_source.html#l00113">113</a> of file <a class="el" href="DMIBlockingMemoryIF_8hpp_source.html">DMIBlockingMemoryIF.hpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classsparta_1_1memory_1_1DMIBlockingMemoryIF_a6050ca36f7253e0eb1009f0d28b488f7_cgraph.png" border="0" usemap="#aclasssparta_1_1memory_1_1DMIBlockingMemoryIF_a6050ca36f7253e0eb1009f0d28b488f7_cgraph" alt=""/></div>
<map name="aclasssparta_1_1memory_1_1DMIBlockingMemoryIF_a6050ca36f7253e0eb1009f0d28b488f7_cgraph" id="aclasssparta_1_1memory_1_1DMIBlockingMemoryIF_a6050ca36f7253e0eb1009f0d28b488f7_cgraph">
<area shape="rect" title="Override of sparta::BlockingMemoryIF::tryWrite." alt="" coords="5,39,195,79"/>
<area shape="rect" href="classsparta_1_1memory_1_1DMIBlockingMemoryIF.html#ad2f22b56513195bde837c1ee9b1a333c" title=" " alt="" coords="243,5,432,46"/>
<area shape="poly" title=" " alt="" coords="195,43,227,39,227,44,195,48"/>
<area shape="rect" href="classsparta_1_1memory_1_1BlockingMemoryIF.html#ae85336d877e0227b567f05f901c0e782" title="Attempt to write memory of size size at address addr." alt="" coords="255,71,420,111"/>
<area shape="poly" title=" " alt="" coords="195,69,240,75,239,80,195,74"/>
<area shape="rect" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a4efd1a8b860fd5224a78b4f17f06853d" title="Determines if the given address spans block boundaries defined for this interface...." alt="" coords="480,5,678,46"/>
<area shape="poly" title=" " alt="" coords="414,68,485,48,487,53,416,73"/>
<area shape="rect" href="classsparta_1_1memory_1_1DebugMemoryIF.html#a56bff166f0c2e250be9450a8a152becc" title="Determines if the range [addr, addr+size) is within the access windows for this interface." alt="" coords="480,71,678,111"/>
<area shape="poly" title=" " alt="" coords="421,88,464,88,464,94,421,94"/>
<area shape="rect" href="classsparta_1_1memory_1_1BlockingMemoryIF.html#a73f4639204dbf2a145e07ab7d575d108" title="Implements tryWrite." alt="" coords="496,136,662,177"/>
<area shape="poly" title=" " alt="" coords="416,109,487,129,485,134,414,114"/>
</map>
</div>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/github/workspace/sparta/sparta/memory/<a class="el" href="DMIBlockingMemoryIF_8hpp_source.html">DMIBlockingMemoryIF.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesparta.html">sparta</a></li><li class="navelem"><a class="el" href="namespacesparta_1_1memory.html">memory</a></li><li class="navelem"><a class="el" href="classsparta_1_1memory_1_1DMIBlockingMemoryIF.html">DMIBlockingMemoryIF</a></li>
    <li class="footer">Generated on Mon Feb 9 2026 03:27:58 for The Sparta Modeling Framework by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
