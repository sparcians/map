<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Sparta Modeling Framework: Simulator Configuration</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">The Sparta Modeling Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('config.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Simulator Configuration</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Sparta includes a 'parameter' mechanism for configuring (and querying the configuration of) a sparta device tree both through C++ and configuration files (See <a class="el" href="param_format.html">Parameter/Configuration Format (.cfg,.yaml)</a>).</p>
<h1><a class="anchor" id="config_goals"></a>
Configuration Goals</h1>
<p>The Sparta configuration system exists to allow configuration of hierarchical simulator before running a simulation and inspection (saving) of the final system configuration for the purpose of analysis or run reproduction.</p>
<h1><a class="anchor" id="config_usage"></a>
Simulator Subclass Configuration</h1>
<p>The user-side configuration of a simulator is covered in <a class="el" href="end_user.html#ctrl_cfg">2 Control and Configuration</a> and <a class="el" href="param_format.html">Parameter/Configuration Format (.cfg,.yaml)</a></p>
<dl class="section user"><dt>Overview</dt><dd>Simulator initialization, at it's simplest, establishes an initial device tree (trees) containing the parameters available for a simulator which is then populated from user configuration files and command-line parameters. Based on these parameters, various C++ resources (subclasses of sparta::Resouce) are instantiated. These resources then add to the device tree some non-configurable objects such as counters, statistics, registers, notification sources, memory interfaces, logging message sources, and ports. At this time the tree is finalized (no more changes) and simulation begins.</dd></dl>
<dl class="section user"><dt>Phased Construction</dt><dd>The simulation setup is divided into several phases <ul>
<li>building - Creating an initial topology of placeholder (sparta::ResourceTreeNodes) and other TreeNodes to roughly define the topology </li>
<li>configuration - Applying user configuration to the tree established in the building phase </li>
<li>finalization - Walking through the configured placeholder tree and instantiating the underlying resources based on the configuration applied to the tree in the previous phase </li>
<li>binding - Not a true phase, but after finalization the simulator can bind ports together between its components. No changes to the tree may be made at this time </li>
<li>running - Running the simulation. No changes to the tree may be made at this time</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Phased Construction Legacy/Limitations</dt><dd>Note: <em>These limitations have been (or will be) addressed by additional features: "Unbound Parameter Tree", "Dynamically Created Parameter Sets", "Topology Files".</em> Early in Sparta's development, these phases existed to keep the configuration process simple and allow all user onfiguration to be written into to the simulator tree's <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">sparta::Parameter</a> nodes exactly once (after building the initial tree) - eliminating the need for re-processing the configuration inputs multiple times. If new parameters could be added tothe tree at any time, re-reading the input configuration could be and expensive operation. This meant that all nodes in the device tree using Sparta parameters would need to be specified before reading the configuration at all. The result was that Sparta parameters could not be used to dictate how many instances of another component should be constructed if that other component had its own Sparta parameters. <br  />
 While this limitation forced the model owner to define their entire parameterized "topologies" in C++ code, probably makes simulator initialization code maintainable and clearly outlines the simulation hierarchy. It is also analogous to how "Topology Files" will work once implemented. In early Sparta, this did introduces a substantial limitation in the form of disallowing sparta parameters to be used to specify the overall simulator topology (e.g. how many cores to create, how many of what units will exist in each core) and prevented resources from creating new parameterized resource children without some challenging ResourceFactory code. Support for pattern-matching-based parameter identification complicated the necessary optimization of compressing the set of input parameters into an efficient tree structure. Initial requirements did not necessitate such this feature, but support for topology definition through parameters has been added using the "Unbound Parameter Tree" and "Dynamically Created Parameter Sets".</dd></dl>
<dl class="section user"><dt>Unbound Parameter Tree</dt><dd>Recently, the unbound parameter tree was added to address the aforementioned strict initialization ordering where the initial tree must be built to include all parameters and then configured (see <a class="el" href="classsparta_1_1ParameterTree.html" title="Virtual Parameter Tree. This represents a tree of parameters read from some source but does not neces...">sparta::ParameterTree</a>). This tree enables access to the user configuration input while constructing the initial device tree in (<a class="el" href="classsparta_1_1app_1_1Simulation.html" title="Simulator which builds a sparta DeviceTree.">sparta::app::Simulation</a>:buildTree_) using an efficient parameter-tree structure which handles pattern-based parameter paths and ensures each parameter is consumed by code, even if not actually associated with a <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">sparta::Parameter</a> node in the final device tree. <br  />
 This feature is not complete specifically due to this limitation: <ul>
<li>The ParameterTree is not capable of understanding configuration files or command line parameters containing parent references (e.g. "x..y" or ".x"). This is mainly an inconvenience. If encountered in a configuration file, generates a warning.</li>
</ul>
The unbound parameter tree is most useful during the build phase. Unbound parameters are read from a configuration file before the building phase and can be accessed even before any nodes are created. If a node foo with a parameter x is expected to be created later but required now (for topology), it can be accessed if specified by the user. <div class="fragment"><div class="line"><span class="keyword">auto</span> pn = n-&gt;getRoot()-&gt;getAs&lt;<a class="code hl_class" href="classsparta_1_1RootTreeNode.html">sparta::RootTreeNode</a>&gt;()-&gt;getSimulator()-&gt;getUnboundParameterTree()-&gt;tryGet(<span class="stringliteral">&quot;top.foo.params.x&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span>(pn){</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Got parameter Value for x = &quot;</span> &lt;&lt; pn-&gt;getValue() &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="aclasssparta_1_1RootTreeNode_html"><div class="ttname"><a href="classsparta_1_1RootTreeNode.html">sparta::RootTreeNode</a></div><div class="ttdoc">TreeNode which represents the root (&quot;top&quot;) of a device tree.</div><div class="ttdef"><b>Definition</b> <a href="RootTreeNode_8hpp_source.html#l00049">RootTreeNode.hpp:50</a></div></div>
</div><!-- fragment --></dd></dl>
<p>This behavior is still experimental and under development. It should be improved soon.</p>
<ul>
<li>The contents of the unbound parameter tree are not yet written as part of the the final configuration output (see --write-final-config command line option). Therefore, unbound parameters may be missing when trying to reproduce a simulation run using the final configuration output of that run. The best practice for this issue is that all unbound parameters should correspond to <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">sparta::Parameter</a> nodes by the time the simulation is finalized. At any time before finalization the simulator should simply create new ParameterSet and Parameter Nodes matching the location of the unbound parameters consumed earlier</li>
</ul>
<ul>
<li>The unbound parameter tree provides no method for lexical casting its content to a vector like a <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">sparta::Parameter</a> node does. Interpreting a value from the unbound parameter tree as a vector must currently be done manually.</li>
</ul>
<ul>
<li>No default values are provided by the unbound parameter tree. Therefore, building-phase code that consumes unbound parameters must be made aware of the defaults for those parameters in case the user does not specify that parmeter as input. This could be done by accessing a static variable which defines a default value in the relevant ParamaeterSet declaration.</li>
</ul>
<dl class="section user"><dt>Initialization Phases</dt><dd>Most of the initialization phases are marked by a different virtual method within <a class="el" href="classsparta_1_1app_1_1Simulation.html" title="Simulator which builds a sparta DeviceTree.">sparta::app::Simulation</a>, though some work is done in the subclass constructor and in <a class="el" href="classsparta_1_1Resource.html" title="The is the base class for all types of resources used by the SPARTA framework.">sparta::Resource</a> subclass constructors. These phases are part of <a class="el" href="classsparta_1_1PhasedObject.html" title="Object having a specific phase in the sparta construction paradigm.">sparta::PhasedObject</a>, from which every <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">sparta::TreeNode</a> in the device tree inherits.</dd></dl>
<dl class="section user"><dt>Phase 1. Resource Factory Instantiation</dt><dd>First, a number of <a class="el" href="classsparta_1_1ResourceFactory.html" title="Templated ResourceFactoryBase implementation which can be used to trivially define Resource Factories...">sparta::ResourceFactory</a> objects are registered with a <a class="el" href="classsparta_1_1app_1_1Simulation.html" title="Simulator which builds a sparta DeviceTree.">sparta::app::Simulation</a>. These objects associate a resource name with a factory capable of instantiating that resource. For example, a factory might be declared for instantiating a "core" object and a "lsu" object. This is typically done within the constructor of a subclass of a <a class="el" href="classsparta_1_1app_1_1Simulation.html" title="Simulator which builds a sparta DeviceTree.">sparta::app::Simulation</a>. <br  />
 The intent of these objects a is to identify resource classes by a string name which can be referenced by parameters specifying topology and eventually used by some sort of topology-definition file one such a feature exists.</dd></dl>
<dl class="section user"><dt>Phase 2. Build-Tree Phase</dt><dd>Within a subclass of <a class="el" href="classsparta_1_1app_1_1Simulation.html" title="Simulator which builds a sparta DeviceTree.">sparta::app::Simulation</a>, the <a class="el" href="classsparta_1_1app_1_1Simulation.html#aecc889666b5da1b6891a6f1ed337fbc8" title="Allows implementer to create new nodes in the tree.">sparta::app::Simulation::buildTree_</a> method allows the subclass to define an initial device tree. The overall device tree topology must be established at this point. This device tree should contain any number of <a class="el" href="classsparta_1_1ResourceTreeNode.html" title="TreeNode subclass representing a node in the device tree which contains a single ResourceFactory and ...">sparta::ResourceTreeNode</a> instances constructed referring to the factories created during resource factory instantiation. When a <a class="el" href="classsparta_1_1ResourceTreeNode.html" title="TreeNode subclass representing a node in the device tree which contains a single ResourceFactory and ...">sparta::ResourceTreeNode</a> is created, the <a class="el" href="classsparta_1_1ParameterSet.html" title="Generic container of Parameters.">sparta::ParameterSet</a> subclass specified by the factory is also constructed and attached to the tree as a child of the ResourceTreeNode called "params". This is immediately available though the contained parameters have default values only - they are not read from the input configuration until after the build phase (This will change later). <br  />
 With the unbound parameter tree feature (see above), parameters can be accessed before and during initial tree constuction. This allows the simulator to consume user parameters not associated with any <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">sparta::Parameter</a> node to determine topology. (Note: More convenient ways of specifying topology such as topology files may be implemented later). <br  />
 Consuming parmeters from the unbound tree can be done from within <a class="el" href="classsparta_1_1app_1_1Simulation.html#aecc889666b5da1b6891a6f1ed337fbc8" title="Allows implementer to create new nodes in the tree.">sparta::app::Simulation::buildTree_</a> as follows: <div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; pt = getUnboundParameterTree();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Approach 1: Assume top.params.cluster_count exists. Throw if nonexistant</span></div>
<div class="line">{</div>
<div class="line">    uint32_t num_clusters = pt.get(<span class="stringliteral">&quot;top.params.cluster_count&quot;</span>).getAs&lt;uint32_t&gt;();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Approach 2: Atempt to get top.params.cluster_count and use a default value if it does not exist</span></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> ccn = pt.tryGet(<span class="stringliteral">&quot;top.params.cluster_count&quot;</span>);</div>
<div class="line">    uint32_t num_clusters = 1; <span class="comment">// Default</span></div>
<div class="line">    <span class="keywordflow">if</span>(ccn){</div>
<div class="line">        num_clusters = ccn-&gt;getAs&lt;uint32_t&gt;();</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> Note that all parameters in the unbound tree must be consumed or must eventually correspond to <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">sparta::Parameter</a> nodes in the device tree one finalization is complete. <br  />
 The best practice for using a parameter form the unbound parameter tree which must be read in the build phase is to eventually create a <a class="el" href="classsparta_1_1ParameterSet.html" title="Generic container of Parameters.">sparta::ParameterSet</a> node with a <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">sparta::Parameter</a> corresponding to the path read from the unbound parameter tree. In the above example, A ParameterSet would be created as a child of the "top" node and it would contain a parameter called "cluster_count". Because of the aforementioned limitations, this parameter is not automatically populated from user input until after the build phase, but doing this still serves several important purposes. <ul>
<li>It Makes the parameter visible to the end-user when inspecting the tree (--show-tree or interactively [when the Python shell is complete]) </li>
<li>The parameter will be written out whenever --write-final-config[-verbose] is used. </li>
<li>Eventually, the value will be read from this ParameterSet immediately instead of using the unbound tree. The unbound tree's visibility to simulator subclasses will be deprecated at that point</li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>The unbound parameter tree cannot be altered by the simulator subclass at any time. It represents external user configuration only. However, new default values for any <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">sparta::Parameter</a> nodes created can be set during the build phase. Note that, input user configuration may override any parameter later if said parameter is specified in the input user configuration. To force-override user parameters, set the value of any <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">sparta::Parameter</a> node during the <b>configuration phase</b> (see below) </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>accessing these parameters provides no method for lexical casting to a vector. Interpreting a value from the unbound parameter tree as a vector must currently be done by hand.</dd></dl>
<dl class="section user"><dt>Phase 3. Configure Tree Phase</dt><dd>The configuration phase for simulator subclasses is performed in the virtual <a class="el" href="classsparta_1_1app_1_1Simulation.html#a9d83dfcb8bf3490bff0e26b08f84c4bf" title="Allows implementer to manually configure the tree if required.">sparta::app::Simulation::configureTree_</a> method. Immediately before this method is called, the <a class="el" href="classsparta_1_1app_1_1Simulation.html" title="Simulator which builds a sparta DeviceTree.">sparta::app::Simulation</a> internally applies the input configuration to all Parameter nodes in the device tree. <br  />
 At this point, user parameters can be overridden by the simulator itself. A common case of this is where simulator-specific command line arguments are given which have the same semantics as some parameter in the device tree. Because simulator-specific command-line options should generally override user configuration input, these commands can override values in the parameter tree.</dd></dl>
<dl class="section user"><dt></dt><dd>In this example, A list of traces on the command line (processed earlier into a trace_filenames_ member) is iterated and one trace filename is assigned to a parameter in each core object. As a result, the actual traces used in this simulation will always show up in the --write-final-config output, even if the user's input configuration is overridden. The run can then be reproduced based on the final configuration as expected <div class="fragment"><div class="line">uint32_t i = 0;</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">const</span> std::string&amp; trace : trace_filenames_){</div>
<div class="line">    <span class="comment">// Find the parameter</span></div>
<div class="line">    std::stringstream ss;</div>
<div class="line">    ss &lt;&lt; <span class="stringliteral">&quot;core&quot;</span> &lt;&lt; i;</div>
<div class="line">    <a class="code hl_class" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a>* core_node = <span class="keyword">nullptr</span>;</div>
<div class="line">    <span class="keywordflow">try</span>{</div>
<div class="line">        core_node = getRoot()-&gt;<a class="code hl_function" href="classsparta_1_1TreeNode.html#ac598185049018290d5ea6cb674d10473">getChild</a>(ss.str());</div>
<div class="line">    }<span class="keywordflow">catch</span>(<a class="code hl_class" href="classsparta_1_1SpartaException.html">sparta::SpartaException</a>&amp; ex){</div>
<div class="line">        <span class="keywordflow">throw</span> <a class="code hl_class" href="classsparta_1_1SpartaException.html">sparta::SpartaException</a>(<span class="stringliteral">&quot;Unable to find a core below top called \&quot;&quot;</span>) &lt;&lt; ss.str()</div>
<div class="line">                                                                                   &lt;&lt; <span class="stringliteral">&quot;\&quot;. It is possible that too many traces were specified on the command line &quot;</span></div>
<div class="line">            <span class="stringliteral">&quot;such that they could not all be assigned to a core. Error encountered at trace&quot;</span></div>
<div class="line">                                                                                   &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; trace;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Get top.core&lt;i&gt;.params.trace_filename node. Throws if not found</span></div>
<div class="line">    core_node-&gt;<a class="code hl_function" href="classsparta_1_1TreeNode.html#ab18a936bf3a826ff18bd374d2a6b531d">getChildAs</a>&lt;<a class="code hl_class" href="classsparta_1_1ParameterBase.html">sparta::ParameterBase</a>&gt;(<span class="stringliteral">&quot;params.trace_filename&quot;</span>)-&gt;setValueFromString(trace);</div>
<div class="line">    ++i;</div>
<div class="line"> }</div>
<div class="ttc" id="aclasssparta_1_1ParameterBase_html"><div class="ttname"><a href="classsparta_1_1ParameterBase.html">sparta::ParameterBase</a></div><div class="ttdoc">Non-templated base class for generic parameter access and iteration.</div><div class="ttdef"><b>Definition</b> <a href="Parameter_8hpp_source.html#l00114">Parameter.hpp:115</a></div></div>
<div class="ttc" id="aclasssparta_1_1SpartaException_html"><div class="ttname"><a href="classsparta_1_1SpartaException.html">sparta::SpartaException</a></div><div class="ttdoc">Used to construct and throw a standard C++ exception. Inherits from std::exception.</div><div class="ttdef"><b>Definition</b> <a href="SpartaException_8hpp_source.html#l00063">SpartaException.hpp:64</a></div></div>
<div class="ttc" id="aclasssparta_1_1TreeNode_html"><div class="ttname"><a href="classsparta_1_1TreeNode.html">sparta::TreeNode</a></div><div class="ttdoc">Node in a composite tree representing a sparta Tree item.</div><div class="ttdef"><b>Definition</b> <a href="TreeNode_8hpp_source.html#l00204">TreeNode.hpp:205</a></div></div>
<div class="ttc" id="aclasssparta_1_1TreeNode_html_ab18a936bf3a826ff18bd374d2a6b531d"><div class="ttname"><a href="classsparta_1_1TreeNode.html#ab18a936bf3a826ff18bd374d2a6b531d">sparta::TreeNode::getChildAs</a></div><div class="ttdeci">const ConstT getChildAs(const std::string &amp;name, bool must_exist=true) const</div><div class="ttdoc">Retrieves a child that is castable to T with the given dotted path.</div><div class="ttdef"><b>Definition</b> <a href="TreeNode_8hpp_source.html#l01606">TreeNode.hpp:1606</a></div></div>
<div class="ttc" id="aclasssparta_1_1TreeNode_html_ac598185049018290d5ea6cb674d10473"><div class="ttname"><a href="classsparta_1_1TreeNode.html#ac598185049018290d5ea6cb674d10473">sparta::TreeNode::getChild</a></div><div class="ttdeci">TreeNode * getChild(const std::string &amp;name, bool must_exist=true)</div><div class="ttdoc">Retrieves a child with this dotted path name.</div><div class="ttdef"><b>Definition</b> <a href="TreeNode_8hpp_source.html#l01531">TreeNode.hpp:1531</a></div></div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>Configuration is an opportune time to create and attached clocks to the tree. This can be done during buildTree, but must be done before the end of configuration to prevent resources from being instantiated with no clock <div class="fragment"><div class="line"><span class="comment">// Within configureTree_</span></div>
<div class="line">sparta::Clock::Handle master_clock = getClockManager().getRoot();</div>
<div class="line">core_clock_ = getClockManager().makeClock(<span class="stringliteral">&quot;core&quot;</span>,</div>
<div class="line">                                          master_clock,</div>
<div class="line">                                          core_frequency_mhz_);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// for each core... {</span></div>
<div class="line">core_node-&gt;<a class="code hl_function" href="classsparta_1_1TreeNode.html#aa3077d3b25e965fd6924258b5eb77f61">setClock</a>(core_clock_.get());</div>
<div class="line">}</div>
<div class="ttc" id="aclasssparta_1_1TreeNode_html_aa3077d3b25e965fd6924258b5eb77f61"><div class="ttname"><a href="classsparta_1_1TreeNode.html#aa3077d3b25e965fd6924258b5eb77f61">sparta::TreeNode::setClock</a></div><div class="ttdeci">virtual void setClock(const Clock *clk)</div><div class="ttdoc">Assigns a clock to this node. This clock will then be accessed by any descendant which has no assigne...</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>Following configuration, all resources will be constructed and the tree will be finalized. This is the last chance to alter the tree structure from within the simulation subclass</dd></dl>
<dl class="section user"><dt>Phase 4. Finalize Tree Phase</dt><dd>There is no virtual method in <a class="el" href="classsparta_1_1app_1_1Simulation.html" title="Simulator which builds a sparta DeviceTree.">sparta::app::Simulation</a> for simulators to implement. This phase involves Sparta walking the existing device tree and constructing all Resources as defined by the tree. For each ResourceTreeNode encountered in the tree, Sparta will construct the resource through the associated ResourceFactory using that ResourceTreeNode and its parameter set as arguments to the Resource's constructor. Each resource can create new children nodes (e.g. <a class="el" href="classsparta_1_1Port.html" title="The port interface used to bind port types together and defines a port behavior.">sparta::Port</a>, <a class="el" href="classsparta_1_1CounterBase.html" title="The base class for all Counters.">sparta::CounterBase</a>, <a class="el" href="classsparta_1_1StatisticDef.html" title="Contains a statistic definition (some useful information which can be computed)">sparta::StatisticDef</a>, sparta::StatisiticSet, <a class="el" href="classsparta_1_1PortSet.html" title="A TreeNode that represents a set of ports used by a Resource.">sparta::PortSet</a>, <a class="el" href="classsparta_1_1log_1_1MessageSource.html" title="Message source object associated with a sparta TreeNode through which messages can be sent.">sparta::log::MessageSource</a>, <a class="el" href="classsparta_1_1NotificationSource.html" title="A TreeNode that generates a specific type of notification which propagates up a tree of TreeNodes (us...">sparta::NotificationSource</a>, and more.</dd></dl>
<dl class="section user"><dt></dt><dd>Resources can even create child ResourceTreeNodes at this time. Currently, the sparta::Parameters for these ResourceTreeNodes constructed at finalization-time will not be automatically populated from user configuration input. Instead, the parameters must be explicitly set. Eventually these parameters will be automatically populated (see the "Unbound Parameter Tree" section above). <a class="el" href="classsparta_1_1Parameter.html" title="Parameter instance, templated to contain only a specific type.">sparta::Parameter</a> nodes created at this time will <b>not</b> show up in the final configuration output until dynamic automatic population from input configuration is implemented for all Parameters</dd></dl>
<dl class="section user"><dt></dt><dd>During finalization, a resouces (in its constructor) cannot be sure if a neighbor or even a child resource has been constructed yet. New nodes may still be added to the tree as finalization continues and no assumptions should be made about resources initialization order. The only exception to this rule is that parent nodes' resources will always be created before their childrens' resources. Any references to other resource objects (such as exchanging pointers) should be done in the startup handler (below). It is safe, however, to look at parent nodes (and all ancestors) and their parameters (if any) for each resource as it is constructed at this point. This is because those nodes must have been created for this a resource's node to exist.</dd></dl>
<dl class="section user"><dt>Phase 5. Bind Tree Phase</dt><dd>After finalization, any remaining ports can be bound together in the virtual <a class="el" href="classsparta_1_1app_1_1Simulation.html#a2481dd90dd3544ce4c5b385617c74cb6" title="Allows implementer to bind ports to gether.">sparta::app::Simulation::bindTree_</a> method. Binding is technically not a phase, just an action that can take place after the tree is finalized and must be done before running. At this point, the device tree is finalized, all resources are constructed, all nodes that will be present in the running simulation exist, and no nodes may be added or destroyed.</dd></dl>
<dl class="section user"><dt></dt><dd>Ports should be bound together as per the desired simulation topology. <div class="fragment"><div class="line"><a class="code hl_function" href="namespacesparta.html#ae0e328d41db963d8fa8d62139d70e960">sparta::bind</a>(getRoot()-&gt;getChildAs&lt;sparta::Port&gt;(<span class="stringliteral">&quot;core0.ports.out_to_memory&quot;</span>),</div>
<div class="line">getRoot()-&gt;getChildAs&lt;sparta::Port&gt;(<span class="stringliteral">&quot;memory.ports.in_from_core0&quot;</span>));</div>
<div class="ttc" id="anamespacesparta_html_ae0e328d41db963d8fa8d62139d70e960"><div class="ttname"><a href="namespacesparta.html#ae0e328d41db963d8fa8d62139d70e960">sparta::bind</a></div><div class="ttdeci">void bind(Bus *p1, Bus *p2)</div><div class="ttdoc">Bind two buses together.</div><div class="ttdef"><b>Definition</b> <a href="Bus_8hpp_source.html#l00333">Bus.hpp:333</a></div></div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Phase 6a. Run Startup Handling</dt><dd>Immediately before running, the <a class="el" href="classsparta_1_1Scheduler.html" title="A class that lets you schedule events now and in the future.">sparta::Scheduler</a> invokes startup handlers. At this time, the tree is guaranteed to be finalized with all resources instantiated. It is safe for all nodes to access any other resource. Prior to this point, a resouces (in its constructor) cannot be sure if a neighbor or even a child resource has been constructed. <div class="fragment"><div class="line">MyModel::MyModel(<a class="code hl_class" href="classsparta_1_1TreeNode.html">sparta::TreeNode</a> * node,</div>
<div class="line">                 <span class="keyword">const</span> MyModelParameterSet * p)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Schedule startup handler</span></div>
<div class="line">    node-&gt;<a class="code hl_function" href="classsparta_1_1TreeNode.html#aec70f36a682dadc1d571fcd723f12cd6">getClock</a>()-&gt;<a class="code hl_function" href="classsparta_1_1Clock.html#aa2d29cba2726bcc43077de19218307ff">getScheduler</a>()-&gt;scheduleStartupHandler (CREATE_Sparta_HANDLER (MyModel, startupHandler_));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyModel::startupHandler_ ()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Access children and sibling resources</span></div>
<div class="line">    <span class="comment">// Schedule initial events</span></div>
<div class="line">    <span class="comment">// Register for notifications, etc.</span></div>
<div class="line">}</div>
<div class="ttc" id="aclasssparta_1_1Clock_html_aa2d29cba2726bcc43077de19218307ff"><div class="ttname"><a href="classsparta_1_1Clock.html#aa2d29cba2726bcc43077de19218307ff">sparta::Clock::getScheduler</a></div><div class="ttdeci">Scheduler * getScheduler() const</div><div class="ttdef"><b>Definition</b> <a href="Clock_8hpp_source.html#l00289">Clock.hpp:289</a></div></div>
<div class="ttc" id="aclasssparta_1_1TreeNode_html_aec70f36a682dadc1d571fcd723f12cd6"><div class="ttname"><a href="classsparta_1_1TreeNode.html#aec70f36a682dadc1d571fcd723f12cd6">sparta::TreeNode::getClock</a></div><div class="ttdeci">const Clock * getClock() override</div><div class="ttdoc">Walks up parents (starting with self) until a parent with an associated local clock is found,...</div><div class="ttdef"><b>Definition</b> <a href="TreeNode_8hpp_source.html#l02040">TreeNode.hpp:2040</a></div></div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Phase 6b. Run Phase</dt><dd>Running is not relevant to simulation initialization except that it comes after binding and no modifications can be made the the device tree structure at run time. This also means that no TreeNodes may be destroyed until the teardown phase</dd></dl>
<dl class="section user"><dt>Phase 7. Teardown Phase</dt><dd>Prior to simulator shutdown, the entire device tree is marked as being in the teardown phase. When destructing <a class="el" href="classsparta_1_1TreeNode.html" title="Node in a composite tree representing a sparta Tree item.">sparta::TreeNode</a> objects, each will throw a <a class="el" href="classsparta_1_1SpartaException.html" title="Used to construct and throw a standard C++ exception. Inherits from std::exception.">sparta::SpartaException</a> if not marked as being in the teardown phase. The goal of this behavior is to prevent any user from accidentally destroying TreeNodes at run-time or even construction time once they are added to a tree. Deleting nodes at run-time can be challenging for Sparta (especially with a Python shell or other remote clients) to handle. Because no legitimate reasons for supporting this have been proposed, destroying nodes prior to teardown is prohibited with the exception of <a class="el" href="classsparta_1_1Counter.html" title="Represents a counter of type counter_type (uint64_t). 2 and greater than 0 with a ceiling specified....">sparta::Counter</a> and <a class="el" href="classsparta_1_1StatisticDef.html" title="Contains a statistic definition (some useful information which can be computed)">sparta::StatisticDef</a> where C++ move semantics can be used to swap nodes during construction in order to allow these nodes to be instantiated within an vector without introducing additional pointer indirection in performance-critical code. <a class="el" href="classsparta_1_1app_1_1Simulation.html" title="Simulator which builds a sparta DeviceTree.">sparta::app::Simulation</a> attempts to cleanly tear down by freeing all nodes allocated on the heap and destructing any object on the simulator's stack. Sparta alwys intends to teardown with no memory leaks so that any number of simulations can be run consecutively in the same process.</dd></dl>
<p>The sparta command line parameter --show-tree/--show-parameters (or --help-tree/--help-parameters) can be used to show the values of all parameters after the build, configuration, and binding phases of the construction process.</p>
<h1><a class="anchor" id="config_des_req"></a>
Configuration System Design Requirements</h1>
<p>For reference, a number of the requirements for the configuration system design are listed here.</p><ol type="1">
<li>Enable command-line configuration of a simulation tree</li>
<li>Support configuration-files to configure a simulation tree</li>
</ol>
<ul>
<li>Separate configuration files for each component in the simulation should be allowed by not required</li>
</ul>
<ol type="1">
<li>Support inspection of all parameters at any time including support to save these parameter to disk in such a way that they can be reloaded for reproducability</li>
<li>Make configuration communication (as opposed to run-time simulation data/timing) between simulation components difficult in favor of the sparta configuration system.</li>
</ol>
<ul>
<li>This ensures tracability of configuration by exposing all parameters to the configuration system such that they may be queried and analyzed. Bugs related to direct C++ communication of parameters between components at configuration-time can be difficult to debug and extra code is required to capture these parameters to compare against other simulations.</li>
</ul>
<ol type="1">
<li>Prevent modification to the set of parameters once the simulation run begins</li>
<li>Strongly type parameters to support C++ plain-old-datatypes as well as strings</li>
<li>Support parameter having vector types so that 1 parameter could be a list of values (e.g. [1,2,3])</li>
<li>Require descriptions associated with every parameter</li>
<li>Define a resource as 1:1 association of a resource class and a parameter set to ensure that all instances of that resource have the same parameters and are effectively interchangable.</li>
<li>Allow validators to be registered on individual parameters </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Aug 22 2025 17:16:11 for The Sparta Modeling Framework by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
